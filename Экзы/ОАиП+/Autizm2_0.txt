
14. Использование функций.
14.1. Создание и использование простой функции.
14.2. Прототипы функций.
14.3. Вызов по значению и вызов по ссылке.
14.4. Использование указателей для связи между функциями
14.5. Рекурсия.
14.5.1. Равноправность функций в языке Си.
14.6. Параметры и аргументы функций
14.6.1. Формальные и фактические параметры.
14.6.2. Аргумент типа void.
14.6.3. Символьные параметры.
14.6.4. Целочисленные параметры.
14.6.5. Параметры в формате чисел с плавающей точкой.
14.6.6. Параметры в формате чисел двойной длины.
14.6.7. Массивы в качестве параметров.
14.6.8. Аргументы по умолчанию
14.7. Возвращение значения функцией: оператор return.
14.8. Типы функций.
14.8.1. Функции типа void.
14.8.2. Функции типа char.
14.8.3. Функции типа int.
14.8.4. Функции типа long.
14.8.5. Функции типа float.
14.8.6. Функции типа double.
14.9. Важные возможности C++.
14.9.1. Встраивание (inline).
14.9.2. Перегрузка (overloading).
14.9.3. Функции с переменным числом параметров. Многоточие (...).
14.9.3.1. Задание числа дополнительных параметров с помощью первого параметра.
14.9.3.2. Определение конца списка параметров с помощью параметра индикатора.
14.9.3.3. Использование специального набора макроопределений.
14.9.3.4. Список указателей переменной длины на char (конкатинация строк)
14.9.3.5. Изменение параметров по числу и по типу
14.9.3.6. Дополнительные примеры функций с произвольным числом параметров
14.10. Аргументы функции main().
14.10.1. Строки.
14.10.2. Целые числа.
14.10.3. Числа с плавающей точкой.
14.11. Области видимости. Локальные и глобальные переменные
14.12. Сложности в правилах области действия (scope rules).
14.12.1. Неопределенные символы в программе на С.
14.12.2. Использование переменной с файловой областью действия.
14.12.3. Приоритет переменных с файловой и локальной областями действия.
14.12.4. Проблемы области действия в C++.
14.12.5. Операция уточнения области действия в C++.
14.13. Математические функции
14.14. Указатель на функцию
14.14.1. Указатели на функции
14.14.2. Указатели на методы
14.14.3. Примеры
14.14.3.1. Пример 1. Простой указатель на функцию
14.14.3.2. Пример 2. Массив указателей на функции
14.14.3.3. Пример 3. Указатель на функцию – параметр функции
14.14.3.4. Пример 4. Сортировка массива
14.14.4. Указатель на функцию и динамическое связывание
14.14.5. Таблицы функций, вызов по имени
14.14.6. Указатель на функцию как средство параметризации алгоритма
14.14.7. Сортировка одной и той же структуры данных по разным критериям
14.15. Массив указателей на функции
14.16. Шаблоны функций в С++. Основные понятия
14.17. Параметры шаблонов функций.
14.18. Шаблоны функций. Аргументы по умолчанию
14.19. Функции округления
14.20. Компиляция программ, состоящих из двух или более функций.

    14. Использование функций.
Принципы программирования на языке Си основаны на понятии функции. В представленных ранее примерах программирования мы уже воспользовались несколькими функциями: printf(), scanf(), getchar(), putchar () и strlen(). Эти функции являются системными, однако мы создали и несколько своих собственных функций под общим именем main(). Выполнение программы всегда начинается с команд, содержащихся в функции main(), затем последняя вызывает другие функции, например getchar(). Теперь мы переходим к вопросу о том, как создавать свои собственные функции и делать их доступными для функции main(), а также друг для друга.
Разработка программного обеспечения на практике является довольно непростым процессом. Программисту требуется учесть все тонкости и нюансы как всего программного комплекса в целом, так и отдельных его частей. Системный подход к программированию основывается на том, что поставленная перед разработчиком задача предварительно разбивается на пару-тройку менее крупных вопросов, которые, в свою очередь, делятся еще на несколько менее сложных задач, и так до тех пор, пока самые мелкие задачи не будут решены с помощью стандартных процедур. Таким образом, осуществляется так называемая функциональная декомпозиция.
Ключевым элементом данной модели для решения конкретной задачи в C++ выступает функция. Функцию можно представить как подпрограмму или некую процедуру, несущую законченную смысловую нагрузку.
Во-первых, что такое функция? Функция — самостоятельная единица программы, спроектированная для реализации конкретной задачи. Функции в языке Си играют ту же роль, какую играют функции, подпрограммы и процедуры в других языках, хотя детали их структуры могут быть разными. Вызов функций приводит к выполнению некоторых действий. Например, при обращении к функции printf() осуществляется вывод данных на экран. Другие же функции позволяют получать некоторую величину, используемую затем в программе. К примеру, функция strlen() «сообщает» программе длину конкретной строки. В общем, функции могут выполнять различные действия и получать значения величин, используемых в программе.
Почему мы пользуемся функциями? Во-первых, они избавляют нас от повторного программирования. Если конкретную задачу необходимо выполнить в программе несколько раз, мы напишем соответствующую функцию только один раз, а затем будем вызывать ее всегда, когда это требуется. Во-вторых, мы можем применять одну функцию, например putchar(), в различных программах. Даже в том случае, если некоторая задача выполняется только в одной программе, лучше оформить ее решение в виде функции, поскольку функции повышают уровень модульности программы и, следовательно, облегчают ее чтение, внесение изменений и коррекцию ошибок. Предположим, например, что мы хотим написать программу, которая делает следующее:

вводит набор чисел
сортирует эти числа
находит их среднее
выводит на печать гистограмму

Соответствующую программу можно записать так:

main()
{
	float list [50];
	readlist(list);
	sort(list);
	average(list);
	bargraph(list);
}

Разумеется, мы должны были бы запрограммировать четыре функции readlist(), sort(), average() и bargraph(), но... это уже детали. Используя смысловые имена функции, мы четко определяем, что программа делает и как она организована. После этого можно заниматься каждой функцией отдельно и совершенствовать ее до тех пор, пока она не будет правильно выполнять требуемую задачу. Дополнительное преимущество указанного подхода заключается в том, что если мы создадим функции достаточно общего вида, то их можно будет использовать и в других программах.
Благодаря тому, что функции представляют собой самостоятельные, отдельно программируемые модули, программа выглядит как модульная структура. Модульное программирование позволяет разбивать программу на работоспособные блоки, которые в целом составляют законченную программу. Например, одна функция может использоваться для ввода данных, другая — для печати, третья — для записи данных на диск. В действительности, все операции в программах на С и C++ осуществляются в теле некоторой функции, которая называется main() и имеется во всех без исключения программах на С или C++.
Если вы работали с другими языками программирования, то заметите, что функции С очень похожи на программные модули других языков. Например, в Паскале применяются функции и процедуры, а в ФОРТРАНЕ только функции. Правильное проектирование функций в С и C++ в значительной степени определяет эффективность, читаемость и переносимость вашего программного кода.
Многие программисты предпочитают думать о функции, как о «черном ящике»; они задают ее через поступающую информацию (вход) и полученные результаты (выход). Все, что происходит внутри черного ящика, их не касается до тех пор, пока не нужно писать программу, реализующую эту функцию. Когда мы используем, например, функцию printf(), мы знаем, что должны передать ей управляющую строку и, возможно, несколько аргументов. Мы знаем также результат вызова функций printf(). He нужно полагать, что при программировании вам придется заниматься созданием функции printf(). Использование функций указанным выше способом позволяет сконцентрировать внимание на общей структуре программы, а не на деталях.
В этот материал включены многие программные примеры, назначение которых заключается в демонстрации способов создания и применения самых различных функций. Во многих примерах используются также встроенные библиотечные функции С и C++, расширяющие возможности ваших программ функций базируется на концепции прототипов функций, которая к моменту создания стандарта уже широко применялась в C++. В настоящий момент программирование на С переживает переходный период. Если вы читали журнальные статьи и книги, посвященные программированию на С, то наверно заметили, насколько различен в них стиль написания функций. Функции могут соответствовать, а могут и не соответствовать новому стандарту ANSI С, что зависит от того, пытаются ли сами программисты следовать этому стандарту. Компилятор Visual C/C++ использует для функций стандарт ANSI С, но может также компилировать и предыдущие версии. Программы на С здесь соответствуют стандарту ANSI С. Сделана попытка приблизить программы на C++ к стандарту ANSI С языка С, поскольку для C++ такого стандарта еще не существует.
Функции — это краеугольный камень в программировании на С и C++. Здесь излагается концепция функций и использование их прототипов согласно последнему стандарту ANSI С. Многочисленные примеры программ познакомят вас с различными типами функций и способами передачи параметров. Также вы узнаете правила применения стандартных переменных C/C++ argc и argv для передачи аргументов командной строки в функцию main(). Кроме этого, рассматриваются некоторые уникальные возможности, имеющиеся в C++.

        14.1. Создание и использование простой функции.
Что нам требуется знать о функциях? Нужно знать, как их можно определять, как к ним обращаться и как устанавливать связи между функцией и программой, ее вызывающей. Чтобы изучить это, мы далее рассмотрим очень простой пример, а затем будем обобщать его, вводя дополнительные характеристики до тех пор, пока не получим полную и ясную картину.
Наша первая скромная цель — создание функции, которая печатает 65 символов » в ряд. Чтобы эта функция выполнялась в некотором контексте, мы включили ее в программу, которая печатает простой титул фирменного бланка. Ниже приведена полная соответствующая программа. Она состоит из функций main() и starbar().

/* титул фирменного бланка! */
#include<stdio.h>
#define NAME "MEGATHINK, INC."
#define ADDRESS "10 Megabuck Plaza"
#define PLACE "Megapolis, CA 94904"
void starbar();
void main()
{
	starbar();
	printf("%s\n", NAME);
	printf("%s\n", ADDRESS);
	printf("%s\n", PLACE);
	starbar();
}

/* далее следует функция starbar() */
#define LIMIT 65
void starbar()
{
	int count;
	for (count=1; count<=LIMIT; count++)
		putchar('*');
	putchar('\n');
}

Результат работы программы выглядит так:



При рассмотрении этой программы необходимо обратить внимание на следующие моменты:
    1. Мы вызвали функцию starbar() (или, можно сказать, обратились к ней) из функции main(), используя только ее имя. Это несколько напоминает заклинание, вызывающее злого духа, но, вместо того чтобы чертить пятиугольник, мы помещаем вслед за именем функции точку с запятой, создавая таким образом оператор:

starbar();



Это одна из форм вызова функции, но далеко не единственная. Когда в процессе выполнения программы компьютер достигает оператора starbar(), он находит указанную функцию, после чего начинает выполнять соответствующие ей команды. Затем управление возвращается следующей строке «вызывающей программы» — в данном случае main().
    2. При написании функции starbar() мы следовали тем же правилам, что и при написании main(): вначале указывается имя, затем идет открывающая фигурная скобка, приводится описание используемых переменных, даются операторы, определяющие работу функции, и, наконец, закрывающая фигурная скобка. Мы даже поместили перед описанием функции starbar() директивы #define и #include, требующиеся для нее, а не для функции main().



    3. Мы включили функции starbar() и main() в один файл. Вообще говоря, можно было создать два отдельных файла. Один файл несколько упрощает компиляцию, а два отдельных файла облегчают использование одной функции в разных программах. Случай двух и более файлов мы обсудим позже, а пока будем держать все наши функции в одном месте. Закрывающая фигурная скобка функции main() указывает компилятору на ее конец. Круглые скобки в имени starbar() говорят о том, что starbar() — это функция. Обратите внимание, что здесь за именем star-bar() не следует символ «точка с запятой»; его отсутствие служит указанием компилятору, что мы определяем функцию starbar(), а не используем ее.

Если рассматривать функцию starbar() как черный ящик, то ее выход — это напечатанная строка, состоящая из символов *. Какие бы то ни было данные на входе у нее отсутствуют, потому что ей не нужно использовать информацию из вызывающей программы. Вообще, этой функции не требуется связь с вызывающей программой.
Обратимся к случаю, когда такая связь необходима.

        14.2. Прототипы функций.
Если вы еще не знакомы с тем, как писать функции на С, то у вас, возможно, возникнут разные вопросы. Как выглядит функция? Где она записывается в программе? Как объявляется? Из чего состоит? Где выполняется проверка типов?
Согласно стандарту ANSI С все функции должны иметь прототипы. Прототипы могут располагаться либо в самой программе на С или C++, либо в заголовочном файле. Большинство прототипов функций находятся в самих программах. Объявление функции в С и C++ начинается с ее прототипа. Прототип функции достаточно прост; обычно он включается в начало программы для того, чтобы сообщить компилятору тип и количество аргументов, используемых некоторой функцией. Использование прототипов обеспечивает более строгую проверку типов по сравнению с той, которая была при прежних стандартах С.
Хотя допустимы и другие стили записи прототипов функций, все же рекомендуется использовать, по возможности, следующий стиль: повторение строки объявления функции с добавлением в конце точки с запятой. Например:

возвращаемый_тип имя_функции(тип_аргумевта(-ов)) (имя_аргумента(-ов));

Функция может иметь тип void, int, float и так далее и определяется возвращаемым типом. Имя_функции() — это любое значимое наименование, выбранное вами для определения этой функции. Если в функцию передается некоторая информация, то необходимо также задать тип_аргумента и затем — имя_аргумента. Аргументы также могут иметь тип void, int, float и так далее. Можно передавать функции несколько значений, повторяя тип и имя аргумента и отделяя их от остальных аргументов запятой. Допускается перечисление только типов аргументов, однако, такая форма прототипов используется нечасто.
Сама функция содержит в себе некий фрагмент программного кода на С или C++ и обычно следует за описанием функции main(). Функция может иметь следующий вид:

возвращаемый_тип имя_функции(типы_аргументов и имена_аргументов)
{
.
.
.
(объявления данных и тело функции)
.
.
return();
}

Обратите внимание на то, что первая строка самой функции идентична прототипу, который располагается в начале программы, за одним важным исключением: в конце отсутствует точка с запятой. В следующем примере на С показаны прототип функции и ее использование в программе:

/*08PROTO.C
Программа на С, иллюстрирующая использование прототипа функции.
Функция складывает два целых числа и возвращает целое число*/

#include "stdafx.h"
#include <iostream>
#include <conio.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <stdlib.h>
using namespace std;

int iadder(int ix, int iy); /* прототип функции */
main()
{
	int ia=23;
	int ib=13;
	int ic;
	ic=iadder(ia,ib);
	printf("The summ is: %d\n",ic);
	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

int iadder(int ix, int iy) /* объявление функции */
{
	int iz;
	iz=ix + iy;
	return(iz); /* возврат из функции */
}



Функция называется iadder(). В прототипе декларируется, что функция имеет два целочисленных аргумента и возвращает целочисленное значение. В действительности, стандарт ANSI С предполагает, что все прототипы функций располагаются в некотором отдельном заголовочном файле. Таким же образом, как вы можете догадаться, связаны заголовочные файлы и соответствующие библиотеки С. Как уже упоминалось, для простых программ допустимо включать прототип функции в тело самой программы.
Написание приведенной выше функции на C++ практически аналогично:

//08PROTO.CPP
//Программа на C++, иллюстрирующая использование прототипа функции.
//Функция складывает два целых числа и возвращает целое число

#include "stdafx.h"
#include <iostream>
#include <conio.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <stdlib.h>
using namespace std;

int iadder(int ix, int iy); // прототип функции
main()
{
	int ia=23;
	int ib=13;
	int ic;
	ic=iadder(ia,ib);
	cout << "The summ is: " << ic << endl;
	printf( "This is executed first.\n" );
	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

int iadder(int ix, int iy) // объявление функции
{
	int iz;
	iz=ix+iy;
	return(iz);
}



        14.3. Вызов по значению и вызов по ссылке.
В предыдущих примерах аргументы передаются функциям по значению. Когда переменные передаются по значению, в функцию передается копия текущего значения этой переменной. Поскольку передается копия переменной, сама эта переменная внутри вызывающей функции не изменяется. Вызов по значению — наиболее распространенный способ передачи информации (параметров) в функцию, и этот метод в С и C++ задан по умолчанию. Главным ограничением вызова по значению является то, что функция обычно возвращает только одно значение.
При вызове по ссылке в функцию передается не текущее значение, а адрес аргумента. Программе требуется меньше памяти, чем при вызове по значению. Кроме того, переменные в вызывающей функции могут быть изменены. Еще одним достоинством этого метода является то, что функция может возвращать более одного значения.
В результате выполнения операции & определяется адрес ячейки памяти, которая соответствует переменной. Если pooh — имя переменной, то &рooh — ее адрес. Можно представить себе адрес как ячейку памяти, но можно рассматривать его и как метку, которая используется компьютером для идентификации переменной. Предположим, мы имеем оператор

pooh = 24;

Пусть также адрес ячейки, где размещается переменная pooh, — 12126. Тогда в результате выполнения оператора

printf( %d %d\n" , pooh, &pooh);

получим

24 12126

Более того, машинный код, соответствующий первому оператору, словами можно выразить приблизительно так: «Поместить число 24 в ячейку с адресом 12126».
Воспользуемся указанной выше операцией для проверки того, в каких ячейках хранятся значения переменных, принадлежащих разным функциям, но имеющих одно и то же имя.

/* контроль адресов */
#include<stdio.h>
void mikado(int);
void main()
{
	int pooh = 2, bah = 5;
	printf(" B main(), pooh = %d u &pooh = %u\n" , pooh, &pooh);
	printf(" B main(), bah = %d u &bah = %u\n", bah, &bah);
	mikado(pooh);
}

void mikado(int bah)
{
	int pooh = 10;
	printf(" B mikado(), pooh = %d u &pooh = %u\n", pooh, &pooh);
	printf(" B mikado(), bah = %d u &bah = %u\n" , bah, &bah);
}
		

Мы воспользовались форматом %u (целое без знака) для вывода на печать адресов на тот случай, если их величины превысят максимально возможное значение числа типа int. В нашей вычислительной системе результат работы этой маленькой программы выглядит так:



О чем это говорит? Во-первых, две переменные pooh имеют различные адреса. То же самое верно и относительно переменных bah. Следовательно, как и было обещано, компьютер рассматривает их как четыре разные переменные. Во-вторых, при вызове mikado(pooh) величина фактического аргумента (pooh из main()) передается формальному аргументу (bah из mikado()). Обратите внимание, что было передано только значение переменной. Адреса двух переменных (pooh в main() и bah в mikado()) остаются различными.
Мы коснулись второго вопроса потому, что этот факт оказывается неверным для всех других языков. В той или иной процедуре Фортрана, например, можно использовать переменные вызывающей программы. Кроме того, в такой процедуре переменные могут иметь различные имена, но адреса их при этом будут совпадать. В языке Си подобные механизмы отсутствуют. Каждая функция использует свои собственные переменные. Это более предпочтительно, потому что «исходные» переменные не будут таинственным образом изменяться из-за того, что вызванная функция обладает побочным эффектом. Но это может также приводить и к некоторым трудностям, о чем и будет рассказано отдельно.
Иногда требуется, чтобы одна функция могла изменять переменные, относящиеся к другой. Например, в задачах сортировки часто бывает необходимо осуществлять обмен значениями между двумя переменными. Предположим, у нас есть две переменные х и у и мы хотим, чтобы они обменялись своими значениями. Простая последовательность операторов

х = у;
y = х;

не является решением поставленной задачи, потому что к тому моменту, когда начнет выполняться оператор во второй строке, первоначальное значение переменной X будет потеряно. Чтобы сохранить это первоначальное значение, необходимо дополнить данный фрагмент еще одной строкой:

temp = х;
х = у;
у = temp;

Теперь у нас есть требуемый метод; реализуем его в виде некоторой функции, а также создадим драйвер для ее проверки. Чтобы сделать более ясным, какая переменная принадлежит функции main(), а какая — функции interchange(), мы будем использовать переменные х и у в первой из них, и u и v — во второй.

/* обмен1 */
#include<stdio.h>
void interchange(int , int);

void main()
{
	int x=5, y=10;
	printf(" At the beginning x = %d and y = %d.\n", x, y);
	interchange(x, y);
	printf(" And now x = %d and y = %d.\n", x, y);
}
void interchange(int u, int v)
{
		int temp;
		temp = u;
		u = v;
		v = temp;
}



Попробуем выполнить эту программу. Результаты будут выглядеть следующим образом:

Вначале х = 5 и у = 10.
Теперь х = 5 и у = 10.

Не может быть! Значения переменных не поменялись местами! Вставим в программу interchange() несколько операторов печати, чтобы понять причину допущенной ошибки.

/* обмен2 */
#include<stdio.h>
void interchange(int ,int );
void main()
{
	int x = 5, y = 10;
	printf(" At the beginning x =%d and y = %d.\n", x, y);
	interchange(x,y);
	printf(" And now x = %d and y = %d.\n", x, y);
}

void interchange(int u,int v)
{
	int temp;
	printf(" At the beginning u = %d and v = %d.\n" , u, v);
	temp = u;
	u = v;
	v = temp;
	printf(" And now u = %d and v = %d.\n" , u, v);
}

Результат работы этой программы выглядит так:



Отсюда видно, что ничего неправильного в работе функции interchange() нет; она осуществляет обмен значениями между переменными u и v. Проблема состоит в передаче результатов обратно в функцию main(). Как мы уже указывали, функции interchange() и main() используют различные переменные, поэтому обмен значениями между переменными u и v не оказывает никакого влияния на х и у! А нельзя ли каким-то образом воспользоваться оператором return? Мы могли бы, конечно, завершить тело функции interchange() строкой

return(u);

и изменить форму вызова в функции main() следующим образом:

х = interchange(x, у);

В результате такого обращения к функции переменная х получит новое значение, но у при этом не изменится.
С помощью оператора return в вызывающую программу можно передать только одну величину. Но нам нужно передать две величины. Это оказывается вполне осуществимым! Для этого нужно лишь воспользоваться «указателями».
В следующем примере используется функция iadder(). На этот раз переменные передаются в функцию по ссылке. Как показано ниже, в С для вызова по ссылке в качестве аргумента функции передается указатель. Этот же метод можно использовать и в C++. /*

//08CBEF.C
//Программа на С, иллюстрирующая передачу параметров по ссылке
#include "stdafx.h"
#include <iostream>
#include <conio.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <stdlib.h>
using namespace std;

int iadder(int *pix, int *piy); //прототип функции
main()
{
	int ia=23;
	int ib=13;
	int ic;
	ic=iadder(&ia,&ib);
	printf("The summ is: %d\n",ic);

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

int iadder(int *pix, int *piy) //объявление функции
{
	int iz;
	iz=*pix + *piy;
	return(iz);
}



Как вы уже знаете, в С в качестве аргументов при объявлении функций можно использовать переменные и указатели. В C++ кроме переменных и указателей имеется третий тип аргументов, называемый ссылочным типом (reference). Ссылочный тип задает адрес, однако не требует операции обращения по адресу. Во многих сложных программах на C++ такой синтаксис упрощает использование переменных-указателей внутри вызываемых подпрограмм. Внимательно изучите синтаксис следующего примера и сравните его с предыдущим:
//  08REFRNC.CPP
// Программа на C++, иллюстрирующая аналогичную передачу параметров
// по ссылке с использованием ссылочного типа C++
#include "stdafx.h"
#include <iostream>
#include <conio.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <stdlib.h>
using namespace std;

int iadder(int &rix, int &riy); //прототип функции

main()
{
	int ia=23;
	int ib=13;
	int ic;
	ic=iadder(ia,ib);
	cout << "The summ is: " << ic << endl;

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

int iadder(int &rix, int &riy) //объявление функции
{
	int iz;
	iz=rix+riy;
	return(iz);
}



Вы заметили отсутствие указателей при просмотре листинга программы на C++? К ссылочному типу данных в примере относятся rix и riy. В C++ запрещены ссылки на ссылки, ссылки на битовые поля и массивы ссылок, а также указатели на ссылки. Вне зависимости от того, используется ли вызов функции по ссылке или же ссылочный тип данных, в любом случае в C++ идет обращение к адресу аргумента.

        14.4. Использование указателей для связи между функциями
Мы только прикоснулись к обширному и увлекательному миру указателей. Сейчас нашей целью является использование указателей для решения задачи об установлении связи между функциями. Ниже приводится программа, в которой указатели служат средством, обеспечивающим правильную работу функции, которая осуществляет обмен значениями переменных. Посмотрим, как она выглядит, выполним ее, а затем попытаемся понять, как она работает.

/* обменЗ */
#include<stdio.h>
void interchange(int * ,int * );

void main()
{
	int x = 5, y = 10;
	printf(" At the beginning x = %d and y = %d.\n" , x, y);
	interchange(&x,&y); /* передача адресов функции */
	printf(" And now x = %d and y = %d.\n" , x, y);
}

void interchange(int *u, int *v) /* u и v являются указателями */
{
	int temp;
	temp = *u; /* temp присваивается значение, на которое указывает u */
	*u = *v;
	*v = temp;
}

После всех встретившихся трудностей, проверим, работает ли этот вариант!



Да, программа работает.
Посмотрим, как она работает. Во-первых, теперь вызов функции выглядит следующим образом:

interchange(&x, &y);

Вместо передачи значений х и у мы передаем их адреса. Это означает, что формальные аргументы и и v, имеющиеся в спецификации

interchange(u,v)

при обращении будут заменены адресами и, следовательно, они должны быть описаны как указатели. Поскольку х и у — целого типа, а u и v являются указателями на переменные целого типа, и мы вводим следующее описание:

int *u, *v;

Далее в теле функции оператор описания

int temp

используется с целью резервирования памяти. Мы хотим поместить значение переменной х в переменную temp, поэтому пишем

temp = *u;

Вспомните, что значение переменной u — это &х, поэтому переменная и ссылается на х. Это означает, что операция *u дает значение х, которое как раз нам и требуется. Мы не должны писать, например, так:

temp = u; /* неправильно */

поскольку при этом происходит запоминание адреса переменной х, а не ее значения; мы же пытаемся осуществить обмен значениями, а не адресами.
Точно так же, желая присвоить переменной у значение переменной х, мы пользуемся оператором

*u = *v;

который соответствует оператору

х = у;

Подведем итоги. Нам требовалась функция, которая могла бы изменять значения переменных x и у. Путем передачи функции адресов переменных х и у мы предоставили ей возможность доступна к ним. Используя указатели и операцию *, функция смогла извлечь величины, помещенные в соответствующие ячейки памяти, и поменять их местами.
Вообще говоря, при вызове функции информация о переменной может передаваться функции в двух видах. Если мы используем форму обращения

function1(х);

происходит передача значения переменной х. Если же мы используем форму обращения

function2(&x);

происходит передача адреса переменной х. Первая форма обращения требует, чтобы определение функции включало в себя формальный аргумент того же типа, что и х:

function1(num)
int num;

Вторая форма обращения требует, чтобы определение функции включало в себя формальный аргумент, являющийся указателем на объект соответствующего типа:

function2(ptr)
int *ptr;

Пользуйтесь первой формой, если входное значение необходимо функции для некоторых вычислений или действий, и второй формой, если функция должна будет изменять значения переменных в вызывающей программе. Вторая форма вызова уже применялась при обращении к функции scanf(). Когда мы хотим ввести некоторое значение в переменную num, мы пишем scanf("%d", &num). Данная функция читает величину, затем, используя адрес, который ей дается, помещает эту величину в память.
Указатели позволяют обойти тот факт, что переменные функции interchange() являются локальными. Они дают возможность нашей функции «добраться» до функции main() и изменить величины описанных в ней объектов.
Программисты, работающие на языке Паскаль, могут заметить, что первая форма вызова аналогична обращению с параметром-значением, а вторая — с параметром-переменной. У программистов, пишущих на языке Бейсик, понимание всей этой методики может вызвать некоторые затруднения. В этом случае, если материал данного раздела покажется вам поначалу весьма необычным, не сомневайтесь, что благодаря некоторой практике, все обсуждаемые средства станут простыми, естественными и удобными.

        14.5. Рекурсия.
Как уже упоминалось ранее, функция может вызывать сама себя. При этом говорят, что возник рекурсивный вызов. Рекурсия бывает:
простой - если функция в теле содержит вызов самой себя;
косвенной – если функция вызывает другую функцию, а та в свою очередь вызывает первую.

При выполнении рекурсии программа сохраняет в стеке значения всех локальных переменных функции и ее аргументов с тем, чтобы в дальнейшем по возвращении из рекурсивного вызова восстановить их сохраненные значения. Рис. 0403 иллюстрирует поведение рекурсивной функции.


Рис. 0403. Рекурсивный вызов

В связи с вышеизложенным, применять рекурсию следует с осторожностью, так как ее использование для функции, содержащих количество переменных или слишком большое вызовов, может вызвать переполнение стека, также помнить, что при использовании рекурсивного вызова разработчик обязан предусмотреть механизм возврата в вызывающую процедуру, чтобы не произошло образования бесконечного цикла.
Некоторые задачи на практике могут быть проще и нагляднее решены именно с использованием рекурсивных функций. Например, решение тривиальной задачи нахождения факториала без обращения к рекурсии могло бы выглядеть следующим образом:

#include <iostream>
using namespace std;

int main ()
{
	setlocale(LC_ALL, "Rus");
	int count = 1;
	long int result =1;
	while(count && count <31){
		cout <<"Введите целое число: ";
		cin >> count;
		for(int i= count; i> 1; i--){
			result *= i;
		}
		cout << result << '\n';
		result = 1;
	}

	getchar(); 	getchar();
	return 0;
}

Ту же задачу можно решить более элегантно, применив рекурсию:

#include <iostream>
using namespace std;

long int fact(long);

int main()
{
	setlocale(LC_ALL, "Rus");
	int count = 1;
	while(count && count < 31){
		cout << "Введите целое число: ";
		cin >> count;
		cout << fact(count) << '\n';
	}

	getchar(); 	getchar();
	return 0;
}

long int fact(long x)
{
	if (x== 0 || x== 1)
		return 1;
	return x * fact(x-1);
}

Как видно, тело функции main () во втором примере максимально упростилось и занимается фактически вводом значения и выводом результата, в то время как все вычисления возложены на единственную содержательную строку в рекурсивной функции fact().



Рекурсия возникает в программах, в которых некоторая функция вызывает сама себя. Поначалу рекурсия кажется похожей на бесконечный цикл, однако, это не так. Рекурсия поддерживается как в С, так и в C++. Рекурсивные алгоритмы позволяют получить эффективное, читабельное и компактное решение задачи. Например: в следующей программе рекурсия используется для вычисления факториала числа. Факториал числа определяется как произведение самого числа и всех предыдущих целых чисел. Например:

8*7*6*5*4*3*2*1= 40320

Необходимо внимательно выбирать тип данных, так как произведение растет очень быстро: факториал 15 равен 1307674368000.

/*08FACTR.C
Программа на С, использующая рекурсивные вызовы функции.
Вычисляет факториал числа.
Пример: 7! =7x6x5x4x3x2x1= 5040*/

#include "stdafx.h"
#include <iostream>
#include <conio.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <stdlib.h>
using namespace std;

double dfactorial(double danswer);

main()
{
	double dnumber=15.0;
	double dresult;
	dresult=dfactorial(dnumber);
	printf("The factorial of %.0lf is: %.0lf\n",dnumber,dresult);

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

double dfactorial(double danswer)
{
	if(danswer <= 1.0)
		return(1.0);
	else
		return(danswer*dfactorial(danswer-1.0));
}



Возникает рекурсия, так как внутри функции dfactorial() имеется вызов ее самой. Обратите также внимание на то, что в функции printf() используется новый код форматирования для печати значения двойной длины: %...lf. Здесь "l" является модификатором формата "f и обозначает тип double вместо float.

            1.1.1. Равноправность функций в языке Си.
Все функции в программе, написанной на языке Си, равноправны: каждая из них может вызывать любую другую функцию и в свою очередь каждая может быть вызвана любой другой функцией. Это делает функции языка Си несколько отличными от процедур Паскаля, поскольку процедуры в Паскале могут быть вложены в другие процедуры (причем, процедуры, содержащиеся в одном гнезде, являются недоступными для процедур, расположенных в другом).
Нет ли у функции main() какой-то специфики? Безусловно, есть. Она заключается в том, что после «сборки» программы, состоящей из нескольких функций, ее выполнение начинается с первого оператора функции main(). Но этим ее исключительность и ограничивается. Даже функция main() может быть вызвана другими функциями, как показывает приведенный ниже пример:

/* вызов функции main() */
#include <stdio.h>
main()
{
char ch;
printf (" Укажите произвольный символ. Q — признак конца работы.\n");
ch = getchar();
printf ("Так! Вы указали %c!\n", ch);
if (ch != 'Q')
	more();
}

more()
{
main();
}

Функция main() вызывает more(), а функция more() вызывает main()! После вызова функции main() ее выполнение начинается с самого начала; мы организовали цикл с взаимным вызовом.
Функция может даже вызывать сама себя. Упростим предыдущий пример следующим образом:

/* main.main */
#include <stdio.h>
main()
{
char ch;
printf (" Укажите произвольный символ. Q признак конца работы.\n");
ch = getchar();
printf ("Так! Вы указали %c!\n", ch); if (ch != 'Q')
main();
}

Ниже приводятся результаты одного прогона программы, показывающие, что она работает. Обратите внимание на то, как обрабатывается символ «новая строка», который передается программе при нажатии клавиши [ввод].



Действие, состоящее в том, что функция вызывает сама себя, называется «рекурсией». Цикл, который мы создали, используя рекурсию, отличается от циклов while и do while. Когда функция main() вызывает сама себя, не происходит передачи управления на ее начало. Вместо этого в памяти машины создаются копии всего набора переменных функции main(). Если вы выведете на печать адреса переменных в обычном цикле, то увидите, что эти адреса не изменяются от итерации к итерации. Что же касается рассматриваемого здесь цикла, то в нем адрес используемой переменной меняется, поскольку при каждом выполнении тела цикла создается новая копия переменной ch . Если программа циклически выполняется 20 раз, то будет создано 20 различных копий переменной, каждая из. которых носит имя ch, но имеет свой собственный адрес.

        14.6. Параметры и аргументы функций
Каждая функция, которую предполагается использовать в программе, должна быть в ней объявлена. Обычно объявления функций размещают в заголовочных файлах, которые затем подключаются к исходному тексту программы с помощью директивы #include. Объявление функции описывает ее прототип (иногда говорят, сигнатура). Прототип функции объявляется следующим образом:

возвр_тип FuncName(список объявляемых параметров);

Здесь возвр_тип - возвращаемый функцией тип данных. Если возвращаемый тип данных не указан, то по умолчанию компилятор считает, что возвращаемый функцией тип есть int. Список объявляемых параметров задает тип и имя каждого параметра функции, разделенные запятыми. Допускается опускать имя параметра. Список объявляемых параметров функции может быть пустым. Приведем примеры прототипов функций:

int swap(int, int);
double max (double parl, double par2);
void func();

Прототип функции может быть пропущен, если определение функции следует до первого ее вызова из любой другой функции. Последний вариант считается плохим стилем программирования, так как бывают случаи перекрестных вызовов, то есть когда две или несколько функций вызывают друг друга, в результате чего невозможно вызвать одну функцию без предварительного определения другой.
Определение функции состоит из ее заголовка и собственно тела, заключенного в фигурные скобки и несущего смысловую нагрузку. Если функция возвращает значение, отличное от типа void, в теле функции обязательно должен присутствовать оператор return с параметром того же типа, что и возвращаемое значение. В случае если возвращаемое значение не будет использоваться в дальнейшем в программе (void), оператор return следует без параметра или вообще может быть опущен, тогда возврат из функции осуществляется по достижении закрывающейся скобки.
Для того чтобы функция выполнила определенные действия, она должна быть вызвана в программе. При обращении к функции она выполняет поставленную задачу, а по окончании работы возвращает в качестве результата некоторое значение.
Вызов функции представляет собой указание идентификатора функции (ее имени), за которым в круглых скобках следует список аргументов, разделенных запятыми:

имя_функции ( аргумент_1,
			аргумент_2,
			аргумент_3,
			аргумент_N);

Каждый аргумент функции представляет собой переменную, выражение или константу, передаваемые в тело функции для дальнейшего использования в вычислительном процессе. Список аргументов функции может быть пустым.
Функция может вызывать другие функции (одну или несколько), а те, в свою очередь, производить вызов третьих и т.д. Кроме того, функция может вызывать сама себя. Это явление в программировании называется рекурсией. Подробнее рекурсия будет рассмотрена ниже.
Как уже было отмечено ранее, любая программа на C++ обязательно включает в себя главную функцию main(). Именно с этой функции начинается выполнение программы.
На рис.0401 показан схематический порядок вызова функций.


Рис. 0401. Вызов функции

Программа начинает выполняться с функции main() до вызова функции FUNC1 (х, у). С этого момента управление программой передается в функцию FUNC1 (х, у), причем в качестве значения переменной Radius данная функция использует величину переменной х, а в качестве переменной Symbol передается значение у (рис. 0402 иллюстрирует передачу параметров в функции). Далее до оператора return выполняется тело функции FUNC1(х, у), после чего управление возвращается в тело функции main (), а именно, следующему за вызовом FUNC1 (х, у) оператору. После этого продолжается выполнение функции main() до вызова функции FUNC2(a, b, с) При вызове этой функции переменная а передает значение логической переменной YesNo, переменная b целочисленной переменной Count, а переменная с - короткому целому Key.


Рис. 0402. Передача параметров в функции

Функция main () часто не имеет аргументов, однако, если требуется при вызове программы передать ей какие-нибудь параметры, синтаксис функции main() меняется:

int main(argc, argv)

Здесь первый аргумент, argc, указывает количество передаваемых параметров, а второй, argv, является указателем на массив символьных строк, содержащих эти аргументы. Массивы и указатели будут рассмотрены позже.
Рассмотрим несколько примеров объявления, вызова и определения функций.

// Объявление функций:
int MyFunction(int Number, float Point);
char InputSymbol();
void SetBit(short Num);
void EmptySample(int, char);

// Вызов функций:
Result = MyFunction(varbl, 3.14);
symb = InputSymbol();
SetBit(3);
EmptySample (2, smb1);

//Определение функций:
int MyFunction (int Number, float Point)
{
int mу_х;
…
return my_x; // my x - типа int
}

char InputSymbol ()
{
char symbol;
cin >>symbol;
return symbol;
}

void SetBit (short number)
{
GlobalBit = GlobalBit | number;
}

void EmptySample (int x, char ch)
{
}

Для того чтобы было более понятно место функции в программе, детально рассмотрим пример вычисления квадрата числа с использованием функции.
В заголовочном файле header. h разместим прототип функции MySquare ():

// header.h
long MySquare(int);

Тогда главный модуль программы будет подключать заголовочный файл, содержать описание и вызов функции MySquare () из функции main().

MyFile.cpp

#include "header.h"

int main()
{
	setlocale(LC_ALL, "Rus");
	int Variable = 5;
	cout << MySquare(Variable);

	getchar(); 	getchar();
	return 0;
}

header.h

long MySquare(int x)
{
	return x * x;
}



Тот же пример может выглядеть несколько иначе, если вместо подключения заголовочного файла поместить прототип функции MySquare () прямо в файл исходного текста программы:

#include <iostream>
using namespace std;

// Прототип функции
long MySquare(int);

int main()
{
	setlocale(LC_ALL, "Rus");
	int Variable = 5;
	cout << MySquare(Variable);

	getchar(); 	getchar();
	return 0;
}

long MySquare(int x)
{
	return x * x;
}

Результат работы программы не изменится - на печать будет выведено число 25.



В этом разделе вы узнаете о том, как передавать аргументы функции. Эти аргументы могут называться по-разному: некоторые программисты называют их аргументами, другие — параметрами или фиктивными переменными.
Аргументы функции не обязательны. Одни разработанные вами функции могут не иметь аргументов, а у других их может быть много. Тип аргументов одной функции может быть разным; это означает, что для них можно использовать любые стандартные типы данных. В следующих примерах показаны функции с аргументами разных типов. Кроме этого, в этих примерах используются функции из различных библиотек С и C++. Дополнительная информация о библиотечных функциях и их прототипах содержится в справочных руководствах по Visual C/C++.
Титул фирменного бланка выглядел бы несколько лучше, если бы текст был сдвинут к центру. Мы сможем поместить текст в центре, если напечатаем нужное число пробелов перед выводом требуемой строки. Воспользуемся некоторой функцией для печати пробелов. Наша функция space() (давайте назовем ее так) будет очень напоминать функцию starbar(), за исключением того, что на этот раз между функцией main() и функцией space() должна быть установлена связь, так как необходимо сообщить последней функции о требуемом числе пробелов.
Рассмотрим это более конкретно. В строке, состоящей из звездочек, 65 символов, а в строке MEGATHINK, INC. — 15. Поэтому в нашем первом варианте программы вслед за этим сообщением шло 50 пробелов. Чтобы сместить текст к центру, нужно сначала напечатать 25 пробелов, а потом текст, в результате чего слева и справа от данной фразы окажется по 25 пробелов. Следовательно, необходимо иметь возможность передать величину «25» функции, печатающей пробелы. Мы применяем тот же способ, что и при передаче символа '*' функции putchar(): используем аргумент. Тогда запись space(25) будет означать, что необходимо напечатать 25 пробелов. 25 — это аргумент. Мы будем вызывать функцию sрасе() три раза: один раз для каждой строки адреса. Вот как выглядит эта программа:

/* титул фирменного бланка2 */
#include<stdio.h>
#include<string.h>
#define NAME "MEGATHINK, INC."
#define ADDRESS " 10 Megabuck Plaza"
#define PLACE "Megapolis, CA 94904"
void starbar();
void space(int);
void main()
{
	int spaces;
	starbar();
	space(25); /* space() использует в качестве аргумента константу */
	printf("%s\n", NAME);
	spaces = (65 - strlen(ADDRESS))/2;
	/* мы заставляем программу вычислять, сколько пропустить пробелов */
	space(spaces); /* аргументом является переменная */
	printf("%s\n", ADDRESS);
	space((65-strlen(PLACE))/2); /* аргументом является выражение */
	printf("%s\n", PLACE);
	starbar();
}

/* определение функции starbar() */
#define LIMIT 65
void starbar()
{
	int count;
	for (count=1; count<=LIMIT; count++ )
		putchar('*'); putchar('\n');
}

/* определение функции space() */
void space(int number)
{
	int count; /* дополнительная переменная описывается после фигурной скобки */
	for (count=1; count<=number; count++)
		putchar(' ');
}
Обратите внимание на то, как мы экспериментировали при вызовах функции space(): мы задавали аргумент тремя различными способами. Являются ли все они работоспособными? Да — и вот доказательство.



Обратите внимание на то, как мы экспериментировали при вызовах функции space(): мы задавали аргумент тремя различными способами. Являются ли все они работоспособными? Да — и вот доказательство.



Рассмотрим сначала, как определить функцию с одним аргументом, после чего перейдем к вопросу о том, как она используется.
Определение нашей функции начинается с двух строк:

space(number)
int number;

Первая строка информирует компилятор о том, что у функции space() имеется аргумент и что его имя number. Вторая строка — описание, указывающее компилятору, что аргумент number имеет тип int. Обратите внимание: аргумент описывается перед фигурной скобкой, которая отмечает начало тела функции. Вообще говоря, вы можете объединить эти две строки в одну:

space(int number;)

Независимо от формы записи переменная number называется «формальным» аргументом. Фактически это новая переменная, и в памяти компьютера для нее должна быть выделена отдельная ячейка.
Посмотрим, как можно пользоваться этой функцией.
Задача в данном случае состоит в том, чтобы присвоить некоторую величину формальному аргументу number. После того как эта переменная получит свое значение, программа сможет выполнить свою задачу. Мы присваиваем переменной number значение фактического аргумента при вызове функции. Рассмотрим наш первый случай использования функции space():

space(25);

Фактический аргумент здесь 25, и эта величина присваивается формальному аргументу — переменной number, т. е. вызов функции оказывает следующее действие:

number = 25;

Короче говоря, формальный аргумент — переменная в вызываемой программе, а фактический аргумент — конкретное значение, присвоенное этой переменной вызывающей программой. Как было показано в нашем примере, фактический аргумент может быть константой, переменной или даже более сложным выражением. Независимо от типа фактического аргумента он вначале вычисляется, а затем его величина (в данном случае некоторое целое число) передается функции. Рассмотрим, например, наше последнее обращение к функции space().

space((65- strlen(PLACE))/2);

Сначала было вычислено значение длинного выражения, образующего фактический аргумент; оно оказалось равным 26. Затем величина 26 присваивается переменной number. Функция не знает и не «хочет» знать, является ли поступившее число константой, значением некоторой переменной или более общего выражения. В заключение повторим снова, что фактический аргумент — это конкретное значение, которое присваивается переменной, называемой формальным аргументом.
Рассматривая функцию space() как черный ящик, можно сказать, что ее вход — это число пропущенных позиций, а выход — фактический пропуск позиций. Вход связан с функцией через аргумент. С помощью аргумента обеспечивается связь между функциями main() и space(). В то же время переменная count описана внутри тела функции, и другие функции ничего не знают о ней. Указанная переменная является частью механизма, скрытого внутри черного ящика. Это не та же переменная, что count в starbar().



            1.1.2. Формальные и фактические параметры.
Каждое описание функции содержит некоторый список аргументов, называемый списком формальных параметров. Элементы в этом списке необязательны, поэтому список может быть как пустым, так и содержать комбинацию элементов любого типа данных, например integer, float и character.
Если какая-то программа вызывает функцию, то она передает этой функции список параметров, называемый списком фактических параметров. Если программа соответствует стандарту ANSI С, то списки формальных и фактических параметров полностью совпадают, хотя на практике строгая проверка не выполняется.
Рассмотрим следующий пример на С:

printf("This is hexadecimal %x and octal %o",ians);

В данном примере функции printf() передается только один параметр, хотя ожидаются два. Если список параметров неполон, то недостающие параметры инициализируются произвольными значениями. В C++ эта проблема отчасти решена: в списке формальных параметров можно указывать значения по умолчанию. Если некоторый параметр отсутствует в списке фактических параметров, то автоматически подставляется его значение по умолчанию. Например, в C++ можно записать следующий прототип функции:

int iyourfunction (int it, float fu=4.2, int iv=10)

Если при вызове функции iyourfunction() не указаны параметры fu или iv, то будут использоваться указанные значения (4.2 или 10). В C++ все формальные параметры, имеющие значения по умолчанию, необходимо ставить в конце списка формальных параметров. Другими словами, допустимы вызовы iyourfunction(10) и iyourfiinction(10,15.2). Если же значение fu не указано, то значение iv указывать нельзя.

Параметры и/или аргументы?
В чем разница аргумента и параметра?
Параметром (формальным параметром) функции называется переменная в функции, которая будет содержать передаваемое снаружи входное значение.
Аргументом называют фактическую переменную или выражение, значение которого используется как входное значение при вызове функции.
Пример:

double Negate(double x)
{
    return -x;
}

Здесь x — параметр функции Negate.

double r = Negate(5.0);

Здесь 5.0 — аргумент вызова функции Negate.
Таким образом, набор параметров (то есть, «переданных снаружи» переменных) функции фиксирован, а вот аргументы (то есть, выражения, значения которых попадут в эти переменные) при каждом из вызовов могут быть свои.

Разница между параметром и аргументом сродни разнице между переменной и ее значением. Впрочем, эти два термина очень часто используют в качестве синонимов. Если вы случайно употребите одно вместо другого (не на экзамене!), вас без проблем поймут.

Формальные и фактические параметры
Важно различать:
    • формальный параметр — аргумент, указываемый при объявлении или определении функции.
    • фактический параметр — аргумент, передаваемый в функцию при её вызове;

Пример на языке Си:

// Описание функции. int a - формальный параметр, имя параметра может отсутствовать.
int myfunction(int a);

// Определение функции. int b - формальный параметр, имя параметра может не совпадать с указанным при объявлении функции.
int myfunction(int b) 
{
   return 0;
}

int main()
{
    int c=0;
    myfunction(c); // Вызов функции. c - фактический параметр.
    return 0;
}

            1.1.3. Аргумент типа void.
В соответствии с ANSI С, отсутствие списка аргументов функции должно быть указано явно при помощи ключевого слова void. В C++ использование void пока не обязательно, но считается целесообразным. В следующей программе имеется простая функция voutput(), не имеющая параметров и не возвращающая никакого значения. Функция main() вызывает voutput(). При выходе из voutput() управление возвращается функции main(). Трудно придумать более простую функцию

/*08FVOID.C
Программа на С печатает сообщение при помощи функции.
В функции используются параметр типа void и стандартная
библиотечная функция С sqrt()*/
#include "stdafx.h"
#include <iostream>
#include <conio.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <stdlib.h>
#include <math.h>
using namespace std;

void voutput(void);

main()
{
	/* Программа определяет квадратный корень */
	printf("This programm will find the square root\n\n\n");
	voutput();

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

void voutput(void)
{
	double dt=12345.0;
	double du;
	du=sqrt(dt);
	printf("The squre root of %lf is %lf\n",dt,du);
}



Обратите внимание, что функция voutput() вызывает библиотечную функцию С, называемую sqrt(). Прототип sqrt() находится в файле math.h. У функции один параметр в формате числа двойной длины, и возвращает она результат извлечения квадратного корня тоже в виде числа двойной длины.

            1.1.4. Символьные параметры.
Функции можно передавать символьные значения. В следующем примере в функции main() одиночный символ считывается с клавиатуры и передается функции voutput(). Символ считывается функцией getch(). В стандартной библиотеке С имеются другие функции, тесно связанные с функцией getch(): getc(), getchar() и getcher(). Функция getch() получает символ от стандартного устройства ввода (клавиатуры) и возвращает символьное значение, не отображая его на экране:
//08FCHAR.C
/*Программа на С считывает символ с клавиатуры, передает его функции
и печатает сообщение, использующее этот символ*/

#include "stdafx.h"
#include <iostream>
#include <conio.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <stdlib.h>
#include <math.h>
using namespace std;

void voutput(char c);

main()
{
	char cyourchar;
	/* Введите один символ с клавиатуры */
	printf("Enter one character from the keyboard. \n");
	cyourchar=getch();
	voutput(cyourchar);

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

void voutput(char c)
{
	int j;
	for(j=0;j<=16;j++)
		/* Введен символ ... */
		printf("The character typed is %c \n",c);
}



По листингу видно, что функции передается единственный символ. Функция 16 раз печатает сообщение и символ. Формат %с в функции printf() задает печать одиночного символа.

            1.1.5. Целочисленные параметры.
В следующем примере одно целое число вводится с клавиатуры при помощи функции С scanf() и передается функции vside(), в которой на основе полученного значения, означающего длину стороны, вычисляются и печатаются площадь квадрата, объем куба и площадь поверхности куба.
//08FINT.C
/*Программа на С вычисляет значения на основании введенной длины.
Функция получает параметр типа int, введенный с
клавиатуры при помощи функции scanf()*/
#include "stdafx.h"
#include <iostream>
#include <conio.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <stdlib.h>
#include <math.h>
using namespace std;

void vside(int is);

main()
{
	int iyourlength=0;
	/* Введите с клавиатуры длину как целое число */
	printf("Enter the length, as an integer from the keyboard. \n");
	scanf("%d",&iyourlength);
	vside(iyourlength);

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

void vside(int is)
{
	int iarea, ivolume,isarea;
	iarea=is*is;
	ivolume=is*is*is;
	isarea=6*iarea;
	/* Длина стороны равна */
	printf("The lenth of a side is %d \n",is);
	/* Квадрат будет иметь площадь */
	printf("The square would have an area of %d \n",iarea);
	/* Куб будет иметь объем */
	printf("The cube would have a volume of %d \n",ivolume);
	/* Площадь поверхности куба */
	printf("The surface area of the cub would have a square of %d \n",isarea);
}



Обратите внимание на то, что переменная is и все вычисленные значения имеют целый тип. А что произошло бы с типами вычисляемых значений, если бы переменная is представляла собой радиус круга и сферы?

            1.1.6. Параметры в формате чисел с плавающей точкой.
Числа с плавающей точкой так же легко передавать в качестве параметров функции, как и целые значения. В следующем примере на С в функцию, названную vhypotenuse(), передаются два числа с плавающей точкой. Для ввода с клавиатуры обоих чисел используется функция scanf().
//08FFLOAT.C
/*Программа на С вычисляет гипотенузу правильного треугольника.
Функция использует параметры типа float, которые вводятся с
клавиатуры при помощи функции scanfО*/
#include "stdafx.h"
#include <iostream>
#include <conio.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <stdlib.h>
#include <math.h>
using namespace std;

void vhypotenuse(float fx, float fy);

main()
{
	float fxlen,fylen;
	/* Введите основание правильного треугольника */
	printf("Enter the base of the right triangle from the keyboard. \n");
	scanf("%f",&fxlen);
	/* Введите высоту правильного треугольника */
	printf("Enter the heite of the right triangle from the keyboard. \n");
	scanf("%f",&fylen);
	vhypotenuse(fxlen, fylen);

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

void vhypotenuse(float ft, float fu)
{
	double dresult;
	dresult=hypot((double) ft, (double) fu);
	/* Гипотенуза правильного треугольника равна */
	printf("The hypotenuse of the right triangle is %g \n",dresult);
}



Следует заметить, что оба параметра функции vhypotenuse() преобразуются в тип double при использовании функции hypot() из math.h. Все функции, описанные в заголовочном файле math.h, получают и возвращают значения типа double. В своих программах вы можете использовать и другие математические функции, перечисленные в табл. 8.1. Для получения более подробной информации вы можете также просмотреть содержимое файла math.h.

Таблица. Математические функции, описанные в заголовочном файле Microsoft math.h

acos, acosl
Арккосинус
asin, asinl
Арксинус
atan, atanl
Арктангенс
atan2,atan2l
Арктангенс
bessel 
Функции Бесселя
_cabs, _cabsl
Абсолютное значение комплексного числа
ceil, ceill
Целочисленное максимальное значение
_chgsign
Инвертирование знака
_clear87, clearfp
Чтение и сброс слова состояния числа с плавающей точкой
_control87, _controlfp
Чтение старого управляющего слова числа с плавающей точкой и установка нового
_copysign
Возвращает число x со знаком числа y
cos,cosl
Косинус 
cosh, coshl
Гиперболический косинус
_dieeetomsbin
Преобразование IEEE-числа двойной точности в двоичный формат Microsoft
div
Деление одного целого на другое, возвращается частное и остаток
_dmsbintoieee
Преобразование Microsoft-числа двойной точности в формат IEEE
exp, expl
Степенная функция
fabs, fabsl
Абсолютное значение
_fieeetomsbin
Преобразование IEEE-числа одинарной точности в двоичный формат Microsoft
_finite
Проверка числа с плавающей точкой на бесконечность
floor, floorl
Нахождение наибольшего целого, меньшего или равного аргументу
fmod, fmodl
Нахождение остатка
_fmsbintoieee
Преобразование Microsoft-числа одинарной точности в формат IEEE
_fpclass
Возвращает слово состояния с информацией о классе чисел с плавающей точкой
_fpieee_flt
Вызов описанного пользователем обработчика исключительных ситуаций для чисел с плавающей точкой IEEE-стандарта
_fpreset
Повторная инициализация пакета математических функций
frexp, frexpl
Вычисление экспоненциального значения
_hypot, _hypotl
Вычисление гипотенузы правильного треугольника 
_isnan
Проверка числа с плавающей точкой на значение “не число” (NAN)
ldexp, ldexpl 
Произведение от аргумента
ldiv
Деление одного целого long на другое, возвращается частное и остаток
log, logl
Натуральный логарифм
log10, log10l
Десятичный логарифм
_logb
Выделение показателя числа с плавающей точкой
_irotl, _irotr
Сдвиг числа unsigned long int влево или вправо
_matherr, _matherrl
Обработка математических ошибок
_max, _min
Определение большего или меньшего из двух значение
modf, modfl
Деление аргумента на целую и дробную части
_nextafter
Определение следующего значения
pow, powl
Вычисление значения, возведенного в степень
rand
Получение псевдослучайного числа
_rotl, _rotr
Сдвиг числа unsigned int влево или вправо
_scalb
Степень числа 2, определяемая аргументом
sin, sinl
Синус
sinh, sinhl
Гиперболический синус
sqrt, sqrtl
Квадратный корень
srand
Инициализация датчика псевдослучайных чисел
_status87, _statusfp
Получение слов состояния числа с плавающей точкой
tan, tanl
Тангенс
tanh, tanhl
Гиперболический тангенс

            1.1.7. Параметры в формате чисел двойной длины.
Тип чисел двойной длины double обеспечивает очень большую точность чисел с плавающей точкой. Все функции, описанные файле math.h, получают и возвращают числа типа double. В следующей программе два числа двойной длины вводятся с клавиатуры. Функция, названная vpower(), возводит первое число в степень, определяемую вторым числом. Поскольку оба числа имеют тип double, можно, к примеру, вычислить, 45.7 в степени 5.2 равно 428118741.757.

//08FDOUBL.C
/*Программа на С возводит число в некоторую степень.
Функция использует параметр типа double и функцию pow()*/
#include "stdafx.h"
#include <iostream>
#include <conio.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <stdlib.h>
#include <math.h>
using namespace std;

void vpower(double dt, double du);

main()
{
	double dtnum,dunum;
	/* Введите основание степени */
	printf("Enter the base number from the keyboard. \n");
	scanf("%lf",&dtnum);
	/* Введите показатель степени */
	printf("Enter the power from the keyboard. \n");
	scanf("%lf",&dunum);
	vpower(dtnum, dunum);

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

void vpower(double dt, double du)
{
	double danswer;
	danswer=pow(dt, du);
	printf("The result %.2f ^ %.2f is %.2f \n",dt,du,danswer);
}



Здесь для возведения числа в некоторую степень используется библиотечная функция pow() с прототипом в файле math.h.

            1.1.8. Массивы в качестве параметров.
В следующем примере содержимое некоторого массива передается в функцию в качестве параметра, вызываемого по ссылке. В этом случае адрес первого элемента массива передается через указатель.

//08FPNTR.C
/*Программа на С передает функции массив в качестве параметра.
Для передачи информации о массиве используется указатель*/
#include "stdafx.h"
#include <iostream>
#include <conio.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <stdlib.h>
#include <math.h>
using namespace std;

void voutput(int *pinums);

main()
{
	int iyourarray[7]={2,7,15,32,45,3,1};
	/* Передать информацию о массиве в функцию */
	printf("Send array information to function. \n");
	voutput(iyourarray);

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

void voutput(int *pinums)
{
	int t;
	/* Результат равен */
	printf("The result is:\n");
	for(t=0;t<7;t++)
		printf(" #%d %d\n",t,pinums[t]);
}



Обратите внимание на то, что при вызове функции указывается только имя iyourarray. Далее вы узнаете о массивах подробнее. В данном примере при указании имени массива в функцию передается адрес первого его элемента. Так как iyourarray — массив целых чисел, массив можно передать, задавая указатель соответствующего типа.
Также допустимо передать информацию по адресу и для безразмерного массива. В следующем примере показано, как это можно сделать на C++. (Такой же подход возможен и в С.) Информация, содержащаяся в массиве iyourarray, передается путем указания адреса его первого элемента.

//  08FARRAY.CPP
// Программа на C++ вызывает функцию и передает ей массив.
// Функция вычисляет среднее значение элементов массива
#include "stdafx.h"
#include <iostream>
#include <conio.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <stdlib.h>
#include <math.h>
using namespace std;

void avg(float fnums[]);

main()
{
	float iyourarray[8]={(float) 12.30,(float) 25.70,
		(float) 82.10,(float) 6.00,(float) 7.01,
		(float) 0.25,(float) 4.20,(float) 6.28};
	// Передать информацию усредняющей функции
	cout << "Send array information to function.\n";
	avg(iyourarray);

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

void avg(float fnums[])
{
	int iv;
	float fsum=0.0;
	float faverage;
	cout << "The result is:\n";
	for(iv=0;iv<8;iv++)
	{
		fsum+=fnums[iv];
		cout << "number " << iv+1 << " is " << fnums[iv] << endl;
	}
	faverage=fsum/iv;
	// Среднее значение равно
	cout << "\nThe average is " << faverage << endl;
}



Среднее значение определяется при помощи суммирования всех элементов и деления на их общее число. Для форматированного вывода на экран используется поток cout.

            1.1.9. Аргументы по умолчанию
C++ допускает при вызове функций опускать некоторые ее параметры. Достигается это указанием в прототипе функции значений аргументов по умолчанию. Например, функция, прототип которой приведен ниже, может при вызове иметь различный вид в зависимости от ситуации.

// Прототип функции:
void ShowInt (int i,
			bool Flag = true,
			char symbol = '\n');
//Вызовы функции ShowInt:
ShowInt (1, false, ‘a’);
ShowInt (1, false);
ShowInt(3);

В первом случае все три аргумента заданы явно, поэтому работа функции осуществляется в обычном режиме. Во втором вызове функции передается два параметра из трех, причем вместо последнего аргумента подставляется значение по умолчанию, а именно символ '\n'. Третий вариант обращения к функции сообщает только один целочисленный параметр, а в качестве остальных аргументов. Используются значения по умолчанию: логическая переменная со значением true и символьная переменная со значением '\n'.
Для используемых параметров по умолчанию существует обязательное правило - все параметры справа от аргумента по умолчанию должны иметь значение по умолчанию. Так, в приведенном выше прототипе нельзя было бы, указав значение параметра по умолчанию для целочисленной переменной i, пропустить определение любого из остальных аргументов по умолчанию.
Рассмотрим пример, в котором осуществляется вывод знакового числа двойной точности с указанием количества значащих символов Другими словами, определим функцию, принимающую в качестве одного из параметров число выводимых знаков. Для решения поставленной задачи можно воспользоваться функцией возведения числа в степень pow() и функцией взятия модуля от длинного числа с плавающей точкой fabs1 (), прототипы которых содержатся в заголовочном файле math. h:

#include <math.h>
#include <iostream>
using namespace std;

void Out (double Numb, double Sig=1, bool Flg=true);

int main()
{
	double Mpi = -3.141592654;
	Out(Mpi, 4, false);
	Out(Mpi, 2);
	Out(Mpi);

	getchar(); 	getchar();
	return 0;
}

void Out(double numb, double sig, bool fig)
{
	if(!fig)
		numb = fabsl(numb);
	numb = (int) (numb * pow(10, sig));
	numb = numb / pow(10,sig);
	cout << numb << '\n';
}

В теле программы производится вызов одной и той же функции Out () с различным числом параметров для вывода значения переменной двойной точности Mpi. В результате работы программы на печать будут выведены следующие значения:
3,1415
-3,14
-3,1



Величина, указываемая в аргументах по умолчанию, может быть не только константным выражением - она может быть глобальной переменной или значением, возвращаемым некоторой функцией.

        14.7. Возвращение значения функцией: оператор return.
Создадим функцию, вычисляющую абсолютную величину числа. Абсолютная величина числа — это его значение (если отбросить знак). Следовательно, абсолютная величина 5 равна 5, а абсолютная величина -3 равна 3. Мы назовем эту функцию abs(). Входом Для abs() может быть любое число, для которого мы хотим найти Абсолютную величину. Выходом функции будет соответствующее неотрицательное число. Входная величина может обрабатываться благодаря наличию аргумента; выходная величина возвращается (т. е. выдается), как вы увидите ниже, при помощи ключевого слова языка Си — return. Поскольку функция abs() должна быть вызвана другой функцией, мы создадим простую программу main(), основной целью которой будет проверка, работает ли функция abs(). Программа, спроектированная для того, чтобы проверять работу функции именно таким образом, называется «драйвером». Драйвер подвергает функцию последовательным проверкам. Если результаты оказываются удовлетворительными, то ее можно поместить в программу, заслуживающую большего внимания. (Термин «драйвер» обычно относится к программам, управляющим работой устройств.) Приведем далее наш драйвер и функцию, вычисляющую абсолютную величину числа:

/* abs.драйвер */
#include<stdio.h>
int abs(int );
void main()
{
	int a= 10, b= 0, c= -22;
	int d, e, f;

	d = abs(a);
	e = abs(b);
	f = abs(c);
	printf(" %d %d %d\n", d, e, f);
}

/* функция, вычисляющая величину числа */
int abs(int x)
{
	int y;
	y = (x < 0) ? - x : x; /*вспомните операцию ? : */
	return (y); /* возвращает значение у вызывающей программе */
}
Результат работы программы выглядит так:



Сначала вспомним операцию условия ?:. Эта операция в функции abs() выполняется следующим образом: если х меньше 0, у полагается равным — х; в противном случае у полагается равным x. Это как раз то, что нам нужно, поскольку если х равен —5, то у равен -(-5), т. е. 5.
Ключевое слово return указывает на то, что значение выражения, заключенного в круглые скобки, будет присвоено функции, содержащей это ключевое слово. Поэтому, когда функция abs() впервые вызывается нашим драйвером, значением abs(a) будет число 10, которое затем присваивается переменной d.
Переменная у является внутренним объектом функции abs(), но значение у передается в вызывающую программу с помощью оператора return. Действие, оказываемое оператором

d = abs(a);

по-другому можно выразить так:

abs(a);
d = у;

Можно ли в действительности воспользоваться такой записью? Нет, так как вызывающая программа даже не подозревает о том, что переменная у существует.
Возвращаемое значение можно присвоить переменной, как в нашем примере, или использовать как часть некоторого выражения, например, следующим образом:

answer = 2*abs(z) + 25;
printf(" %d\n" , abs(—32 + answer));

Оператор return оказывает и другое действие. Он завершает выполнение функции и передает управление следующему оператору в вызывающей функции. Это происходит даже в том случае, если оператор return является не последним оператором тела функции. Следовательно, функцию abs() мы могли бы записать следующим образом:

/* функция, вычисляющая абсолютную величину числа, вторая версия */
abs(x)
	int x;
{
	if (x < 0)
		return(-x);
	else
		return(x);
}

Эта версия программы проще, и в ней не используется дополнительная переменная у. Для пользователя, однако, обе версии неразличимы, поскольку у них имеется один и тот же вход и они обеспечивают один и тот же выход. Только внутренние структуры обеих функций различны. Даже версия данной программы, приведенная ниже, работает точно так же:

/* функция, вычисляющая абсолютную величину числа, третья версия */
abs(x)
	int(x);
{
	if (х < 0)
		return(-x);
	else
		return(x);
	printf(" Профессор Флеппард — болван. \n");
}

Наличие оператора return препятствует тому, чтобы оператор печати printf() когда-нибудь выполнился в программе. Профессор Флеппард может пользоваться в своих программах объектным кодом, полученным в результате компиляции данной функции, и никогда не узнает об истинных чувствах своего студента-программиста.
Вы можете также использовать просто оператор

return;

Его применение приводит к тому, что функция, в которой он содержится, завершает свое выполнение и управление возвращается в вызывающую функцию. Поскольку у данного оператора отсутствует выражение в скобках, никакое значение при этом не передается функции.

        14.8. Типы функций.
В следующем разделе приводятся примеры программ на С и C++ для каждого из важнейших типов данных, возвращаемых функциями. Тип функции показывает тип возвращаемого ею значения. Ни в одном из примеров в предыдущих разделах функции не возвращали информацию, и поэтому они имели тип void (пустой).
Тип функции определяется типом возвращаемого ею значения, а не типом ее аргументов. Если указание типа отсутствует, то по умолчанию считается, что функция имеет тип int. Если значения функции не принадлежат типу int, то необходимо указать ее тип в двух местах.
    • Описать тип функции в ее определении:

char pun(ch, n) /* функция возвращает символ */
int n;
char ch;

float raft(num) /* функция возвращает величину типа float */
int num;

    • Описать тип функции также в вызывающей программе. Описание функции должно быть приведено наряду с описаниями переменных программы; необходимо только указать скобки (но не аргументы) для идентификации данного объекта как функции.

main()
{
char, rch, pun();
float raft;

Запомните! Если функция возвращает величину не типа int, указывайте тип функции там, где она определяется, и там, где она используется.

            1.1.10. Функции типа void.
Раз уж во всех предыдущих примерах использовался тип void, то в данном разделе пример такого типа будет более развернутым. Как вы уже знаете, в С и C++ числовую информацию можно вводить и выводить в шестнадцатеричном, десятичном и восьмеричном форматах — но не в двоичном. Представление данных в двоичном формате удобно для двоичной арифметики или для создания битовых масок. Функция vbinary() преобразует десятичное число, введенное с клавиатуры, в двоичное и выводит его на экран. Двоичные цифры не упаковываются как одно двоичное число, а хранятся отдельно в массиве. Таким образом, для просмотра двоичного числа необходимо распечатать содержимое массива.

//08VOIDF.C
/*Программа на С иллюстрирует использование функции типа void.
Программа печатает двоичное представление числа*/

#include <iostream>
#include <conio.h>
#include <stdio.h>
using namespace std;

void vbinary(int ivalue);

main()
{
	int ivalue;
	/* Введите число с основанием 10 для преобразования в двоичное */
	printf("Enter a decimal number to conversion to binary.\n");
	scanf("%d",&ivalue);
	vbinary(ivalue);

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

void vbinary(int idata)
{
	int t=0;
	int iyourarray[50];
	while(idata != 0)
	{
		iyourarray[t]=(idata %2);
		idata/=2;
		t++;
	}
	t--;
	printf("The binary value is:\n");
	for(;t>=0;t--)
		printf("%1d",iyourarray[t]);
	printf("\n");
}



Процесс преобразования чисел от большего основания к меньшему представляет собой достаточно простой математический алгоритм. Например, десятичные числа можно преобразовать в другую систему счисления при помощи последовательного деления числа на значение нового основания. Если выполняется переход от основания 10 к основанию 2, то число с основанием 10 несколько раз делится на 2. Получаются частное и остаток. Частное становится делимым для каждого последующего деления. Остаток становится очередной цифрой в преобразованном числе. В случае двоичного преобразования остаток может быть или 1, или 0. Вот пример того, как число 13 преобразуется в двоичное:



В функции vbinary() цикл while выполняется до тех пор, пока в результате арифметических операций значение переменной idata не станет равным нулю. Операция деления по модулю определяет остаток и запоминает очередной бит в массиве. Затем происходит деление переменной idata, причем сохраняется только целая часть. Этот процесс повторяется до тех пор, пока частное (та же самая переменная idata) не станет равным нулю.
Отдельные биты в массиве, образующие двоичный результат, должны выводится из массива в обратном порядке. Это можно увидеть по листингу программы. Взгляните на цикл for, используемый в функции. Можете ли вы придумать какой-нибудь алгоритм данного преобразования, чтобы двоичное представление хранилось не в массиве, а в переменной?

            1.1.11. Функции типа char.
В этом разделе вы увидите слегка измененный вариант описанного ранее примера. Функция С clowercase() имеет символьный параметр и возвращает также символьное значение. В данном примере некоторая заглавная буква вводится с клавиатуры и передается в функцию, в которой для преобразования символа в строчную букву используется библиотечная функция tolower() (из стандартной библиотеки с прототипом в файле ctype.h). Близкие tolower() функции: toascii() и toupper().
//08CHARF.C
/*Программа на С иллюстрирует использование функции типа char.
Функция получает символ в верхнем регистре и преобразует его
в нижний регистр*/

#include <iostream>
#include <conio.h>
#include <stdio.h>
using namespace std;

char clowercase(char c);

main()
{
	char clowchar,chichar;
	/* Введите символ в верхнем регистре */
	printf("Enter an uppercase character.\n");
	chichar=getchar();
	clowchar=clowercase(chichar);
	printf("Entering character is %c\nConverting character is %c\n",chichar,clowchar);

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

char clowercase(char c)
{
	return(tolower(c));
}



            1.1.12. Функции типа int.
Следующая функция имеет целочисленные параметры и возвращает целые значения. Функция icube() получает из main() некоторое число (0, 2, 4, 6, 8, 10 и так далее), возводит его в куб и возвращает целое значение в main(). Исходное число и его куб выводятся на экран.
//08INTF.C
/*Программа на С иллюстрирует использование функции типа int.
Функция считывает по очереди целые числа и возвращает
их значения, возведенные в куб*/
#include <iostream>
#include <conio.h>
#include <stdio.h>
using namespace std;

int icube(int ivalue);

main()
{
	int k,inumbercube;
	for(k=0;k<20;k+=2)
	{
		inumbercube=icube(k);
		/* Куб числа ... равен ... */
		printf("The cube of the number %2d is %d\n",k,inumbercube);
	}

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

int icube(int ivalue)
{
	return(ivalue*ivalue*ivalue);
}



            1.1.13. Функции типа long.
Следующий пример представляет собой программу на C++, получающую в качестве параметра целочисленную переменную и возвращающую значение типа long. Данный тип, используемый в Visual C/C++ и в других распространенных компиляторах, не является стандартным типом языка ANSI С. Приведенная функция возводит число 2 в некоторую целую степень.
// 08LONGF.CPP
// Программа на C++, иллюстрирующая использование функции типа long.
// Эта функция получает целые числа и возвращает значения,
// равные заданной степени числа 2

#include <iostream>
#include <conio.h>
#include <stdio.h>
using namespace std;

long lpower(int ivalue);

main()
{
	int k;
	long lanswer;
	for(k=0;k<21;k++)
	{
		lanswer=lpower(k);
		// 2 в степени ... равно ...
		cout << "2 raised to the " << k
			<< " power is " << lanswer << endl;
	}

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

long lpower(int ivalue)
{
	int t;
	long lseed=1;
	for(t=0;t<ivalue;t++)
		lseed*=2;
	return(lseed);
}



Эта функция умножает исходное число само на себя столько раз, сколько нужно для возведения в заданную степень. Например, для возведения числа 2 в 6-ю степень (2 в 6-й степени) программа выполняет следующее умножение:

2*2*2*2*2*2 = 64

Могут ли функции, описанные в файле math.h, дать тот же результат? Ответ можно найти из ранее приведенной таблицы.

            1.1.14. Функции типа float.
В следующем примере массив типа float передается в качестве параметра в функцию, которая возвращает значение типа float. В этом примере на C++ определяется произведение всех элементов массива.
// 08FLOATF.CPP
// Программа на C++ иллюстрирует использование функции типа float.
// Функция получает массив чисел типа float и возвращает их
// произведение в виде числа с плавающей точкой

#include <iostream>
#include <conio.h>
#include <stdio.h>
using namespace std;

float fproduct(float farray[]);

main()
{
	float fmyarray[7]={(float) 4.3,(float) 1.8,(float) 6.12,(float) 3.19,
			(float) 0.01,(float) 0.1,(float) 9876.2};
	float fmultiplied;
	fmultiplied=fproduct(fmyarray);
	// Произведение всех введенных чисел равно
	cout << "The product of all array enteris is: "
		<< fmultiplied << endl;

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

float fproduct(float farray[])
{
	int i;
	float fpartial;
	fpartial=farray[0];
	for(i=1;i<7;i++)
		fpartial*=farray[i];
	return(fpartial);
}



Поскольку вычисляется произведение всех элементов массива, значение его первого элемента должно быть присвоено переменной fpartial до начала цикла for. Обратите внимание на то, что цикл в функции fproduct() начинается с 1, а не с обычного нулевого значения.

            1.1.15. Функции типа double.
В следующем примере на С передаются и возвращаются значения типа double. Функция dtrigcosine() преобразует значение угла, выраженное в градусах, в косинус этого угла.
//08DOUBLE.C
/*Программа на С иллюстрирует использование функции типа double.
Функция считывает целые числа от 0 до 90 и возвращает значение
косинуса каждого числа*/

#include <iostream>
#include <conio.h>
#include <stdio.h>
#include <math.h>
using namespace std;

const double dPi=3.14159265359;
double dtrigcosine(double dangle);

main()
{
	int j;
	double dcosine;
	for(j=0;j<91;j++)
	{
		dcosine=dtrigcosine((double) j);
		/* Косинус ... градусов равен */
		printf("The cosine of %d degrees is %19.18lf \n",j,dcosine);
	}

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

double dtrigcosine(double dangle)
{
	double dpartial;
	dpartial=cos((dPi/180.0)*dangle);
	return(dpartial);
}



Следует заметить, что функция dtrigcosine() для получения результата использует функцию cos(), описанную в файле math.h. Для всех тригонометрических функций значение угла должно быть преобразовано из градусов в радианы. Напомним, что pi радианов равно 180 градусам.

        14.9. Важные возможности C++.
Для создания функций на C++ можно использовать некоторые специфические возможности языка. Одним из его достоинств является возможность написания встроенных функций. Код некоторой встроенной функции воспроизводится в том месте программы, в котором она вызывается. Поскольку компилятор располагает этот код в точке вызова функции, то при использовании коротких, часто вызываемых функций, сокращается время выполнения программы.
Помимо этого, в C++ функции можно перегружать. Перегрузка позволяет использовать одно и то же имя функции для нескольких ее прототипов. Затем различные прототипы распознаются не по имени, а по типу и списку аргументов. Перегрузка очень полезна в функциях, предназначенных для работы с разными типами данных.

            1.1.16. Встраивание (inline).
В результате работы компилятора каждая функция представляется в виде машинного кода. Если в программе вызов функции встречается несколько раз, в местах таких обращений генерируются коды вызова уже реализованного экземпляра функции. Однако выполнение вызовов требует некоторой затраты времени. Таким образом, если тело функции небольшого размера и обращение к ней в программе происходит довольно часто, на практике можно указать компилятору вместо вызовов функции в соответствующих местах генерировать все ее тело. Осуществляется это с помощью ключевого слова inline. Teм самым увеличивается производительность реализованного кода, хотя, конечно, размер программы может увеличиваться. Компиляторы различных фирм накладывают свои ограничения на использование встраиваемых функций, поэтому перед использованием inline-функций необходимо обратиться к руководству компилятора.
Ключевое слово inline должно предшествовать первому вызову встраиваемой функции (например, содержаться в ее прототипе).

#include <iostream>
using namespace std;

// Прототип встраиваемой функции:
inline int Sum(int, int);

int main()
{
	int A= 2, B= 6, C= 3;
	char eol = '\n';
	// Вызовы встраиваемой функции,
	// генерируют все тело функции
	cout << Sum (A, B) << eol;
	cout << Sum (B, C) << eol;
	cout << Sum (A, C) << eol;

	getchar(); 	getchar();
	return 0;
}

int Sum(int x, int y)
{
	return x + y;
}



В приведенном примере в каждом месте вызова функции Sum () будет сгенерирован код тела всей функции.
Ключевое слово inline можно рассматривать как директиву или, лучше сказать, как указание компилятору C++ на встраивание этой функции. По разным причинам компилятор может проигнорировать это указание. Например, функция может быть слишком длинной. Встраиваемые функции используются в первую очередь для сокращения времени выполнения программы при частом вызове коротких функций.

// Программа на C++ иллюстрирует использование встроенных функций.
// Встроенные функции работают лучше всего в тех случаях, когда часто
// повторяются короткие функции. В этом примере некоторое сообщение
// выводится на экран несколько раз
#include "stdafx.h"
#include <iostream>
#include <conio.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <stdlib.h>
#include <math.h>
using namespace std;

// Это - встроенная функция
inline void voutput(void)
{
	cout << "This is an inline function!" << endl;
}

main()
{
	int t;
	// Программа печатает сообщение несколько раз
	cout << "This program prints a message several times." << endl;
	for(t=0;t<3;t++)
		voutput();

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}



            1.1.17. Перегрузка (overloading).
Следующий пример иллюстрирует перегрузку функции. Обратите внимание на то, как описаны прототипы двух функций с одинаковым именем и областью действия. Конкретная функция будет выбираться в зависимости от передаваемых аргументов. Функцию adder() можно вызывать с параметрами целого типа или типа float.

// Программа на C++ иллюстрирует перегрузку функций.
// Перегружаемая функция получает массив целых чисел или чисел с
// плавающей точкой и возвращает их сумму в виде числа int или float
#include "stdafx.h"
#include <iostream>
#include <conio.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <stdlib.h>
#include <math.h>
using namespace std;

int adder(int iarray[]);
float adder(float farray[]);

main()
{
	int iarray[7]={5,1,6,20,15,0,12};
	float farray[7]={3.3,5.2,0.05,1.49,3.12345,31.0,2.007};
	int isum;
	float fsum;
	isum=adder(iarray);
	fsum=adder(farray);
	// Сумма целых чисел равна
	cout << "The sum of the integer numbers is: "
			<< isum << endl;
	// Сумма чисел с плавающей точкой равна
	cout << "The sum of the float numbers is: "
			<< fsum << endl;

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

int adder(int iarray[])
{
	int i;
	int ipartial;
	ipartial=iarray[0];
	for (i=1;i<7;i++)
		ipartial+=iarray[i];
	return (ipartial);
}

float adder(float farray[])
{
	int i;
	float fpartial;
	fpartial=farray[0];
	for (i=1;i<7;i++)
		fpartial+=farray[i];
	return (fpartial);
}



При программировании перегружаемых функций имеется несколько препятствий, которые необходимо обойти. Например: если некоторые функции отличаются только типом, но не аргументами, то эти функции перегружать нельзя. Также запрещается следующий способ перегрузки:

int yourfunction(int number)
int yourfunction(int &value) //запрещается

Такой синтаксис не допускается, поскольку иначе каждый прототип получал бы аргументы одного и того же типа. Несмотря на эти ограничения, перегрузка является очень важной чертой в C++, и достаточно широко представлена в дальнейшем.

            1.1.18. Функции с переменным числом параметров. Многоточие (...).
Многоточие можно использовать тогда, когда по каким-то причинам предполагается создать функцию с неизвестным заранее числом идущих в функцию аргументов. В объявлении и определении такой функции переменное число аргументов задается многоточием, обязательно в конце списка формальных параметров.
Многоточие иногда используют, но в зависимости от компиляторов, один из старых способов может совсем не давать желаемого эффекта. До С++11 рекомендуется использовать только вариант с stdarg , а варианты, показанные ниже, рекомендуется не использовать вообще.
Для того, чтобы получить доступ ко всем параметрам, принимающих значения аргументов, заходящих в функцию, обязательно знать имя и тип хотя бы одного параметра.
В С++ можно создавать функции с переменным числом параметров. Параметры, их количество и типы, становятся известны только во время вызова функции. Формат описания функций с переменным числом параметров:

<тип> <имя> (<список явных параметров>, …)
{
<тело функции>
}

Здесь:
<тип> – тип возвращаемого значения,
<список параметров> – список параметров известных до вызова функции.

Переменный список параметров задается в заголовке функции многоточием:

int f(…)

Этот заголовок не вызывает у компилятора протестов. Такая запись означает, что при определении функции компилятору неизвестны ни количество параметров, ни их типы, и он, естественно, не может ничего проверить. Количество параметров и их типы становятся известными только при вызове функции.
Однако у программиста с написанием таких функций сразу возникают проблемы. Ведь имена параметров отсутствуют! Поэтому доступ можно осуществить только одним способом – косвенным, используя указатель. Вспомним, что все параметры при вызове помещаются в стек. Если мы каким-то образом установим указатель на начало списка параметров в стеке, то, манипулируя с указателем, мы, в принципе, можем «достать» все параметры!
Таким образом, список параметров совсем пустой быть не может, должен быть прописан хотя бы один явный параметр, адрес которого мы можем получить при выполнении программы. Заголовок такой функции может выглядеть так:

int f(int k...)

Ни запятая, ни пробел после параметра не обязательны, хотя можно их и прописать.
Есть одно обстоятельство, которое ограничивает применение таких функций: при написании функции с переменным числом параметров помимо алгоритма обработки программист должен разрабатывать и алгоритм доступа к параметрам. Так что список необъявленных параметров не может быть совсем уж произвольным – в языке C++ не существует универсальных средств распознавания элементов этого списка. Это же означает, что передача аргумента не того типа, который задумывался, или не тем способом, который подразумевался при разработке, приведет к катастрофическим последствиям – компилятор-то ничего не проверяет.
Попробуем написать функцию, вычисляющую среднее арифметическое своих аргументов. Для этого требуется решить несколько проблем
    • как установиться на список параметров в стеке;
    • как «перебирать» параметры;
    • как закончить перебор.

Для доступа к списку параметров нам потребуется указатель, значением которого будет адрес последнего явного параметра в списке. Ответ на второй вопрос очевиден – надо изменять значение этого указателя, чтобы переместиться на следующий параметр. Отсюда следует, что указатель должен быть типизированным, поскольку с бестиповым указателем нельзя выполнять арифметические операции. Это же означает, что программист при разработке функции с переменным числом параметров должен отчетливо себе представлять типы аргументов, которые будет обрабатывать функция. Кроме того, способ передачи параметров должен быть одинаковым для всех параметров: либо все – по значению, либо все – по ссылке, либо все – по указателю.
Ответ на последний вопрос не вызывает затруднений. Это можно сделать одним из двух способов:
    • явно передать среди обязательных параметров количество аргументов;
    • добавить в конец списка аргумент с уникальным значением, по которому будет определяться конец списка параметров;

И тот, и другой способ имеют право на жизнь — все определяется потребностями задачи и вкусами программиста.
Если не один из этих способов не используется, тогда можно использовать специальный набор макроопределений.
Параметры функции помещаются в стек, при этом первый параметр оказывается в вершине стека. Переход от одного параметра к другому осуществляется с помощью указателей.

    2. Задание числа дополнительных параметров с помощью первого параметра.
Функция вычисляет сумму значений дополнительных параметров. Список явных параметров состоит из одного параметра, который задает число дополнительных параметров.

#include <stdio.h>
#include <conio.h>
#include <iostream>
using namespace std;

void main()
{
  int sum(int n,...); //прототип функции с переменным
                      //числом параметров
  cout << "\n 4+6=" << sum(2, 4, 6); //10
  cout << "\n 1+2+3+4+5+6=" << sum(6, 1, 2, 3, 4, 5, 6); //21
  cout << "\n Parametrov net.Summa ravna:" << sum(0);
  getch();
}
int sum(int n,...)//n-число суммируемых параметров
{
  int s=0;
  int *p = &n; //получение адреса параметров в стеке
  for(int i=1; i<=n; i++)
     s+=*++p; //суммируем числа
  return s;
}




Для доступа к параметрам, которые один за другим попали в стек, используется адрес первого параметра (*p = &n;), таким образом, указатель устанавливается на начало списка параметров в стеке (в памяти). Затем в цикле при помощи указателя p перемещаемся по параметрам и суммируем их, извлекая (*p) из памяти. Все параметры должны иметь одинаковый тип.
Проверка соответствия типов для дополнительных параметров не выполняется, поскольку компилятор не имеет информации, необходимой для проведения проверки. При вызове функции дополнительные параметры типа char и short передаются как int, а float — как double.

Реализация функции, которая в качестве первого параметра получает количество аргументов, на первый взгляд, не вызывает затруднений. Однако, если первый аргумент – целое число, то требуется преобразование указателя. И тут не все варианты проходят. Не будет работать такой вариант:

#include <iostream>
#include <stdarg.h>
using namespace std;

//Такой вариант неработоспособен
double f(int n, ...) //количество элементов
{
	int *p = &n; //указатель – «целый»
	double sum = 0, count = n;
	for (; n--; (double*)p++) //преобразование int* ->double*
		sum += (*p);
	return ((sum) ? sum / count : 0);
}

void main()
{
	double y = f(4, 1.0, 2.0, 3.0, 4.0, 0.0); //NOT 2.5
	cout << y << endl;
	system("pause");
}



#include <iostream>
#include <stdarg.h>
using namespace std;

//Такой вариант тоже неработоспособен
double f(int n, ...) //количество элементов
{
	double *p = (double *)&n; //преобразование адреса
	double sum = 0, count = n;
	for (; n--; p++) //изменение указателя
		sum += (*p);
	return ((sum) ? sum / count : 0);
}

void main()
{
	double y = f(4, 1.0, 2.0, 3.0, 4.0, 0.0); //NOT 2.5
	cout << y << endl;
	system("pause");
}



Причина кроется в том, что изменение указателя производится на столько байт, сколько в памяти занимает базовый тип. В обоих случаях мы установились не на начало списка double-параметров, а на sizeof(int) байтов «раньше» — на целую переменную. И от этого адреса происходит изменение указателя на 8 байт (sizeof(double)), что приводит к совершенно неверным результатам. Решение заключается в том, чтобы сначала изменить «целый» указатель, а потом уже его преобразовать в double *. Так всегда необходимо делать, если тип первого параметра отличается от типов отсутствующих параметров (листинг 7.8).
Листинг 7.8. Вычисление среднего арифметического аргументов (количество)

#include <iostream>
#include <stdarg.h>
using namespace std;

double f(int n, ...) //количество элементов
{
	int *p = &n;
	p++; //установка «целого» на double
	double *pp = (double *)p; //преобразование типа указателя
	double sum = 0, count = n;
	for (; n--; pp++) //правильное увеличение на 8
		sum += (*pp);
	return ((sum) ? sum / count : 0);
}

void main()
{
	double m[] = { 1.0, 2.0, 3.0, 4.0, 0.0 };
	cout << f(4, m[0], m[1], m[2], m[3], m[4]) << endl; //2.5
	system("pause");
}



В строке

	p++; //установка «целого» на double

операция p++ устанавливает указатель на первый элемент списка параметров типа double. Для дальнейшего изменения указателя на 8 мы использовали преобразование типа указателя:

	double *pp = (double *)p; //преобразование типа указателя

После этой строки операция pp++ будет увеличивать указатель на sizeof(double)=8, что нам и требуется.
Мы использовали способ передачи параметров по значению. В этом случае в качестве фактических аргументов можно задавать произвольные выражения. Однако можно использовать и передачу ссылки – это несколько осложняет вызов, поскольку в этом случае в списке аргументов могут прописываться только переменные. Необходимо также помнить, что все фактические аргументы должны передаваться одинаковым способом. Тогда прототип первого варианта функции выглядит так (тело функции не изменяется):

double f(double &n, ...)

При вызове можно использовать элементы массива:

double m[] = {1.0,2.0,3.0,4.0,0.0};
cout <<f(m[0],m[1],m[2],m[3],m[4])<<endl;

Эта программа выведет на экран 2.5.

#include <iostream>
#include <stdarg.h>
using namespace std;

double f(double &n, ...) //количество элементов
{
	double *p = &n;
	double sum = 0, count = 0;
	while (*p) //пока аргумент не равен нулю
	{
		sum += (*p); //суммируем аргумент
		p++; //перемещаемся на следующий аргумент
		count++; //считаем  количество аргументов
	}
	return ((sum) ? sum / count : 0);
}

void main()
{
	double m[] = { 1.0, 2.0, 3.0, 4.0, 0.0 };
	cout << f(m[0], m[1], m[2], m[3], m[4]) << endl; //2.5
	system("pause");
}



Язык C++ в качестве элементов переменного списка аргументов разрешает прописывать указатели. Однако обработка такого варианта вызывает сложности – нам требуется двойной косвенный доступ, а указатель для доступа к стеку — «одноразовый». Таким образом, если передавать параметры-указатели, то в приведенной выше программе (с первым параметром-количеством) значение *рр – это не число типа double, а адрес этого числа. Тут без «обмана» компилятора не обойтись, поскольку он просто так не пропускает преобразование «одноразовой» косвенности в двойную. Но мы помним, что все типизированные указатели, независимо от типа и косвенности всегда представляют собой адрес, размер которого в Intel – 4 байта. Тогда можно использовать union (листинг 7.9).
Листинг 7.9. Переменный список параметров-указателей (количество)

#include <iostream>
#include <stdarg.h>
using namespace std;

double f(int n, ...)
{
	int *p = &n; //«одноразовый» указатель   
	p++;//«достаем» список параметров-указателей
	union Pointer
	{
		double **pp; double *kp;
	}; //«подстава» указателей
	Pointer A;
	A.kp = (double *)p; //«обманываем» компилятор
	double sum = 0, count = n;
	for (; n--; A.pp++) //изменяем двойной указатель!
		sum += (**A.pp); //двойной доступ!
	return ((sum) ? sum / count : 0);
}

void main()
{
	double y = f(4, 1.0, 2.0, 3.0, 4.0, 0.0); //NOT 2.5
	cout << y << endl;
	system("pause");
}

Хотя по стандарту такое использование union означает undefined behaviour (неопределенное поведение), и непереносимо, но на практике (например, на платформе Intel) работает хорошо. Однако при переносе на другую платформу надо будет проверять корректность работы такой функции.
Необходимо обратить внимание на то, что изменяем мы «двойной» указатель – «одноразовый» использовать нельзя, поскольку будет изменение на sizeof(double)=8 байт, а нам требуется изменение на sizeof(double*)= 4 байта. И при суммировании используется двойной косвенный доступ. Обращение к такой функции выполняется так:

cout <<f(2,&a,&b)<<endl;

Аналогичная функция без счетчика аргументов может использовать в качестве признака окончания списка параметров нулевой указатель. Но в данном случае «обманывать» компилятор не требуется — в функции непосредственно используется «двойной» указатель (листинг 7.10).
Листинг 7.10. Переменный список параметров-указателей (ноль в конце)

#include <iostream>
#include <stdarg.h>
using namespace std;

double f(double *a, ...)
{
	double **p = &a; //берем адрес-адреса
	double sum = 0, count = 0;
	while (*p != 0) //NULL – прямо в списке параметров
	{
		sum += (**p); //выбираем значения
		count++; p++; //бежим по списку
	}
	return ((sum) ? sum / count : 0);
}

void main()
{
	double a = 5, b = 8;
	double y = f(&a, &b, 0); //6.5
	cout << y << endl;
	system("pause");
}



Вызов такой функции выглядит так:

	double y = f(&a, &b, 0);

Особо обратите внимание на следующее: в списке параметров 0 – это значение, а не адрес. Поэтому в теле функции проверка окончания цикла делается с одной звездочкой, а не с двумя.

#include <iostream>
using namespace std;

// приметивная функция нахождения сумы
// первий параметр количество елементов
int sum(int count, ...){
   int s = 0;
   for(int i = 1; i <= count; ++i){
           s += (&count)[i];       
   }
   return s;
}

int main(){
   cout << sum(3, 20, 30, 40) << endl; //90
   system("pause");
   return 0;  
}



    3. Определение конца списка параметров с помощью параметра индикатора.

#include <iostream>
#include <stdlib.h>
using namespace std;

void MyFunc(int a,...) //Так объявляется функция с заранее неизвестным числом параметров
{
 int *P=&a; //Взятие адреса у первого параметра

 while (*P) //Пока встречаются параметры и параметр не равен 0
  {
    cout << *P << " "; //Вытаскиваем значение с адреса по которому живет параметр
    P++; //Адресная арифметика. Смена текущего адреса на следующий
  }
}

int main()
{
	system("CLS");
	MyFunc(100,200,300,400,0); //В функцию передается 4 параметра и пятый как идентификатор того, что параметры кончились
	cout << "\n";
	system("PAUSE");
}



Функция product() вычисляет произведение дополнительных параметров. Как только встречается нулевой параметр, вычисление произведения прекращается. Указатель p указывает на начало списка параметров (double*p=&a;).

#include <iostream>
using namespace std;

double product(double a, ...)
{
  double  b;
  if (a)//проверяем на отсутствие дополнительных параметров
  {  b = 1.0; //b - произведение
     //цикл до тех пор, пока p не укажет на 0
     for (double* p=&a; *p; p++)
          b *= *p;
  }
  else
     b = 0.0;
  return b;
}

void main()
{  double product(double a, ...);//прототип функции с
                                // переменным числом параметров
  cout << "\n product (6e0, 5e0, 3e0, 0e0) = "
       << product (6e0, 5e0, 3e0, 0e0); //90
  cout << "\n product (1.5f, 2.0f, 0.0f, 3.0f, 0.0f) = "
       << product (1.5f, 2.0f, 0.0f, 3.0f, 0.0f); //3
  cout << "\n product (0.0) = " << product (0.0); //0
  cout << "\n product (1.0e-28,0.0) = "
       << product (1.0e-28,0.0) << "\n";//1.0e-28
  system("PAUSE");
}



Напомним, что при вызове функции дополнительные параметры типа float передаются как double, так что для параметров типа float надо использовать функцию с параметрами типа double.

    4. Использование специального набора макроопределений.
Для использования в программе функций с переменным числом параметров, при вызове которых можно использовать параметры разных типов, удобно использовать специальный набор макроопределений (заголовочный файл stdarg.h). Макрокоманды для доступа к списку фактических параметров переменной длины, имеют следующий формат:

//связывание переменной param с первым параметром
void va_start(va_list param,<последний явный параметр>);
//получение значения очередного параметра типа type
type va_arg(va_list param, type);
//организации корректного выхода из функции
void va_end(va_list param);

Они объявлены в загаловке <stdarg.h> и их синтаксиз следующий

type va_arg(va_list argptr, type);
void va_copy(va_list target, va_list source);
void va_end(va_list argptr);
void va_start(va_list argptr, last_parm);

Макросы va_arg, va_start и va_end работают вместе, чтобы сделать возможной передачу функции переменного числа аргументов. Самым распространенным примером функции, которая принимает переменное число аргументов, является функция printf(). Тип va_list определен в заголовке <stdarg.h>(а в среде языка C++ — в заголовке <cstdarg>).
Кроме перечисленных макросов, в файле stdarg.h определен специальный тип данных va_list, который является указателем. Именно такого типа должны быть первые операнды, используемые при обращении к макрокомандам va_start, va_arg, va_end.
Определим порядок использования макросов. В теле функции обязательно определяется переменная типа va_list: va_list f. С помощью макроса va_start переменная f связывается с первым необязательным параметром, т.е. с началом списка неизвестной длины:

va_start(f,<последний явный параметр>)

Теперь с помощью указателя f можно получить значение фактического параметра, задав его тип. Макрос

va_arg(f, type);

позволяет получить значение очередного параметра типа type. Кроме того, макрос меняет значение указателя f на адрес следующего фактического параметра в списке.
Макрокоманда va_end предназначена для организации корректного выхода из функции с переменным числом параметров: va_end(f).

#include <iostream>
#include <stdarg.h>
using namespace std;

// приметивная функция нахождения сумы
// первий параметр количество елементов
int sum(int count,...)
{
   va_list ap;
   int s = 0;
   va_start(ap,count); //связывание переменной param с первым параметром
   for(int i=0; i<count; i++)
       s+=va_arg(ap,int); //получение значения очередного параметра типа type
   va_end(ap); //организации корректного выхода из функции
   return s;
}

int main()
{
   cout << sum(3, 20, 30, 40) << endl; //90
   system("pause");
   return 0;  
}



Общая процедура создания функции, которая может принимать переменное количество аргументов, такова. Функция должна иметь по крайней мере один известный параметр(может и больше), указываемый до переменного списка параметров. Крайний справа известный параметр называется last_parm. Его имя используется в качестве второго параметра в обращении к макросу va_start(). Прежде чем можно будет получить доступ к любому параметру из списка параметров переменной длины, необходимо инициализировать указатель на аргумент argptr, обратившись к макросу va_start(). После этого параметры возвращаются посредством обращения к макросу va_arg() с передачей значения параметра type, которое представляет собой тип следующего параметра. Наконец после прочтения всех параметров до возвращения из функции необходимо вызвать макрос va_end(), чтобы гарантировать корректное восстановление стека. Если макрос va_end() не вызывается, высока вероятность аварийного отказа программы.

Пример
В следующей программе применяется функция sum_series(), которая возвращает сумму ряда чисел. Первый аргумент содержит количество аргументов, перечисленных за ним. В этом примере суммируются первые пять элементов следующего ряда чисел.

1     1     1      1            1
-  +  -  +  -  +  — ...  +  ---
2     4     8     16          2n

Результат равен 0.968750.

#include <stdio.h>
#include <stdarg.h>
#include <iostream>
using namespace std;

double sum_series(int, ...);

int main(void)
{
	double d;

	d = sum_series(5, 0.5, 0.25, 0.125, 0.0625, 0.03125);
	printf("Sum is: %f\n",d);
	system("PAUSE");
	return 0;
}

double sum_series(int num, ...)
{
	double sum = 0.0, t;
	va_list argptr;

	/* Инициализируем указатель argptr. */
	va_start(argptr, num);

	/* Суммируем ряд. */
	for(; num; num--) {
		t = va_arg(argptr, double);
		sum += t;
	}

	/* Реализуем корректное завершение. */
	va_end(argptr);

	return sum;
}



Вернемся к уже привычным для нас примерам, для демонстрации использования макроопределений.
В качестве примера рассмотрим реализацию функции вычисления среднего арифметического (вариант с количеством аргументов) с использованием этих макросов (листинг 7.12).
Листинг 7.12. Вычисление среднего с использование стандартных средств (количество)

#include <iostream>
#include <stdarg.h>
#include <string.h>
using namespace std;

double f(int n, double a, ...)
{   va_list p; //объявление указателя
   double sum = 0, count = 0;
   va_start(p, n); //инициализация указателя
   while(n--)            
   { sum+=va_arg(p,double); //перемещение указателя
     count++;
   }
   va_end(p); //«закрытие» указателя
   return ((sum)?sum/count:0);
}

void main()
{
	double y = f(4, 1.0, 2.0, 3.0, 4.0);
	cout << y << endl;
	system("pause");
}



Листинг 7.13. Вычисление среднего стандартными средствами (ноль в конце)

#include <iostream>
#include <stdarg.h>
#include <string.h>
using namespace std;

double f(double a, ...)
{   va_list p; //объявление указателя
   double sum = 0, count = 0;
   va_start(p, a); //инициализация указателя
   double k = a; //промежуточная переменная
   do { sum+=k;  count++;
   } while(k=va_arg(p,double)); //пока не ноль -передвигаемся
   va_end(p); //«закрыли» указатель
   return ((sum)? sum/count: 0);
}

void main()
{
	double y = f(1.0, 2.0, 3.0, 4.0, 0.0);
	cout << y << endl;
	system("pause");
}



Многоточие используется тогда, когда количество аргументов неизвестно. Неопределенное количество аргументов может быть указано в операторе функции с формальными параметрами. Например:

void yourfunction(int t,float u, ...) ;

Такая запись указывает компилятору С, что за обязательными переменными t и u могут следовать, а могут и не следовать другие аргументы. Конечно же, многоточие приостанавливает проверку типов.
В следующей программе на С иллюстрируется использование многоточия. Однако, вы можете воздержаться от детального изучения данного алгоритма до тех пор, пока полностью не познакомитесь с типами указателей на строки.

/*08ELIP.C
Программа на С иллюстрирует использование операции многоточие
(...) и поддерживающих ее макросов va_arg, va_start и va_end*/

#include "stdafx.h"
#include <iostream>
#include <conio.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <stdlib.h>
#include <math.h>
#include <stdarg.h>
#include <string.h>
using namespace std;

// многим напоминает printf
void vsmallest(char *szmessage, ...);

main()
{
	vsmallest("Print %d integers, %d %d %d",10,4,1);

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

void vsmallest(char *szmessage, ...)
{
	int inumber_of_percent_ds=0;
	va_list type_for_ellipsis;
	int ipercent_d_format = 'd';
	char *pchar;
// возвращает местоположение ‘d’ в формате %d
	pchar=strchr(szmessage,ipercent_d_format);
// подсчет неопределенных количеств форматов %d
	while(*++pchar != '\0') {
		pchar++;
		pchar=strchr(pchar,ipercent_d_format);
		inumber_of_percent_ds++;
	}
	printf("print %d integers,",inumber_of_percent_ds);
//////////////////////////////////
// стандартные макросы С
// va_start
// va_arg
// va_end
//////////////////////////////////

// масрос
// устанавливает type_for_ellipsis на начало
// переменного списка аргументов
	va_start(type_for_ellipsis,szmessage);
	while(inumber_of_percent_ds--)
// макрос
// выбор следующего аргумента из списка переменных
// int выбирает тип данных
		printf(" %d",va_arg(type_for_ellipsis, int));
// устанавливаент указатель в null
	va_end(type_for_ellipsis);
}



Прототип функции vsmallest() описан с двумя аргументами: указателем на строку и аргументом типа (...) — что составляет список аргументов переменной длины. Конечно, функции с переменным списком аргументов должны получать какую-то информацию о способе обработки этого списка. В программе 08ELIP.C эта информация поступает из строкового аргумента.
Строго говоря, функция vsmallest() похожа на функцию printf(). Эта подпрограмма просматривает строку форматирования szmessage и определяет, сколько форматов %d в ней содержится. Затем эта расчетная информация используется для выборки и печати информации из списка аргументов переменной длины. Хотя это выглядит очевидным, данный алгоритм требует достаточно сложных действий.
Функция strchr() возвращает местоположение символа "d" в формате %d. Первый формат %d можно проигнорировать, поскольку этого требует выходное сообщение. В цикле while продолжается обработка строки szmessage: просматривается и подсчитывается неопределенное количество форматов %d (inumber_of_percent_ds). Когда этот процесс заканчивается, печатается начало выходного сообщения.
Макрос va_start() устанавливает указатель type_for_ellipsis на начало переменного списка аргументов. Вспомогательный макрос va_arg() выбирает следующий аргумент из списка переменных. Этот макрос использует свой второй параметр для определения выбираемого типа данных: в данном примере — это тип int. Функция vsmallest() заканчивается вызовом макроса va_end(). Последний из трех стандартных макросов С для поддержки операции многоточие, va_end(), устанавливает указатель в null.

    5. Список указателей переменной длины на char (конкатинация строк)
Напоследок осталось рассмотреть пример, в котором список указателей переменной длины составляют указатели на char. Мы выделяем этот случай по двум причинам:
    • размер данных (char) меньше, чем размер указателя (char*) – в остальных случаях размер данных больше или равен размеру указателя;
    • char* — это единственный указатель, вместо которого при вызове можно задавать не адрес.

Типичной функцией, в которой можно применить переменный список параметров, является функция сцепления произвольного количества строк в одну. Заголовок такой функции может выглядеть так:

char *f(char *s1, ...)

Функция должна сначала вычислить количество памяти, необходимой для целевой строки, а потом уже помещать туда результат сцепления. Используем тот же прием, что и в предыдущем примере – последний параметр должен быть 0 (листинг 7.11).
Листинг 7.11. Сцепление строк (ноль в конце)

#include <iostream>
#include <stdarg.h>
#include <string.h>
using namespace std;

char *f(char *s1, ...)
{
	char **cp = &s1; //адрес первого указателя
	int len = 0;
	//цикл для определения общей длины сцепляемых строк
	while (*cp) { len += strlen(*cp); cp++; }
	char *s = new char[len + 1]; //память для строки
	s[0] = 0; //"очищаем" строку
	//цикл для сцепления строк
	cp = &s1; //опять установка на 1-й параметр
	while (*cp)
	{
		strcat(s, *cp); //прицепляем первую (и следующие)
		cp++; //перемещаемся на следующую
	}
	return s;
}

void main()
{
	char *sd = f("First ", "Two ", "Three ", 0);
	cout << sd << endl;
	system("pause");
}

Вызов такой функции может быть таким

char *ss = f(s1, s2, s3, 0);

где s1, s2, s3 – это либо объявленные константы, либо переменные типа char *. Ту же функцию можно вызывать и с явно прописанными константами:

	char *sd = f("First ", "Two ", "Three ", 0);



Очевидно, вместо параметра-указателя (ссылки) можно подставлять выражение, имеющее результатом указатель (ссылку). В частности, на месте указателя на char можно вызвать функцию, которая вводит строку с клавиатуры.

Приведем пример использования макросов в функции конкатенации любого числа строк. Строки передаются функции с помощью списка указателей. В конце списка помещается нулевой указатель NULL.

#include <stdio.h>
#include <conio.h>
#include <stdarg.h> //для макросов переменного списка параметров
#include <iostream>

using namespace std;
// функция конкатенации неопределенного числа строк
char *concat(char *s1, ...)
{
  va_list par; //указатель на параметры списка
  char *cp;
  int len = strlen(s1); //длина 1-го параметра
  va_start(par,s1); //начало переменного списка

  //цикл для определения общей длины параметров строк
  while(cp = va_arg(par, char *))
       len += strlen(cp);

  //выделение памяти для результата
  char *stroka = new char[len + 1];
  strcpy(stroka, s1);

  va_start(par, s1);//начало переменного списка
  //цикл конкатенации параметров строк
  while(cp = va_arg(par, char *))
            strcat(stroka, cp);

  va_end(par);
  return stroka;
}
void main()
{
  setlocale(LC_CTYPE, "Russian");
  //прототип функции с переменным числом параметров
   char *concat(char *s1, ...);
   char *s; //указатель для результата
   s = concat("\nVerba"," volant, ","scripta ","manent\n",
   "(Слова исчезают, написанное остается.)", NULL);
   cout << s << "\n";

  system("PAUSE");
}



В приведенной функции concat() тип параметров заранее известен и фиксирован (указатель на символы).

    6. Изменение параметров по числу и по типу
В некоторых случаях параметры могут изменяться как по числу, так и по типу. В этих случаях необходимо, каким-то образом сообщать функции типы параметров для правильного их извлечения из стека. Например, в функциях printf() и scanf() в качестве первого операнда задается строка форматов, которая и содержит информацию о вводимых или выводимых данных.
Следующий пример, функция miniprintf(), показывает, как это можно сделать. В этой функции допускаются только два вида форматов %d и %f, которые позволяют макросу va_arg() правильно извлекать значения. Окончание вывода определяется завершением перебора форматов.

#include <conio.h>
#include <stdarg.h> //для макросов переменного списка параметров
#include <iostream>
using namespace std;

void miniprintf(char *format, ...)
{
   va_list ap; //указатель на необязательный параметр
   char *p; //для просмотра строки format
   int ii; //целые параметры
   double dd; //параметры типа double

   va_start(ap, format); //настроились на первый параметр

   for(p = format; *p; p++)
   { if(*p != '%' ) //Если встретится символ %
		{cout << *p;
		 continue;
		}
	switch (*++p) //То анализируем следующий за этим симолом символ
	{	case 'd': ii = va_arg(ap, int); //Если это символ d, то значит параметр int
			  cout << ii; //Выводим параметр типа int на экран
			  break;
		case 'f': dd = va_arg(ap, double); //Если это символ f значит параметр double
			  cout << dd; //Выводим параметр типа double на экран
			  break;
		default:  cout << *p;
	}
   }//конец цикла просмотра строки форматов

   va_end(ap); //подготовка к завершению функции
}

void main()
{
    void miniprintf(char *format, ...);
    int k = 123;
    double d = 2.718282;
    //Вывод двух чисел с разными типами
    miniprintf("\n Integer k = %d \n Double d = %f", k, d);
	 cout << "\n";
	 system("PAUSE");
}



    7. Дополнительные примеры функций с произвольным числом параметров

НЕ РЕКОМЕНДУЕТСЯ. Может работать. А может работать неправильно

#include <iostream>
#include <stdlib.h>

void MyFunc(int a, ...) //Так объявляется функция с заранее неизвестным числом параметров
{

}

int main()
{
	system("CLS");
	MyFunc(100, 200, 300, 400, 0); //В функцию передается 4 параметра и пятый будет использован как идентификатор того, что параметры кончились
	system("PAUSE");
}

Вот такой код не вызывает возражений, а многоточие после первого параметра внутри параметров функции обозначает, что в функцию можно передать для обработки более одного параметра.
Должен возникнуть вопрос как же получить доступ к каждому из этих параметров. Для того, чтоб хорошо понять то что будет написано, требуется знание указателей. Чтобы иметь доступ к каждому из параметров, нужно знать адрес первого параметра, а чтобы взять этот адрес, как раз и требуется указатель

НЕ РЕКОМЕНДУЕТСЯ. просто может работать. А может работать неправильно.

#include <iostream>
#include <stdlib.h>
using namespace std;

void MyFunc(int a, ...) //Так объявляется функция с заранее неизвестным числом параметров
{
	int *P = &a; //Взятие адреса у первого параметра
	while (*P) //Пока встречаются параметры и параметр не равен 0
	{
		cout << *P << " ";//Вытаскиваем значение с адреса по которому живет параметр
		P++; //Адресная арифметика. Смена текущего адреса на следующий
	}
	cout << "\n";
}

int main()
{
	system("CLS");
	MyFunc(100, 200, 300, 400, 0); //В функцию передается 4 параметра и пятый как идентификатор того, что параметры кончились
	system("PAUSE");
}



Что можно увидеть? Первым делом внутри функции происходят взятие адреса первого параметра, при этом тип указателя должен совпадать с типом этого параметра. Дальше идет простой перебор всех параметров с помощью цикла.

Таким же образом можно привести классический пример суммирования элементов

#include <iostream>
#include <stdlib.h>
using namespace std;

void MyFunc(double a, ...) //Так объявляется функция с заранее неизвестным числом параметров
{
	double *P = &a; //Взятие адреса у первого параметра
	double sum = 0; //Инициализация значения суммы в ноль

	while (*P) //Пока встречаются параметры и параметр не равен 0
	{
		sum = sum + (*P);//Прибавляем к сумме то что взяли по адресу P
		P++; //Адресная арифметика. Смена текущего адреса на следующий
	}


	cout << sum << endl; //Вывод результата на экран
}

int main()
{
	system("CLS");
	MyFunc(100.0, 200.0, 300.0, 400.0, 0.0); //В функцию передается 4 параметра и пятый как идентификатор того, что параметры кончились
	system("PAUSE");
}



Вообще весь этот механизм удобно использовать тогда, когда требуется обработка однотипных элементов и чем-то всё напоминает обычный массив элементов. Учитывая, что указатель должен быть того же типа, что и элемент, расположенный по адресу на который он ссылается, можно сказать, что переменное число параметров может быть корректно использовано как раз тогда, когда все параметры передаваемые в такую функцию принадлежат одному и тому же типу (имеются ввиду те параметры, которые идут туда где расположено многоточие).
Даже если типы передаваемых параметров будут различны, то компилятор не выдаст ошибки, но ошибки не выведется только потому что если компилятор видит эти три точки на месте параметров, то он отключает проверку типов. На самом деле легко увидеть эффект небезопасности работы с функцией, в которой указано, что будет более одного параметра, если первый параметр объявить например как int, (соответственно указатель на первый параметр как int), а во время передачи в функцию написать число с точкой (например 1.0 запустить и потом 11.0 и запустить). Т.е. если требуется передать параметры других типов, то их все нужно дописать перед списком предполагаемых неизвестных.
Например void MyFunc(float x, char S[],int n,…), после чего с первыми работать в обычной манере, а с теми что после n с помощью указателя на int и, соответственно, передавать туда параметры с тем же типом, что и у этого n (Исходя из логики того, что тип указателя должен совпадать с типом объекта на адрес которого указатель ссылается).


        14.10. Аргументы функции main().
В обоих языках, С и C++, имеется возможность обработки аргументов командной строки, которые представляют собой параметры, вводимые вместе с именем программы при ее вызове из командной строки операционной системы. Эта возможность позволяет передавать аргументы непосредственно вашей программе без дополнительных запросов из этой программы. Например, пусть некоторая программа получает из командной строки четыре аргумента:

YOURPROGRAM Sneakers, Dumbdog, Shadow, Wonderdog

Здесь четыре значения передаются из командной строки программе YOURPROGRAM. На самом деле эта информация передается функции main(). Один аргумент, получаемый main(), argc, представляет собой целое число, определяющее количество элементов командной строки плюс 1.
Начиная с DOS 3.0, название программы считается первым элементом, передаваемым из командной строки. Второй аргумент — это указатель на массив указателей на строки, называемый argv. Так как все элементы являются символьными строками, argv имеет тип char *[argc]. Поскольку все программы имеют название, argc всегда на единицу больше числа аргументов командной строки. В дальнейшем вы познакомитесь с различными способами извлечения разных типов данных из командной строки. Названия аргументов argc и argv являются общепринятыми именами переменных, используемых во всех программах на С и C++.

            7.1.1. Строки.
Аргументы командной строки передаются как символьные строки, что облегчает работу с ними. В следующем примере на С пользователь должен из командной строки задать программе несколько имен. Чтобы убедиться в том, что пользователь их ввел, анализируется аргумент argc и, если он не больше 2, происходит выход из программы с сообщением о повторной попытке.

/*08SARGV.C
Программа на С иллюстрирует ввод в программу строковых данных
с аргументом командной строки
C:\> 08SARGV.EXE 07 Nik Helen*/

#include "stdafx.h"
#include <iostream>
#include <conio.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <stdlib.h>
#include <math.h>
using namespace std;

int main(int argc,char *argv[])
{
	int t;
	if(argc<2)
	{
		/* Введите несколько имен в командной строке */
		/* при запуске этой программы! */
		printf("Enter several names on the commond line\n");
		printf("when executing this program!\n");
		/* Попробуйте еще раз. */
		printf("Please try again.\n");
		exit(0);
	}
	for(t=1;t<argc;t++)
		printf("Entry #%d is %s\n",t,argv[t]);

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}





Эта программа целиком находится в функции main() и не требует дополнительных функций. Имена, введенные с командной строки, печатаются на экране в том же порядке. Если из командной строки вводятся цифровые значения, то они интерпретируются как ASCII-строки отдельных символов и должны печататься такими как есть.

            7.1.2. Целые числа.
Во многих программах желательно иметь возможность ввода из командной строки целых чисел; это может быть, к примеру, программа для вычисления средних оценок студентов. В таких случаях символьная информация в кодах ASCII должна быть преобразована в целые значения. В приведенном ниже примере на C++ из командной строки вводится одно целое число. Поскольку на самом деле это число является символьной строкой, оно преобразуется в целое при помощи библиотечной функции atoi(). Значение из командной строки ivalue передается в использованную в предыдущем примере функцию vbinary(), которая преобразует значение ivalue в строку двоичных цифр и печатает ее на экране. Когда управление возвращается функции main(), значение ivalue печатается в восьмеричном и шестнадцатеричном форматах.
// 08IARGV.CPP
// Программа на C++ иллюстрирует ввод в программу целых чисел
// из командной строки
// C:\> 08IARGV.EXE 97

#include <iostream>
#include <conio.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <stdlib.h>
#include <math.h>
using namespace std;

void vbinary(int idigits);

int main(int argc, char *argv[])
{
	int ivalue;
	if(argc!=2)
	{
		// Введите десятичное число в командной строке.
		// Оно будет преобразовано в двоичное, восьмеричное и
		// шестнадцатеричное.
		cout<<"Enter a decimal number on the command line.\n";
		cout<<"It will be converted to binary, octal and hexadecimal.\n";
		exit(1);
	}
	ivalue=atoi(argv[1]);
	// Десятичное значение равно
	cout << "The decimal value is: " << ivalue << endl;
	vbinary(ivalue);
	// Восьмеричное значение равно
	cout << "The octal value is: " << oct << ivalue << endl;
	// Шестнадцатеричное значение равно
	cout << "The hexadecimal value is: " << hex << ivalue << endl;

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

void vbinary(int idigits)
{
	int t=0;
	int iyourarray[50];
	while(idigits != 0)
	{
		iyourarray[t]=(idigits %2);
		idigits/=2;
		t++;
	}
	t--;
	// Двоичное значение равно
	cout << "The binary value is: ";
	for(;t>=0;t--)
		cout << dec << iyourarray[t];
	cout << endl;
}





Особый интерес представляет форматирование различных чисел. Как вы помните, двоичные числа хранятся в массиве, а для вывода на экран содержимого массива iyourarray печатаются в обратном порядке по одной цифре за раз в десятичном формате:

cout << dec << myarray[i];

Для печати числа в восьмеричном формате используется следующий оператор:

cout << "The octal value is: "
<< oct << ivalue << endl;

Также можно распечатать шестнадцатеричный эквивалент, заменив oct на hex, что и показано ниже:

cout << "The hexadecimal value is: " << hex << ivalue << endl;

Если не применять дополнительного форматирования, то шестнадцатеричные цифры а, Ь, с, d, e и f печатаются строчными. Позднее вы познакомитесь со многими способами форматирования, в том числе узнаете, как печатать эти символы заглавными буквами.

            7.1.3. Числа с плавающей точкой.
Поскольку вы знаете, как вводить целые числа из командной строки, числа float не создают дополнительных проблем. Следующий пример на С позволяет ввести из командной строки значения нескольких углов. Вычисляются косинусы углов и печатаются на экране. Поскольку у значений углов тип float, они могут выглядеть по-разному, например: 12.0, 45.78, 0.12345 или 15.

/*08FARGV.C
Программа на С иллюстрирует ввод в программу чисел
с плавающей точкой из командной строки
C:\> 08FARGV.EXE 90 45.78 0.12345 45*/

#include "stdafx.h"
#include <iostream>
#include <conio.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <stdlib.h>
#include <math.h>
using namespace std;

const double dPi=3.14159265359;

int main(int argc, char *argv[])
{
	int t;
	double ddegree;
	if(argc < 2)
	{
		/* Введите несколько углов в командной строке. */
		/* Программа вычислит и напечатает */
		/* косинусы введенных углов. */
		printf("Type several angels on the command line.\n");
		printf("Programm will colculate and print\n");
		printf("the cosine af the angles entered.\n");
		exit(1);
	}
	for(t=1;t<argc;t++)
	{
		ddegree=(double) atof(argv[t]);
		printf("The cosine of %f is %15.14lf\n",
				ddegree, cos((dPi/180)*ddegree));
	}

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}





Функция atof() используется для преобразования строковых аргументов командной строки в тип float. В программе для вычисления косинуса в функции printf() используется функция cos().

        14.11. Области видимости. Локальные и глобальные переменные
Переменные могут быть объявлены как внутри тела какой-либо функции, так и за пределами любой из них.
Переменные, объявленные внутри тела функции, называются локальными. Такие переменные размещаются в стеке программы и действуют только внутри той функции, в которой объявлены. Как только управление возвращается вызывающей функции, память, отводимая под локальные переменные, освобождается.
Каждая переменная характеризуется областью действия, областью видимости и временем жизни.
Под областью действия переменной понимают область программы, в которой переменная доступна для использования.
С этим понятием тесно связано понятие области видимости переменной. Если переменная выходит из области действия, она становится невидимой. С другой стороны, переменная может находиться в области видимости, если к ней можно получить доступ (с помощью операции разрешения видимости, в том случае, если она непосредственно не видима).
Временем жизни переменной называется интервал выполнения программы, в течение которого она существует.
Локальные переменные имеют своей областью видимости функцию или блок, в течение которых она существует. В то же время область действия локальной переменной может исключать внутренний блок, если в нем объявлена переменная с тем же именем. Время жизни локальной переменной определяется временем выполнения блока или функции, в которой она объявлена.
Это означает, например, что в разных функциях могут использоваться переменные с одинаковыми именами совершенно независимо друг от друга.
В рассматриваемом ниже примере переменные с именем х определены сразу в двух функциях - в main () и в Sum (), что, однако, не мешает компилятору различать их между собой:

#include <iostream>
using namespace std;

// Прототип функции:
int Sum(int a, int b);

int main()
{
	// Локальные переменные:
	int x = 2;
	int у = 4;
	cout << Sum(x, у);

	getchar(); 	getchar();
	return 0;
}

int Sum(int a, int b)
{
	// Локальная переменная х
	// видна только в теле функции Sum()
	int x = a + b;
	return x;
}

В программе осуществляется вычисление суммы двух целочисленных переменных посредством вызова функции Sum().



Глобальные переменные, как указывалось ранее, объявляются вне тела какой-либо из функции и действуют на протяжении выполнения всей программы. Такие переменные доступны в любой из функций программы, которая описана после объявления глобальной переменной. Отсюда следует вывод, что имена локальных и глобальных переменных не должны совпадать. Если глобальная переменная не проинициализирована явным образом, она инициализируется значением 0.
Область действия глобальной переменной совпадает с областью видимости и простирается от точки ее описания до конца файла, в котором она объявлена. Время жизни глобальной переменной - постоянное, то есть совпадает с временем выполнения программы.
Вообще говоря, на практике программисты стараются избегать использования глобальных переменных и применяют их только в случае крайней необходимости, так как содержимое таких переменных может быть изменено внутри тела любой функции, что чревато серьезными ошибками при работе программы.
Рассмотрим пример, поясняющий вышесказанное:

#include <iostream>
using namespace std;

// Объявляем глобальную переменную Test:
int Test = 200;
void PrintTest(void);

int main()
{
	setlocale(LC_ALL, "Rus");
	// Объявляем локальную переменную Test:
	int Test = 10;
	// Вызов функции печати
	// глобальной переменной:
	PrintTest ();
	cout << "Локальная: "<< Test << '\n';

	getchar(); 	getchar();
	return 0;
}

void PrintTest(void)
{
	cout << "Глобальная: " << Test << '\n';
}


Первоначально объявляется глобально переменная Test, которой присваивается значение 200. Далее объявляется локальная переменная с тем же именем Test, но со значением 10. Вызов переменной printTest() из main () фактически осуществляет временный выход и тела главной функции. При этом все локальные переменные становятся недоступны и PrintTest() выведет на печать глобальную переменную Test. После этого управление программой возвращается в функцию main(), где конструкцией cout<< выводится на печать локальная переменная Test. Результат работы программы выглядит следующим образом:

Глобальная: 200
Локальная: 10



В C++ допускается объявлять локальную переменную не только в начале функции, а вообще в любом месте программы. Если объявление происходит внутри какого-либо блока, переменная с таким же именем, объявленная вне тела блока, "прячется". Видоизменим предыдущий пример с тем, чтобы продемонстрировать процесс сокрытия локальной переменной:

#include <iostream>
using namespace std;

// Объявляем глобальную переменную Test:
int Test = 200;
void PrintTest(void);

int main()
{
	setlocale(LC_ALL, "Rus");
	// Объявляем локальную переменную Test:
	int Test = 10;
	// Вызов функции печати
	// глобальной переменной:
	PrintTest();
	cout << " Локальная: " << Test << '\n';
	// Добавляем новый блок с еще одной
	// локальной переменной Test:
	{
		int Test = 5;
		cout << " Локальная: " << Test << '\n';
	}
	// Возвращаемся к локальной Test
	// вне блока:
	cout << " Локальная: " <<Test << '\n';

	getchar(); 	getchar();
	return 0;
}

void PrintTest(void)
{
	cout << "Глобальная: " << Test << '\n';
}

Результат модифицированной программы будет выглядеть следующим образом:

Глобальная: 200
Локальная: 10
Локальная: 5
Локальная: 10



        14.12. Сложности в правилах области действия (scope rules).
Если используются переменные с различной областью действия, то можно столкнуться с совершенно неожиданными результатами программирования, называемыми побочными эффектами. Например, как вы уже знаете, может существовать переменная (вернее две переменные с одинаковым именем) как с файловой, так и с локальной областью действия. Правила области действия констатируют, что переменная с локальной областью действия (называемая локальной переменной) имеет приоритет по сравнению с переменной с файловой областью действия (называемой глобальной переменной). Хотя это выглядит достаточно просто, давайте рассмотрим несколько проблем, которые не так очевидны и с которыми вы можете столкнуться при программировании.

            7.1.4. Неопределенные символы в программе на С.
В следующем примере четыре переменные имеют локальную область действия внутри функции main(). Копии переменных il и im передаются в функцию iproduct(). Это не нарушает правила области действия. Однако, когда функция iproduct() пытается обратиться к переменной in, она ее не находит. Почему? Потому что область действия этой переменной локальна для функции main().

/*08SCOPEP.C
Программа на С иллюстрирует проблемы, связанные с правилами
области действия. Предполагается, что функция вычисляет
произведение трех чисел. Компилятор выдает ошибку, поскольку
переменная in не известна функции, вычисляющей произведение*/

#include "stdafx.h"
#include <iostream>
#include <conio.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <stdlib.h>
#include <math.h>
#include <stdarg.h>
#include <string.h>
using namespace std;

int iproduct(int iw,int ix);
/* int in=10; */

main ()
{
	int il=3;
	int im=7;
	int in=10;
	int io;
	io=iproduct(il,im);
	/* Произведение чисел равно */
	printf("The product of the numbers is: %d\n", io);

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

int iproduct(int iw,int ix)
{
	int iy;
	iy=iw*ix;
	/* iy=iw*ix*in; */
	return (iy);
}



Компилятор С выдает предупреждение и сообщение об ошибке. Сначала он предупреждает о том, что переменная in, объявленная в функции main(), нигде там не используется, а затем выдает сообщение об ошибке, говорящее о том, что переменная in нигде не объявлена в функции iproduct(). Единственный способ избавиться от этой проблемы — дать переменной in глобальную область действия.

            7.1.5. Использование переменной с файловой областью действия.
В следующем примере переменной in определена файловая область действия. Глобальная видимость переменной in во всем файле позволяет ее использовать как функции main(), так и функции iproduct(). Также надо заметить, что обе функции, main() и iproduct(), могут изменять значение переменной. Существует хорошее программистское правило: если функции должны быть действительно переносимыми, не следует позволять им менять глобальные переменные.

/*08FSCOPE.C
Программа на С иллюстрирует проблемы, связанные с правилами
области действия. Предполагается, что функция вычисляет
произведение трех чисел. Предыдущая проблема решена: третьей
переменной задана файловая область действия*/

#include "stdafx.h"
#include <iostream>
#include <conio.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <stdlib.h>
#include <math.h>
#include <stdarg.h>
#include <string.h>
using namespace std;

int iproduct(int iw,int ix);
int in=10;

main()
{
	int il=3;
	int im=7;
	int io;
	io=iproduct(il,im);
	printf("The product is: %d\n", io);

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

int iproduct(int iw,int ix)
{
	int iy;
	iy=iw*ix*in;
	return(iy);
}

Эта программа будет компилироваться без ошибок и напечатает на экране значение произведения 210.



            7.1.6. Приоритет переменных с файловой и локальной областями действия.
Правила области действия констатируют, что у переменной, имеющей как локальную, так и файловую область действия, используется ее локальное, а не глобальное значение. Это положение иллюстрирует следующая небольшая программа:
//  08SCOPEP.CPP
/*Программа на С иллюстрирует проблемы, связанные с правилами
области действия. Предполагается, что функция вычисляет
произведение трех чисел, но каких чисел? Две переменные задаются
как параметры функции. Третья переменная имеет и файловую и
локальную область действия*/

#include "stdafx.h"
#include <iostream>
#include <conio.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <stdlib.h>
#include <math.h>
#include <stdarg.h>
#include <string.h>
using namespace std;

int iproduct(int iw,int ix);
int in=10;

main()
{
	int il=3;
	int im=7;
	int io;
	io=iproduct(il,im);
	printf("The product of the numbers is: %d\n", io);

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

int iproduct(int iw,int ix)
{
	int iy;
	int in=2;
	iy=iw*ix*in;
	return(iy);
}



В этом примере переменная in имеет одновременно файловую и локальную области действия. Когда переменная in используется в функции product(), локальная область действия имеет приоритет, и возвращаемый результат равен 3 *7 * 2 = 42.

            7.1.7. Проблемы области действия в C++.
Следующий пример на C++ работает нормально до момента вывода информации на экран. Оператор cout правильно распечатывает значения переменных il и im. Но при обращении к переменной in он выбирает глобальную переменную с файловой областью действия. Результат, выдаваемый программой, 3*7*10 = 42, является явной ошибкой. Как вы знаете, в подобной ситуации функция iproduct() использует локальное значение переменной in.

// 08SCOPEP.CPP
// Программа на C++ иллюстрирует проблемы, связанные с правилами
// области действия. Предполагается, что функция вычисляет
// произведение трех чисел. Переменная in имеет локальную область
// действия и используется в функции для вычисления произведения.
// Однако, в главной функции определено, что значение этой переменной
// равно 10. Что здесь неправильно?

#include "stdafx.h"
#include <iostream>
#include <conio.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <stdlib.h>
#include <math.h>
#include <stdarg.h>
#include <string.h>
using namespace std;

int iproduct(int iw,int ix);
int in=10;

main()
{
	int il=3;
	int im=7;
	int io;
	io=iproduct(il,im);
	cout << "The product of " << il <<" * " << im << " * " << in << " is: " << io << endl;

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

int iproduct(int iw,int ix)
{
	int iy;
	int in=2;
	iy=iw*ix*in;
	return (iy);
}



Как решить эту проблему, если вы действительно хотите вычислить произведение и использовать глобальное значение переменной in? В C++ для этого можно использовать упомянутую выше операцию уточнения области действия и записать оператор следующим образом:

iy=iw*ix*::in;



            7.1.8. Операция уточнения области действия в C++.
Как было показано выше, объявление локальной переменной скрывает глобальную переменную с таким же именем. Таким образом, все обращения к имени глобальной переменной в пределах области действия локального объявления вызывают обращение к локальной переменной. Однако C++ позволяет обращаться к глобальной переменной из любого места программы с помощью использования операции разрешения области видимости. Для этого перед именем переменной ставится префикс в виде двойного двоеточия (::):

#include <iostream>
using namespace std;

// Объявление глобальной переменной
int Turn = 5;

int main ()
{
	setlocale(LC_ALL, "Rus");
	// объявление локальной переменной
	int Turn = 70;
	// Вывод локального значения:
	cout << Turn << '\n';
	// Вывод глобального значения:
	cout << ::Turn << '\n';

	getchar(); 	getchar();
	return 0;
}

В результате в две строки будет выведено два значения: 5 и 70.



Из рассмотренного примера видно, что были объявлены глобальная и локальная переменные с именем Turn, которые позже были выведены на печать.
В следующем примере для того, чтобы избежать конфликтов между переменными как с файловой, так и с локальной областями действия, используется операция уточнения области действия (scope resolution operator ::). Предыдущая программа выдавала неправильное значение произведения, так как в вычислениях использовалось локальное значение. Обратите внимание на то, как в приведенном листинге в функции iproduct() используется операция уточнения области действия.

// 08GSCOPE.CPP
// Программа на C++ иллюстрирует проблемы, связанные с правилами
// области действия, и использование операции уточнения области
// действия. При вычислении произведения с помощью этой операции,
// в функции используется переменная с файловой областью действия

#include "stdafx.h"
#include <iostream>
#include <conio.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <stdlib.h>
#include <math.h>
#include <stdarg.h>
#include <string.h>
using namespace std;

int iproduct(int iw,int ix);
int in=10;

main()
{
	int il=3;
	int im=7;
	int io;
	io=iproduct(il,im);
	cout << "The product of " << il <<" * " << im
		<< " * " << in << " is: " << io;

	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

int iproduct(int iw,int ix)
{
	int iy;
	int in=2;
	iy=iw*ix*(::in);
	return(iy);
}



Операцию уточнения области действия не обязательно заключать в круглые скобки — они использованы в этом примере только для выделения операции. Теперь при вычислениях используется глобальная переменная с файловой областью действия. При выводе результата на экран вы увидите значение 3 * 7 * 10 = 210.
Операция уточнения области действия очень важна в C++. Дополнительные примеры применения этой операции приводятся в последующем изложении материала.

        14.13. Математические функции
Прототипы стандартных математических функций определены в заголовочном файле math.h. Рассмотрим некоторые из них, наиболее часто употребляемые в повседневной работе.
Ранее уже упоминалась функция pow(), позволяющая возводить число в степень. Синтаксис данной функции выглядит следующим образом:

double pow(double x, double у);

Таким образом, компилятору сообщается, что необходимо число двойной точности х возвести в степень числа двойной точности у.
К данной категории также относятся логарифмические функции и функция извлечения корня числа:

double log(double); // натуральные
float logf(float);
long double logl(long double);
double log10(double); // десятичные
float log10(float);
long double log10 (long double);
double sqrt(double); // корень числа
float sqrtf(float);
long double sqrtl(long double);

Другая большая группа - функции получения абсолютной величины числа,

int abs(int); // целые
double f abs (double); // двойной точности
long labs (long); // длинные
float fabsf (float); // с плавающей точкой
long double fabsl (long double);// длинные
// двойной	
// точности

воспринимают в качестве параметра аргумент некоторого типа (свой для каждой из функций) и возвращают его беззнаковую форму.
Для вычисления остатка от деления числа х на у используется функция fmod(), которая имеет следующий синтаксис:

double fmod(double x, double y);

Стандартная библиотека располагает широким набором тригонометрических функций и их модификаций для различных типов аргументов:

// Арккосинус:
double acos(double);
float acosf(float);
// Арксинус:
double asin(double);
float asinf(float);
// Арктангенс:
double atan(double);
float atanf(float);
// Арктангенс отношения у/х:
double atan2(double x, double y);
float atan2f(float, float);
// Косинус:
double cos(double);
float cosf(float);
// Гиперболический косинус:
double cosh(double);
float coshf(float);
// Синус:
double sin(double);
float sinf(float);
// Гиперболический синус:
double sinh(double);
float sinhf(float);
// Тангенс:
double tan(double);
float tanf(float);
// Гиперболический тангенс:
double tanh(double);
float tanhf(float);

Следует отметить, что углы тригонометрических функций указываются в радианах. Ниже приводится пример, осуществляющий перевод градусов в радианы и вывод значения синуса для введенного в градусах числа.

#include <math.h>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, "Rus");
	double Angle;
	double PI = 3.14159;
	cout << "Введите угол в градусах: ";
	cin >> Angle;
	cout << "Значение синуса: ";
	cout << sin(Angle * PI / 180) << '\n';

	getchar(); 	getchar();
	return 0;
}



К сожалению, в C++ нет готовой реализации функции возведения аргумента в квадрат. Эту функцию можно реализовать, например, следующим образом:

inline double sqr(double x)
{return pow(x, 2);}	

Заметим, что для работы данной функции необходимо задействовать заголовочный файл math.h, содержащий прототип функции pow().

        14.14. Указатель на функцию

            7.1.9. Указатели на функции
Синтаксис
Указатели на функции задаются следующим образом:

void f() { }
void (*pf)() = &f;
pf();

В этом коде f - некоторая функция.
Во второй строчке определяется переменная pf, которая является указателем на функцию, которая ничего не возвращает и не принимает ни одного аргумента. В определении pf ей присваивается адрес функции f.
В третьей строке мы вызываем функцию по указателю pf(в данном случае будет вызвана функция f).

Пример 1
void swap(int & a, int & b) { }
void (*pswap)(int &, int &) = &swap;


Пример 2
void f(int a) { }
void g(int b) { }

void (*pf)(int) = &f;
pf(10); // Вызывается f(10)

pf = &g;
pf(20); // Вызывается g(20)

Примечание
Во время присваивания указателю на функцию адреса функции амперсанд(&) можно опустить. В этом случае будет выполнено автоматическое привидение имени функции к адресу этой функции.

Пример 3
void f() { }
void g() { }

void (*pf) = &f; // Верно, &f - указатель на функцию f
pf = g; // Тоже верно, имя функции(g) автоматически приводится к указателю на функцию.

Пример 4
Пусть мы хотим реализовать таймер, который через заданные промежутки времени выполняет произвольный код. Пользователи нашего таймера должны иметь возможность указать какой именно код должен исполняться таймером. ООП-подход к решению данной задачи на C++ может выглядеть следующим образом:

struct TimerClient {
   virtual void OnTimer() = 0;
};

Пользователи нашего таймера могут наследоваться от TimerClient и передавать нашему таймеру указатели на наследников. Наша реализация таймера будет вызывать OnTimer() и таким образом исполнять клиентский код.
Альтернативой ООП являются указатели на функции. Мы могли бы передать таймеру указатель на функцию, которую будет вызывать наша реализация.

            7.1.10. Указатели на методы
Синтаксис
Рассмотрим следующий класс:

struct Array2D
{
   int height() const;
   int width() const;
};

Методы height и width имеют одинаковую сигнатуру. Если у нас есть экземпляр класса Array2D, то мы можем использовать указатели на методы следующим образом:

int (Array2D::*f)() = &Array2D::height;
// Определение указателя на метод объекта Array2D, который возвращает int
//  и не принимает аргументов. (f)

Array2D a;
Array2D * p = &a;

(a.*f)(); // Вызывается a.height()
(p->*f)();

f = &Array2D::width;

(a.*f)();  //Вызывается a.width()
(p->*f)();

const функции в структуре (классе)
Вначале о const, применяемом к функции структуры или класса.
Функция класса, объявленная const, трактует this как указатель на константу. Вообще тип this в методе класса X будет X*. Но если метод класса объявлена как const, то тип this будет const X*. В таких методах не может быть ничего присвоено переменным класса, которые не объявлены как static или как mutable . Также const-функции не могут возвращать не const ссылки и указатели на данные класса и не могут вызывать не const-функции класса. const-функции иногда называют инспекторами (inspector), а остальные мутаторами (mutator).

class C
{
public:
 int inspect() const;   // Эта функция обещает не менять *this
 int mutate();          // Эта функция может менять *this
};

В классе могут присутствовать две функции отличающиеся только const.

class C
{
 ...
public:
 int func () const;
 int func ();
};

Не всякая функция может быть объявлена константной. Конструкторы и деструкторы не могут быть объявлены как const. Также не бывает static const функций.

class C
{
 int i;
public:
 static int func () const;    //ошибка
};

Замечание.
Модификатор const после имени функции означает, что функция не может изменять члены-переменные того объекта, к которому она принадлежит. Более того, из этой функции можно вызывать только такие же константные функции. Зачем все это нужно - используя это, можно защитить самого себя от случайного изменения информации, которая не должна меняться

А теперь пример для указателя на метод класса (структуры)

struct MyClass
{
   int method() const
   {
       return 10;
   }
   int method()
   {
       return 5;
   }
}

int (MyClass::*f)() const = &MyClass::method;
int (MyClass::*g)() = &MyClass::method;

MyClass obj;
(obj.*f)(); // Вернёт 10. Будет вызван константный метод
(obj.*g)(); // Вернёт 5. Будет вызван неконстантный метод.

            7.1.11. Примеры

    8. Пример 1. Простой указатель на функцию
#include <iostream>
#include <math.h>
using namespace std;

// площадь круга радиуса R
double area(double R)
{
	const double PI = 3.1415;
	return PI * R * R;
}

int main()
{
	setlocale(LC_ALL, "rus");
	double r = 1.0;
	cout << "для круга радиуса " << r << " площадь = " << area(r) << endl;

	double(*pfunc)(double);    // переменная указатель на функцию
	pfunc = area;

	cout << "для круга радиуса " << r << " площадь = " << (*pfunc)(r) << endl;
	cin >> r;
	return 0;
}



    9. Пример 2. Массив указателей на функции
Предположим, для некоторого крупного проекта мы готовим последовательность тестов, выполняемых в процесс развития и роста самого тестируемого проекта (это так называемая технология разработки тестирования, и очень продуктивная). Число пошаговых тестов в такой ситуации будет постоянно нарастать по мере продвижения готовности базового проекта.

#include <iostream>
using namespace std;

void test1(void)
{
	cout << "выполняется тест №1" << endl;
	// ...
}

void test2(void)
{
	cout << "выполняется тест №2" << endl;
	// ...
}

void test3(void)
{
	cout << "выполняется тест №3" << endl;
	// ...
}

void(*tests[])(void) =  // массив указателей на функции
{
	test1, test2, test3 // последовательность тестов
	// ... и много других тестов
};

int main()
{
	setlocale(LC_ALL, "rus");
	for (int i = 0; i < sizeof(tests) / sizeof(tests[0]); i++)
	{
		tests[i]();
	}
	int x;
	cin >> x;
	return 0;
}



В этом листинге tests[ ] – это массив указателей на функции без параметров и без возвращаемых значений. Красивое решение, не правда ли? Мы можем не задумываясь добавлять новые функции массива вызываемых тестов, и они все последовательно будут вызываться при выполнении.

    10. Пример 3. Указатель на функцию – параметр функции
Мы можем пойти ещё дальше: если указатель на функцию представляет функцию в выражениях, можно передать указатель на функцию в качестве параметра другой, охватывающей функции, и последняя будет выполнять в своём теле переданную параметром функцию, не зная какое действие при этом выполняется.
Для иллюстрации всего сказанного создадим программу самого примитивного калькулятора, выполняющего арифметические действия над целочисленными операндами

#include <iostream>
#include <stdlib.h>
using namespace std;

int calculate(int op1, int op2, int(*func)(int, int))
{
	return func(op1, op2);
}

/* сложение, вычитание, умножение, деление,
остаток, возведение в степень: */
int summ(int op1, int op2) { return op1 + op2; }
int diff(int op1, int op2) { return op1 - op2; }
int mult(int op1, int op2) { return op1 * op2; }
int divd(int op1, int op2) { return op1 / op2; }
int bals(int op1, int op2) { return op1 % op2; }
int powr(int op1, int op2)
{
	int ret = 1;
	while (op2--) ret *= op1;
	return ret;
}

typedef int(*fint_t)(int, int);		// fint_t - указатель на функцию
// функции 6-ти арифметических операций
fint_t foper[] =					// массив указателей на функции
{
	summ, diff, mult, divd, bals, powr
};

int main()
{
	setlocale(LC_ALL, "rus");
	char coper[] = { '+', '-', '*', '/', '%', '^' };
	int noper = sizeof(coper) / sizeof(coper[0]);
	do
	{
		char buf[120];
		char *str = buf;
		char *endptr;
		char oper;

		//flush сбрасывает буфер
		cout << "выражение для вычисления (<op1><знак><op2>): " << flush;
		cin >> buf;

		int op1, op2;

		//strtod - преобразование строки в
		//значение с плавающей запятой двойной точности
		op1 = strtod(str, &endptr);
		oper = *endptr++;
		op2 = strtod(str = endptr, &endptr);

		int i;
		for (i = 0; i < noper; i++)
		{
			if (oper == coper[i]) {
				cout << op1 << ' ' << oper << ' ' << op2 << " = "
					<< calculate(op1, op2, foper[i]) << endl;
				break;
			}
		}
		if (i == noper)
			cout << "неверный знак операции: " << oper << endl;
	} while (true);

	return 0;
}



Здесь собственно вычисление выполняет функция calculate(). Но она ничего не «знает» о выполняемых действиях и о арифметических операциях вообще: она применяет к 2-м первым своим параметрам одну из 6-ти функций, которую ей передали 3-м параметром для выполнения.
В этом коде функция strtod() – стандартная функция библиотеки языка C (ANSI C, стандарта POSIX), которая извлекает десятичное число из строки, полученной со стандартного потока ввода. В контексте наших обсуждений это интересно тем, что:
    • программа на C++ может использовать всё множество библиотечных вызовов языка C;
    • программа C++ использует на этапе выполнения разделяемые библиотеки языка C (.so или .dll), и при отсутствии стандартной библиотеки C, программы на C++ становятся неработоспособными.

Наблюдательный пользователь мог бы заметить, что функция calculate() при всём своём желании и не могла бы выполнить ни одно из требуемых арифметических действий, так как выполняющие эти действия функции sum(), dif(), mul() и div() описаны позже функции calculate() и не видимы в коде функции calculate().
Таким образом, мы рассмотрели несколько различных случаев, когда функции в C++ используются, как экземпляры данных. Они могут объединяться в массивы, встраиваться в качестве полей структур, или передаваться другим функциям в качестве параметров. Все эти и подробные возможности реализуются за счёт указателей на функции (хотя по синтаксису записей они могут и не выглядеть как указатели, за счёт умного компилятора C++, который по контексту понимает, что должны использоваться адреса функций).

    11. Пример 4. Сортировка массива
Создадим массив, который в зависимости от выбора пользователя сортируется по убыванию или же возрастанию.
Чтобы сортировать какой-то массив, нужно этот массив создать и заполнить значениями, с этого и начинается написание программы по сортировке массива.

#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL,""); //Для русских символов
	const int N=10; //Размер массива
	int my_choose=0; //В переводе звучит как Мой Выбор
	int A[N]={9,8,7,6,1,2,3,5,4,9}; //Объявление массива и его инициализация значениями
		cout << "1. Сортировать по возрастанию\n";
		cout << "2. Сортировать по убыванию\n";
		cin >> my_choose; //Ожидание ввода пользователя
	cout<<"Исходные данные: ";
return 0;
}

После написания такого кода возникает необходимость отображения массива на экране. Если подумать, то мы будем показывать исходный массив, будем показывать модифицированный. Одна операция будет выполнена как минимум дважды, а это плохо при написании всего в одну кучу, потому что увеличивает количество строк кода программы, следовательно увеличивает время написания программы и следовательно повышает вероятность ошибок и усложняет поиск ошибок. На таком маленьком коде — это едва заметно, но постепенно код будет расти и чем больше будет, тем это будет заметнее. У хорошей программы как и у хорошего здания должен быть крепкий фундамент, поэтому выносим операцию отображения массива на экране в отдельную функцию.

void show_array(const int Arr[],const int N) //Функция покажет массив на экране
{
	for (int i=0; i<N; i++)
		cout<<Arr[i] << "  "; //Поэлементно выводим значения массива на экран
	cout << "\n";
}

И еще одно пояснение к простому примеру

#include <iostream>
using namespace std;

bool from_min(int a,int b)
{
	return a>b;
}

int main()
{
	cout<<from_min(14,5);//return => 1
	cout<<"\n";
	cout<<from_min(5,14);//return => 0

	cin.get();
	cin.get();
	return 0;
}

В этом коде мы не возвращаем явно указанного значения, но несмотря на это в разных случаях функция будет возвращать различные данные. Если условие после return для параметров функции справедливо, функция- вернет 1, иначе 0.
Для решения задачи используем алгоритм пузырьковой сортировки. Добавляем сразу три функции в основной код. Две из них — это функции, указатель для которых будет использован, а третья — пузырьковая сортировка.

#include <iostream>
using namespace std;

bool from_min(const int a,const int b) //Проверка одного условия
{
	return a>b;
}

bool from_max(const int a,const int b) //Проверка другого условия
{
	return a<b;
}

void bubble_sort(int Arr[],const int N, bool (*compare)(int a,int b)) //Функция пузырьковой сортировки
{
	for (int i=1;i<N;i++){
		for (int j=0;j<N-1;j++){
			if ((*compare)(Arr[j],Arr[j+1]))
				swap(Arr[j],Arr[j+1]); //Сравниваем элемент со сразу за ним идущим
		}
	}
}

void show_array(const int Arr[],const int N)
{
	for (int i=0;i<N;i++)
		cout<<Arr[i] << "  ";
	cout << "\n";
}

int main()
{
	setlocale(LC_ALL,"");
	const int N=10;
	int my_choose=0;
	int A[N]={9,8,7,6,1,2,3,5,4,9};
		cout<<"1. Сортировать по возрастанию\n";
		cout<<"2. Сортировать по убыванию\n";
		cin>>my_choose;

	cout<<"Исходные данные: ";	
	show_array(A,N);
	cout<<"Сортированный массив:  ";
	switch (my_choose)
	{
		case 1: bubble_sort(A,N,from_min); break;
		case 2: bubble_sort(A,N,from_max); break;
		default: cout<<"\rНеизвестная операция ";
	}

	show_array(A,N);
	cin.get();
	cin.get();
	return 0;
}



Замечание.
    • имя функции — начальный адрес её кода имеет приоритет ниже чем круглые скобки, поэтому указатель на функцию нужно заключать в скобки
    • int *func(int a,int b) — функция принимает два параметра на целое и возвращает указатель на целое
    • int (*func)(int a,int b) — указатель на функцию с двумя параметрами, каждый параметр — целое

http://ermak.cs.nstu.ru/cprog/html/093.htm
            11.1.1. Указатель на функцию и динамическое связывание
Указатель на функцию - переменная, которая содержит адрес некоторой функции. Соответственно, косвенное обращение по этому указателю представляет собой вызов функции.
Определение указателя на функцию имеет вид:

int (*pf)();		// без контроля параметров вызова
int (*pf)(void);		// без параметров, с контролем по прототипу
int (*pf)(int, char*);	// с контролем по прототипу

В соответствии с принципом контекстного определения типа данных эту конструкцию следует понимать так: pf - переменная, при косвенном обращении к которой получается функция с соответствующим прототипом, например int_F(int, char*), то есть pf содержит адрес функции или указатель на функцию. Следует обратить внимание на то, что в определении указателя присутствует прототип - указатель ссылается не на произвольную функцию, а только на одну из функций с заданной схемой формальных параметров и результата.
Перед началом работы с указателем его необходимо назначить на соответствующий объект, в данном случае - на функцию. В синтаксисе Си выражение вида &имя_функции имеет смысл - начальный адрес функции или указатель на функцию. Кроме того, по аналогии с именем массива использование имени функции без скобок также интерпретируется как указатель на эту функцию. Указатель может быть инициализирован и при определении.

int INC(int а) { return a+1; }
extern int DEC(int);
int (*pf)(int);
pf = &INC;
pf = INC;			// присваивание указателя
int (*pp)(int) = &DEC;	// инициализация указателя

Естественно, что функция, на которую формируется указатель, должна быть известна транслятору - определена или объявлена как внешняя. Синтаксис вызова функции по указателю совпадает с синтаксисом ее определения.

n = (*pf)(1) + (*pp)(n);	// эквивалентно
n = INC(1) + DEC(n);

Как и обычный указатель, указатель на функцию имеет размерность адреса, т.е. на уровне архитектуры является машинным словом, содержащим адрес функции в соответствии с системой формирования адресов процессором (системой адресации памяти). Это позволяет, в свою очередь, опускаться до таких машинно-зависимых действий как вызов функции по заданному адресу памяти, преобразуя целую константу к указателю на функцию.

void (*pf)(void) = (void(*)(void))0x1000;	// Константа 1000 – шестнадцатеричный адрес
void main() { (*pf)(); }			// функции, которую вызывает main
							// void(*)(void) –абстрактный тип данных –
							// указатель на функцию

Указатель на функцию прежде всего имеет отношение к системному программированию. Достаточно сказать, что кроме Си в явном виде он встречается только в Паскале (процедурный тип), но во многих случаях входит в скрытые механизмы управления программной средой, известные как динамическое связывание функций. Динамическое и статическое связывание относя и к переменным. По отношению к функции термин динамическое связывание следует понимать как установление соответствия между именем функции и ее адресом. Если рассматривать этот вопрос по отношению обычным функциям на Си, то можно выделить три этапа связывания:
    • если определение функции и ее вызов находятся в одном модуле (файле), то транслятору ничего не мешает вычислить относительный адрес функций внутри объектного модуля во время трансляции – статическое связывание;
    • при вызове внешней функции, определение которой находится в другом файле (а программный код – в другом объектном модуле), адрес функции становится известен при компоновке программного файла  из объектных модулей. Хотя процедура компоновки выполняется после трансляции, данное связывание также называется статическим;
    • набор внешних функций (объектный модуль целиком) может быть оформлен в виде динамически связываемой библиотеки – DLL  (dynamic linking library). Она загружается в память одновременно с программным модулем и связывание имени внешней функции с ее адресом в адресном пространстве DLL происходит при загрузке. Это связывание уже считается динамическим. При наличии в каждом приложении отображаемого адресного пространства (виртуальной памяти) программный код DLL  может одновременно использоваться (разделяться) несколькими приложениями.

Если на уровне среды программирования или непосредственно в Си-программах имеет место элемент динамического связывания, то с уверенностью можно сказать, что в том или ином виде (явно или неявно) используется указатель на функцию:
    • уже упомянутые нами DLL, а также все возможные виды динамической загрузки внутреннего (исполняемого) программного кода;
    • виртуальные функции в Си++ – при конструировании объекта производного класса в базовый класс помещается указатель на таблицу виртуальных функций для производного класса (массив указателей на функции);
    • функции, работающие с произвольными типами данных – для настройки на конкретный тип данных в качестве «довеска» получают указатель на функцию, которая «знает», как с ним работать. В результате основной алгоритм изолируется от типа данных, с которым работает.

            11.1.2. Таблицы функций, вызов по имени
Тип данных вида void (*pp[])() расшифровывается в соответствии с контекстным определением типа данных как массив указателей на функции с общим прототипом (схемой передачи параметров и результата) – последовательность операций в контексте – массив – указатель – вызов функции. Образно, хотя и не совсем точно этот тип можно назвать таблицей функций, вызов которых может производиться по номеру (индексу).
В самом простом примере наличие таблицы функций позволяет сделать вызов функции по заданному символьному имени регулярным (циклическим). В принципе, то же самое можно сделать с помощью обычного переключателя (switch), но для этого придется еа каждую новую функцию добавлять фрагмент программного кода. Здесь же достаточно внести в массивы символьное имя и ее адрес.

extern double sin(double);
extern double cos(double);
extern double tan(double);
char *names[] = { "sin","cos","tan",NULL};	// Массив имен (указатели на строки)
double   (*pf[])(double) = { sin, cos, tan };	// Таблица функций (адреса функций)
//---------------------------------------------------------------------------------
//---- Вызов функции по имени из заданного списка
double call_by_name(char *pn, double arg) {
for ( int i=0; names[i]!=NULL; i++)
	if (strcmp(names[i],pn) == 0) {	// Имя найдено -
		 return ((*pf[i])(arg));	// вызов функции по i-му
	}						// указателю в массиве pf
return 0.;
}

В принципе, используя технику работы с двоичными файлами и динамические массивы, можно было бы выполнить динамическую загрузку функций из программных файлов. Однако эта задача является архитектурно зависимой и требует учета особенностей перемещения программного кода и защиты памяти программы в операционной системе.

            11.1.3. Указатель на функцию как средство параметризации алгоритма
Оригинальность и обособленность указателя на функцию заключается в том, что указуемым объектом является не переменная (компонента данных программы), а функция (компонента алгоритма). Но сущность указателя при этом не меняется: если обычный указатель позволяет параметризовать алгоритм обработки данных, то указатель на функцию позволяет параметризовать сам алгоритм. Это значит, что некоторая его часть может быть заранее неизвестна (не определена, произвольна) и будет подключаться к основному алгоритму только в момент его выполнения (динамическое связывание).



Параметризация алгоритма

Для реализации указанного принципа основная функция должна получать необходимый для ее работы «довесок» в виде формального параметра – указателя на функцию. В качестве примера приведем функцию вычисления определенного интеграла, в которой подынтегральная функция (в математическом смысле) передается в виде вычисляющей ее функции (в «программистском» смысле), которая передается формальным параметром - указателем на функцию.

//------Численное интегрирование произвольной функции
double INTEG(double a, double b, int n, double(*pf)(double))
// a,b - границы интегрирования, n - число точек
// pf - подынтегральная функция
{
	double s,h,x;
	for (s=0., x=a, h = (b-a)/n; x <=b; x+=h)
		s += (*pf)(x) * h;
	return s;
}
	extern double sin(double);

	void main()
	{
		printf("sin(0..pi/2)=%lf\n",INTEG(0.,M_PI/2,40,sin));
	}

            11.1.4. Сортировка одной и той же структуры данных по разным критериям
Другой частный пример подобного рода – сортировка одной и той же структуры данных по разным критериям. В массиве структур типа user для задания способа сравнения используется указатель на внешнюю функцию сравнения, которая в качестве параметров получает две ссылки на сравниваемые структуры.

//------Сортировка массива структур по разным критериям
struct user{
     char name[20];
     int account;
     double time;
}     S[]={…};

//-------- Вставка погружением
// cmp - указатель на функцию сравнения двух struct user
void sort(user A[], int (*cmp)(user&,user&)){
	for (int i=1;A[i].name[0]!=0;i++)
		for(int j=i; j>0 && (*cmp)(A[j],A[j-1])<0; j--)	{
			user c=A[j];
			A[j]=A[j-1];	// Обмен элементов массива -
			A[j-1]=c;		// структурированных переменных
		}
}

//--------- функция сравнения по имени
int cmp_name(user &u1, user &u2){
	return strcmp(u1.name,u2.name);
}

//--------- функция сравнения по account
int cmp_account(user &u1, user &u2){
	return u1.account - u2.account;
}

//--------- функция сравнения по time
int cmp_time(user &u1, user &u2){
	return u1.time - u2.time;
}

void main(){
	sort(S,cmp_name);
	sort(S,cmp_account);
	sort(S,cmp_time);
}

Этот пример можно обобщить на случай использования данных любого типа. В Си отсутствует понятие произвольный (неопределенный) тип, но понятие указатель на неопределенный (произвольный) тип существует – это void*. Однако прямое использование этого указателя невозможно. Какой же здесь выход?
Если существуют несколько идентичных структур данных, отличающихся типом хранимых данных, то один и тот же алгоритм будет отличаться только отдельными операциями, касающимися переменных этого типа. Например, при сортировке массива указателей на строки сравнение реализуется выражением вида strcmp(p[i],p[i-1]), а в массиве указателей на целые используется непосредственное сравнение *p[i]<*p[i-1]. Если эту операцию вынести за пределы алгоритма, реализовать отдельной функцией, а указатель на нее передавать в качестве параметра, то мы получим универсальную функцию сортировки массивов указателей на переменные любого типа данных. Можно назвать ее условно (хотя и не совсем точно) итератором.
Типичными итераторами являются:
    • итератор обхода (foreach), выполняющий для каждой переменной в структуре данных указанную функцию;
    • итераторы проверки и поиска по условию (firstthat), возвращающие указатель на первую (последнюю, очередную) переменную, которая удовлетворяет условию, проверяемому в функции;
    • итераторы, работающие на упорядоченных данных, использующие сравнение: сортировка, поиск минимального, двоичный поиск, включение с сохранением порядка.



Структура итератора

Итератор являет собой пример универсализации алгоритма, основанный на разделении «компетенций» между различенными его частями:
    • структура данных, обрабатываемая итератором, содержит в своих элементах указатели на переменные произвольного (неизвестного для итератора) типа void*, но одинакового в каждом экземпляре структуры данных. Структура данных «знает», где хранятся переменные, но «не знает», как их обработать;
    • итератор получает в качестве параметров указатель на структуру данных и указатель на функцию обработки. Эта функция «знает», как обработать переменные, но «не знает», где их взять;
    • итератор выполняет алгоритм обработки структуры данных в соответствии со своим назначением: foreach - обходит все переменные, firstthat - обходит и проверяет все переменные, итератор сортировки -сортирует указатели на хранимые объекты (или соответствующие элементы структуры данных, например, элементы списка);
    • действие, которое надлежит выполнить над хранимыми объектами произвольного типа, реализуется вызовом внешней функции через указатель. Итератор извлекает из структуры данных указатели void* на хранимые данные и передает их внешней функции.
    • прототип (схема формальных параметров и результата) внешней функции различна для разных типов итераторов. Для foreach – указатель имеет вид  void (*pf)(void*), для firstthat – int (*pf)(void*), для итераторов, использующих сравнение – int (*cmp)(void*,void*).

//------------------------------------------------------
//----- Итераторы foreach, firstthat и поиска минимального для списка
struct list {
	list *next;		// Указатель на следующий
	void *pdata; };	// Указатель на данные

//----- Итератор: для каждого элемента списка
void ForEach(list *pv, void (*pf)(void*) ) {
	for (; pv !=NULL; pv = pv->next)
		(*pf)(pv->pdata);
}

//----- Итератор: поиск первого в списке по условию
void *FirstThat(list *pv, int (*pf)(void*)) {
	for (; pv !=NULL; pv = pv->next)
		if ((*pf)(pv->pdata)) return pv ->pdata;
	return NULL;
}

//----- Итератор: поиск минимального в списке
void *FindMin(list *pv, int (*pf)(void* ,void*))
{
	list *pmin;
	for ( pmin=pv; pv !=NULL; pv = pv->next)
		if ((*pf)(pv->pdata ,pmin->pdata) <0) pmin=pv;
	return pmin;
}

//----- Примеры использования итератора ------------------
//----- Функция вывода строки
void print(void *p) { puts((char*)p); }

//----- Функция проверки : длины строки >5
int bigstr(void *p) { return strlen((char*)p ) > 5; }

//----- Функция сравнения строк по длине
int scmp(void *p1, void *p2)
{
	return strlen((char*)p1)- strlen((char*)p2);
}

//----- Вызов итераторов для статического списка,
// содержащего указатели на строки
list a1={NULL,"aaaa"}, a2={&a1,"bbbbbb"}, a3={&a2,"ccccc"}, *PH=&a3;

//----- Итератор сортировки для массива указателей
void Sort(void **pp, int (*pf)(void*,void*))
{
	int i,k;
	do{
		for (k=0,i=1; pp[i] !=NULL; i++)
			if ( (*pf)(pp[i-1],pp[i])>=0)	// вызов функции сравнения
			{
				void *q;					// перестановка указателей
				k++;
				q = pp[i-1];
				pp[i-1] = pp[i];
				pp[i] = q;
			}
	}while(k);
}

// Пример вызова итератора сортировки для массива
// указателей на целые переменные
int cmp_int(void *p1, void *p2)
{ return *(int*)p1-*(int*)p2; }

int b1=5, b2=6, b3=3, b4=2;
void *PP[] = {&b1, &b2, &b3, &b4, NULL};

void main()
{
	 char *pp;
	ForEach(PH,print);
	pp = (char*) FirstThat(PH,bigstr);
	if (pp !=NULL) puts(pp);
	pp = (char*) FindMin(PH,scmp);
	if (pp !=NULL) puts(pp);
	Sort(PP,cmp_int);
	for (int i=0; PP[i]!=NULL;i++)
		printf("%d ",*(int*)PP[i]);
	puts("");
}

        14.15. Массив указателей на функции
Трудно понимать указатели, но указатели понимать нужно. Сам по себе указатель вызывает массу непониманий и массу вопросов, а тут еще массив зачем-то с функциями к нему.
Массив указателей на функции можно использовать в разных целях. Один из вариантов такого использования — это если, к примеру, у вас в коде есть одна куча разных функций, но схожих по смыслу и другая куча разных функций, не похожих на первые функции, но похожих друг на друга. Вот можно похожие функции собрать в массив и потом уже вызывать из массива. Не возьмусь утверждать, но скорее всего так будет проще не запутаться.

#include <iostream>
using namespace std;

void a() {cout<<"This is A";} //функция а
void b() {cout<<"This is B";} //функция b
void c() {cout<<"This is C";} //функция с

int main()
{
	void (*P[3])()={a,b,c}; //Массив из 3-х указателей на функции
	(*P[2])(); //Обращение к элементу массива вызывает функцию
	//cin.get();
	cout<<"\n";
	system("PAUSE");
return 0;
}



Чтобы этот материал лучше окреп в сознании, возьмем еще 1 пример. В этом примере программа будет вести себя в зависимости от того, что выбрал пользователь. Принципиально этот пример вообще ничем не отличается от вышеприведенного, но может помочь понять то, что не получилось понять с первого раза.

#include <iostream>
using namespace std;

void a(int a) {cout<<"Функция a";}
void b(int b) {cout<<"Функция b";}
void c(int c) {cout<<"Функция с";}

int main()
{
	setlocale(LC_ALL,"");
	int my_choose=0;
	void (*P[3])(int)={a,b,c};
	cout<<"Какую из 3 функций выбрать? ";
	cin>>my_choose;
	my_choose--; //После считывания уменьшаем число на 1. Чтобы отсчет был как от единицы

	(*P[my_choose])(my_choose); //Вызываем функцию, обращаясь к индексу массива

	cin.get();
	cin.get();
	return 0;
}



Замечание.
Если (*P[my_choose])(my_choose);
P[my_choose] — выделяет указатель, расположенный в элементе массива с индексом my_choose
* — разыменовывает указатель, чтобы вызвать функцию
(my_choose) — my_choose передается в функцию как аргумент

        14.16. Шаблоны функций в С++. Основные понятия
http://ci-plus-plus-snachala.ru/?p=55

#include <iostream>
#include <stdlib.h>
using namespace std;

template <class T>  //Шаблон функции с одним параметром T

T MyFunc(T a)  //Тип функции MyFunc определяется шаблоном. В функцию принимается один параметр a, тип которого также определяется шаблоном
{
	return a; //Что приняли, то и вернули
}

void main()
{
	system("CLS");
	cout<<MyFunc(10)<<endl; //MyFunc возвращает тип int
	cout<<MyFunc(10.222)<<endl; //MyFunc возвращает тип double
	cout<<MyFunc("HELLO")<<endl; //возвращает тип массив char
	system("PAUSE");
}



Ключевое слово template обозначает Шаблон.
template <class T> обозначает Шаблон функции с одним параметром T

Несложно заметить большое сходство с написанием прототипа обычной функции.
После написания template и указания в угловых скобках всех параметров (В приведенном примере один параметр T) в примере написана функция MyFunc. Вместо явного указания типа, тип для функции и тип для параметра этой функции был указан как тип по шаблону. Для такого указания типа используются имена параметров, указанных в угловых скобках шаблона.
Проще говоря — этот описанный тип T можно изменить на привычный тип (int, double или другой).
Сейчас тот этап когда нужно все четко расставить на свои места и понять, что вместо указания явного типа для описываемой функции были использованы возможности шаблонов С++. Можно сказать, что шаблон функции вытеснил описание типов и встал на их место.
Дальше проще. Функция MyFunc возвращает некоторое значение. Для того, чтоб было максимально просто понять материал,- что функция принимает, то и возвращает, используется только один параметр. Так как функция возвращает один параметр, то и в шаблоне для этой функции должен быть указан один параметр. Если в шаблоне указан один параметр — то и внутри функции по этому шаблону нужен один, если два — то два и т.д.
Теперь остается функция main. Внутри функции main три раза происходит вызов функции MyFunc и каждый раз в нее передается и в ней принимается один параметр. При этом каждый раз этот параметр воспринимается компилятором как параметр некоторого типа, причем типы различны. (Это указано в комментариях кода). Тут как раз немного отображается смысл использования шаблонов. Без шаблонов нужно писать отдельные функции, которым нужно явно задать тип, который они возвращают и в нашем случае — это три отдельные функции с уникальными именами, выполняющие одно и то же с единственным отличием — разница результирующего типа.

Пример.
Используя шаблоны функций сравнить два числа и вернуть большее значение

!!! Этот пример в С++ приводит к ошибке.
#include <iostream>
#include <stdlib.h>
using namespace std;

template <class T>

T max(T a, T b)
{
	if (a>b)
		return a;
	else
		return b;
}

void main()
{
	system("CLS");
	cout << max(12,100)<<endl;
	cout << max(12.33,3.0)<<endl;
	//cout<<max(12.33,3)<<endl; //ОШИБКА
	system("PAUSE");
}

Небольшой код, в функцию max передается два параметра, тип которых при приеме внутри функции определяется шаблоном. В самом шаблоне определяемый тип указан как один параметр. В коде указан момент, который может привести к ошибке. Просто если в самом шаблоне указан один параметр, то такая запись интерпретируется компилятором как «Сколько бы функция не принимала параметров вовнутрь себя, возложив на меня обязанности указания типов, все эти параметры я расценю как однотипные» и, соответственно работайте с ними как с однотипными и не выпендривайтесь.
Решение проблемы в примере. Если нужно, чтоб шаблон обрабатывал параметры как параметры с разными типами, значит нужно внутри шаблона прописать более двух параметров. Это делается через запятую

#include <iostream>
#include <stdlib.h>
using namespace std;

template <class T1, class T2> //Шаблон функции с двумя параметрами

T1 max(T1 a, T2 b) //Функция max, тип функции равен типу первого принимаемого параметра
{
	if (a > b) return a;
	else return b;
}

void main()
{
	system("CLS");
	cout << max(12, 100)<< endl; //Возвращет тип int и равно 100
	cout << max(120.222, 100)<< endl; //Возвращает тип double и равно120.222
	cout << max(10, 55.5555)<< endl; //Возвращает тип int и равно 55

	system("PAUSE");
}

Обратите внимание, что теперь можно выполнить сравнение двух разных типов данных.



В этом коде у невнимательного читателя может возникнуть вопрос: «А почему функция возвращает не 55.5555, а 55» — Ответ прост. Шаблоны функций очень похожи на прототипы функций. В качестве первого параметра вовнутрь функции передается целочисленное значение 10. Это 10 обрабатывается компилятором с помощью шаблона. В  шаблоне для типа первого параметра функции определен параметр Т1 (Он первый внутри угловых скобок). В добавок к этому сама функция max имеет тип, равный типу Т1, поэтому функция возвращает тот тип, который компилятор определяет из первого входного параметра вовнутрь функции.
Изъясняясь короче
        ◦ Из функции main вызывается функция max. В функцию передается 2 параметра
        ◦ Функция max принимает два переданных в нее параметра
        ◦ В функции max для обработки данных происходит некоторый анализ при помощи шаблона
        ◦ В шаблоне указано, что функция имеет два различных параметра, компилятор говорит понял, разберусь
        ◦ Компилятор обработал данные с помощью шаблона и выбрал подходящий тип для каждого из параметров
        ◦ Код написан таким образом, что тип функции max равен типу первого принимаемого параметра

Ко всему этому написанному материалу можно добавить, что можно использовать различного рода локальные переменные, тип которых будет определяться компилятором при помощи  шаблона. (по аналогии с примером типа функции)

#include <iostream>
#include <stdlib.h>
using namespace std;

template <class T>

void Show(T a)
{
	T n; //Переменная n. Тип переменной равен типу параметра а и определяется шаблоном
	n = a; //Присвоение в n значения a
	cout << n << endl; //Что приняли, то и вывели на экран
}

void main()
{
	system("CLS");
	Show(10);
	Show(20.999);
	Show("HELLO");
	system("PAUSE");
}



По факту это то же, что и первый приведенный код. Просто кому-то может понадобиться использовать шаблон таким образом где внутри функции определяется какая-то локальная переменная, тип которой определяется с помощью шаблона или какие-то другие причины.

Замечание.
    • Шаблоны функции позволяют вам объявлять типонезависимые или общие функции
    • Если вы используете функцией только один какой-то тип, нет необходимости применять  шаблон
    • Если параметрам функции требуется несколько различных типов, то  шаблон назначает каждому типу уникальный идентификатор, который компилятор в процессе компиляции обработает как переменную нужного типа

        14.17. Параметры шаблонов функций.
http://ci-plus-plus-snachala.ru/?p=3965
Проблемным моментом в шаблонной функции предыдущего раздела был тип возвращаемого значения. Это просто логическое продолжение того материала.
Для начала листинг кода такой вот несложной функции

#include <iostream>

using namespace std;

template <typename T1, typename T2>  //Шаблон с двумя аргументами
inline T1 max(T1 const& a, T2 const &b){  //Функция с шаблонными аргументами
   if (a>b) return a;
   else return b;
}

int main()
{
   cout << max(10, 66.999);  //Вызов функции
	cout << endl;
	system("PAUSE");
}



Здесь, в принципе, ничего сложного нет. Если знакомы с функциями и передачей в них параметров, то все должно быть понятно. Если еще плохо знаете, то, наверное, рановато сюда попали. В main происходит вызов функции max, в которую передаем 2 значения, причем типы этих значений различны (int и double). Функция принимает эти параметры, как а и b. Принимает она их по ссылке, благодаря чему не создается нутренних локальных копий этих переменных. А указанием const, мы обозначаем, что изменять мы эти значения не намерены. Типы принимаемых параметров, мы оставляем на потом. Т.е. когда нам надо будет вызвать эту функцию, тогда мы и скажем, что подставить в T1 и что подставить в T2.
Этот код имеет 2 недостатка. Первый, наиболее очевидный, в том, что возвращаемое значение из функции max, может принимать оба типа. Какой она тип вернет зависит от порядка передаваемых в нее аргументов.

#include <iostream>
using namespace std;

template <typename T1, typename T2>

inline T1 max(T1 const& a, T2 const &b){
   if ( a > b ) return a;
   else return b;
}

int main(){
   const double N1 = 66.999;
   const int N2 = 54;

   std::cout << (max)(N1,N2) << "\t| " << sizeof(max)(N1,N2) << "\n";  //Вернулся double
   std::cout << (max)(N2,N1) << "\t| " << sizeof(max)(N2,N1) << "\n";  //Вернулся int, после точки самоубилось
	system("PAUSE");
}



Думать о том, в каком порядке передавать аргументе — дело не благодарное. А в ином случае вот такие вот фокусы происходят.
Другая проблема не столь очевидная в том, что Т2 может неявно приводиться к Т1. Если немного подумать, можно легко понять, что функция возвращает тип Т1. А тип Т2 может не совпадать с типом Т1. Что если переменная типа Т2 больше чем переменная типа Т1 ? Возвращать надо Т2, но так типы не совпадают, происходит приведение типа из Т2 в Т1. Для этого приведения внутри функции создается внутренняя локальная переменная. Живет она внутри функции и умирает вместе с завершением работы функции. В свою очередь из-за этого нельзя вернуть результат по ссылке.

#include <iostream>
using namespace std;

template <typename T1, typename T2>
inline T1 const& max(T1 const& a, T2 const &b){
   if (a > b) return a;
   else return b;
}

int main(){
   const double N1 = 66.999;   //
   const int N2 = 54;

  std::cout << (max)(N2,N1)  << "\n";  //T1 == int (54), T2 == double(66.999),  T2>T1 --> Приведение типов --> Сломалось.
  std::cout << (max)(N1,N2)  << "\n";  //T1 == double(66.999), T2 == int(54), T1>T2 --> T1 приводить к T1 бессмысленно, нет приведения, усё ОК.
  system("PAUSE");
}



Такие вот недостатки у такого очевидного способа.
Один из вариантов обхода такого неудобства — это задавать дополнительный параметр вывода в шаблон.

#include <iostream>
using namespace std;

template <typename T1, typename T2, typename RT>  //Добавили третий параметр
inline RT const& max(T1 const& a, T2 const &b){   //Указали, что тип возвращаемого значения - тип третьего параметра
   if (a > b) return a;
   else return b;
}

int main(){
   const double N1 = 66.999;   //
   const int N2 = 54;

//Явно указали типы для шаблонной функции
  std::cout << max<int,double,double>(N2,N1)  << "\n";
  std::cout << max<double,int,double>(N1,N2)  << "\n";
  system("PAUSE");
}



Такой вот способ решения в лоб. Но здесь опять же имеет значение порядок передаваемых типов. Шаг влево, шаг вправо и програма ломается. Немного невнимательности и ищи, свищи проблему.
Просто поменяйте местами типы в угловых скобках.
В общем так делать можно, но это требует особой внимательности и делать так достаточно утомительно.
Такая проблема тоже решаема. Решается она достаточно просто. Достаточно изменить порядок параметров, принятых шаблоном. И все будет намного удобнее.

#include <iostream>
using namespace std;

template <typename RT, typename T1, typename T2>  //RT в начало
inline RT const& max(T1 const& a, T2 const &b){  //Возвращаем тип RT
   if (a>b) return a;
   else return b;
}

int main(){
   const double N1 = 66.999; //
   const int N2 = 54;

  std::cout << max<double>(N2, N1)  << "\n";  //В угловых скобках указываем тип возвращаемого значения
  std::cout << max<double>(N1, N2)  << "\n";
  system("PAUSE");
}



Теперь все заработало. В угловых скобках мы явно указали тип данных, который ожидаем от функции, этот тип данных пришел в RT. Остальные типы пришли в T1 и в T2. Они туда ушли молча. Ушли в том порядке, в котором мы отдаем их вовнутрь функции. Так в первом случае (первой строчке) в T1 ушел тип из переменной N2 (int), в T2 тип N1 (double), а во втором случае T1 из N1(double),T2 из N2(int).
Согласитесь, что это намного удобнее чем думать о порядке типов и изменять весь этот порядок при необходимости.

Замечание.
    • Следует явно задавать все типы, которые нельзя определить неявно
    • В угловых скобках перед именем шаблонной функции указываются параметры шаблона, в круглых скобках после имени шаблонной функции указываются параметры вызова

Это все касается шаблонов функций. В шаблонах классов, например, можно использовать аргументы шаблона по умолчанию.

        14.18. Шаблоны функций. Аргументы по умолчанию
http://ci-plus-plus-snachala.ru/?p=4019
Этот материал показывает маленький фокус с обработкой матриц. До С++11 обработка двумерных и более мерных матриц внутри функций требовала того, чтобы программисты С++ явно указывали саму матрицу и ее размеры. Либо использования двумерного массива как одномерного, либо другого извращенного варианта. Язык С++ развивается и дополняется различными возможностями. С одной стороны это плохо, с другой удобства — это удобства. Поэтому простой прием обработки двумерного статически создаваемого массива внутри функции.
Очень простая задача. Показать двумерный массив на экране при помощи функции.
Вот наш массив

int m[3][3] {{ 1, 2, 3}, {4, 5, 6}, { 8, 9, 10}};

Прошу заметить, что это не массив **, а массив [][], т.е. статически создаваемый. Вот этот массив мы и будем выводить на экран. Начнем с самого простого способа, используя возможности С++11.
Благодаря тому, что количество строк и столбцов в этом массиве одинаковое, можно обработать его с помощью функции очень даже простым способом.

#include <iostream>
using namespace std;

template <const unsigned size = 0>   //Аргумент шаблона по умолчанию, можно int size=0, но const unsigned посолиднее и правильнее.
void foo(const int m[][size])  // Массив сам определит размер в пустых скобках, это как при объявлении массива int Arr[]={1,2,3}; --> Arr знает, что у него 3 элемента
{
	for (int i = 0; i<size; i++){
		for (int j = 0; j<size; j++){
			cout << m[i][j] << "\t";
		}
		cout << "\n";
	}
}

int main() {
	int m[3][3] {{ 1, 2, 3}, { 4, 5, 6 }, { 8, 9, 10 }};  //Инициализация массива значениями
	foo(m);  //Вызов функции, передаем в функцию массив
	system("PAUSE");
}



Из-за того, что размеры строк и колонок одинаковые, нам не нужно дополнительно узнавать сколько там у массива получилось в пустых скобках. Мы ведь итак знаем, что у него число строк и колонок одинаковое. Удивительно, но этот код прекрасно работает благодаря тому, что мы использовали шаблон, в котором указали аргумент по умолчанию.
Но что делать, если массив не такой "ровный", а прямоугольный, где число строк и колонок разнится. То, что массив способен распознать часть своего размера не обозначает, что это сможем сделать мы, да и этот показанный прием даст сбой. Вот пример такого сбоя.

#include <iostream>
using namespace std;

template <const unsigned size1 = 0, const unsigned size2 = 0>
void foo(const int m[][size1])
{
	for (int i = 0; i<size1; i++){
		for (int j = 0; j<size2; j++){
			cout << m[i][j] << "\t";
		}   cout << "\n";
	}
}

int main() {
	int m[3][4] {{ 1, 2, 3, 4}, { 5, 6, 7, 8 }, { 9, 10, 11, 12 }};
	foo(m);
	system("PAUSE");
}



И на экране нет массива! Сбой, прием не работает. Это не сбой, это наша (в текущей ситуации моя) ошибка. Достаточно посмотреть, что получается в size1 и в size2 с помощью cout. (Думаю, это Вы осилите и без моей помощи). Получим массив [0][4]. Когда функция foo инстанирует шаблон, то этот шаблон создаст массив m[0][4], а это совсем не наш [3][4]. Вы же можете создать, например, нулевой массив int Arr[0][0]; А заполнить? Но то только пол беды. А если бы и не ноль строк, узнать число элементов сам массив может и может, а мы вот по идее не можем. Внутри функции получается указатель, а размер указателя — это не размер массива. В первом успешном варианте нас спасло то, что мы знали, что число строк и колонок одинаковое, а сейчас-то нам число строк неизвестно совсем. Но, решение есть и оно, как оказывается, очень даже не сложное. Для наглядности size1 и size2 поменяю на Row и Col соответственно, это не должно Вас смутить.

#include <iostream>
using namespace std;

template <const unsigned Row = 0, const unsigned Col = 0> //Два параметра по умолчанию
void foo(int m[][Col])
{
	for (unsigned i = 0; i<Row; i++){
		for (unsigned j = 0; j<Col; j++){
			cout << m[i][j] << "\t";
		}   cout << "\n";
	}
}

int main() {
	int m[3][4] {{ 1, 2, 3, 4}, { 4, 5, 6, 7 }, { 8, 9, 10, 11 }};
	foo<3>(m);//Заметьте, что мы не указываем число колонок, но можно указать через запятую. Так короче
	system("PAUSE");
}



Несложно же. И это работает. До C++11 компиляторы не захотят компилировать эти коды, но время не стоит на месте. В завершении приведу еще один пример, не знаю насколько он полезен или же бесполезен, но он может оказаться весьма интересным для изучения возможностей языка C++. Вернем ссылку на двумерный массив.

#include <iostream>
//#include <mem.h>
#include <memory.h>

using namespace std;

template <const unsigned Row = 0, const unsigned Col = 0>
const int(&foo(const int m[][Col]))[Row][Col]
{
	static int Arr[Row][Col];  //обязательно static

	for (int i = 0; i<Row; i++){
		for (int j = 0; j<Col; j++){
			Arr[i][j] = m[i][j] * 2;   //Увеличиваем ячейку вдвое
		}
	}

	return Arr;
}

int main() {
	const int Row = 3, Col = 4;
	int K[Row][Col] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };

	memcpy(K, foo<Row>(K), Col * Row * sizeof(K) / sizeof(*K));  //Копируем в К массив, получившийся в функции

	/*выводим массив на экран*/
	for (const auto &i : K){
		for (const auto &j : i){
			cout << j << "\t";
		}
		cout << "\n";
	}
	system("PAUSE");
}



static нужен для того, чтобы по завершению работы функций, массив не самоубился. Вспоминаем о том, что все локальные переменные, созданные внутри функции по завершению функции умирают. А массив — это переменная. Поэтому в этом варианте ключевое слово static очень нам пригодилось.


Дополнительно смотри тему 07_Шаблоны в ОАП


        14.19. Функции округления
Зачастую требуется воспользоваться округленным значением той или иной переменной. C++ предлагает набор функций для решения этой задачи. В зависимости от конкретной ситуации может понадобиться функция, округляющая значение аргумента в большую или меньшую сторону. Рассмотрим наиболее часто используемые варианты вызовов.
Для округления числа в меньшую сторону используется функция floor() и ее разновидности для различных типов аргументов и возвращаемых параметров. Данная функция имеет следующий синтаксис:

double floor(double x);
long double floorl(long double x);

Округление в большую сторону производится с помощью функции ceil():

double ceil(double x);
long double ceil(long double x);

Однако в реальности проблема выбора, в какую же сторону производить округление, возлагается на разрабатываемую программу. Ниже предлагается два варианта решения этой задачи.

Вариант I:

inline double Round(double x)
	{return floor(x +.5);}

Вариант II:

double round(double num)
{
	double frac;
	double val;
	frac = modf(num, val);
	if(frac < 0.5) num = val;
	else num = val + 1.0;
	return num;
}

Для работы обоих вариантов функции необходимо задействовать заголовочный файл math.h, содержащий прототип функций floor() и modf().

        14.20. Компиляция программ, состоящих из двух или более функций.
Простейший способ использования нескольких функций в одной программе заключается в том, чтобы поместить их в один файл, после чего осуществить компиляцию программы, содержащейся в этом файле так, как будто она состояла из одной функции
Второй способ заключается в применении директивы #include Если одна функция содержится в файле с именем filel.c, а вторая в файле file2.c, поместите эту директиву в файл filel.c

#include "file2.с"

Дополнительная информация о директиве #include будет приведена позднее. Другие возможные способы являются в большей степени системнозависимыми Вот некоторые из них
ОС UNIX. Предположим, filel.c и file2.c — два файла, содержащие программные тексты, соответствующие функциям языка Си. В результате выполнения команды

cc filel.c file2.c

будет осуществлена компиляция функций, содержащихся в обоих файлах, и получен файл выполняемого кода с именем a.out. Кроме того, будут созданы два файла с «объектным» кодом — file 1.0 и file2.0. Если позже вы измените текст, содержащийся в файле с именем file1.c, а второй файл оставите без изменений, то сможете осуществить компиляцию первого файла, а затем объединить полученный объектный код с объектным кодом, соответствующим второму файлу, при помощи команды

cc file.c file.0

Компиляторы Lattice С и MICROSOFT С. Выполните раздельную компиляцию функций, содержащихся в файлах filel.c и file2.c; в результате будут получены два файла с объектным кодом — filel.obj и file2.obj. Используйте системный редактор связей для объединения их друг с другом и со стандартным объектным модулем С. obj:

link с file1 file2

Системы, построенные на основе трансляции в ассемблерный код. Некоторые из таких систем позволяют компилировать функции, содержащиеся в нескольких файлах, сразу так же, как в ОС UNIX с помощью команды:

cc fue1.с file2.c

или какого-то ее эквивалента. В некоторых случаях вы можете получить отдельные модули с кодом ассемблера, а затем объединить их, используя процесс ассемблирования.
Резюме. Для создания больших программ вы должны использовать функции в качестве «строительных блоков». Каждая функция должна выполнять одну вполне определенную задачу. Используйте аргументы для передачи значений функции и ключевое слово return для передачи результирующего значения в вызывающую программу. Если возвращаемое функцией значение не принадлежит типу int, вы должны указать тип функции в ее определении и в разделе описаний вызывающей программы. Типичное определение функции имеет следующий вид:

имя (список аргументов)
описание аргументов
тело функции

Пример

diff(x, у) /* имя функции и список аргументов */
int x, у; /* описание аргументов */

{ /* начало тела функции */

	int z; /* описание локальной переменной */
	z = x - у;
	return(z);
} /* конец тела функции */

Наличие списка аргументов и описаний не является обязательным. Переменные, отличные от аргументов, описываются внутри тела, которое заключается в фигурные скобки.
Если вы хотите, чтобы при выполнении функции происходило изменение значений переменных в вызывающей программе, вы должны пользоваться адресами и указателями.

Что вы должны были узнать.
    • Как определять функцию.
    • Как передавать функции информацию: при помощи аргументов.
    • Различие между формальным и фактическим аргументами: первый является переменной, используемой функцией, а второй — значением, поступающим из вызывающей функции.
    • Где необходимо описывать аргументы: после имени функции и перед первой фигурной скобкой.
    • Где необходимо описывать остальные локальные переменные: после первой фигурной скобки.
    • Когда и как использовать оператор return.
    • Когда и как использовать адреса и указатели для доступа к объектам.

Вопросы и ответы.
Вопросы.
    1. Напишите функцию, возвращающую сумму двух целых чисел.
    2. Какие изменения должны были бы произойти с функцией из вопроса 1, если вместо целых складывались бы два числа типа float?
    3. Напишите функцию alter(), которая берет две переменные х и у типа int и заменяет соответственно на их сумму и разность.
    4. Проверьте, все ли правильно в определении функции, приведенной ниже?

salami(num)
{
	int num, count;
	for(count = 1; count <= num; num++ )
		printf("O салями! \n" );
}

Ответы.
    1. 
sum(j,k)
{
	return (j + k);
}

    2. 
float sum(j.k)
float j,k;

Необходимо также привести описание функции float sum() в вызывающей программе.
    3. Поскольку мы хотим изменить две переменные в вызывающей программе, можно воспользоваться адресами и указателями. Обращение к функции будет выглядеть так: alter(&x,&y) Возможное решение имеет следующий вид:

alter(px, py)
int *px, *ру; /* указатели на х и у*/
{
	int sum, diff;
	sura = *px+ *py; /* складывает содержимое двух переменных, определяемых адресами */
	diff = *рх - *ру;
	*рх = sum;
	*ру = diff;
}

    4. Нет; переменная num должна быть описана перед первой фигурной скобкой, а не после нее. Кроме того, выражение num++ необходимо заменить на count++

Упражнения.
    1. Напишите функцию max(х,у), возвращающую большее из двух значений.
    2. Напишите функцию chline(ch.i,j), печатающую запрошенный символ с i-й по j-ю позиции. Смотри программу художник-график, приведенную ранее.

15. Классы памяти.
15.1. «Зоопарк» классов памяти.
15.1.1. Автоматические переменные.
15.1.2. Регистровые переменные.
15.1.3. Статические переменные.
15.1.4. Внешние переменные.
15.1.5. Внешние статические переменные.
15.2. Объявление переменных на внутреннем уровне.
15.3. Объявление переменных на внешнем уровне.
15.4. Переменные класса volatile
15.5. Ключевое слово mutable
15.6. Классы памяти и область действия.
15.6.1. Правила области действия переменной.
15.6.2. Операция уточнения области действия в C++.
15.6.3. Выбор класса памяти.
15.7. Пространства имен
15.8. Функции и классы памяти.
15.8.1. Объявления функций на внешнем уровне.
15.9. Функция получения случайных чисел.
15.10. Игра в кости.
15.11. Функция получения целых чисел: getint().
15.12. Сортировка.

    15. Классы памяти.
Одно из достоинств языка Си состоит в том, что он позволяет управлять ключевыми механизмами программы. Классы памяти языка Си — пример такого управления; они дают возможность определить, с какими функциями связаны какие переменные и как долго переменная сохраняется в программе.
Ранее уже упоминалось о таком важном свойстве переменной, как время жизни. Существует четыре модификатора переменных, определяющих область видимости и время действия переменных. Все они приводятся в таблице 4.1.

Таблица 4.1. Модификаторы переменных

Модификатор
Применение
Область действия
Время жизни
auto
локальное
Блок
временное
register
локальное
Блок
временное
extern
глобальное
Блок
временное
static
локальное
Блок
постоянное

глобальное
Файл

volatile
глобальное
Файл
постоянное

Ниже будет рассмотрен более подробно каждый из приведенных классов памяти.
Программирование, точно так же как написание романа (или даже письма),— это не просто знание языковых правил — это нечто большее. Здесь мы рассмотрим несколько полезных функций. При этом попытаемся привести некоторые соображения, используемые при конструировании функций. В частности, сделаем упор на значение модульного подхода, разбивающего программы на выполнимые задачи. Сначала, однако, обсудим классы памяти.
В C/C++ имеется четыре наиболее распространенных спецификатора классов памяти:
auto
register
static
extern

Класс памяти предшествует объявлению переменной и указывает компилятору способ хранения этой переменной. Объекты, объявленные со спецификаторами auto или register, имеют локальное время жизни, а спецификаторы static или extern указывают на глобальное время жизни.
Эти четыре спецификатора класса памяти кроме класса памяти определяют видимость переменной или функции. Область видимости (иногда определяемая как область действия) относится к той части исходной программы, в которой к переменной или функции можно обращаться по имени. Объект с глобальным временем жизни существует на протяжении всего времени выполнения исходной программы.
Место, где располагается объявление переменной или функции в исходном файле, также влияет на класс памяти и видимость. Объявления, находящиеся вне всех описаний функций, считаются расположенными на внешнем уровне, а объявления, встречающиеся внутри описаний функций, относятся ко внутреннему уровню.
Точный смысл каждого спецификатора класса памяти зависит от двух факторов: от того, на каком уровне расположено объявление — на внешнем или на внутреннем; и от типа объекта — переменная это или функция. 

        15.1. «Зоопарк» классов памяти.

            1.1.1. Автоматические переменные.
Модификатор auto используется при описании локальных переменных. Поскольку для локальных переменных данный модификатор используется по умолчанию, на практике его чаще всего опускают.

#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, "Rus");
	auto int MyVar = 2;
	//то же что int MyVar = 2;
	cout << MyVar;

	getchar(); 	getchar();
	return 0;
}



Модификатор auto применяется только к локальным переменным, которые видны только в блоке, в котором они объявлены. При выходе из блока такие переменные уничтожаются автоматически.
По умолчанию переменные, описанные внутри функции, являются автоматическими. Можно, однако, это подчеркнуть явно с помощью ключевого слова auto:

main()
{
auto int plox;
}

Так поступают, если хотят, например, показать, что определение переменной не нужно искать вне функции.
Автоматические переменные имеют локальную область действия. Только функция, в которой переменная определена, «знает» ее. (Конечно, можно использовать аргументы для связи значения и адреса переменной с другой функцией, однако это частичное и косвенное «знание».) Другие функции могут использовать переменные с тем же самым именем, но это должны быть независимые переменные, находящиеся в разных ячейках памяти.
Автоматическая переменная начинает существовать при вызове Функции, содержащей ее. Когда функция завершает свою работу и возвращает управление туда, откуда ее вызвали, автоматическая переменная исчезает. Ячейка памяти может снова использоваться для чего-нибудь другого.
Следует еще сказать об области действия автоматической переменной: область действия ограничена блоком ({}), в котором переменная описана. Мы всегда должны описывать наши переменные в начале тела функции (блока), так что областью действия их является вся функция. Однако в принципе можно было бы описать переменную внутри подблока. Тогда переменная будет известна только в этой части функции. Обычно при создании программы, программисты редко принимают во внимание упомянутое свойство. Но иногда торопливые программисты пользуются такой возможностью, особенно когда пытаются быстрее внести коррективы.

            1.1.2. Регистровые переменные.
Модификатор register предписывает компилятору попытаться разместить указанную переменную в регистрах процессора. Если такая попытка оканчивается неудачно, переменная ведет себя как локальная переменная типа auto. Размещение переменных в регистрах, оптимизирует программный код по скорости, так как процессор оперирует с переменными, находящимися в регистрах, гораздо быстрее, чем с памятью. Но в связи с тем, что число регистров процессора ограничено, количество таких переменных может быть очень небольшим.

#include <iostream.h>
int main ()
{
	register int REG;
	…
	return 0;
}

Модификатор register применяют только к локальным переменным. Попытка употребления данного модификатора (так же как и модификатора auto) к глобальным переменным вызовет сообщение об ошибке. Переменная существует только в пределах блока, содержащего ее объявление.
Обычно переменные хранятся в памяти машины. К счастью, регистровые переменные запоминаются в регистрах центрального процессора, где доступ к ним и работа с ними выполняются гораздо быстрее, чем в памяти. В остальном регистровые переменные аналогичны автоматическим переменным. Они создаются следующим образом:

main()
{
register int quick;
…
}

Мы сказали «к счастью», потому что описание переменной как регистровой, является скорее просьбой, чем обычным делом. Компилятор должен сравнить ваши требования с количеством доступных регистров, поэтому вы можете и не получить то, что хотите. В этом случае переменная становится простой автоматической переменной.

#include <iostream>	//cout
#include <conio.h>	//_getch();
using namespace std;

int int_pwr(register int m,  register int e);

int main()
{
	int io;
	io=int_pwr(2,30);//возведение 2 в степень 
	cout << "2 is equal to 30 degrees "  << io;
	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

int int_pwr(register int m,  register int e)
{
  register int temp;
  temp = 1;
  for(; e; e--) temp = temp * m;
  return temp;
}




            1.1.3. Статические переменные.
Статические переменные во многом похожи на глобальные переменные. Для описания статических переменных используется модификатор static. Если такая переменная объявлена глобально, то она инициализируется при запуске программы, а ее область видимости совпадает с областью действия и простирается от точки объявления до конца файла. Если же статическая переменная объявлена внутри функции или блока, то она инициализируется при первом входе в соответствующую функцию или блок. Значение переменной сохраняется от одного вызова функции до другого. Таким образом, статические переменные можно использовать для хранения значений переменных на протяжении времени работы программы.
Замечание.
1) Статические переменные не могут быть объявлены в других файлах как внешние.
2) Если статическая переменная не проинициализирована явным образом, то, как и глобальная переменная, она инициализируется значением 0.
В качестве примера рассмотрим реализацию счетчика вызовов некоторой функции:

#include <iostream>
using namespace std;

int Count(void);

int main()
{
	int result;
	for(int i= 0; i< 30; i++)
		result = Count();
	cout << result;

	getchar(); 	getchar();
	return 0;
}

int Count (void)
{
	static short counter = 0;
	counter++;
	//...
	return counter;
}



Здесь главная функция в цикле (30 paз подряд) вызывает функцию Count (), которая содержит статическую переменную counter. Как видно из примера, начальная инициализация этой переменной нулем выполнится только один раз, при первом вхождении в тело функции. Поскольку значение переменной сохраняется между вызовами функции, на печать будет выведено число 30.
Название раздела не следует понимать буквально, т. е. считать, что такие переменные не могут изменяться. В действительности слово «статические» здесь означает, что переменные остаются в работе. Они имеют такую же область действия, как автоматические переменные, но они не исчезают, когда содержащая их функция закончит свою работу. Компилятор хранит их значения от одного вызова функции до другого. Следующий пример иллюстрирует это и показывает, как описать статическую переменную.

#include<stdio.h>
trystat()
{
	int fade = 1;
	static int stay = 1;
	printf(" fade = %d and stay = %d\n", fade++, stay++);
}

main()
{
	int count;
	for (count = 1; count <= 3; count++)
		{
		printf("Iteration %d:\n" , count);
		trystat();
		}
}

Результаты работы программы



Заметим, что функция trystat() увеличивает каждую переменную после печати ее значения. 
Статическая переменная stay «помнит», что ее значение было увеличено на 1, в то время как для переменной fade начальное значение устанавливается каждый раз заново. Это указывает на разницу в инициализации: fade инициализируется каждый раз, когда вызывается trystat(), в то время как stay инициализируется только один раз при компиляции функции trystat().

            1.1.4. Внешние переменные.
Эта программа состоит из нескольких модулей, некоторые переменные могут использоваться для передачи значений из одного файла в другой. При этом некоторая переменная объявляется глобальной в одном модуле, а в других файлах, в которых она должна быть видима, производится ее объявление с использованием модификатора extern. Если объявление внешней переменной производится в блоке, она является локальной.
В отличие от предыдущих, этот модификатор сообщает, что первоначальное объявление переменной производится в каком-то другом файле. Рассмотрим пример использования внешней переменной:

// файл myheader.h
void ChangeFlag(void);

// файл myfunction.cpp
extern bool Flag;
void ChangeFlag(void)
{
	Flag = !Flag;
}

#include "myheader.h"
#include <iostream>
using namespace std;

extern bool Flag;

int main()
{
	setlocale(LC_ALL, "Rus");
	ChangeFlag();
	if(Flag)
		cout << "Сейчас TRUE\n";
	else
		cout << "Сейчас FALSE\n";

	getchar(); 	getchar();
	return 0;
}



Сначала в файле myheader.h объявляется функция ChangeFlag(). Далее в файле myfunction.cpp следует объявление глобальной логической переменной Flag и определяется реализация тела функции ChangeFlag() и наконец в главном модуле подключается заголовочный файл myheader.h и переменная Flag описывается как внешняя (extern). Поскольку описание функции ChangeFlag() включается в главный модуль директивой #include "myheader.h", данная функция доступна в теле функции main().
Переменная, описанная вне функции, является внешней. Внешнюю переменную можно также описать в функции, которая использует ее, при помощи ключевого слова extern. Описания могут выглядеть примерно так:

int errupt; /* Три переменные, описанные вне функции */
char coal;
double up;
main()
{
	extern int errupt; /* объявлено, что З переменные */
	extern char coal; /* являются внешними */
	extern double up;

Группу extern-описаний можно совсем опустить, если исходные определения переменных появляются в том же файле и перед функцией, которая их использует. Включение ключевого слова extern позволяет функции использовать внешнюю переменную, даже если она определяется позже в этом или другом файле. (Оба файла, конечно, должны быть скомпилированы, связаны или собраны в одно и то же время.)
Если слово extern не включено в описание внутри функции, то под этим именем создается новая автоматическая переменная. Вы можете пометить вторую переменную как «автоматическую» с помощью слова auto и тем самым показать, что это ваше намерение, а не оплошность.
Три примера демонстрируют четыре возможных комбинации описаний:

/* Пример1 */
int hocus;
main()
{
	extern int hocus; /* hocus описана внешней */
	...
}

magic()
{
	extern int hocus;
	...
}

Здесь есть одна внешняя переменная hocus, и она известна обеим функциям main() и magic().

/* Пример2 */
int hocus;
main()
{
	extern int hocus; /* hocus описана внешней */
	…
}

magic()
{
	/* hocus не описана совсем */
	...
}

Снова есть одна внешняя переменная hocus, известная обеим функциям. На этот раз она известна функции magic() по умолчанию.

/* ПримерЗ */
int hocus;
main()
{
	int hocus; /* hocus описана и является автоматической по умолчанию */
	...
}

magic()
{
	auto int hocus; /* hocus описана автоматической */
	...
}

В этом примере созданы три разные переменные с одинаковым именем. Переменная hocus в функции main() является автоматической по умолчанию и локальной для main(), в функции magic() она явно описана автоматической и известна только для magic(). Внешняя переменная hocus не известна ни main(), ни magic(), но обычно известна любой другой функции в файле, которая не имеет своей собственной локальной переменной hocus.
Эти примеры иллюстрируют область действия внешних переменных. Они существуют, пока работает программа, и так как эти переменные доступны любой функции, они не исчезнут, если какая-нибудь одна функция закончит свою работу.

            1.1.5. Внешние статические переменные.
Вы можете также описать статические переменные вне любой функции. Это создаст «внешнюю статическую» переменную. Разница между внешней переменной и внешней статической переменной заключается в области их действия. Обычная внешняя переменная может использоваться функциями в любом файле, в то время как внешняя статическая переменная может использоваться только функциями того же самого файла, причем после определения переменной. Вы описываете внешнюю статическую переменную, располагая ее определение вне любой функции.

static randx = 1;
rand()
{
…
…
}

        15.2. Объявление переменных на внутреннем уровне.
Любой из четырех спецификаторов класса памяти можно использовать для объявления переменных на внутреннем уровне. (По умолчанию используется auto.) Спецификатор auto объявляет переменную с локальным временем жизни. Она видна только в том блоке, в котором описана, и может иметь инициирующее значение.
Спецификатор класса памяти register указывает компилятору на необходимость размещения переменной в регистре (если это возможно). При использовании этого спецификатора увеличивается скорость доступа и уменьшается размер кода программы. Видимость переменной такая же, как при использовании спецификатора auto. Если компилятор встречает объявление register, но отсутствуют доступные регистры, переменной назначается класс памяти auto и она запоминается в оперативной памяти.
В ANSI С нельзя использовать адрес объекта типа register. Это ограничение, однако, не распространяется на C++. Если используется операция определения адреса (&) вместе с регистровой переменной в C++, компилятор помещает ее в оперативной памяти, так как он должен сохранить переменную в таком месте, которое имеет действительный адрес.
Переменная, объявленная на внутреннем уровне со спецификатором класса памяти static, имеет глобальное время жизни, но видима только в том блоке, в котором она объявлена. В отличие от переменных auto, переменные static сохраняют свои значения при выходе из блока. Можно инициализировать переменную static при помощи констант. По умолчанию начальное значение — ноль.
Переменная, объявленная со спецификатором класса памяти extern, является ссылкой на переменную с таким же именем, описанную на внешнем уровне в любом исходном файле программы. Внутреннее объявление extern используется для того, чтобы сделать видимым внутри блока описание переменной, сделанное на внешнем уровне. Это демонстрируется в следующей программе:

#include<stdio.h>
#include<iostream.h>
int ivalue1=1;
void function_a(void)
{
	// запоминается адрес глобальной переменной ivalue1;
	static int *pivalue1= &ivalue1;
	// создается новая локальная переменная ivalue1; при этом глобальная
	// переменная ivalue1 становится недоступной
	int ivalue1 = 32;
	// новая локальная переменная ivalue2
	// видима только внутри функции function_a
	static int ivalue2 = 2;
		ivalue2 += 2;
		// печатаются числа 32, 4 и 1:
	cout << " "<<ivalue1<<" " << ivalue2<< " "<< *pivalue1;
}

main ()
{
// обращается к переменной ivalue1, описанной выше
	extern int ivalue1;
//по умолчанию — начальное значение = 0, переменная ivalue2
// видима только в main()

	static int ivalue2;
	// запоминается в регистре (по возможности),
	// начальное значение = 0

	register int rvalue = 0;
	//по умолчанию - класс памяти auto, переменная int_value3
	//получает начальное значение 0
	int int_value3 = 0;
	// печатаются числа 1, 0, 0, 0:
	cout << ivalue1 <<" "<< rvalue <<" "<<ivalue2 <<" "<< int_value3;
		function_a() ;
}

Результаты работы программы:



Поскольку ivalue1 переопределяется в function_a(), доступ к глобальной переменной ivalue1 запрещен. Однако, при помощи указателя pivalue1 получен адрес глобальной переменной ivalue1 для печати хранящегося в ней значения.

        15.3. Объявление переменных на внешнем уровне.
В объявлении переменных на внешнем уровне можно использовать только класс памяти static или extern (auto или register использовать нельзя). Это могут быть либо описания переменных, либо ссылки на переменные, описанные в другом месте. Внешнее объявление переменной, инициализирующее переменную (неявно или явно), является объявлением-описанием:

static int ivalue1; // по умолчанию подразумевается 0
static int ivalue1 = 10 // явная инициализация
int ivalue2 =20; // явная инициализация

Если переменная описывается на внешнем уровне, она видима в оставшейся части того исходного файла, в котором она объявлена, и не видима в этом файле до точки ее описания. Кроме того, она не видима в других исходных файлах программы, если ее видимость не обеспечена ссылочным объявлением.
Внутри исходного файла можно только один раз описать переменную на внешнем уровне. Если использовать спецификатор класса памяти static, в другом исходном файле можно описать еще одну переменную с таким же именем и спецификатором static. Поскольку каждое статическое описание видимо только в соответствующем исходном файле, конфликтов не будет. При помощи спецификатора extern объявляется ссылка на переменную, которая описана в другом месте. Объявление external можно использовать для обеспечения видимости описания из другого файла или для того, чтобы расширить видимость переменной в том же самом файле. Переменная видима на протяжении оставшейся части того исходного файла, в котором находится объявленная ссылка.
Для того чтобы внешняя ссылка была действительной, связанная с ней переменная должна быть объявлена только один раз на внешнем уровне. Описание может располагаться в любом исходном файле программы. Следующая программа на C++ иллюстрирует использование ключевого слова extern:

//Исходный файл А
#include <iostream>	//cout
#include <conio.h>	//_getch();
using namespace std;

void function_a(void);
void function_b(void);

int ivalue = 10;	// действительное описание переменной
					// ivalue
int main()
{
	ivalue++;	// используется объявление extern, приведенное выше
	cout << ivalue << "\n";	// печатается 11
	function_a();
	_getch();
	return(0);
}

extern int ivalue;	// переменная ivalue определяется видимой

void function_a(void)
{
	ivalue++;	// обращение к ivalue
	cout << ivalue << "\n";		// печатается 12
	function_b();
}


//
//Исходный файл В
//
#include <iostream>	//cout
using namespace std;

extern int ivalue;	// ссылка на переменную ivalue,
					// объявленную в Исходном файле А
void function_b(void)
{
	ivalue++;
	cout << ivalue;	// печатается 13
}

        15.4. Переменные класса volatile
В тех случаях, когда необходимо предусмотреть возможность модификации переменной периферийным устройством или другой программой, используют модификатор volatile. В связи с этим компилятор не пытается оптимизировать программу путем размещения переменной в регистрах.
Пример объявления таких переменных приведен ниже:

volatile short sTest;
volatile const int vciTest;

Как видно из примера, переменная vciTest с модификатором volatile в то же время может быть объявлена как константа. В этом случае ее значение не сможет меняться в разрабатываемой программе, но может модифицироваться в зависимости от внешних факторов.

Указывая volatile при объявлении переменной, программист просит компилятор не оптимизировать эту переменную.
Компилятор скорее всего оптимизирует код вроде такого, если переменная cancel не менялась в теле цикла.

bool cancel = false;
while( !cancel ) {
    ;
}

Если cancel не меняется, то ее и проверять каждый раз незачем, компилятор и не будет ее проверять.
Зато если вы укажете перед переменной volatile, то оптимизиации не будет. Предполагается, что переменная cancel могла измениться каким-то волшебным образом.

volatile bool cancel = false;
while( !cancel ) {
  ;
}

Каким волшебным образом? Из другого потока? Но обеспечивать доступ к переменным из разных потоков с помощью volatile не есть хорошо. Потому что переменную надо проверять (лочить) при считывании и записи. Чтобы не получилось, например, такой ситуации: один поток пишет в переменную, другой в этот же момент считывает и считает наполовину старое значение, наполовину новое, короче не пойми что получится.
Чисто теоретически указания volatile при работе с потоками достаточно, если тип данных, с которым идет работа, может быть записан на данной архитектуре атомарно, в один прием. Соответственно, надо точно знать к каким именно типам это относится. Казалось бы уж что-что, так bool должен писаться в один прием. Но на некоторых Windows'ах это вовсе даже и не так. И атомарность присутствует только при работе с char...
Несмотря ни на что, volatile таки используется для доступа к переменной из разных потоков.
Итак, volatile в языке Си - это квалификатор переменной, говорящий компилятору, что значение переменной может быть изменено в любой момент и что часть кода, которая производит над этой переменной какие-то действия (чтение или запись), не должна быть оптимизирована.

Есть три основных типа ошибок, касающихся квалификатора volatile:
    • неиспользование volatile там, где нужно
обычно совершается программистами, которые не знают про существование volatile, или видели, но не понимают, что это такое;
    • использование volatile там, где нужно, но не так, как нужно
присуща программистам, знающим, насколько важен volatile при программировании параллельных процессов или при доступе к периферийным регистрам, но не учитывающие некоторые его нюансы;
    • использование volatile там, где не нужно (бывает и такое)
такое делают те, кто однажды обжегся на первых двух ошибках. Это не ошибка и она не приведет к неправильному поведению программы, но создаст свои неприятности.

Замечание.
Полезным для подробностей будет сайт:
    1) http://www.quizful.net/post/cpp-keywords-usage
    2) http://we.easyelectronics.ru/Soft/skolzkaya-dorozhka-dlya-poklonnikov-volatile.html

Пример несоответствующего кода

В этом примере несовместимого кода доступ к volatile объекту осуществляется с помощью ссылки, не зависящей от volatile, что приводит к неопределенному поведению:

#include <iostream>
using namespace std;

void func(void) {
  static volatile int **ipp;
  static int *ip;
  static volatile int i = 0;

  printf("i = %d.\n", i);

  ipp = &ip; /* Может выдавать warning диагностику */
  ipp = (int**) &ip; /* Нарушение ограничений; Может выдавать warning диагностику */
  *ipp = &i; /* обоснованный */
  if (*ip != 0) { /* обоснованный */
    /* ... */
  }
}

//void func(void) {
//  static volatile int **ipp;
//  static volatile int *ip;
//  static volatile int i = 0;
//
//  printf("i = %d.\n", i);
// 
//  ipp = &ip;
//  *ipp = &i;
//  if (*ip != 0) {
//    /* ... */
//  }
//}

int main () {
    func();
    system("PAUSE");
    return 0;
}



Назначение ipp = &ip небезопасно, потому что оно позволяет действительному следующему коду ссылаться на значение изменчивого объекта i через невостребованную ссылку ip. В этом примере компилятор может оптимизировать весь блок if, потому что *ip! = 0 должен быть ложным, если объект, на который указывает ip, не является изменчивым.

Удовлетворительное решение

В этом совместимом решении ip объявляется volatile:

#include <iostream>
using namespace std;

//void func(void) {
//  static volatile int **ipp;
//  static int *ip;
//  static volatile int i = 0;
// 
//  printf("i = %d.\n", i);
// 
//  ipp = &ip; /* Может выдавать warning диагностику */
//  ipp = (int**) &ip; /* Нарушение ограничений; Может выдавать warning диагностику*/
//  *ipp = &i; /* обоснованный */
//  if (*ip != 0) { /* обоснованный */
//    /* ... */
//  }
//}

void func(void) {
  static volatile int **ipp;
  static volatile int *ip;
  static volatile int i = 0;
 
  printf("i = %d.\n", i);

  ipp = &ip;
  *ipp = &i;
  if (*ip != 0) {
    /* ... */
  }
}

int main () {
    func();
    system("PAUSE");
    return 0;
}




        15.5. Ключевое слово mutable
Иногда есть необходимость изменить некий объект внутри класса, гарантируя неприкосновенность остальных элементов. Неприкосновенность можно гарантировать при помощи const, однако const запрещает изменение всего.

class Exm
{
    int a;
    int b;
public:
    int getA() const
    {
        return a; // все правильно
    }
    int setA(int i) const
    {
        a = i;// ошибка доступа
    }
}

Помочь в данном случае может определение переменной а с ключевым словом mutable. Внесём исправление в приведённый чуть выше пример:

class Exm
{
    mutable int a; // добавили в объявление ключевое слово mutable
    // позволяющие игнорировать модификатор const
    // по отношению к данной переменной
    int b;
public:
    int getA() const //
    {
        return a; // все правильно
    }
    int setA(int i) const
    {
        a = i;// теперь всё правильно. Мы можем изменять переменную а
        b = i; // Ошибка! Переменная b  по прежнему не доступна для изменения.
    }
}

Пример.
Предположим, вы идете в гостиницу, и вы отдаете приказ официанту принести немного блюд. После подачи заказа вы вдруг решите изменить порядок питания. Предположим, что отель предоставляет возможность изменить заказанную пищу и снова принять заказ новой еды в течение 10 минут после подачи 1-го порядка. Через 10 минут заказ не может быть отменен, и старый заказ не может быть заменен новым заказом. Смотри код.

#include <iostream>
#include <string.h>
using std::cout;
using std::endl;

class Customer
{
    char name[25];
    mutable char placedorder[50];
    int tableno;
    mutable int bill;
public:
    Customer(char* s, char* m, int a, int p)
    {
        strcpy(name, s);
        strcpy(placedorder, m);
        tableno = a;
        bill = p;
    }
    void changePlacedOrder(char* p) const
    {
        strcpy(placedorder, p);
    }
    void changeBill(int s) const
    {
        bill = s;
    }
    void display() const
    {
        cout << "Customer name is: " << name << endl;
        cout << "Food ordered by customer is: " << placedorder << endl;
        cout << "table no is: " << tableno << endl;
        cout << "Total payable amount: " << bill << endl;
    }
};
 
int main()
{
    const Customer c1("Pravasi Meet", "Ice Cream", 3, 100);
    c1.display();
    c1.changePlacedOrder("GulabJammuns");
    c1.changeBill(150);
    c1.display();

    cout << "\n";
    system("PAUSE");
    return 0;
}



Внимательно наблюдайте вывод вышеприведенной программы. Значения элементов locationorder и элементов счета изменяются из функции const, потому что они объявлены как изменяемые.
Ключевое слово mutable в основном используется, чтобы разрешить конкретный член данных объекта const быть модифицированным. Когда мы объявляем функцию as const, этот указатель, переданный функции, становится const. Добавление измененного в переменную позволяет указателю const изменять члены.
mutable особенно полезен, если большинство членов должны быть постоянными, но некоторые должны быть обновляемыми. Члены данных, объявленные как изменяемые, могут быть изменены, даже если они являются частью объекта, объявленного как const. Вы не можете использовать изменяемый спецификатор с именами, объявленными как static или const, или ссылкой.

Как упражнение предсказывает выход следующих двух программ

// PROGRAM 1
#include <iostream>
using std::cout;
 
class Test {
public:
  int x;
  mutable int y;
  Test() { x = 4; y = 10; }
};

int main()
{
    const Test t1;
    t1.y = 20;
    cout << t1.y;

    cout << "\n";
    system("PAUSE");
    return 0;
}



// PROGRAM 2
#include <iostream>
using std::cout;
 
class Test {
public:
  int x;
  mutable int y;
  Test() { x = 4; y = 10; }
};
int main()
{
    const Test t1;
    t1.x = 8;
    cout << t1.x;

    cout << "\n";
    system("PAUSE");
    return 0;
}




mutable показывает, что член класса является изменяемым, и его можно изменять в функциях, у которых указан модификатор const, а также у константных объектов.
Следующий пример полностью рабочий :

#include <iostream>
using std::cout;
struct foo
{
    foo () : a(0) {} //инициализация a=0
    void change () const { a++; }
    mutable int a;
};

int main ()
{
    const foo f;
    f.change();
    f.a = 100;
    cout << f.a;

	cout << "\n";
	system("PAUSE");
	return 0;
}



Это ключевое слово может использоваться в классах, где, например, есть кэш, который может потребоваться обновлять в каждой функции вне зависимости от требования константности объекта. Еще пример - при ленивой инициализации данных класса(сигнализирующий флаг будет изменяемым, mutable).

        15.6. Классы памяти и область действия.
Мы уже упоминали раньше, что локальные переменные известны только функциям, содержащим их. В языке Си предполагается также, что о глобальных переменных «знают» сразу несколько функций. Предположим, например, что и main(), и critic() имеют доступ к переменной units. Это будет иметь место, если отнести units к «внешнему» классу памяти, как показано ниже:

#include<stdio.h>
#include<iostream.h>
int units; /* внешняя переменная */
critic()
{
	extern int units;
	printf (" You haven't good luck. Try again\n");
	//Тебе не везет, попробуй еще
	scanf (" %d", &units);
}
main()
{
	extern int units;
	printf (" How much pounds of butter is on a barrel?\n");
	//Сколько фунтов масла в бочонке?
	scanf (" %d", &units);
	while (units != 56)
		critic();
	printf(" You must looking through the directory \n");
	//Вы должны посмотреть в справочнике
}

Результаты работы программы



Мы сделали это. Обратите внимание, что второе значение units было прочитано функцией critic(), однако main() также «узнала» это новое значение, когда оно вышло из цикла while.
Мы сделали переменную units внешней, описав ее вне любого определения функции. Далее, внутри функций, использующих эту переменную, мы объявляем ее внешней при помощи ключевого слова extern, предшествующего спецификации типа переменной. Слово extern предлагает компьютеру искать определение этой переменной вне функции. Если бы мы опустили ключевое слово extern в функции critic(), то компилятор создал бы в функции critic новую переменную и тоже назвал бы ее units. Тогда другая переменная units() [которая находится в main()] никогда не получила бы нового значения.
Каждая переменная, как мы знаем, имеет тип. Кроме того, каждая переменная принадлежит к некоторому классу памяти. Есть четыре ключевых слова, используемые для описания классов памяти: extern (для внешнего), auto (для автоматического, static и register. До сих пор мы не обращали внимание на классы памяти, так как переменные, описанные внутри функции, считались относящимися к классу auto, если они не описывались иначе (по умолчанию они относились к классу auto).
Определение класса памяти переменной зависит от того, где переменная описана и какое ключевое слово (если оно есть) используется.
Класс памяти позволяет установить два факта. Во-первых, определить, какие функции имеют доступ к переменной. (Пределы, до которых переменная доступна, характеризуют ее «область действия».) Во-вторых, определить, как долго переменная находится в памяти. Теперь перейдем к свойствам каждого типа.

            1.1.6. Правила области действия переменной.
Для рассмотрения предлагается четыре правила видимости переменной, называемых также правилами области действия. Четыре области действия для переменной следующие: блок, функция, файл и программа. Переменная, объявленная внутри блока или функции известна только в этом блоке и функции. Правила области действия для переменных, используемых с функциями, в С и C++ аналогичны. Переменная, объявленная внешней по отношению к функции, известна в том файле, в котором она описана, начиная с момента объявления и до конца файла. Переменная, объявленная на внешнем уровне в одном исходном файле и объявленная как внешняя в других файлах, имеет в качестве области действия всю программу.



            1.1.7. Операция уточнения области действия в C++.
Область действия переменной, если она используется в функции, относится к диапазону, где эта переменная доступна. Правила области действия для переменных, используемых с функциями, в С и C++ аналогичны. Переменные могут иметь следующие области действия: локальную, файловую или внутри класса.
Локальную переменную можно использовать в описании функции. Тогда ее область действия ограничена этой функцией. Эта переменная считается доступной или видимой только внутри функции и имеет локальную область действия.
Переменные с областью действия внутри файла объявляются вне отдельных функций или классов. Эти переменный доступны или видимы во всем файле, где они объявлены и являются глобальными.
Можно задать переменную с областью действия внутри файла, а затем включить ее в описание функции, сделав область ее действия локальной. В этом случае локальная область действия имеет приоритет над файловой. В C++ имеется новое программное средство, называемое операцией уточнения области действия (::). Когда используется эта операция, выполняется обращение не к локальной переменной, а к переменной с областью действия внутри всего файла. Тогда переменная становится глобальной. Синтаксис обращения к глобальной переменной следующий:

::yourvariable

Пример (рассматривался в теме функции):

#include <iostream>	//cout
#include <conio.h>	//_getch();
using namespace std;

int iproduct(int iw,int ix);
int in=10;

int main()
{
	int il=3;
	int im=7;
	int io;
	io=iproduct(il,im);
	cout << "The product of " << il <<" * " << im
		<< " * " << in << " is: " << io;
	printf ("\n\nPress any key to finish\n");
	_getch();
	return(0);
}

int iproduct(int iw,int ix)
{
	int iy;
	int in=2;
	iy=iw*ix*(::in); //iy=iw*ix*(in);
	return(iy);
}



Операцию уточнения области действия не обязательно заключать в круглые скобки — они использованы в этом примере только для выделения операции. Теперь при вычислениях используется глобальная переменная с файловой областью действия. При выводе результата на экран вы увидите значение 3 * 7 * 10 = 210.
Операция уточнения области действия очень важна в C++. Правила области действия для переменных обуславливают появление своеобразных программных ошибок. Дополнительные примеры применения этой операции приводятся в последующем изложении материала.

            1.1.8. Выбор класса памяти.
Ответ на вопрос почти всегда один — «автоматический». В конце концов, почему этот класс памяти выбран по умолчанию? Мы знаем, что на первый взгляд использование внешних переменных очень соблазнительно. Опишите все ваши переменные как внешние, и у вас никогда не будет забот при использовании аргументов и указателей для связи между функциями в прямом и обратном направлениях. К сожалению, у вас возникнет проблема с функцией С, коварно изменяющей переменные в функции А, а это совсем не входит в ваши интересы. Неоспоримый совокупный опыт использования машин, накопленный в течение многих лет, свидетельствует о том, что такая проблема значительно перевешивает кажущуюся привлекательность широкого использования внешних переменных.
Одно из золотых правил защитного программирования заключается в соблюдении принципа «необходимо знать только то, что нужно». Организуйте работу каждой функции автономно, насколько это возможно, и используйте глобальные переменные только тогда, когда это действительно необходимо.
Иногда полезны и другие классы памяти. Но прежде чем их использовать, спросите себя, необходимо ли это.
Резюме: Классы памяти
Ключевые слова auto, extern, static, register
Общие замечания
Класс памяти определяет область действия переменной и продолжительность ее существования в памяти. Класс памяти устанавливается при описании переменной с соответствующим ключевым словом. Переменные, определенные вне функции, являются внешними и имеют глобальную область действия. Переменные, определенные внутри функции, являются автоматическими и локальными, если только не используются другие ключевые слова. Внешние переменные, определенные раньше функции, доступны ей, даже если не описаны внутри ее.
Свойства

КЛАСС
ПАМЯТИ
КЛЮЧЕВОЕ
СЛОВО
ПРОДОЛЖИТЕЛЬНОСТЬ
СУЩЕСТВОВАНИЯ
ОБЛАСТЬ
ДЕЙСТВИЯ
Автоматический
Регистровый
Статический
auto
register
static
Временно
Временно
Постоянно
Локальная
Локальная
Локальная
Внешний
Внешний статический
extern
static
Постоянно
Постоянно
Глобальная (все файлы)
Глобальная (один файл)

Классы памяти, перечисленные выше пунктирной линии, описываются внутри функции. Классы памяти, перечисленные ниже этой линии, определяются вне функции.
Теперь рассмотрим функцию, использующую внешнюю статическую переменную.

        15.7. Пространства имен
Определения функций и переменных в заголовочных файлах неразрывно связаны с понятием пространства имен. Это понятие появилось сравнительно недавно. До введения понятия пространства все объявления идентификаторов и констант, сделанные в заголовочном файле, помещались компилятором в глобальное пространство имен. Такое положение вещей приводило к возникновению массы конфликтов, связанных с использованием различными объектами одинаковых имен. Чаще всего недоразумения возникали, когда в одной программе использовались библиотеки, разработанные различными производителями. Введение понятия пространства имен позволило значительно снизить количество подобных конфликтов имен. Когда в программу включается заголовок нового стиля, его содержимое помещается не в глобальное пространство имен, а в пространство имен std. Если в программе требуется определить некоторые идентификаторы, которые, как Вы подозреваете, могут переопределить уже имеющиеся, просто заведите свое собственное, новое пространство имен. Это достигается путем использования ключевого слова namespace:

namespace _имя_пространства_
{
// объявления
…
}

Таким образом, объявления внутри нового пространства имен будут находится только внутри видимости определенного имени _пространства_имён, предотвращая тем самым возникновение конфликтов. В качестве примера создадим следующее пространство имен:

namеspace NewNameSpace
{
int x, у, z;
void SomeFunction(char smb);
}

Для того чтобы указать компилятору, что следует использовать имена из конкретного именного пространства (в данном случае из NewNameSpace), можно воспользоваться операцией разрешения видимости:

NewNameSpace::х = 5;

Однако, если в программе обращения к собственному пространству имен производятся довольно часто, такой синтаксис вызывает определенные неудобства. В качестве альтернативы можно воспользоваться инструкцией using, синтаксис которой имеет две формы:

using namespace имя_пространства имен;

или

using имя_пространства_имен::идентификатор;

При использовании первой формы компилятору сообщается, что в дальнейшем необходимо использовать идентификаторы из указанного именного пространства вплоть до того момента, пока не встретится следующая инструкция using. Например, указав в теле программы

using namespace NewNameSpace;

можно напрямую работать с соответствующими идентификаторами:

х=0; y=z=4;
SomeFunction('А');

На практике часто после включения в программу заголовков явно указывается использование идентификаторов стандартного пространства имен:

using namespace std;

Вторая форма записи предписывает компилятору использовать указанное пространство имен лишь для конкретного идентификатора. Таким образом, определив

using namespace std;
using NewNameSpace::z;

можно использовать идентификаторы стандартной библиотеки C++ и целочисленную переменную z из пространства имен NewNameSpace без использования операции разрешения видимости:

z=12;

Следует понимать, что указание нового пространства имен инструкцией using namespace отменяет видимость стандартного пространства std, поэтому для получения доступа к соответствующим идентификаторам из std потребуется каждый раз использовать операцию разрешения видимости std::.
Пространства имен не могут быть объявлены внутри тела какой-либо функции, однако могут объявляться внутри других пространств. При этом для доступа к идентификатору внутреннего пространства необходимо указать имена всех вышестоящих именованных пространств. Например, объявлено следующее пространство имен:

namespace Highest
	{
		namespace Middle
			{
				Namespace Lowest
					{
						int nAttr;
					}
			}
	}

Использование объявленной переменной nAttr будет выглядеть:

Highest :: Middle:: Lowest:: nAttr = 0;

Допускается объявление нескольких именованных пространств с одним и тем же именем, что позволяет разделить его на несколько файлов. Несмотря на это, содержимое всех частей будет храниться в одном и том же пространстве имен.
Чтобы объявления переменных и функций в некотором пространстве имен были более упорядоченными, рекомендуется в пределах описания пространства имен объявлять только прототипы функций, помещая определение тела функции отдельно. При этом следует явно указывать, к какому пространству имен относится функция:

namespace Nspace
{
	char с;
	int i;
	void Fund (char Flag);
}

void Nspace::Fund(char Flag)
{
	// тело функции
	…
}

Кроме вышесказанного, допускается объявление неименованных пространств имен. В этом случае просто опускается имя пространства после ключевого слова namespace. Например:

namespace
{
char cByte;
long lvalue;
}

Обращение к объявленным элементам производится по их имени, без какого-либо префикса. Неименованные пространства имен могут быть использованы только в том файле, в котором они объявлены.
Стандарт языка C++ предусматривает определение псевдонимов пространства имен, которые ссылаются на конкретное пространство имен. Чаще всего псевдонимы используются для упрощения работы с длинными именами пространств. Следующий пример иллюстрирует создание более короткого псевдонима и его использование для доступа к переменной.

namespace A_Very_Long_Name_Of_NameSpace
{
float у;
}

A_Very_Long_Name_Of_NameSpace:: у = 0.0;
namespace Neo = A Very_Long_Name_Of_NameSpace;
Neo::y = 13.4;

Предположим, у вас есть крупный проект который содержит огромное количество классов и переменных. Естественно над ним не будет работать один человек, а значит возможны ошибки из-за, например, создание второго класса с именем Employee (ведь программист может и не знать, что кто-то уже создал класс с таким именем). Программисты называют это коллизиями имен. Чтобы избежать подобных проблем и придумали объединять большие участки кода в пространство имен. Они добавляют своеобразный префикс к каждому идентификатору в данном пространстве.
Давайте рассмотрим небольшой пример:

#include <iostream>

namespace myMath { // наше пространство имен
    int abs(int x) { // функция нахождения модуля
        if (x < 0) {
            return -x;
        } else {
            return x;
        }
    }

    const double E = 2.718; // константа 
}

int main() {
    cout << "|-1| = " << myMath::abs(-1) << endl; // пользуемся пространством имен
    cout << "e^2 = " << myMath::E * myMath::E << endl;

    system("PAUSE");
    return 0;
}



Возможно вы уже догадались как использовать данную конструкцию, но для полного понимания давайте рассмотрим программу более подробно:
    • Сначала мы объявляем пространство имен, в котором будем работать. Делается это при помощи ключевого слова namespace после которого следует имя пространства. Все то, что окажется внутри фигурных скобок будет принадлежать данному пространству имен.
    • Далее мы указываем код, который хотим «наградить» специальным префиксом (в нашем случае это myMath::).
    • Теперь мы можем использовать написанный ранее код также, как и код вне пространства имен с одной лишь разницей. Теперь мы обязаны указывать принадлежность функции или переменной к конкретному пространству имен. Делается это при помощи следующей конструкции:

<имя пространства>::<имя его члена>

Как видите нет ничего сложного. Но это в некоторых случаях очень неудобно, постоянно указывать префикс. Хотелось бы иметь возможность использовать по умолчанию какое-либо пространство имен. Хорошо, что C++ поддерживает такую возможность.
Как вы можете заметить, в начале каждой программы мы для удобства опускали стандартный префикс std (стандартная библиотека шаблонов находится именно в данном пространстве имен). Делали мы это для удобства чтения кода, а также для того, чтобы не усложнять код наших программ. В реальных проектах рекомендуется этого не делать.
Так вот, чтобы опустить какой-либо префикс, нужно это поле ключевых слов using namespace указать имя пространства имен, префикс которого мы не хотим указывать. Вот пример:

#include <iostream>

namespace CL { // пространство
    int var = 0;
}

using namespace CL; // отбрасываем префикс CL
 
int main() {
    std::cout << "var= " << var << "\n";
    var = 1; // используем переменную var
    std::cout << "var= " << var << "\n";

    system("PAUSE");
    return 0;
}



Пример

MyClass.h

namespace myNameSpace {
	class MyClass {
		int i;
	public:
		MyClass();
		int getValue();
	};
}

MyClass.cpp

#include "MyClass.h"

myNameSpace::MyClass::MyClass() {
	i = 123;
}

using namespace myNameSpace;
int MyClass::getValue() {
	return i;
}

TestCPP.cpp

#include <iostream>
#include "MyClass.h"

using namespace std;
using namespace myNameSpace;

int main() {
	MyClass a;
	cout << a.getValue() << endl;
	system("PAUSE");
	return 0;
}




        15.8. Функции и классы памяти.
Как вы видели ранее, в объявлении типа данных может участвовать спецификатор класса памяти. К примеру, переменную можно объявить следующим образом:

static float fyourvariable;

Функции также могут иметь класс памяти extern и static. Функция объявляется с классом памяти extern, если она описана в другом файле, внешнем по отношению к данной программе. Невозможно объявить функцию static так, чтобы к ней можно было обращаться извне, кроме как из файла, где она описана.
Мы уже несколько раз касались вопроса о том, что переменные в функции являются ее внутренними переменными и «не известны» вызывающей функции. Аналогично переменные вызывающей функции не известны вызываемой функции. Вот почему для связи с ней, т. е. для передачи значений в нее и из нее, мы пользуемся аргументами и оператором return. Переменные, известные только одной функции, а именно той, которая их содержит, называются «локальными» переменными. До сих пор это был единственный вид переменных, которыми мы пользовались, но в языке Си допускается наличие переменных, известных нескольким функциям. Такие нелокальные переменные называются «глобальными», и мы вернемся к ним позже. Теперь же мы хотим подчеркнуть, что локальные переменные являются действительно локальными. Даже в том случае, если мы используем одно и то же имя для переменных в двух различных функциях, компилятор (и, таким образом, компьютер) «считает» их разными переменными. Мы можем показать это, используя операцию & (не путайте с операцией &&).

            1.1.9. Объявления функций на внешнем уровне.
При объявлении функции на внешнем или внутреннем уровнях можно использовать спецификаторы класса памяти static или extern. Функции, в отличие от переменных, всегда имеют глобальное время жизни. Правила видимости для функций немного отличаются от правил видимости переменных.
Функции, объявленные как static, видимы только в том исходном файле, в котором они описаны. Функции, находящиеся в том же файле, могут вызывать статическую функцию, а функции из других файлов — не могут. Кроме того, в другом исходном файле можно объявить другую статическую функцию с таким же именем, и не будет конфликта.
Функции, объявленные как external, видимы во всех исходных файлах, образующих программу (если вы где-то не переопределите функцию как static). Внешнюю функцию могут вызывать все функции.

Замечание
Объявления функций, в которых опущен спецификатор класса памяти, являются по умолчанию external.

        15.9. Функция получения случайных чисел.
Вы не можете обойтись без функции получения случайных чисел. Когда кто-либо требует от вас какое-нибудь число, нужно обратиться к этому полезному средству, вместо того чтобы, заикаясь, каждый раз оправдываться. Вы можете использовать ее во многих машинных играх, что менее практично.
Сейчас мы покажем вам «генератор» псевдослучайных чисел. Это означает, что фактическая последовательность чисел предсказуема (компьютерам не известна их самопроизвольность), но они разбросаны довольно равномерно в пределах возможного диапазона значений.
Схема начинает с числа, называемого «зерно». Она использует его для создания нового числа, которое становится новым зерном. Затем новое зерно можно использовать для создания более нового зерна и т. д. Чтобы эта схема работала, функция случайных чисел должна помнить зерно, которое она использовала при последнем вызове. Ага! Она требует статическую переменную. Вот версия 1. (Скоро будет и версия 2.)

/* версия1 функции rand() */
rand()
{
	static int randx = 1;
	randx = (randx * 25173 + 13849) % 65536; /* магическая формула */
	return( randx);
}

Статическая переменная randx начинает со значения 1 и изменяется при помощи магической формулы каждый раз при вызове функции. Результатом в нашей системе является число, находящееся в диапазоне от - 32768 до 32767. Системы с разной длиной переменной типа int будут давать различные результаты.
Проверим работу функции при помощи этого простого драйвера:

/* драйвер1 функции rand() */
main()
{
	int count;
	for(count = 1; count <= 5; count++ )
		printf(" %d\n" , rand());
}

Результаты работы программы:



Получаем результат:



Эта последовательность чисел выглядит довольно случайной. Запустим драйвер еще раз. Теперь имеем



Получилось абсолютно то же самое; это и есть «псевдоэффект». Каждый раз, когда работает основная программа, мы начинаем с одного и того же значения зерна, равного 1. Можно обойти эту проблему, введя вторую функцию srand(), которая позволяет вновь устанавливать зерно в начальное значение. Хитрость заключается в том, чтобы сделать randx внешней статической переменной, известной только функциям rand() и srand(). Храните эти две функции в своем собственном файле и компилируйте этот файл отдельно. Вот модификация программы:

/* файл для rand() и srand() */
static int randx =1;
rand()
{
	randx = (randx * 25173 + 13849) % 65536;
return(randx);
}

srand (unsigned x)
{
	 
	randx = x;
}

Используем другой драйвер:

/* драйвер2 функции rand() */
main()
{
	int count;
	int seed;
	printf(" Please, enter your value of a corn\n");
//Пожалуйста, введите свое значение зерна
		scanf(" %d" , &seed);
	srand(seed);/* установите зерно в начальное значение */
	for (count = 1; count <= 5; count++ )
		printf(" %d\n" , rand());
	}
}

Результаты работы программы



Программа проработала один раз:



Используя значение 1 для переменной seed, получаем те же значения, что и прежде. Давайте теперь попытаемся ввести значение 2:



Очень хорошо! Мы получили другую последовательность чисел. Теперь попытаемся придумать применение для этих функций.

        15.10. Игра в кости.
Мы собираемся смоделировать очень распространенную игру в кости. В наиболее популярной форме этой игры используются две фишки, имеющие по 6 сторон (два кубика). Однако есть и другие варианты. Многие игроки и азартные игры используют любые из пяти геометрически возможных фишек, имеющих 4, 6, 8, 12 и 20 сторон. (Древние греки доказали, что есть только 5 правильных геометрических тел с гранями одинаковой формы и размера; эти тела и являются основой вариантов фишек. Можно сделать фишку с иным количеством сторон, но тогда не все грани будут одинаковыми и такие фишки не будут иметь равные шансы при бросании.)
На машинные вычисления эти. геометрические рассуждения не налагают ограничений, поэтому мы изобретем электронную игральную кость, у которой по вашему желанию может быть любое число сторон. Давайте начнем с 6 сторон, затем сделаем обобщение. Нам нужны случайные числа от 1 до 6, а функция rand() создает числа в диапазоне от —32768 до 32767, поэтому мы должны внести некоторые поправки. Вот один подход
Разделим случайное число на 32768. В результате получим число х в диапазоне -1 < = х < 1. (Мы должны превратить его в тип float, чтобы иметь десятичные дроби.)
Добавим 1. Наше новое число удовлетворяет отношению 0 <= х < 2.
Разделим на 2. Теперь имеем 0 < = х < 1.
Умножим на 6. Имеем 0 < = х < 6. (Близко к тому, что нужно, но 0 не является возможным значением.)
Прибавим 1: 1 < = х < 7. (Заметим, что эти числа все еще являются десятичными дробями.)
Преобразуем в целые числа. Теперь мы имеем целые в диапазоне от 1 до 6.
Для обобщения достаточно заменить значение 6 в п. 4 на число сторон.

Вот функция, которая выполняет эти действия:

/* электронное бросание костей */
#define SCALE 32768.0
rollem (sides);
float sides;
{
	float roll;
	roll = ( (float) rand()/SCALE + 1.0) * sides/2.0 + 1.0;
	return ( (int) roll);
}

Мы включили в программу два явных описания типа, чтобы показать, где выполняются преобразования типов.
Обратимся к программе, которая использует эти средства:

/* многократное бросание кости */
main()
{
	int dice, count, roll, seed; float sides;
	printf(" Введите, пожалуйста, значение зерна. \n");
	scanf(" %d", &seed);
	srand (seed);
	printf(" Введите число сторон кости, 0 для завершения\n");
	scanf(" %d" , &sides);
	while (sides > 0)
	{
		printf(" Сколько костей? \n" );
		scanf(" %d", dice);
		for ( roll = 0, count = 1; count <= dice; count++ )
			roll += rollem(sides); /* бросание всех костей набора */
		printf("У вас выпало %d, для %d %. 0f-сторонних костей.\n" , roll, dice, sides);
		printf(" Сколько сторон? Введите 0 для завершения.\n");
		scanf("%f", &sides);
	}
	printf(" Удачи вам!\n");
}

Теперь давайте используем эту программу:



Вы можете использовать функцию rollem() по-разному. Пусть число сторон (sides) равно двум, тогда бросание монеты даст следующий результат: «орел» выпал 2 раза, а «решка» — один (или наоборот, смотря, что вы предпочитаете). Можно легко модифицировать программу, чтобы показать как отдельные результаты, так и итог. Или вы можете построить имитатор игры «крапе». Если вам нужно большое число бросаний, вы можете легко модифицировать свою программу и получить результат, подобный следующему:

Введите значение зерна.
10
Введите количество ходов; введите 0 для завершения.
18
Сколько сторон и сколько костей?
6 3
Здесь 18 ходов для 3 6-сторонних костей.

	7	5	9	7 	12	10	7	12	10	14
	9	8	13	9	10	7	16	10

Сколько ходов? Введите 0 для завершения.
0

Использование функции rand() [но не rollem()] изменило бы вашу программу угадывания чисел: компьютер стал бы выбирать, а вы угадывать, вместо того чтобы сделать наоборот.
Разработаем еще некоторые функции. Сначала мы хотим создать функцию, которая читает целые числа.

        15.11. Функция получения целых чисел: getint().
Вероятно, наш проект покажется вам очень простым. В конце концов, мы можем использовать функцию scanf() с форматом %d, если хотим прочитать целое число. Такой подход очень прост, но он имеет один большой недостаток. Если вы ошибочно напечатали, скажем, Т вместо 6, scanf() попытается интерпретировать Т как целое число. Мы хотим создать функцию, которая проверяет вводимую информацию и предупреждает вас, если введено нецелое число. Теперь, может быть, наш проект уже не кажется таким простым. Однако не беспокойтесь — мы хорошо начали: у нас есть имя для новой функции. Мы назовем ее getint().
План
К счастью, мы уже выработали стратегию. Во-первых, заметим, что любую вводимую информацию можно читать как строку символов. Целое число 324, например, можно прочитать как строку из трех символов: символ ' 3', символ ' 2' и символ ' 4'. Это подсказывает нам следующий план:
Прочитать вводимую информацию как символьную строку.
Проверить, состоит ли строка только из символов цифр и стоит ли перед ними знак плюс или минус.
Если все это имеет место, превратить символьную строку в правильное числовое значение.
Если нет, выдать предупреждение.

Этот план так хорош, что он должен работать. (Тот факт, что он представляет собой стандартный подход, существовавший на протяжении многих лет, придает нам также некоторую уверенность в возможности его выполнения. Но, прежде чем начать программировать, нужно подумать, что будет делать наша функция. В частности, до того как мы займемся содержанием нашей функции getint(), нужно точно решить, как она должна взаимодействовать со своим окружением: с какой информацией? Какую информацию она должна получать от вызывающей программы? Какую информацию должна возвращать? В каком виде должна быть эта информация? Снова мы рассматриваем функцию как черный ящик. Мы хотим знать, что входит в функцию и что выходит из нее и, наконец, что находится внутри ее. Этот подход помогает обеспечивать более однородное взаимодействие между различными частями программы. Иначе вы можете оказаться в положении человека, пытающегося установить трансмиссию автомашины «Вольво" в автомобиль «Тойота». Сама функция правильная, но интерфейс является проблемой.
Поток информации для getint()
Какой выход должна иметь наша функция? Во-первых, несомненно, что она должна была бы выдавать значение прочитанного числа. Конечно, функция scanf() уже делает так. Во-вторых, и это очень существенно, мы собираемся создать такую функцию, которая будет выдавать сообщения о состоянии, т. е. найдено или нет целое число. Чтобы функция была действительно полезной, она должна также сообщать о нахождении ею символа EOF. Тогда мы могли бы использовать функцию getint() в цикле while, который читает целые числа до тех пор, пока не обнаружит символ EOF. Короче говоря, нам нужно, чтобы getint() возвращала два значения целое число и состояние.
Так как мы хотим иметь два значения, то с одной функцией return с этой задачей нам не справиться. Нам следует иметь два указателя. Однако полное решение задачи мы получим, если используем указатели для выполнения основной работы функции и функцию return для выдачи некоторого кода состояния. Именно это и делает функция scanf(). Она возвращает количество символов, которые нашла, и символ EOF, если встречает его. Ранее мы не пользовались такой возможностью, но могли бы, если бы применяли вызов вида

status = scanf(" %d" , &number);

Теперь будем это делать. Тогда наш вызов функции выглядел бы следующим образом:

status = getint(&number);

Правая часть равенства использует адрес переменной number, чтобы получить ее значение, a return применяется для получения значения переменной status.



Мы должны выбрать коды для выдачи сообщения о состоянии. Так как предполагается, что неописанные функции имеют тип int, наши коды должны состоять из целых чисел. Используем следующие коды для сообщения о состоянии:
-1 означает, что найден символ EOF
1 означает, что найдена строка, содержащая не цифры.
0 означает, что найдена строка, содержащая только цифры.

Нашу функцию getint() можно представить себе как имеющую один вход и два выхода. На ее вход поступает адрес целой переменной, значение которой считывается. На первом выходе имеем значение считанного целого, полученного через указатель. (Таким образом, аргумент-указатель является двусторонним каналом передачи информации.) На втором выходе получаем код состояния, что обеспечивается функцией return. Отсюда следует, что «скелет» нашей функции должен выглядеть примерно так:

getint(ptint)
int *ptint; /* указатель на целое число */
{
	int status;
...
	return(status);
}

Замечательно! Теперь мы должны просто заполнить внутренность функции.
Содержание getint()
Наш основной план для getint() в общих чертах на псевдокоде выглядит примерно так:
    • читаем на входе информацию в виде символов
    • помещаем символы в строку, пока не встретим символ EOF
    • если встретился символ EOF, устанавливаем состояние в STOP в противном случае
    • проверяем строку, преобразуем символы в целое число, если возможно,
    • и выдаем сообщение о состоянии (YESNUM или NONUM)

Здесь мы используем STOP, YESNUM и NONUM как символические константы, равные —1, 0 и 1, как описано выше.
Рассмотрим еще некоторые вопросы. Как функция будет решать, что она достигла конца входной строки? Должны ли мы ограничивать длину строки?
Мы вошли в область, где нам предстоит решать, что предпочесть: удобство программиста или удобство пользователя. Самым простым было бы предложить пользователю нажимать на клавишу [ввод], когда строку надо закончить. Это означало бы один ввод на строку. Для пользователя все же было бы приятнее, если бы функция могла размещать несколько чисел в одной и той же строке:

2	34	4542	2	98

Мы решили предоставить привилегию пользователю. Пусть функция будет считать, что строка начинается с символа, не являющегося пробелом или «новой строкой», и заканчивается символом пробела или «новой строкой». Такой ввод может производиться в одну строку или в несколько строк.
Мы ограничим вводимую строку 80 символами. Так как строки заканчиваются нуль-символом, нам нужен массив из 81 символа для включения в него этого символа. Это слишком щедро, потому что нам нужно только 6 символов для 16-разрядного целого числа и знака. Вы можете вводить более длинные числа, но их размер будет сокращен до размера строки.
Чтобы сделать программу более модульной, мы поручим преобразование «строка в целое число» другой функции, и назовем ее stoi(). У нас будет также возврат функцией stoi() соответствующего кода состояния в функцию getint(), a getint(), в свою очередь, может передать код состояния своей вызывающей программе. Функция stoi() выполнит последние две строки нашего плана (на псевдокоде).

/* getint() */
#include <stdio.h>
#define LEN 81 /* максимальная длина строки */
#define STOP -1 /* коды состояний */
#define NONUM 1
#define YESNUM 0
getint(ptint)
int *ptint; /* указатель на вывод целого числа */
{
	char intarr[LEN]; /* запоминание вводимой строки */
	int ch;
	int ind = 0; /* индекс массива */
	/* обход начальных символов «новая строка», пробелов и табуляций */
	while ((ch = getchar()) == ' \n' || ch == " || ch == ' \t');
		while (ch != EOF && ch != '\n' && ch != ' ' && ind < LEM)
		{
			intarr[ind++] = ch; /* запись символа в массив */
			ch = getchar(); /* получение очередного символа */
		}
		intarr[ind] = ' \0'; /* конец массива по нуль-символу */
		if (ch == EOF)
			return(STOP);
		else
			return ( stoi(intarr, ptint) ); /* выполнение преобразования */
}

Мы получаем символ ch. Если он является символом пробела, или «новой строки», или табуляции, мы берем следующий символ и так продолжаем до тех пор, пока не получим символ, отличающийся от перечисленных. Затем, если этот символ не EOF, помещаем его в массив. Продолжаем брать символы и помещать их в массив, пока не найдем запрещенный символ или не достигнем предельного размера строки. Далее помещаем нуль-символ ('\0') в следующую позицию массива, чтобы отметить конец строки. Таким образом, мы создали массив в виде стандартной символьной строки. Если EOF был последним прочитанным символом, возвращаем STOP; иначе идем дальше и пытаемся преобразовать строку. Мы вызываем новую функцию stoi(), чтобы выполнить эту работу. Что делает stoi()? При вводе она берет символьную строку и указатель на целую переменную, использует указатель для присваивания значения самой переменной, а также return для пересылки сообщения о состоянии, которое getint() передает затем функции getarray(). Поразительно! Двойная игра! Вот менее компактный способ использования функции stoi():

status = stoi(intarr, print); 
return (status);

Здесь status была бы переменной типа int. Первый оператор дает значение, на которое указывает ptint; она также присваивает значение переменной Status. Второй оператор возвращает это значение программе, которая вызвала getint(). Наша единственная строка программы имеет точно такой же эффект, за исключением того, что нам не нужна промежуточная переменная status. Теперь напишем функцию stoi().
Преобразование строки в целое: stoi()
Сначала опишем, каким должен быть вход и выход у этой функции. Вход будет символьной строкой, поэтому stoi() будет иметь символьную строку в качестве аргумента. На выходе должно быть получено два значения: состояние и преобразованное целое число, Мы применяем return для состояниями поэтому должны использовать указатель для возврата другого значения. Таким образом, появится второй аргумент — указатель на целое число. Скелет нашей функции будет выглядеть примерно так:

stoi(string, intptr)
char string[]; /* вводимая строка */
int *intptr; /* указатель на переменную, получающую целое значение*/
{
	int status;
	...
	return(status);
}

Прекрасно, а что можно сказать об алгоритме выполнения преобразования? На некоторое время проигнорируем знак и предположим, что строка содержит только цифры. Возьмем первый символ и преобразуем его в числовой эквивалент. Предположим, это символ ' 4'. Он имеет в коде ASCII числовое значение 52 и в таком виде запоминается. Если мы из него вычтем 48, то получим 4, т. е.

'4' - 48 = 4

Но 48 — это ASCII-код символа ' 0', поэтому

'4' - '0' =4

Действительно, этот последний оператор был бы справедлив в любом коде, в котором используются последовательные числа для представления последовательных цифр. Поэтому если num — числовое значение, a chn — символ цифры, то

num = chn — ' 0';

Итак, мы используем этот метод для преобразования первой цифры в число. Теперь возьмем следующий элемент массива. Если он ' \0', то у нас была только одна цифра, и мы закончили работу. Предположим, однако, что этот элемент ' 3'. Превратим его в числовое значение 3. Но если оно равно 3, то 4 должно было быть числом 40, а оба числа вместе 43:

num = 10 * num + chn - ' 0';

Теперь просто продолжим этот процесс, умножая старое значение num на 10 каждый раз, когда мы находим следующую цифру. Наша функция будет использовать этот метод.
Вот определение функции stoi(). Мы храним ее в том же файле, что и getint(), так что она может использовать те же самые директивы #define.

/* превращает строку в целое число и сообщает о состоянии */
stoi(string, intptr)
char string[]; /* строка, подлежащая преобразованию в целое*/
int *intptr; /* значение целого */
{
	int sign =1; /* проверяет наличие знака + или — */
	int index = 0;
	if (string[index] == ' -' || string[index] == ' + ')
		sign = (string[index++] == '-') ? -1 : 1;/* установить знак */
	*intptr = 0; /* начальное значение */
	while(string[index] >= '0' && string [index] <= '9')
		*intptr = 10 * (*intptr) + string[index++ ] - '0';
	if (string [index] == ' \0')
	{
		*intptr = sign * (*intptr);
		return(YESNUM);
	}
	else /* найден символ, отличный от цифры, знака или '\0'*/
		return(NONUM);
}

Оператор while продолжает работу, преобразуя цифры в числа, пока не достигнет нецифрового символа. Если это символ ' \0', все прекрасно, потому что он означает конец строки. Любой другой нецифровой символ отсылает программу к else для сообщения об ошибке.
Стандартная библиотека языка Си содержит функцию atoi() (перевод кода ASCII в целое число), очень похожую на stoi(). Основная разница заключается в том, что stoi() проверяет на нецифровые строки, a atoi() использует return вместо указателя, для возврата числа, и пропускает пробел, как мы это делали в getint(). Можно было бы осуществить все проверки состояния в getint() и использовать atoi() вместо stoi(), но мы полагаем, что было бы интереснее разработать нашу собственную версию.
Проверка
Так ли уж правильны наши рассуждения? Давайте проверим нашу функцию на учебной программе:

/* проверка функции getint()*/
#define STOP -1
#define NONUM 1
#define YESNUM 0
main()
{
	int num, status;
	printf(" Программа прекращает считывание чисел, если
			встречает EOF.\n" );
	while ( (status = getint(&num)) != STOP)
		if (status == YESNUM)
			printf(" Число %d принято \n", num);
		else
			printf(" Это не целое число! Попытайтесь снова\n");
	printf("Это оно.\n");
}

Вот пример работы программы:



Как видите, программа выполняется. Обратите внимание на то, как мы сумели организовать цикл для неограниченного считывания целых чисел до тех пор, пока не будет введен символ EOF. Это удобное свойство.
Есть ли здесь ошибки? По меньшей мере, одна. Если непосредственно за числом следует символ EOF без разделяющего пробела или символа новой строки, ввод прекращается, и это число не принимается во внимание:

706 EOF /* 706 принято*/
706EOF /* 706 не принято*/

Мы не хотели делать пример слишком сложным, поэтому допустили возможность этой ошибки. Дальнейшую разработку программы, как мы думаем, может осуществить сам читатель в качестве упражнения.
Теперь, когда у нас есть удобная функция для получения целых чисел, займемся новой задачей, в которой она будет использоваться.

        15.12. Сортировка.
Одним из наиболее распространенных тестов для машин является сортировка. Мы хотим разработать программу для сортировки целых чисел. Снова применим принцип черного ящика и подумаем в терминах ввода и вывода. Наш общий замысел, показанный на рисунке, довольно прост.



На данном этапе программа еще недостаточно определена, чтобы ее кодировать. Следующий шаг заключается в определении главных задач, которые должна выполнить программа для достижения поставленных целей. Их три:
Считывание чисел.
Сортировка чисел.
Печать отсортированных чисел.

На рисунке показано это разделение при движении от верхнего уровня конструкции вниз к более детальному.



Теперь мы имеем три черных ящика, каждый со своим входом и выходом. Можно передать каждую часть разным группам программистов, если мы уверены в том, что числа, выводимые блоком «считывание», представлены в той же самой форме, которую использует блок «сортировка» для ввода.
Как вы можете видеть, делается упор на модульность. Мы разделили исходную задачу на три более мелких, но лучше управляемых.
Что дальше? Теперь приложим наши усилия к каждому из трех модулей в отдельности, разделяя их на более простые элементы до тех пор, пока не достигнем момента, когда программа станет очевидной. Делая это, обратим внимание на такие важные проблемы, как выбор представления данных, локализация ошибок и передача информации.
Вернемся к нашему примеру и займемся сначала задачей считывания.
Считывание числовых данных
Многие программы включают считывание чисел, поэтому идеи, которые мы развиваем здесь, будут полезны везде. Общий вид первой части программы ясен: использовать цикл для считывания чисел до тех пор, пока все числа не будут считаны. Но в этом есть нечто большее, чем вы можете себе представить!



Выбор представления данных
Как мы представляем группу чисел? Можно использовать группу переменных, по одной на каждое число. Об этом даже страшно подумать. Можно использовать массив, по одному элементу на каждое число. Это значительно лучше, поэтому давайте использовать массив.
Однако какого типа будет массив? Типа, int? Типа double? Нам нужно знать, как такую программу можно будет применять. Предположим, что она должна работать с целыми числами. (А что если она должна применять и целые, и нецелые числа? Это возможно, но потребуется работы больше, чем нам бы хотелось сейчас.) Будем использовать массив целых чисел для запоминания чисел, которые мы считываем.
Завершение ввода
Как программа «узнает», сколько ей нужно считать чисел? Ранее мы обсудили несколько решений этой проблемы, большинство из которых были неудовлетворительны. Однако теперь, когда есть функция getint(), у нас нет проблем. Вот один подход:

    • читаем число до тех пор пока не встретится символ EOF
    • заносим число в массив и
    • читаем следующее число, если массив не заполнен

Заметим, что здесь есть два разных условия, приводящих к завершению этой части программы: символ EOF и заполнение массива.
Дальнейшие рассуждения
Прежде чем реализовать все это на языке Си, нам нужно еще решить, что будем делать с проверкой ошибок? Должны ли мы превратить эту часть программы в функцию?
Сначала мы решим, что делать, если пользователь вводит ошибочные данные, скажем букву вместо целого числа? Без функции getint() мы полагались бы на «гипотезу идеального пользователя», согласно которой пользователь не делает ошибок при вводе. Однако мы считаем, что эту гипотезу нельзя применять ни к одному пользователю, кроме себя. К счастью, можно использовать способность функции getint() сообщать о состоянии, что поможет нам выйти из затруднительного положения.
Теперь займемся программированием, которое можно легко реализовать в main(). Для соблюдения модульности следует использовать разные функции для каждой из трех основных частей программы, что мы как раз и сделаем. Входом для этой функции будут числа с клавиатуры или файл, а выходом — массив, содержащей неотсортированные числа. Было бы хорошо, если бы такая функция помогла основной программе узнать, сколько было считано чисел, поэтому предусмотрим это для выхода. В конце концов, нужно подумать и о пользователе. Мы заставим функцию печатать сообщение, указывающее ее пределы, и осуществлять эхо-печать входной информации.
main() и getarray()
Вызовем нашу функцию getarray(), предназначенную для считывания. Мы определили эту функцию в терминах ввода и вывода и наметили в общих чертах схему на псевдокоде. Теперь давайте напишем функцию и покажем, как она включается в основную программу:
Сначала напишем main():

/* сортировка */
#define MAXSIZE 100
/* предельное количество сортируемых целых чисел */

main()
{
	int numbers [MAXSIZE]; /* массив для ввода */
	int size; /* количество вводимых чисел */
	size = getarray(numbers, MAXSIZE); /* запись чисел в массив */
	sort(numbers, size); /* сортировка массива */
	print(numbers, size); /* печать отсортированного массива */

Это общий вид программы. Функция getarray() размещает введенные числа в массиве numbers и выдает сообщение о том, сколько значений было считано; эта величина записывается в size. Затем идут функции sort() и print(), которые мы еще должны написать; они сортируют массив и печатают результаты. Включая в них size, мы облегчаем им работу и избавляем от необходимости выполнять самим подсчет. Мы также снабдили getarray() переменной MAXSIZE, которая сообщает размер массива, необходимого для запоминания.
Теперь, когда мы добавили size к передаваемой информации, нужно модифицировать рисунок нашего черного ящика, смотри рисунок.



Теперь рассмотрим функцию getarray():

/* getarray(), использующая getint() */
#define STOP - 1 /* признак EOF */
#define NONUM 1 /* признак нецифровой строки */
#define YESNUM 0 /* признак строки цифр */
getarray(array, limit);
int array [], limit;
{
	int num, status;
	int index = 0; /* индекс массива */
	printf (" Эта программа прекращает считывание чисел после %d значений\n" , limit);
	printf (" или если введен символ EOF.\n" );
	while(index < limit && (status = getint(&num)) != STOP)
	{/* прекращает считывание после достижения limit или EOF */
		if (status == YESNUM)
		{
			array [index++ ] = num;
			printf(" число %d принято. \n" , num);
		}
		else
			if (status == NONUM)
				printf (" Это было не целое число! Попытайтесь снова\n" );
			else
				printf (" Этого не может быть! Что-то неправильно. \n" );
			if (index == limit) /* сообщить, если массив заполнен */
				printf (" Все %d элементов массива заполнены. \n" , limit);
		return (index);
	}
}

Это значительная часть программы, и у нас есть немало замечаний.
Разъяснения
Так как немного трудно вспомнить значение, скажем кода — 1, мы используем мнемонические символические константы для представления кодов состояния.
Применяя эти коды, мы создаем getarray() для управления каждым из возможных значений состояния. Состояние STOP вызывает прекращение цикла чтения, если getint() находит на своем «пути» EOF. Состояние YESNUM говорит о запоминании числа в предлагаемом массиве. Кроме того, отсылается «эхо-число» пользователю, чтобы он знал, что оно принято. Состояние NONUM предписывает пользователю попытаться выполнить задачу еще раз. (Это признак «дружелюбия»).
У нас есть еще оператор else. Единственный путь достижения этого оператора возможен, если getint() возвращает значение, отличное от -1, 0 или 1. Однако это единственные значения, которые могут быть возвращены, поэтому else является, по-видимому, бесполезным оператором. Почему он включен в программу? Мы вставили его как пример «защитного программирования», как способ защиты программы от будущей ошибки. Когда-нибудь мы (или кто-нибудь еще), может быть, решим обратиться к функции getint() и добавить в ее репертуар немного больше возможных значений состояния. Наиболее вероятно, что мы забудем (а они могут никогда не узнать), что getarray() предполагает только три возможных ответа. Поэтому мы включаем это последнее else, чтобы «поймать» любые новые ответы, которые появятся, и значительно упростить будущую отладку.
Размер массива устанавливается в main(). Поэтому мы не задаем его, когда описываем аргумент-массив в getarray(). Мы ставим только квадратные скобки в оператор, чтобы указать, что аргумент является массивом.

int numbers [MAXSIZE]; /* размер задается в main */
int array[] /* нет определения размера в вызвавшей функции */

Мы решили применить ключевое слово return для возврата числа прочитанных элементов. Таким образом, вызов нашей функции

size = getarray(numbers);

присваивает значение переменной size и дает значения массиву numbers.
Вы можете спросить, почему мы не использовали указатели в вызове

size = getarray(numbers);

ведь у нас функция изменяет значение чего-то (массива) в вызывающей программе? Ошибаетесь — мы использовали указатель! В языке Си имя массива является также указателем на первый элемент массива, т. е.

numbers == &numbers[0]

Когда функция getarray() создает массив array, то адрес элемента array[0] совпадает с адресом элемента numbers[0] и т. д. для всех других индексов. Поэтому все манипуляции, которые выполняет getarray() с array[], фактически выполняются с numbers[]. Мы будем более подробно говорить о связи между указателями и массивами позднее. Теперь же нам нужно усвоить, что функция воздействует на массив в вызывающей программе, если мы используем массив в качестве аргумента функции.
В функциях, содержащих счетчики и пределы, таких как getarray(), наиболее вероятным местом появления ошибок являются «граничные условия», где значения счетчиков достигают своих пределов. Мы собираемся прочитать максимальное количество чисел, указанное в MAXSIZE, или же мы намерены ограничиться одним? Хотим обратить внимание на детали, такие, как ++index или index++ и < или < =. Мы также должны помнить, что у массивов индексы начинаются с 0, а не с 1. Проверьте вашу программу и посмотрите, работает ли она так, как должна. Самое простое — предположить, что limit равен 1 и пройти по программе шаг за шагом.
Обычно наиболее трудной частью программы является обеспечение ее взаимодействия с пользователем удобным и надежным способом. Это относится и к нашей программе. Теперь, когда мы справились с getarray(), находим, что функция sort() должна быть проще и print() — тоже. Теперь перейдем к функции sort().
Сортировка данных
Рассмотрим еще раз функцию main():



main()
{
	int numbers [MAXSIZE]; /* массив для ввода */
	int size; /* количество введенных элементов */
	size = getarray(numbers, MAXSIZE); /* помешает ввод в массив */
	sort(numbers, size); /* сортировка массива */
	printf(numbers, size); /* печать отсортированного массива */
}

Мы видим, что функция sort() имеет на входе массив целых чисел, предназначенных для сортировки, и счетчик количества элементов, подлежащих сортировке. На выходе получается массив, содержащий отсортированные числа. Мы все еще не решили, как выполнять сортировку, поэтому мы должны дополнительно уточнить это описание.
Очевидно, в начале трудно определить направление сортировки. Собираемся ли мы вести сортировку от большего к меньшему, или наоборот? Мы свободны в выборе и допустим, что хотим сортировать от большего к меньшему. (Можно сделать программу, работающую любым из этих методов, но тогда нам нужно придумать способ сообщить ей о своем выборе.)
Рассмотрим теперь метод, который будем использовать для сортировки. В настоящее время разработано много алгоритмов сортировки; возьмем один из самых простых.
Вот наш план на псевдокоде:

от n = первому элементу до n = ближайшему к- последнему элементу находим самое большое из оставшихся чисел и помещаем его в n-ю позицию

Он выполняется примерно так. Сначала пусть n = 1. Мы просматриваем весь массив, находим самое большое число и помещаем его в первый элемент. Затем n = 2, и мы опять просматриваем весь массив, кроме первого элемента, находим самое большое из оставшихся чисел и помещаем его во второй элемент. Продолжаем этот процесс до тех пор, пока не достигнем ближайшего - к - последнему элементу. Теперь осталось только два элемента. Мы сравниваем эти числа и помещаем большее в элемент, ближайший - к - последнему. Оставшееся самое меньшее из всех чисел помещаем в последний элемент.
Это выглядит очень похоже на задачу с циклом for, но мы все же должны описать процесс «найти и поместить» более детально. Как сделать так, чтобы мы находили каждый раз самое большое из оставшихся чисел? Вот один способ. Сравните первый и второй
элементы оставшегося массива. Если второй больше, поменяйте их местами. Теперь сравните первый элемент с третьим. Если третий больше, поменяйте местами эти два. Каждый раз больший элемент перемещается вверх. Продолжаем таким образом, пока не сравним первый элемент с последним. Если вы дошли до конца, самое большое число теперь будет в первом элементе оставшегося массива. По существу мы имеем отсортированный массив для первого элемента, но остаток массива находится в беспорядке. На псевдокоде это можно выразить так:

для n = от второго до последнего элемента сравниваем n-й элемент с первым; если n-й больше, меняем их местами.

Это напоминает еще один цикл for. Его следует вставить в первый цикл for. Внешний цикл показывает, какой элемент массива должен быть заполнен, а внутренний цикл находит значение, которое следует поместить туда. Записывая обе части на псевдокоде и переводя их на язык Си, мы получаем следующую функцию:

/* сортировка массива целых чисел в порядке убывания */
sortarray(array, limit)
int array[], limit;
int top, search;
{
for (top = 0; top < limit - 1; top++ )
	for (search = top + 1; search < limit; search*+ )
		if (array[search] > array[top])
			interchange( &array[search], &array[top] );
}

Мы помним, что первый элемент имеет индекс 0. Кроме того, раньше была создана функция обмена, поэтому мы использовали ее здесь. Так как функция interchange «работает» с двумя элементами массива, а не со всем массивом, мы должны использовать адреса только двух интересующих нас элементов. (В то время как имя array является указателем на весь массив, нам нужно применить операцию &, чтобы указывать на отдельные элементы.) Мы использовали top в качестве индекса для элемента массива, который следует заполнить, так как он является вершиной неотсортированной части массива. Индекс search перемещает по массиву в порядке убывания текущий элемент. Большинство текстов использует обозначения i и j для этих индексов, однако это осложняет ситуацию, если нужно посмотреть, что происходит.
Этот алгоритм иногда называют «пузырьковой сортировкой», так как самое большое значение медленно поднимется вверх.
Именно теперь мы должны написать функцию print().
Печать данных



Эта программа достаточно проста:

/* печать массива */
print(array, limit)
int array[], limit;
{
	int index;
	for (index = 0; index <= limit; index++ )
		printf(" %d\n", array[index]);
}

Если мы хотим сделать что-нибудь другое, например печатать по строкам, а не в столбец, можно всегда вернуться и изменить эту функцию, оставив другие функции неизменными. Аналогично, если мы нашли алгоритм сортировки, который нам больше нравится, можно заменить этот модуль программы. Это один из приятных моментов модульной программы.
Результаты
Давайте скомпилируем и протестируем нашу программу сортировки. Чтобы упростить проверку граничных условий, временно изменим MAXSIZE на 5.
В нашем первом тесте будем снабжать программу числами до тех пор, пока она не откажется их принимать.

Эта программа прекращает считывание чисел после 5 значений,
или если встретился символ EOF.



Программа считала 5 чисел и отсортировала их. Теперь посмотрим, как будет выглядеть результат, если она остановится, встретив символ EOF.

Эта программа прекращает считывание чисел после 5 значений, или если встретился символ EOF.
456	928
-23	+16
Клавиша [control z] (передает EOF в нашу систему)
928
456
16
-23

Быстрее чем вы сможете сказать «экология это наука о домашнем хозяйстве», целый огромный массив отсортирован.
Успех! Это было не просто, но не невозможно. Разделив задачу на небольшие части и продумав, какой информацией должна обмениваться каждая из них, мы свели задачу к частям, поддающимся управлению. Кроме того, отдельные модули, которые мы создали, можно использовать как части подобных программ.
Обзор
Чего же мы достигли? Если посмотреть с практической стороны, то мы разработали генератор случайных чисел и программу сортировки целых чисел. При этом создали функцию getint(), которую можно использовать в других программах. Если посмотреть с педагогической точки зрения, то мы проиллюстрировали несколько основных принципов и концепций, полезных при создании программ.
Следует обратить внимание на самый существенный момент: программы: нужно проектировать, а не создавать их методом проб и ошибок. Вы должны внимательно подумать о форме и содержании ввода и вывода для программы. Необходимо разделить программу на хорошо определенные задачи, затем раздельно запрограммировать, принимая во внимание взаимодействие их друг с другом. Идея заключается в достижении модульности. Если необходимо, разбивайте модули на еще более мелкие модули. Используйте функции для повышения степени модульности и простоты программы.
При проектировании программы, попытайтесь предвидеть, что может идти неправильно и программируйте, исходя из этого. Используйте локализацию ошибок, чтобы контролировать действия в местах потенциальных затруднений, или по крайней мере предупреждать пользователя, что может возникнуть осложнение. Гораздо лучше дать пользователю еще одну возможность ввести данные, чем продолжать выполнять программу и прийти к аварийной ситуации.
Если создается функция, сначала определите, как она будет взаимодействовать с вызывающей программой. Решите также, какая информация будет входить в нее, а какая выходить. Какими должны быть аргументы? Хотите ли вы использовать указатели, или возврат, или то и другое? Если вы примете во внимание все эти параметры, то можете обратить внимание на работу самой функции.
Используйте эти идеи, и ваша программа будет более надежной и менее подверженной аварийным ситуациям. Вы получаете тело функции, которое можете применять в других программах. Программирование в таком случае потребует меньше времени. Вообще все это похоже на хороший рецепт здорового программирования.
Не забывайте о классах памяти. Переменные можно определять вне функции; в этом случае их называют внешними (или глобальными) и они доступны более чем для одной функции. Переменные, определенные внутри функции, являются локальными для нее и не известны другим функциям. Если можно, используйте автоматическую разновидность локальных переменных. Они охраняют переменные одной функции от воздействия других функций.

Что вы должны были узнать.
    • Как представлять функцию: черный ящик с информационным потоком.
    • Что такое «проверка ошибок» и почему эта процедура хороша.
    • Алгоритм сортировки.
    • Как заставить функцию изменять массив: function(array).
    • Как преобразовать строку цифр в число.
    • Классы памяти: auto, extern, static и register.
    • Область действия каждого класса памяти.
    • Какой класс памяти использовать: обычно auto.

Вопросы и ответы.
Вопросы.
Что может сделать наш алгоритм сортировки неэффективным?
Как следует изменить нашу программу сортировки, чтобы она сортировала в порядке возрастания, а не убывания?
Измените функцию print () таким образом, чтобы она печатала по 5 чисел в строке.
Как следует изменить функцию stoi(), чтобы обрабатывать строки, представляющие восьмеричные числа?
Какие функции «знают» каждую переменную из описанных ниже? Есть ли здесь какие-нибудь ошибки?
/* файл1 */
int daisy;
main()
{
	int lily;
}

petal()
{
	extern int daisy, lily;
}

/* файл2 */
static int lily; int rose,
stem()
{
	int rose;
}

root()
{
	extern int daisy;
}

Ответы.
Предположим, что вы сортируете 20 чисел. Программа производит 19 сравнений, чтобы найти одно самое большое число. Затем делается 18 сравнений, чтобы найти следующее самое большое. Вся информация, полученная во время первого поиска «забывается» за исключением самого большого числа, поставленного на первое место. Второе самое большое число можно временно поместить на место с номером 1, а затем при сортировке опустить вниз. Много сравнений, выполнявшихся в первый раз, повторяется второй, третий раз и т. д.
Замените
array[search] > array [top] на
array[search] < array[top]

    1. 
/* печать массива */
	print(array, limit)
	int array[], limit);
	int index;
	for ( index = 0; index < limit; index++ )
		{
		printf(" %10d" , array[index]);
		if (index % 5 == 4)
			printf(" \n" );
		}
	printf(" \n");
}

Во-первых, обеспечьте, чтобы разрешенные символы были только цифрами от 0 до 7. Во-вторых, умножайте на 8 вместо 10 каждый раз, когда обнаружите новую цифру.
daisy известна функции main() по умолчанию и функциям petal() и root() благодаря extern-описанию. Она не известна функции stem(), потому что они находятся в разных файлах. Первая lily локальна для main: ссылка на lily в petal() является ошибочной, потому что в каждом из этих файлов нет внешней lily.
Есть внешняя статическая lily, но она известна только функциям второго файла.
Первая, внешняя rose, известна функции root(), а функция stem() отменила ее своей собственной локальной rose.

Упражнения.
Некоторые пользователи, возможно испугаются, если их попросить ввести символ EOF.
    • Модифицируйте getarray() и вызываемые ею функции так, чтобы использовать символ # вместо EOF.
    • Модифицируйте затем их так, чтобы можно было использовать либо EOF, либо #.

Создайте программу, которая сортирует числа типа float.
Создайте программу, превращающую смешанный текст из прописных и строчных букв в текст, состоящий только из прописных букв.
Создайте программу, которая удваивает пробелы в тексте с одиночными пробелами.
 

16. Дополнительные приемы программирования.
16.1. Совместимость типов.
16.1.1. Определение совместимости типов в ANSI С.
16.2. Идентичный тип.
16.2.1. Перечисляемые типы.
16.2.2. Типы массивов.
16.2.3. Типы функций.
16.2.4. Типы структур и объединений.
16.2.5. Типы указателей.
16.2.6. Совместимость нескольких исходных файлов.
16.3. Макроопределения.
16.3.1. Определение макросов.
16.3.2. Макросы и параметры.
16.3.3. Сложности при раскрытии макросов.
16.3.4. Создание и использование собственных макросов.
16.3.5. Макросы, поставляемые вместе с компилятором.
16.3.6. Выбор макроопределения или функции.
16.4. Директивы препроцессора.
16.4.1. Директива #define.
16.4.2. Директива #include.
16.4.2.1. Заголовочные файлы.
16.4.2.2. Правильное использование заголовочных файлов.
16.4.2.3. Более эффективное использование заголовочных файлов.
16.4.2.4. Новый стиль заголовков
16.4.2.5. Предварительная компиляция заголовочных файлов.
16.4.2.6. Файлы limits.h и float.h.
16.4.3. Директивы #ifdef и #endif.
16.4.4. Директива #undef.
16.4.5. Директива #ifndef.
16.4.6. Директива #if.
16.4.7. Директива #else.
16.4.8. Директива #elif.
16.4.9. Директива #line.
16.4.10. Директива #error.
16.4.11. Директива #pragma.
16.5. Оператор defined.
16.6. Условная компиляция.
16.7. Дополнительные операции препроцессора.
16.7.1. Операция подстановки строки (#).
16.7.2. Операция конкатенации (##).
16.7.3. Операция подстановки символа (#@).
16.8. Обработка ошибок: perror().
16.9. Модели памяти.
16.9.1. Модель tiny.
16.9.2. Модель small.
16.9.3. Модель medium.
16.9.4. Модель compact.
16.9.5. Модель large.
16.9.6. Модель huge.
16.10. Модификаторы функций.
16.11. Модификаторы cdecl и pascal.
16.12. Динамическое распределение памяти. Связанные списки.
16.12.1. Особенности использования связанных списков.
16.12.2. Простой связанный список.

    16. Дополнительные приемы программирования.
Здесь рассматриваются дополнительные приемы программирования, общие для С и C++. Многие обсуждаемые темы, такие как совместимость типов и макросы, затрагивают такие средства языка, которые при разработке алгоритма программы нужно использовать с осторожностью. Другие описываемые средства, например поставляемые с компилятором макросы и условные команды препроцессора, помогают создавать более рациональные приложения. В конце темы описана концепция и синтаксические конструкции, необходимые для создания динамически связанных списков. После знакомства с нюансами программирования вы будете иметь достаточную подготовку по C/C++, чтобы без затруднений перейти к принципам объектно-ориентированного программирования.
Язык Си был разработан в помощь работающим программистам, а им нравится его препроцессор. Этот полезный помощник Он просматривает программу до компилятора (отсюда и термин «препроцессор») и заменяет символические аббревиатуры в программе на соответствующие директивы. Он отыскивает другие файлы, необходимые вам, и может также изменить условия компиляции. Однако эти слова еще не отражают истинную пользу и значение препроцессора, поэтому обратимся к примерам. Конечно, до сих пор мы снабжали все примеры директивами #define и #include, но теперь мы можем подытожить все, что изучили, и развить тему дальше.

        16.1. Совместимость типов.
Как вы уже хорошо знаете, С — слабо типизированный язык, а C++ имеет чуть большую типизацию (например, перечисляемые типы). Вы видели, как язык С может выполнять автоматические и явные преобразования типов, используя оператор явного приведения типа. В следующем разделе освещается не всегда очевидный способ интерпретации компилятором C/C++ совместимых типов.

            1.1.1. Определение совместимости типов в ANSI С.
Сама идея совместимых типов возникла в комитете ANSI С. Благодаря многим рекомендациям комитета в С появились средства, например прототипы функций, упрощающие поддержку языка. Комитет пытался определить набор правил или синтаксических конструкций, фиксирующих автоматические и неявные возможности языка.
Комитет ANSI С установил, что для того, чтобы два типа были совместимыми, они должны либо быть одного и того же типа, либо быть указателями, функциями или массивами, обладающими некоторыми свойствами; эти требования раскрыты в следующих параграфах.

        16.2. Идентичный тип.
Понятие "составной тип" связано с темой совместимости. Составной тип — это общий тип, образованный двумя совместимыми типами. Два любых совпадающих типа являются совместимыми, и их составной тип принадлежит к тому же типу.
Два арифметических типа идентичны, если они — одного типа. Краткие объявления одного и того же типа также идентичны. В следующем примере обе переменные, shivalue1 и shivalue2, имеют идентичный тип:

short shivalue 1;
short int shivalue2;

В следующем примере тип int совпадает с типом unsigned int:

int sivalue1;
unsigned int sivalue2;

Однако, типы int, short и unsigned отличаются друг от друга; при работе с символьными данными большое различие существует между типами char, signed char и unsigned char.
Как постановил комитет ANSI С, любой тип, которому предшествует какой-либо модификатор доступа, порождает несовместимые типы. Например, следующие два объявления относятся к несовместимым типам:

int ivalue1;
const int ivalue2;

Попробуйте определить, какие типы являются совместимыми в следующих объявлениях:

char *pc1, * рс2;
struct {int ix, iy;} stanonymous_coord1, stanonymous_coord2;
struct stxy {int ix, iy;} stanycoords;
typedef struct stxy STXY;
STXY stmorecoords;

Переменные pc1 и рс2 являются совместимыми указателями на символы, поскольку при объявлении дополнительный пробел между символом * и именем рс2 является ненужным (незначащим).
Вас, наверное, не удивит то, что переменные stanonymous_coord1 и stanonymous_coord2 принадлежат к одному типу. Однако, тип переменной stanycoords не является идентичным типу предыдущих двух переменных. Хотя все три переменные содержат два одинаковых целочисленных поля, переменные stanonymous_coord1 и stanonymous_coord2 имеют анонимный структурный тип, а переменная stanycoords имеет теговый тип stxy.
Благодаря объявлению typedef, для компилятора типы struct stxy и STXY — идентичны, и поэтому переменная stanycoords идентична stmorecoords.
Важно помнить то, что компилятор рассматривает объявления typedef как синонимы типов, но не как совершенно новые типы. В следующем операторе определяется новый тип MYFLOAT, аналогичный типу float:

typedef float MYFLOAT;

            1.1.2. Перечисляемые типы.
Первоначально комитет ANSI С установил, что каждый перечисляемый тип совместим с зависящим от реализации интегральным типом; однако, в C++ перечисляемые типы с интегральными несовместимы. В С и C++ никакие определения перечисляемых типов, находящиеся в одном исходном файле, не являются совместимыми. Это правило аналогично тому, как отличаются структуры с тегами и структуры без тегов (анонимные). Вот почему в следующем примере типы ebflag1 и ebflag2 совместимы, а eflag1 — нет:

enum boolean {0,1} ebflag1;
enum {0,1} eflag1;
enum boolean ebflag2;

            1.1.3. Типы массивов.
Если два массива содержат элементы совместимых типов, то сами массивы считаются совместимыми. Если размер указан только для одного массива или же не указан совсем, то совместимость типов остается. Однако в случае, когда размеры указаны для обоих массивов, для того, чтобы они были совместимыми, размеры должны совпадать. Найдите все совместимые массивы в следующих объявлениях:

int imax20[20];
const int cimax20[20];
int imax10[10];
int iundefined[];

Безразмерный массив iundefined совместим с обоими массивами imax20 и imax10. Однако, два этих последних массива несовместимы, так как имеют различные размеры. Несовместимость массивов imax20 (элементы типа int) и cimax20 (элементы тип const int) объясняется тем, что несовместимы их элементы. Если у двух массивов указан размер, то составной тип совместимых массивов будет иметь тот же размер. В приведенном примере составной тип массивов iundefined и imax.20 — int[20].

            1.1.4. Типы функций.
Для того чтобы считать совместимыми две функции, имеющие прототипы, должны выполниться три условия. Две функции должны иметь один и тот же возвращаемый тип и одинаковое число параметров; при этом соответствующие параметры должны быть совместимых типов. Однако, имена параметров могут не совпадать.

            1.1.5. Типы структур и объединений.
При объявлении в программе новой структуры или объединения вводится новый тип, отличный (не совместимый) от любого другого типа в том же исходном файле. Поэтому в следующем примере переменные stanonymous1, stanonymous2 и stfloat1 отличаются друг от друга.
Однако же, ссылка на спецификатор типа, являющегося структурой, объединением или перечисляемым типом, принадлежит к тому же типу. Для связи ссылки и объявления типа используется поле тега, поэтому поле тега можно рассматривать как название типа. Вот почему переменные stfloat1 и stfloat2 имеют совместимые типы.

struct {float fvalue1, fvalue2;} stanonymous1;
struct {float fvalue1, fvalue2;} stanonymous2;
struct sttwofloats {float fvalue1, fvalue2;} stfloat1;
struct sttwofloats stfloat2;

            1.1.6. Типы указателей.
Два типа указателей считаются совместимыми, если они оба указывают на совместимые типы. Составной тип двух совместимых указателей такой же, как составной тип, на который осуществляется ссылка.

            1.1.7. Совместимость нескольких исходных файлов.
Поскольку каждое объявление структуры, объединения или перечисляемого типа рассматривается, как новый несовместимый тип, может возникнуть вопрос: что произойдет, если возникнет необходимость сослаться на эти типы из других файлов этой же программы.
Повторяющиеся объявления структур, объединений и перечисляемых типов совместимы в исходных файлах, если в них объявляются одни и те же элементы, в одном и том же порядке и элементы имеют совместимые типы. Для перечисляемых типов, однако, не требуется, чтобы константы перечисления объявлялись в том же порядке, хотя каждая константа должна иметь то же самое перечисляемое значение.

        16.3. Макроопределения.
Ранее было рассказано, как использовать директиву препроцессора #define для объявления символьных констант. Директиву препроцессора #define Ту же самую директиву можно использовать для определения макросов. Макрос — это фрагмент кода, который выглядит и работает так же, как функция.
Преимущество правильно написанного макроса заключается в скорости выполнения. Макрос раскрывается (заменяется его определением #define) во время работы препроцессора, при этом создается так называемый встраиваемый код. Именно поэтому макросы не вызывают дополнительных затрат времени, как это обычно случается при вызове функций. Однако, при каждой подстановке макроса увеличивается общий размер исполняемой программы.
Обратная ситуация — определения функций раскрываются только один раз и не имеет значения сколько раз они вызываются. Оптимальный выбор между скоростью выполнения и общим размером программы поможет вам решить, каким образом записывать конкретную процедуру.
Имеются и другие, более тонкие различия между макросами и функциями, касающиеся момента раскрытия кода. Их можно разбить на три категории. В С имя функции имеет значение адреса, по которому эта функция располагается. Поскольку макрос является встраиваемым средством и может раскрываться много раз, не существует единого адреса, связанного с ним. Поэтому макрос нельзя использовать в контексте, где требуется указатель на функцию. Кроме того, можно объявить указатель на функцию, но невозможно объявить указатель на макрос.
Компилятор С по-разному анализирует объявление функции и описание макроса #define, поэтому он не выполняет никаких проверок типов в макросе. В результате этого при передаче макросу неправильного количества аргументов или при ошибке в типе аргумента никаких сообщений от компилятора получено не будет.
Так как макросы раскрываются до начала фактической компиляции программы, некоторые макросы могут неправильно обрабатывать аргументы, если этот аргумент вычисляется в макросе несколько раз.
Макрос это фрагмент кода, который выглядит и работает так же, как функция. Однако функцией он не является. Имеется несколько различий между макросами и функциями:
    • макрос заменяется своим определением во время работы препроцессора, то есть еще до компиляции программы. Поэтому макросы не вызывают дополнительных затрат времени, как при вызове функции
    • использование макросов приводит к разрастанию исходного кода и увеличения размера исполняемой программы. Функции являются в некотором смысле антиподом макросов. Код, который они представляют, встраивается в программу только один раз, что приводит к сокращению кода программы. С другой стороны, при выполнении программы требуется дополнительное время для организации вызова функции;
    • компилятор не выполняет никаких проверок типов в макросе. Поэтому при передаче макросу аргумента, не соответствующего подразумеваемому типу, или неверного числа аргументов, никаких сообщений об ошибке не будет.
    • поскольку макрос является средством для встраивания фрагмента кода, не существует единого адреса, связанного с ним. Поэтому нельзя объявить указатель на макрос или использовать его адрес

Для определения макросов используется директива #define. Как и функции, макросы могут иметь параметры.

            1.1.8. Определение макросов.
Макросы определяются аналогично символьным константам. Единственное отличие в том, что строка подстановки substitution_string обычно содержит несколько значений:

#define search_string substitution_string

Для того чтобы показать сходство описаний, в следующем примере директива препроцессора используется для определения символьной константы и макроса:

/* #define — символьная константа */
#define iMAX_ROWS 100
/* #define — макрос */
#define NL putchar('\n')

Макрос NL заставляет препроцессор при просмотре исходного текста программы находить каждое вхождение символов NL и заменять его на оператор putchar(‘\n'). Следует обратить внимание на то, что в конце макроса отсутствует точка с запятой. Это объясняется тем, как макрос вызывается в исходном тексте программы:

int main(void)
{
…
…
…
	NL;

Компилятор требует, чтобы вызов макроса заканчивался точкой с запятой. Предположим, что строка substitution_string в макросе заканчивается точкой с запятой:

#define NL putchar('\n');

Тогда после раскрытия макроса в исходном тексте получится следующее:

int main(void)
{
…
…
…
	putchar('\n'); ;

Директива #define, подобно всем директивам препроцессора, начинается с символа # в самой левой позиции. Она может появиться в любом месте исходного файла, а даваемое ею определение имеет силу от места появления до конца файла. Мы активно используем эту директиву для определения символических констант в наших программах, однако она имеет более широкое применение, что мы и покажем дальше. Вот пример, иллюстрирующий некоторые возможности и свойства директивы #define:

/* простые примеры директивы препроцессора */
#include<stdio.h>
#define TWO 2 /* по желанию можно использовать комментарии */
#define MSG "An old grey cat is singing a cheerful song"
/*Старый серый кот поет веселую песню.*/
/* обратная косая черта продолжает определение на следующую строку */
#define FOUR TWO*TWO
#define PX printf("X = %d.\n", x)
#define FMT "X = %d.\n"
void main()
{
	int x = TWO;
	PX;
	x = FOUR;
	printf(FMT, x);
	printf(" %s\n", MSG);
	printf("TWO: MSGX\n");

}

Каждая строка состоит из трех частей. Первой стоит директива #define. Далее идет выбранная нами аббревиатура, известная у программистов как «макроопределение». Макроопределение не должно содержать внутри себя пробелы. И, наконец, идет строка (называемая «строкой замещения»), которую представляет макроопределение. Когда препроцессор находит в программе одно из ваших макроопределений, он почти всегда заменяет его строкой замещения. (Есть одно исключение, которое мы вам сейчас покажем.) Этот процесс прохождения от макроопределения до заключительной строки замещения называется «макрорасширением». Заметим, что при стандартной форме записи на языке Си можно вставлять комментарии; они будут игнорироваться препроцессором. Кроме того, большинство систем разрешает использовать обратную косую черту (' \' ) для расширения определения более чем на одну строку.
«Запустим» наш пример, и посмотрим за его выполнением.



Вот что произошло. Оператор

int x = TWO; превращается в int x = 2;

т. е. слово TWO заменилось цифрой 2. Затем оператор

РХ; превращается в printf("X равно %d.\n" , х);

поскольку сделана полная замена. Это новшество, так как до сих пор мы использовали макроопределения только для представления констант. Теперь же мы видим, что макроопределение может представлять любую строку, даже целое выражение на языке Си. Заметим, однако, что это константная строка; РХ напечатает только переменную, названную X.



Следующая строка также представляет что-то новое. Вы можете подумать, что FOUR заменяется на 4, но на самом деле выполняется следующее:

х = FOUR; превращается в х — TWO*TWO; превращается в х = 2*2;

и на этом все заканчивается. Фактическое умножение имеет место не во время работы препроцессора и не при компиляции, а всегда без исключения при работе программы. Препроцессор не выполняет вычислений; он только очень точно делает предложенные подстановки.
Заметим, что макроопределение может включать другие определения. (Некоторые компиляторы не поддерживают это свойство «вложения».)
В следующей строке

printf(FMT, х); превращается в printf("X равно %d.\n" , х)

когда FMT заменяется соответствующей строкой. Этот подход может оказаться очень удобным, если у вас есть длинная строка, которую вы используете несколько раз.
В следующей строке программы MSG заменяется соответствующей строкой. Кавычки делают замещающую строку константой символьной строки; поскольку программа получает ее содержимое, эта строка будет запоминаться в массиве, заканчивающемся нуль-символом. Так,
#define HAL 'Z' определяет символьную константу, а #define HAP "Z" определяет символьную строку: Z\0
Обычно препроцессор, встречая одно из ваших макроопределений в программе, очень точно заменяет их эквивалентной строкой замещения. Если эта строка также содержит макроопределения, они тоже замещаются. Единственным исключением при замене является макроопределение, находящееся внутри двойных кавычек. Поэтому

printf("TWO: MSG");

печатает буквально TWO: MSG вместо печати следующей строки:
2: "Старый серый кот поет веселую песню."

Если вам нужно напечатать эту строку, можно использовать оператор

printf(" %d: %s\n" , TWO, MSG);

потому что здесь макроопределения находятся вне кавычек.
Когда следует использовать символические константы? Вероятно, вы должны применять их для большинства чисел. Если число является константой, используемой в вычислениях, то символическое имя делает яснее ее смысл. Если число — размер массива, то символическое имя упрощает изменение вашей программы при работе с большим массивом. Если число является системным кодом, скажем для символа EOF, то символическое представление делает вашу программу более переносимой; изменяется только определение EOF. Мнемоническое значение, легкость изменения, переносимость: все это делает символические константы заслуживающими внимания.
Легко ли этого достичь? Рискнем и рассмотрим простую функцию, т. е. макроопределение с аргументами.

            1.1.9. Макросы и параметры.
В языке С макросы могут иметь аргументы. Такие макросы необходимо определять вместе с параметрами, назначение которых аналогично аргументам функции: они определяют места подстановки фактических параметров. В следующем примере показано, как определить и использовать макрос с параметрами:

/* макроопределения */
#define READ_RESPONSE(с) scanf("%c",(&c))
#define MULTIPLY(х,у) ((х)*(у))
int main(void)
{
	char cresponse;
	int a = 10, b = 20;
…
…
…
	READ_RESPONSE(cresponse); /* раскрытие макроса */
	printf("%d",MULTIPLY(a,b));

В данном примере переменные х, у и с указывают места подстановки значений а, b и cresponse, соответственно. Два макроса, READ_RESPONSE and MULTIPLY, иллюстрируют различные способы вызова макросов в программе. К примеру, MULTIPLY подставляется в оператор printf(), а READ_RESPONSE используется самостоятельно.
Макроопределение с аргументами очень похоже на функцию, поскольку аргументы его заключены в скобки. Ниже приведено несколько примеров, иллюстрирующих, как определяется и используется такая «макрофункция». В некоторых примерах к тому же указаны возможные ловушки, поэтому читайте их внимательно.

/* макроопределение с аргументами */
#include<stdio.h>
#define SQUARE(x) x*x 
#define PR(x) printf("x = %d.\n" , x)
void main()
{
	int x = 4;
	int z;
	z = SQUARE(x);
	PR(z);
	z = SQUARE(2);
	PR(z);
	PR(SQUARE(x));
	PR(SQUARE(x + 2));
	PR(100/SQUARE(2));
	PR(SQUARE(++ x));
}



	z = SQUARE(2); // 16=4*4
	PR(z);
	PR(SQUARE(x)); // 4=2*2
	PR(SQUARE(x + 2)); // 16=4*4
	PR(100/SQUARE(2)); // 100=100/2*2
	PR(SQUARE(++ x)); // 30=++x{5}*++x{6}

Всюду, где в вашей программе появляется макроопределение SQUARE(x), оно заменяется на х*х. В отличие от наших прежних примеров при использовании этого макроопределения мы можем совершенно свободно применять символы, отличные от х. В макроопределении 'х' замещается символом, использованным в макровызове программы. Поэтому макроопределение SQUARE(2) замещается на 2*2. Таким образом, X на самом деле действует как аргумент. Однако, как вы вскоре увидите, аргумент макроопределения не «работает» точно так же, как аргумент функции. Вот результаты выполнения программы. Обратите внимание, что некоторые ответы отличаются от тех, которые вы могли бы ожидать.

z равно 16.
z равно 4.
SQUARE(x) равно 16.
SQUARE(x + 2) равно 14.
100/SQUARE(2) равно 100.
SQUARE(++ x) равно 30.

Первые две строки предсказуемы. Заметим, однако, что даже внутри двойных кавычек в определении PR переменная замещается соответствующим аргументом. ВСЕ аргументы в этом определении замещаются.
Третья строка представляет интерес:

PR(SQUARE(x));

она становится следующей строкой:

printf(" SQUARE(x) равно %d.\n" , SQUARE(x));

после первого этапа макрорасширения. Второе SQUARE(x) расширяется, превращаясь в х*х, а первое остается без изменения, потому что теперь оно находится внутри двойных кавычек в операторе программы, и таким образом защищено от дальнейшего расширения. Окончательно строка программы содержит

printf(" SQUARE(x) равно %d.\n" , х*х);

и выводит на печать

SQUARE(x) равно 16.

при работе программы.
Давайте еще раз проверим то, что заключено в двойные кавычки. Если ваше макроопределение включает аргумент с двойными кавычками, то аргумент будет замещаться строкой из макровызова. Но после этого он в дальнейшем не расширяется, даже если строка является еще одним макроопределением. В нашем примере переменная х стала макроопределением SQUARE(x) и осталась им.
Теперь мы добрались до несколько специфических результатов, Вспомним, что x имеет значение 4. Это позволяет предположить, это SQUARE(x + 2) будет равно 6*6 или 36. Но напечатанный результат говорит, что получается число 14, которое, несомненно, никак не похоже на квадрат целого числа! Причина такого вводящего в заблуждение результата проста, и мы уже об этом говорили: препроцессор не делает вычислений, он только замещает строку. Всюду, где наше определение указывает на х, препроцессор подставит строку х + 2. Таким образом,

х*х становится х + 2*х + 2.

Единственное умножение здесь 2*х. Если х равно 4, то получается следующее значение этого выражения:

4 + 2*4 + 2 = 4 + 8 + 2 = 14.

Этот пример точно показывает очень важное отличие между вызовом функции и макровызовом. Вызов функции передает значение аргумента в функцию во время выполнения программы. Макровызов передает строку аргументов в программу до ее компиляции; это другой процесс, происходящий в другое время.
Можно ли ваше определение переделать так, чтобы SQUARE(x + 2) было равно 36? Конечно. Нам просто нужно больше скобок:

#define SQUARE(x) (х)*(х)

Тогда SQUARE(x + 2) становится (х + 2)*(х + 2), и мы получаем наше желанное умножение, так как перенесли скобки в строку замещения.
Однако это не решает всех наших проблем. Рассмотрим случаи, которые приводят к следующей строке на выходе:

100/SQUARE(2) превращается в 100/2*2
Вычисления следует вести слева направо, т. е.
(100/2)*2 или 50*2 или 100.

Эту путаницу можно исправить, определив SQUARE(x) следующим образом:

#define SQUARE(x) (x*x)

Это даст

100/(2*2), что, в конечном счете, эквивалентно 100/4 или 25.

Чтобы выполнить два последних примера, нам необходимо определение

#define SQUARE(x) ((x)*(x))

Это урок использования необходимого количества скобок для гарантии, что операции и соединения выполняются в правильном порядке.
Даже эти предосторожности не спасают последний пример от беды:

SQUARE(++ x) превращается в ++х* ++х

и х увеличивается дважды — один раз до умножения и один раз после:

++х* ++х = 5*6 = 30

(Так как порядок выполнения операций не установлен, то некоторые компиляторы превратят это в 6*5, но конечный результат будет тем же самым.)
Единственное лекарство в этом случае — не использовать ++х в качестве аргумента для макроопределения. Заметим, что ++х обычно работает как аргумент функции, так как ему присваивается значение 5, и затем это значение 5 передается функции.
Внешне использование макроса похоже на использование функции (из-за чего их иногда называют псевдофункциями). Поскольку, как отмечено выше, это все-таки разные объекты, принято имена макросов записывать прописными буквами.
По этой причине в качестве общего правила рекомендуется всегда заключать в скобки каждый параметр макроса. Кроме того, если вызов макроса может появляться в инструкциях, содержащих операторы приведения типа, например,

doubleValue = (double) SQUARE (x + 1);

то рекомендуется заключать в скобки все тело макроса:

#define SQUARE (x) ((х) * (х))

И последнее замечание по поводу использования макросов. Обычно в тексте программы дополнительные пробелы не являются значащими. Они служат только для удобства чтения кода. В случае с макросами это не так. Например, пробел между именем макроса и его параметрами может привести к изменению смысла макроса, как в следующем макроопределении:

#define BAD_MACRO (x) printf ("%d", x)

Оно будет раскрыто в следующую инструкцию:

(х) printf("%d", x);

Это приведёт к ошибке компиляции. Чтобы исправить ошибку, достаточно удалить лишний пробел между именем макроса и его параметром.

#define BAD_MACRO(x) printf("%d", x)

Если определение макроса не умещается на одной строке, оно может быть продолжено в последующих строках. Для продолжения макроопределения в следующей строке достаточно в конце текущей строки поставить знак '\'.
Например,

#define MAKEWORD(a, b) ((WORD) (((BYTE) (a)) \
	|(((WORD)((BYTE)(b))) << 8)))

В определении макроса могут участвовать другие макросы, то есть макросы могут быть вложенными. Следующий пример демонстрирует использование вложенных макросов:

#define PI 3.14159
#define SQUARE(x) ((x)*(x))
#define CIRCLE_AREA(x) (PI * SQUARE(x))

Макрос может быть аннулирован в любом месте программы с помощью директивы #undef. Например,

#include <iostream>
using namespace std;

//Макроопределение 
#define MULTIPLY(x, у) ((x)*(у))
int main()
{
	setlocale(LC_ALL, "Rus");
	int a = 2, b = 3;
	printf("%d", MULTIPLY(a, b));
#undef MULTIPLY(x, у)
	// Не закоментированный printf приведет к ошибке
	//printf("%d", MULTIPLY(a, b));

	getchar(); 	getchar();
	return 0;
}




            1.1.10. Сложности при раскрытии макросов.
При использовании макросов одни символы или лексемы буквально заменяются на другие. Фактический синтаксический анализ объявления макроса, выражения внутри него и оператора, где он вызывается, выполняется после процесса раскрытия макроса. Иногда это может привести к неожиданным результатам. Например: следующее макроопределение кажется совершенно правильным:

#define SQUAREIT(x) x * х

Предположим, что оператор вызывает его со значением, равным 5:

iresult = SQUAREIT(5) ;

Компилятор получает следующий оператор:

iresult =5 * 5;

На первый взгляд все выглядит правильно. Предположим, однако, что этот же самый макрос вызывается в следующем операторе:

iresult = SQUAREIT(x + 1);

Вместо

iresult = (х + 1) * (х + 1);

компилятор получит следующее:

iresult = х + (1 * х) + 1);

В качестве общего правила можно посоветовать всегда заключать в скобки каждый параметр, появляющийся в теле макроопределения, как это было показано при описании макросов READ_RESPONSE и MULTIPLY. Кроме того, если макровызов может выполняться в операции явного приведения типа, например в

dresult = (double)SQUAREIT(x + 1);

то лучше всего заключать в скобки все тело макроса:

#define SQUAREIT(x) ((x) * (х))

Для большинства современных компиляторов С дополнительные пробелы внутри стандартных операторов С не являются значащими. Это не относится к макроопределениям. Посмотрите внимательно на следующий пример и найдите ошибку:

/* неправильное макроопределение */
#define BAD_MACRO (ans) scanf("%d",(&ans))

Напомним, что при выполнении директивы #define препроцессор ищет строку поиска и заменяет ее строкой подстановки. Эти две строки разделены несколькими пробелами. При раскрытии приведенного описания компилятор получит следующее:

(ans) scanf("%d",(&ans));

Создан неправильный оператор. Проблема заключается в пробеле между именем макроса BAD_MACRO и (ans). Из-за этого пробела список параметров стал частью строки подстановки, а должен был быть на соответствующем месте в строке поиска. Для того чтобы исправить определение BAD_MACRO, нужно удалить лишний пробел:

#define BAD_MACRO(ans) scanf("%d",(&ans))

Для того чтобы определить степень вашего понимания проблем, встречающихся при использовании макросов, попробуйте предсказать результат следующих операторов:

int х = 5;
iresult = SQUAREIT(x++);

При использовании некоторых операций С, подобных инкременту (++) и декременту (--), ситуация становится не всегда предсказуемой. Результат приведенного выражения может оказаться равным 30, а не 25, как ожидалось; это вызвано тем, что различные реализации компиляторов С могут вычислять данное выражение различными способами. Например, при раскрытии синтаксиса макрос может выглядеть так:

/* iresult = х * х; */
iresult = 5*5;
или так
/* iresult = х * (х+1); */
iresult =5*6;

            1.1.11. Создание и использование собственных макросов.
При описании макросов могут использоваться другие макроопределения. Эта возможность может использоваться для улучшения читаемости текста программы. Для примера можно рассмотреть следующие последовательные макроопределения:

#define NL putchar('\n')
#define TAB putchar('\t')
#define F0RMAT1 NL, NL, TAB
#define F0RMAT2 NL, TAB, TAB
#define BEGIN_PROMPT FORMAT1,		printf("Want to begin?"); \
													printf("\nType 1 for yes, 0 for no")	
#define READ_RESPONSE F0RMAT2,scanf("%d", (&c) )
#define FORMAT_PRINT(ccontrol,ivalue, fvalue) \
							printf("\n%c\t%d\t%8.2f", (ccontrol), (ivalue), (fvalue))

Вместо того, чтобы включать в основную программу все операции, определенные в макросах, достаточно написать следующее:

int main(void)
{
	char cresponse;
	int ivalue = 23;
	float fvalue = 56.78;
…
…
…
	BEGIN_PROMPT;
	READ_RESPONSE(cresponse);
	FORMAT_PRINT(cresponse,ivalue,fvalue);

Читаемость текста программы улучшается, но нужно, однако, помнить о том, что при этом отключается автоматическая проверка типов, выполняемая компилятором, и возможны побочные эффекты, вызванные ошибками в синтаксисе вызывающих операторов.

            1.1.12. Макросы, поставляемые вместе с компилятором.
Комитет ANSI С рекомендовал, чтобы во всех компиляторах С были описаны пять специальных макросов без параметров. Название каждого макроса начинается и заканчивается двумя символами подчеркивания; это показано в следующей таблице:

Таблица. Предопределенные макросы ANSI
Макрос
Описание
__DATE__
Строка, представляющая в форме mmm.dd.yyyy дату создания данного файла
__FILE__
Имя текущего обрабатываемого файла
__LINE__
Номер текущей строки обрабатываемого файла
__STDC__
Определен, если установлен режим совместимости с ANSI С
__TIME__
Время начала обработки текущего файла в формате hh.mm.ss
__TIMESTAMP__
Строковая константа, представляющая собой дату и время последней модификации исходного файла в виде Ddd Mmm hh:mm:ss уууу (день месяц часы:минуты:секунды год)

Предопределенные макроопределения вызываются аналогично тем, которые описаны пользователем. К примеру, для печати на экране имени программы, даты и текущего номера строки можно использовать следующий оператор:

printf("%s I %s I Line number: %d", __FILE__ , __DATE__ , __LINE__);

Следующий пример демонстрирует использование этих макросов:

#include <iostream>
using namespace std;

char* Date = __DATE__;
char* Time = __TIME__;

int main()
{
	setlocale(LC_ALL, "Rus");
	FILE* file;
	//…
	printf("Дата создания %s, "
		"время создания %s\n", Date, Time);
	//…
	file = fopen("Ex.cpp","r+t");
	if (file = NULL){
		printf("Ошибка в вызове функции fopen() "
			"в файле %s, строка %d\n",
			__FILE__, __LINE__);

		getchar(); 	getchar();
		return 1;
	}
	else{
		printf("Вызов функции fopen() выполнен корректно "
			"в файле %s, строка %d\n",
			__FILE__, __LINE__);
		getchar(); 	getchar();
		return 0;
	}

	//…

	return 0;
}




            1.1.13. Выбор макроопределения или функции.
Многие задачи можно решать, используя макроопределение с аргументами или функцию. Что из них следует применять нам? На этот счет нет строгих правил, но есть некоторые соображения.
Макроопределения должны использоваться скорее как хитрости, а не как обычные функции: они могут иметь нежелательные побочные эффекты, если вы будете неосторожны. Некоторые компиляторы ограничивают макроопределения одной строкой, и, по-видимому, лучше соблюдать такое ограничение, даже если ваш компилятор этого не делает.
Выбор макроопределения приводит к увеличению объема памяти, а выбор функции — к увеличению времени работы программы. Так что думайте, что выбрать! Макроопределение создает «строчный» код, т. е. вы получаете оператор в программе. Если макроопределение применить 20 раз, то в вашу программу вставится 20 Строк кода. Если вы используете функцию 20 раз, у вас будет только одна копия операторов функции, поэтому получается меньший объем памяти. Однако управление программой следует передать туда, где находится функция, а затем вернуться в вызывающую Программу, а на это потребуется больше времени, чем при работе со «строчными» кодами.
Преимущество макроопределений заключается в том, что при их использовании вам не нужно беспокоиться о типах переменных (макроопределения имеют дело с символьными строками, а не с фактическими значениями). Так наше макроопределение SQUARE(X) можно использовать одинаково хорошо с переменными типа int или float.
Обычно программисты используют макроопределения для простых действий, подобных следующим:

#define MAX(X,Y) ( (X) > (Y) ? (X) : (Y))
#define ABS(X) ( (X) < 0 ? - (X) : (X))
#define ISSIGN(X) ((Х) == ' +' || (X) == ' ' ? 1 : 0

(Последнее макроопределение имеет значение 1 (истинно), если х является символом алгебраического знака.) Отметим следующие моменты:
    • В макроопределении нет пробелов, но они могут появиться в замещающей строке. Препроцессор «полагает», что макроопределение заканчивается на первом пробеле, поэтому все, что стоит после пробела, остается в замещающей строке.



    • Используйте круглые скобки для каждого аргумента и всего определения. Это является гарантией того, что элементы будут сгруппированы надлежащим образом в выражении, подобном

forks = 2*MAX(guests + 3, last);

    • Для имен макрофункций следует использовать прописные буквы. Это соглашение не распространяется так широко, как соглашение об использовании прописных букв для макроконстант. Применение их предостережет вас от возможных побочных эффектов макроопределений.

Предположим, что вы разработали несколько макрофункций по своему усмотрению. Должны ли вы их переопределять каждый раз, когда пишете новую программу? Нет, если вы вспомните о директиве #include. Теперь рассмотрим ее.

        16.4. Директивы препроцессора.
На практике имеется 12 команд препроцессора, называемых иногда директивами. Они перечислены в следующей таблице. Две директивы из 12 вам уже знакомы — #include и #define.

#include	#define	#ifdef	#endif
#undef	#ifndef	#if	#else
#elif	#line	#error	#pragma

Напомним, что препроцессор С обрабатывает исходный файл перед тем, как компилятор транслирует программу в объектный код. Выбирая правильные директивы, можно создать более эффективные заголовочные файлы, решить некоторые проблемы программирования и предотвратить наложения объявлений при наличии множества файлов.
Эти директивы обычно используются при программировании больших модулей. Они позволяют приостановить действие более ранних определений и создать файлы, каждый из которых можно компилировать по-разному.
Директивы препроцессора представляют собой команды компилятору, которые позволяют управлять компиляцией программы и сделать ее код более понятным. Все директивы начинаются с символа #. Перед начальным символом # и вслед за ним могут располагаться пробелы. Директивы обрабатываются во время первой фазы компиляции специальной программой - препроцессором.


            1.1.14. Директива #define.
Директива #define позволяет определить некоторый идентификатор или связать его с некоторой последовательностью лексем. В последнем случае он служит для определения макроса. Макросы мы рассмотрим чуть позже, а здесь приведем пример использования директивы #define для определения некоторого идентификатора или символической константы:

#define _cplusplus

После того, как символическая константа определена в данном файле, она может быть использована в других директивах препроцессора. Отменить определение символической константы можно с помощью директивы

#undef

Например:

#undef _cplusplus

            1.1.15. Директива #include.
Когда препроцессор «распознает» директиву #include, он ищет следующее за ней имя файла и включает его в текущий файл. Директива имеет вид:

#include <header_name>
#include "header name"
#include macro identifier
#include <stdio.h> имя файла в угловых скобках
#include "mystuff.h" имя файла в двойных кавычках

Здесь header_name должно быть именем файла с расширением или именем заголовка в новом стиле. Традиционно используется расширение .h или .hpp. Кроме того, в header name может указываться путь к файлу. Препроцессор удаляет директиву #include из текста файла с исходным кодом и направляет содержимое указанного в ней файла для обработки компилятором. Если указан путь к файлу, компилятор ищет его в указанном каталоге. Первая и вторая форма синтаксиса различаются используемым компилятором алгоритмом поиска файла, если полный путь к нему не задан. Форма <header_name>, в которой имя заголовочного файла задается в угловых скобках, указывает компилятору, что заголовочный файл следует искать в подкаталоге \include компилятора. Форма "header_name", в которой имя заголовочного файла задается в двойных кавычках, указывает, что заголовочный файл следует искать в текущем каталоге, затем - в подкаталоге \include компилятора.
Первая и вторая версии не подразумевают никакого раскрытия макроса. В третьей версии предполагается, что существует макроопределение, которое раскрывается в допустимое имя заголовочного файла.
В операционной системе UNIX угловые скобки сообщают препроцессору, что файл следует искать в одном или нескольких стандартных системных каталогах. Кавычки говорят ему, что сначала нужно смотреть в вашем каталоге (или в каком-то другом, если вы определяете его именем файла), а затем искать в «стандартных» местах.

#include <stdio.h> ищет в системном каталоге
#include "hot.h"ищет в вашем текущем рабочем каталоге
#include "/usr/biff/p.h" ищет в каталоге /usr/biff

В типичной микропроцессорной системе эти две формы являются синонимами, и препроцессор ведет поиск на указанном диске.

#include "stdio.h" ищет на стандартном диске
#include < stdio.h> ищет на стандартном диске
#include "a:stdio.h" ищет на диске а

Зачем включают файлы? Потому что они несут нужную вам информацию. Файл stdio.h, например, обычно содержит определения EOF, getchar() и putchar(). Две последние функции определены как макрофункции.
По соглашению суффикс .h используется для «заголовочных» файлов, т. е. файлов с информацией, которая располагается в начале вашей программы. Заголовочные файлы обычно состоят из операторов препроцессора. Некоторые файлы, подобно stdio.h, включены в систему, но вы можете создать и свой собственный.

    2. Заголовочные файлы.
Предположим, например, что вам нравится использовать булевы переменные, т. е. вместо того чтобы иметь 1 как «истину» и 0 как "ложь", хотели бы использовать слова TRUE и FALSE. Можно создать файл, названный, скажем, bool.h, который содержал бы эти определения:

/* файл bool.h */
#define BOOL int;
#define TRUE 1
#define FALSE 0

Вот пример программы, использующей этот заголовок:

/* считает пустые символы */
#include <stdio.h>
#include <BOOL.h>
main()
{
	int ch;
	int count = 0;
	BOOL whitesp();
	while ( (ch = getchar() ) != EOF)
		if ( whitesp(ch) )
			count++ ;
	printf(" There is  %d empty symbols\n", count);
	/*Имеется %d пустых символов*/
}

BOOL whitesp(c)
char c;
{
	if(c==' '||с==' \n'||с ==' \t')
		return(TRUE);
	else
		return(FALSE);
}

Замечания по программе.
    • Если две функции в этой программе ('main()' и 'whitesp()') следовало скомпилировать раздельно, то нужно было бы использовать директиву #include "bool.h" с каждой из них.
    • Выражение if (whitesp(ch)) аналогично if (whitesp(ch)) == TRUE, так как сама функция whitesp(ch) имеет значение TRUE или FALSE.
    • Мы не создали новый тип BOOL, так как BOOL уже имеет тип int. Цель наименования функции BOOL — напомнить пользователю, что функция используется для логических вычислений (в противоположность арифметическим).
    • Использование функции в предусматриваемых логических сравнениях может сделать программу яснее. Она может также сэкономить наш труд, если сравнение встречается в программе более одного раза.
    • Мы могли бы использовать макроопределение вместо функции для задания whitesp().

Многие программисты разрабатывают свои стандартные заголовочные файлы, чтобы использовать их в программах. Некоторые файлы могут создаваться для специальных целей, другие можно использовать почти в каждой программе. Так как включенные файлы могут содержать директивы #include, можно, если хотите, создать сжатый, хорошо организованный заголовочный файл. Рассмотрим этот пример:

/* заголовочный файл mystuff.h*/
#include < stdio.h>
#include "bool.h"
#include "funct.h"
#define YES 1
#define NO 0

Во-первых, мы хотим напомнить вам, что препроцессор языка Си распознает комментарии, помеченные /* и */, поэтому мы можем включать комментарии в эти файлы.
Во-вторых, мы включили три файла. По-видимому, третий содержит некоторые макрофункции, которые используются часто.
В-третьих, мы определили YES как 1, тогда как в файле bool.h мы определили TRUE как 1. Но здесь нет конфликта, и мы можем использовать слова YES и TRUE в одной и той же программе. Каждое из них будет заменяться на 1.
Может возникнуть конфликт, если мы добавим в файл строку

#define TRUE 2

Второе определение вытеснило бы первое, и некоторые препроцессоры предупреждали бы вас, что TRUE переопределено.
Директива #include не ограничивается заголовочными файлами. Если вы записали нужную функцию в файл sort .с, то можно использовать

#include "sort.c"

чтобы скомпилировать его совместно с вашей текущей программой.
Директивы #include и #define являются наиболее активно используемыми средствами препроцессора языка Си. Рассмотрим более сжато другие его директивы.

    3. Правильное использование заголовочных файлов.
Поскольку заголовочные файлы состоят из синтаксически правильных символьных (ASCII) текстов программ на C/C++ и могут включаться в другие файлы в тех местах, где использована директива #include, многие начинающие программисты используют их не по назначению. Иногда эти файлы некорректно используются для описания целых функций или наборов функций. Хотя при этом компилятор не выдает никаких сообщений, логическая структура программы нарушается.
Заголовочные файлы применяются для описания объявлений, используемых совместно несколькими исходными файлами; они централизованно хранят объявления всех внешних переменных, прототипы функций, определения классов, структур, объединений, перечисляемых типов и встраиваемых функций. Переменные, функции и классы должны объявляться в файлах при помощи заголовочных файлов и директив #include.
Таким образом, устраняются два источника ошибок. Во-первых, гарантируется, что все файлы содержат одни и те же объявления. Во-вторых, если некоторое объявление нужно обновить, то необходимо сделать только одну замену в заголовочном файле. Исчезает вероятность того, что данное объявление в каком-нибудь отдельном файле осталось не обновленным. Часто в заголовочные файлы входят следующие компоненты:
    • Директивы препроцессора
    • Объявления констант const
    • Прототипы функций
    • Определения typedef
    • Определения структур
    • Перечисляемые типы
    • Внешние ссылки extern

При разработке заголовочных файлов нужно проявлять некоторую осторожность. Предусматриваемые объявления должны быть логически связаны друг с другом. На компиляцию заголовочного файла требуется время, и, если этот файл слишком большой или содержит очень много несвязанных элементов, то издержки в виде увеличения времени компиляции могут поставить под сомнение целесообразность его использования.
Второй важный момент — это то, что заголовочный файл никогда не должен содержать нестатических определений. Если два файла в одной программе будут включать некий заголовочный файл, имеющий внешнее определение, то большинство редакторов связей (компоновщиков) не станут обрабатывать программу из-за наличия многократно описанных символов (multiple defined symbols). Поскольку в заголовочных файлах часто применяются постоянные значения, то по умолчанию режим компоновки идентификаторов const — статический, и поэтому внутри этих файлах можно определять константы.
Заголовочные файлы обычно используются для объявления типов данных, констант, прототипов функций, определения структур и перечисленных типов, а также внешних ссылок используемых совместно несколькими файлами исходного кода. Подключение объявлений, содержащихся в заголовочном файле, к файлу исходного кода программы производится директивой #include. Тем самым гарантируется, что все файлы, к которым подключен заголовочный файл, содержат одинаковые объявления. С другой стороны, если нужно изменить некоторое объявление, это достаточно сделать в одном месте - в соответствующем заголовочном файле. Реально осуществляемые проекты могут быть достаточно сложны. В них бывает трудно отследить повторное подключение заголовочного файла, которое может произойти неявно. Для предотвращения многократных включений заголовочного файла используется стандартный прием, основанный на комбинации директив препроцессора. Рассмотрим пример:

#ifndef _HEADERFILENAME_
	#define _HEADERFILENAME_
	//текст заголовочного файла
#endif // _HEADERFILENAME_

В этом примере в начале заголовочного файла проверяется, не объявлена ли уже символическая константа _HEADERFILENAME_ и, если - нет (это означает, что данный заголовочный файл еще не подключен), то эта символическая константа объявляется. Затем идет остальной текст заголовочного файла. Последняя строка этого файла содержит директиву #endef, закрывающую объявления, начатые директивой #ifndef.

    4. Более эффективное использование заголовочных файлов.
Эффективность компиляции заголовочных файлов можно повысить, если использовать комбинации директив препроцессора. Лучше всего это показать на примере:

#ifndef _INC_IOSTREAM
#define _INC_IOSTREAM
#if !defined(_INC_DEFS )
#include <_defs.h>
#endif
#if !defined(_INC_MEM )
#include <mem.h> // для доступа к memcpy и NULL
#endif
#endif /* !_INC_IOSTREAM */

Перед тем как рассматривать отдельные операторы в данном примере, необходимо сказать, что при первом проходе компилятор строит таблицу символов. В частности, элементами такой таблицы являются псевдоимена заголовочных файлов. Использование псевдоимен позволяет компилятору отличать один символ от другого. Транслятор С добавляет в начало этих символов подчеркивание.
При компиляции проще всего управлять видимостью файла заголовков, если заключить код внутри его в следующие комбинации из трех операторов:

#ifndef _INC_myheader
#define _INC_myheader /* начало видимости _INC_MYHEADER */
...
...
...
#endif /* окончание условной видимости _INC_MYHEADER */

Это же самое было сделано в предыдущем примере, где вместо _INC_MYHEADER использовался параметр _INC_IOSTREAM. Первый раз, когда компилятор включает данный заголовочный файл, параметр _INC_IOSTREAM не определен. Этот фрагмент кода включается, после чего становятся видимыми все вложенные операторы. Начиная с данного момента, любые дополнительные операторы #include <iostream.h>, находящиеся в других файлах, использующихся для создания исполняемого модуля, будут обходить вложенный код.

    5. Новый стиль заголовков
Исторически так сложилось, что в языке C++ при подключении заголовочных файлов использовался тот же синтаксис, что и в языке С для совместимости с разработанным на тот момент программным обеспечением. Однако при стандартизации языка этот стиль был изменен и теперь вместо заголовочных файлов (как это было в С) указываются некоторые стандартные идентификаторы, по которым компилятор сам находит необходимые файлы. Предопределенные идентификаторы представляют собой имя заголовка в угловых скобках без указания расширения (.h). Ниже приводится пример включения заголовков в стиле C++:

#include <iostream>
#include <stdlib>
#include <new>

Помимо этого, для включения в программу библиотек функций языка С в соответствии с новым стандартом заголовок преобразуется следующим образом: отбрасывается расширение .h и к имени заголовка добавляется префикс с. Таким образом, например, заголовок <string.h> заменяется заголовком <cstring>. Если же используемый компилятор не поддерживает объявления заголовков в новом стиле, можно по-прежнему использовать заголовки в стиле языка С, хотя это и не рекомендуется стандартом C++.

    6. Предварительная компиляция заголовочных файлов.
Правильное использование заголовочных файлов позволяет увеличить скорость компиляции программы; для этой же цели служат предварительно компилированные заголовочные файлы. Предварительная компиляция наиболее удобна тогда, когда оттранслированный и не меняющийся фрагмент программы используется вместе с другим фрагментом, находящимся в стадии проектирования.
Предварительно компилированный заголовочный файл (.РСН) получается при запуске компилятора с опцией /Yc. Синтаксис следующий:

/Ycyourfile

Пробелы между опцией /Yc и именем файла yourfile не допускаются. При наличии ключа /Yc компилятор транслирует весь исходный файл, включая все заголовочные файлы. Предварительно компилированный файл запоминается с именем yourfile, совпадающим с названием исходного файла, и расширением .РСН.
Для автоматического создания и использования предварительно компилированных заголовочных файлов достаточно выбрать меню Options|Compiler options и щелкнуть на опциях Precompiled Headers и Automatic Use of Precompiled Headers.

    7. Файлы limits.h и float.h.
Для того, чтобы создаваемые программы были переносимыми, согласно требованиям комитета ANSI C все компиляторы С документируют системно-зависимые диапазоны представления целых чисел и чисел с плавающей точкой. В табл. 14.1 перечислены находящиеся в файле limits.h общие определения, отвечающие требованиям комитета ANSI C.

Таблица. Значения, определенные в файле limits.h (ANSI C)

#define
Значение
Описание 
#define CHAR_BIT
8
Количество разрядов в типе char
#define SCHAR_MIN
(-127)
Минимальное значение signed char
#define SCHAR_MAX
127
Максимальное значение signed char
#define UCHAR_MAX
Oxff
Максимальное значение unsigned char
#define SHRT_MIN
(-32767)
Минимальное значение (signed) short
#define SHRT_MAX
32767
Максимальное значение (signed) short
#define USHRT_MAX
Oxfff
Максимальное значение unsigned short
#define INT_MIN
(-32767)
Минимальное значение (signed) int
#define INT_MAX
32767
Максимальное значение (signed) int
#define UINT_MAX
Oxfff
Максимальное значение unsigned int
#define LONG_MIN
(-2147483647)
Минимальное значение (signed) long
#define LONG_MAX
2147483647
Максимальное значение (signed) long
#define ULONG_MAX
Oxffffffff
Максимальное значение unsigned long
#define CHAR_MIN
SCHAR_MIN
Минимальное значение char

Эти определения можно использовать в программе для того, чтобы гарантировать согласованность диапазонов используемых данных и указанных типов. Например, целое число в системе VAX занимает 4 байта, а в РС-совместимом компьютере только 2. Одно из решений данной проблемы — следующее:

if (PROGRAM_NEEDED_MAX > INT_MAX)	// требуемое максимальное значение
	pvoid = new llong_storage;	// значение long
else
	pvoid = new iinteger_storage;	// значение int

В следующей таблице перечислены определения чисел с плавающей точкой, отвечающие требованиям комитета ANSI С.

Таблица Значения, определенные в файле float.h (ANSI С)

#define
Значение
Описание 
#define FLT_RADIX
2
Основание показателя
#define FLT_ROUNDS
1
Округление при сложении: до ближайшего
/* минимальное значение, при котором 1.0+FLT_EPSILON!=1.0*/
#define FLT_EPSILON 1.192092896e-07F
/* минимальное значение, при котором 1.0+DBL_EPSILON!=1.0*/
#define DBL_EPSILON 2.2204460492503131e-016
/* минимальное значение, при котором 1.0+LDBL_EPSILON!=1.0*/
#define LDBL_EPSILON 1.084202172485504434e-019L
#define FTL_DIG
6
Точность: количество десятичных цифр
#define DBL_DIG
15
Точность: количество десятичных цифр
#define LDBL_DIG
18
Точность: количество десятичных цифр
#define FLT_MIN
1.175494351e-38F
Min положительное значение 
#define DBL_MIN
2.2250738585072014e-308
Min положительное значение
#define LDBL_MIN
3.3621031431120935063e-4932L
Min положительное значение
#define FLT_MIN_EXP
(-125)
Min показатель с основанием 2
#define DBL_MIN_EXP
(-1021)
Min показатель с основанием 2
#define LDBL_MIN_EXP
(-16381)
Min показатель с основанием 2
#define FLT_MIN_10_EXP
(-10)
Min показатель с основанием 10
#define DBL_MIN_10_EXP
(-307)
Min показатель с основанием 10
#define LDBL_MIN_10_EXP
(-4931)
Min показатель с основанием 10
#define FLT_MAX
3.402823466e+38F
Max значение
#define DBL_MAX
1.7976931348623158e+308
Max значение
#define LDBL_MAX
1.189731495357231765e+4932L
Max значение
#define FLT_MAX_EXP
128
Max показатель с основанием 2
#define DBL_MAX_EXP
1024
Max показатель с основанием 2
#define LDBL_MAX_EXP
16384
Max показатель с основанием 2
#define FLT_MAX_10_EXP
38
Max показатель с основанием 10
#define DBL_MAX_10_EXP
308
Max показатель с основанием 10
#define LDBL_MAX_10_EXP
4932
Max показатель с основанием 10

            7.1.1. Директивы #ifdef и #endif.
Директива #ifdef позволяет проверить, определена ли символическая константа и, если – да, следующие за ней строки будут направлены для обработки компилятором. Она относится к так называемым условным директивам, поскольку проверяет выполнение некоторого условия и в зависимости от результата проверки изменяет процесс компиляции. Используемая совместно с данной (и другими условными директивами), директива #endif сообщает препроцессору о конце условного блока кода.

Приведем примеры использования этих директив:

#ifdef _DEBUG
	//Какая-то часть исходного кода,
	//которая должна выполняться в отладочной
	//версии программы
#endif

Другой случай использования этих директив, который вы часто можете встретить в стандартных заголовочных файлах это случай использования функций языка С. В этом случае необходимо изменить объявление функции, добавив к нему модификатор extern "С", запрещающий использование декорирования имей. Обычно это выглядит следующим образом:

#ifdef _cplusplus
	extern "С" {
#endif
	//Объявления заголовочного файла,
	//требующие запрета декорирования имен
#ifdef_clusplus
	}
#endif

Директивы #ifdef и #endif представляют собой две из нескольких условных директив препроцессора. Их можно использовать для выборочного включения в программу некоторых операторов. Директива #endif применяется со всеми условными командами препроцессора и означает конец условного блока. Например, если ранее было определено имя LARGE_CLASSES, то в следующем фрагменте программы описывается новое имя MAX_SEATS:

#ifdef LARGE_CLASSES
#define MAX_SEATS 100
#endif

Всякий раз, когда в программе на C++ используются стандартные функции С, директиву #ifdef можно применять для модификации объявления функции с тем, чтобы выполнялась необходимая внешняя компоновка extern "С”, запрещающая трансляцию имени функции. Обычно для этого используются следующие два фрагмента с директивами, обрамляющими компилируемый код:

/* использован в graph.h */
#ifdef 	cplusplus
extern "С" { /* позволяет использование в C++ */
#endif
/* объекты трансляции */
#ifdef 	cplusplus
}
#endif


Упомянутые нами директивы позволяют выполнять условную компиляцию. Вот пример.

#ifdef MAVIS

#include "horse.h" /* выполнится, если MAVIS определен */
#define STABLES 5

#else

#include "cow.h" /'выполнится, если MAVIS не определен */
#define STABLES 15

#endif

Директива ifdef сообщает, что если последующий идентификатор (MAVIS) определяется препроцессором, то выполняются все последующие директивы вплоть до первого появления #else или #endif. Когда в программе есть #else, то программа от #else до #endif будет выполняться, если идентификатор не определен.
Такая структура очень напоминает конструкцию if-else языка Си. Основная разница заключается в том, что препроцессор не распознает фигурные скобки { }, отмечающие блок, потому что он использует директивы #else (если есть) и #endif (которая должна быть) для пометки блоков директив.
Эти условные конструкции могут быть вложенными.
Директивы #ifdef и #if можно использовать с #else и #endif таким же образом. Директива #ifndef опрашивает, является ли последующий идентификатор неопределенным; эта директива противоположна #ifdef. Директива #if больше похожа на обычный оператор if языка Си. За ней следует константное выражение, которое считается истинным, если оно не равно нулю:

#if SYS == " IBM"
#include "ibm.h"
#endif

Одна из целей использования «условной компиляции» — сделать программу более мобильной. Изменяя несколько ключевых определений в начале файла, вы можете устанавливать различные значения и включать различные файлы для разных систем.

            7.1.2. Директива #undef.
Директива #undef сообщает препроцессору об отмене всех предыдущих определений для указанного идентификатора. В следующем примере для изменения значения константы MAX_SEATS используется уже знакомая директива #ifdef и #undef:

#ifdef LARGE_CLASSES
#undef MAX_SEATS 30
#define MAX_SEATS 100
#endif

Дополнительно можно заметить, что компилятор не выдаст ошибки, если будет попытка отменить имя, ранее не определявшееся; если некоторое имя было отменено, то его можно определить заново при помощи другой директивы #define.
Директива #undef отменяет самое последнее определение поименованного макроопределения.

#define BIG 3
#define HUGE 5
#undef BIG /* BIG теперь не определен */
#define HUGE 10 /* HUGE переопределен как 10 */
#undef HUGE /* HUGE снова равен 5 */
#undef HUGE /* HUGE теперь не определен */

Очевидно (мы надеемся), вы не будете компилировать файл, как в этом примере. Предположим, что у вас есть большой стандартный файл, определенный директивой #include, который вы хотели бы использовать, но для этого некоторые из его определений для одной из функций программы нужно будет временно изменить. Вместо того чтобы иметь дело с этим файлом, вы можете просто включить его, а затем окружить такую выделяющуюся функцию соответствующими директивами #define и #undef.
Или, предположим, что вы работаете с большой системой программ. Вы хотите задать макроопределение, но не уверены, использует ли ваше определение другие определения откуда-нибудь из другого места системы. В этом случае просто отмените ваше макроопределение в том месте, где оно вам больше не нужно, а оригинал этого макроопределения, если он есть, будет по-прежнему оставаться в силе для остальной части системы.

            7.1.3. Директива #ifndef.
Сходной с директивой #ifdef является директива #ifndef. Эта директива также проверяет существование указанного в ней идентификатора, однако следующие за ней строки кода передаются компилятору, если этот идентификатор не определен. Приведем пример ее использования:

#ifndef WINVER
	#define WINVER 0x0400
#endif

Несомненно, становится понятным принцип работы условных директив. По команде #ifndef препроцессор определяет отсутствие указанного идентификатора и выполняет некоторые действия. Следующий фрагмент кода взят непосредственно из файла stdio.h:

#ifndef _SIZE_T_DEFINED
	typedef unsigned int size_t;
	#define _SIZE_T_DEFINED
#endif

В данном случае в выполняемых по условию операторах используются директивы препроцессора typedef и #define. Этот фрагмент кода определяет тип size_t, который согласно требованию комитета ANSI С является возвращаемым типом для оператора sizeof().

            7.1.4. Директива #if.
В директиве #if также присутствует лексема defined. В следующем фрагменте показано как при помощи директивы #if и конструкции defined выполняются те же действия, которые требовали вложенных директив #ifndef и #ifdef:

#if defined(LARGE_CLASSES) && !defined (PRIVATE_LESSONS)
	#define MAX_SEATS 30
#endif

#ifdef LARGE_CLASSES
	#ifndef PRIVATE_LESSONS
		#define MAX_SEATS 30
#endif

Два этих примера дают один результат; однако, первый воспринимается быстрее. В директивах #ifdef и #ifndef возможно единственное условие проверки; директива #if в сочетании с defined позволяет использовать сложные выражения.

            7.1.5. Директива #else.
Директива #else применяется совместно с условными директивами и позволяет отделить часть кода, которая будет обрабатываться, если предыдущее условие не выполняется. Например:

#ifdef __FLAT__
	#include <win32\windowsx.h>
#else
	#include <win16\windowsx.h>
#endif

Применение директивы #else достаточно очевидно. Предположим, что некоторая программа переносится с компьютера VAX на PC. Для целых чисел VAX отводит 4 байта или 32 бита, а в PC выделяется только 2 байта или 16 бит. Следующий фрагмент кода, использующий директиву #else, обеспечивает одинаковый размер целых чисел в обеих системах:

#ifdef VAX_SYSTEM
	#define INTEGER short int
#else
	#define INTEGER int
#endif

Понятно, что при выполнении программы на компьютере VAX в ней должен быть определен идентификатор VAX_SYSTEM. Легко увидеть, что комбинации директив препроцессора дают интересные решения.

            7.1.6. Директива #elif.
Две другие условные директивы - #if и #elif - также используются для проверки условия. Имя последней из них является сокращением английских слов “else if”. Она позволяет проверить условие, альтернативное установленному в директиве #if. Приведем пример их использования:

#if _MSC_VER < 901
	//…
#elif _MSC_VER < 1001
	//...
#endif

При использовании условных директив нужно иметь в виду следующие правила:
    • для каждой директивы #if должна присутствовать соответствующая директива #endif;
    • директивы #elif и #else являются необязательными; если ни одно из выражений не истинно, компилируется секция кода, следующая за #else;
    • значение выражения должно быть целой константой;
    • в выражениях могут применяться операции сравнения =, >, >=, <,<=.

Директива #elif является сокращением от "else if"; она используется как альтернативный вариант при построении вложенных операторов #if. При помощи следующих операторов определяется какой размер класса определен и однозначно задается макрос BILL:

#if defined (LARGE_CLASSES)
		#define BILL printf("\nCost per student $100.00.\n")
	#elif defined (PRIVATE_LESSONS)
		#define BILL printf ("\nYour tuition is $1000.00.\n")
	#else
		#define BILL printf("\nCost per student $150.00.\n")
#endif

Нужно заметить, что директивы не обязательно начинаются с первой позиции в строке. Отступы в командах препроцессора обеспечивают читаемость текста программы; это — одна из многих полезных рекомендаций, разработанных комитетом ANSI и принятых в С Visual C/C++.

            7.1.7. Директива #line.
Директива #line изменяет внутренний счетчик строк компилятора. Синтаксис ее использования следующий:

#line целая_константга <"имя_файла">

Если ваша программа состоит из частей, составленных из других программных файлов, часто оказывается полезным пометить такие части номерами строк исходного файла, из которого они взяты, а не последовательными номерами, которые получаются в результате в объединенном файле. Директива #line указывает, что следующий номер строки исходного кода начинается с целой константы из файла с заданным именем, указанной в этой директиве. Если имя файла однажды указано в этой директиве, все последующие директивы #line задают нумерацию относительно того же файла. По умолчанию нумерация осуществляется относительно текущего файла. Макросы раскрываются в аргументы директивы #line. Эта директива чаще всего используется различными утилитами, поставляемыми с компилятором. Приведем пример использования этой директивы:

//Исходный файл В
#line 1
void AnotherFunc()
{
	…
}

//Исходный файл А
#include "SourceB"
void main()
{
	//…
	ANotherFunc();
}

В этом случае при включении в исходный файл кода из другого файла, нумерация его срок начинается с единицы, а не с очередного номера в файле А.
Директива #line отменяет автоматическую нумерацию строк, выполняемую компилятором; она может помочь при отладке программы. Предположим, что в файл из 400 строк вставлена процедура длиной 50 строк. Все внимание уделяется ошибкам, которые могут возникнуть в этом объединенном коде.
Обычно компилятор начинает нумерацию с начала файла. Если возникла ошибка, то компилятор печатает сообщение с указанием номера строки — к примеру, 289. Где расположена эта ошибка в этом объединенном файле?
Если же включить директиву #Iine в начало только что добавленной процедуры, то компилятор выдаст номер ошибочной строки относительно начала функции:

#line 1
int imy_mergefunction(void)
{
...
...
...
}

            7.1.8. Директива #error.
Директива #error указывает компилятору, что нужно напечатать сообщение об ошибке и прекратить компиляцию. Обычно ее используют внутри условных директив. Вот типичный пример ее использования:

#if!defined(MYNAME)
	#error Должна быть определена \
	константа MYNAME
#endif

#include <stdio.h>
#include <iostream>
using namespace std;

//Макроопределение 
#define MU 13
int main()
{
	setlocale(LC_ALL, "Rus");
	int a = 2, b = 3;
	printf("%d", MU);
#undef MU
#if!defined(MU)
	#error Должна быть определена константа MU
#endif

	getchar(); 	getchar();
	return 0;
}



Директива #еrrоr указывает компилятору на сообщение об ошибке, определенное пользователем и которое можно использовать для расширения собственных возможностей компилятора по расшифровке ошибок и выдаче сообщений. После того, как компилятор встречает директиву #error, он ищет в остальной части программы синтаксические ошибки, но объектный файл не создает. В следующем примере печатается предупреждение, если значение _CHAR_UNSIGNED не определено:

#if !defined( _CHAR_UNSIGNED )
	#error /J option required. /* нужна опция /J */
#endif

            7.1.9. Директива #pragma.
Директива #pragma определяет зависящие от реализации команды компилятора. Компилятор Visual C/C++ поддерживает следующие указания:

alloc_text	auto_inline	check_pointer
check_stack	code_seg	comment
data_seg	function	hdrstop
inline_depth	inline_recursion	init_seg
intrinsic	linesize	loop_opt
message	native_caller	optimize
pack	page	pagesize
skip	subtitle	title
warning

Директива #pragma позволяет управлять возможностями компилятора. Синтаксис ее использования следующий:

#pragma имя_директивы

К сожалению, имя директивы зависит от реализации этой директивы в компиляторе. Поэтому вам придется изучить документацию, относящуюся к конкретному компилятору. В таблице приведены несколько имен_директив, встречающихся во всех известных нам компиляторах, и их назначение.

Таблица. Имена директив и их назначение
Директива
Описание
Argsused
Подавляет предупреждение о неиспользуемом параметре для функции, следующей за директивой.
Hdrfile
Задает компилятору имя файла перекомпилированных заголовков. Синтаксис:

#pragma hdrfile "filename"

Здесь filename - имя файла перекомпилированных заголовков.
Hdrstop
Сообщает компилятору, что следующая за ней информация не включается в файл перекомпилированных заголовков.
Option
Директива предписывает компилятору использовать указанные в ней опции при компиляции следующего за ней кода.
Warn
Директива предписывает компилятору разрешить или подавить вывод предупреждающего сообщения. Синтаксис:

#pragma warn [+I - I.]xxx,

где xxx трехбуквенный идентификатор предупреждающего сообщения, используемый в командной строке с опцией -w. Если ему предшествует "+". то выдача сообщения разрешается, если "-", то запрещается. Если номеру сообщения предшествует точка, для него восстанавливается исходное состояние.
Warning
Директива предписывает компилятору разрешить или подавить вывод предупреждающего сообщения. Синтаксис:

#pragma warning(enable:хххх)
#pragma warning(disable:хххх)
#pragma warning(default:xxxx)

Первая форма разрешает вывод предупреждающего сообщения компилятора с номером хххх, вторая - запрещает, третья - восстанавливает поведение компилятора по умолчанию.

Приведем примеры использования этой директивы:

#if defined (__STDC__)
	//Следующая директива запрещает
	//использование ключевых слов,
	//не входящих в стандарт ANSI
	#pragma warn -nak
#endif

//…
#ifndef _DEBUG
	//Следующая директива запрещает
	//вывод предупреждающего сообщения
	//с номером 4701
	#pragma warning(disable:4701)
#endif

//…
#ifndef DEBUG
	#if defined (__STDC__)
		#pragma warn.nak
#endif

        16.5. Оператор defined.
В директивах #if и #elif может применяться оператор defined. Он позволяет проверить, был ли перед этим определен идентификатор или макрос с указанным в этом операторе именем. Можно также применять операцию логического отрицания (!) для проверки того, что идентификатор или макрос не определен. Следующий пример демонстрирует это:

#if defined(_MFC_COMPACT_)
	#if !defined(_BORLANDC_)
		#undef _ANONYMOUS_STRUCT
	#else
		#define _ANONYMOUS_STRUCT
	#endif
#endif

Могут использоваться и более сложные условия для проверки:

#if defined(__LARGE__) || \
	defined(__HUGE__) || \
	defined(__COMPACT__)
	typedef long ptrdiff_t;
#else
	typedef int ptrdiff_t;
#endif

Приведем пример использования директивы #elif:

#if defined (__OS2__)
	#define _RTLENTRY __stdcall
	#define _USERENTRY __stdcall
#elif defined (__WIN32__)
	#define _RTLENTRY __cdecl
	#define _USERENTRY __cdecl
#else
	#define _RTLENTRY __cdecl
	#define _USERENTRY __cdecl
#endif

        16.6. Условная компиляция.
Не всегда команды препроцессора располагаются только в заголовочных файлах; их можно использовать в исходном коде для более эффективной компиляции. Найдите небольшое отличие в следующем фрагменте программы (подсказка — размер исполняемой программы):

/* компилируемый оператор if */
if(DEBUG_ON) {
	printf("Entering Example Function");
	printf("First argument passed has a value of %d",ifirst_arg);
}
/* оператор сравнения */
#if defined(DEBUG_ON)
	printf("Entering Example Function");
	printf("First argument passed has a value of %d",ifirst_arg);
#endif

Первый оператор if компилируется всегда — это означает, что отладочная информация постоянно присутствует в исполняемом файле программы, отражаясь на его размере. Но что делать, если нежелательно продавать программу, имеющую вспомогательный код, нужный лишь на этапе проектирования? Для этого достаточно выполнить условную трансляцию этих избыточных операторов.
Во второй части фрагмента показана выборочная компиляция кода с использованием директивы #if defined. При отладке программы нужно определить DEBUGON; при этом компилятор будет видеть операторы, заключенные между командами #if...#endif. Однако, когда окончательная версия программы готова, определение параметра DEBUG_ON удаляется. После этого компилятор перестает транслировать отладочные операторы и размер исполняемой программы уменьшается.
На простом примере можно увидеть, как при помощи директив #if...#endif отключать трансляцию двух операторов printf(). Скопируйте предыдущий фрагмент в какую-нибудь программу на С, не выполняющую никаких действий. Включите все необходимые заголовки и атрибуты (#include, main(). { и так далее). Не определяйте DEBUG_ON. Скомпилируйте программу и убедитесь в том, что отсутствуют ошибки. После этого удалите оператор #include <stdio.h> и повторите трансляцию.
Теперь компилятор остановится на первом операторе printf(), заключенном в блоке операторов if...printf() Напечатается сообщение "Function 'printf’ should have a prototype." (Функция 'printf’ должна иметь прототип.).
Этого и следовало ожидать, поскольку оператор printf () внутри If всегда виден для компилятора. После этого достаточно удалить или закомментировать блок операторов if...printf() и повторить компиляцию. Компилятор не будет реагировать на операторы printf(), заключенные между директивами препроцессора #if...#endif — он их не увидит. Эти операторы станут видимыми на этапе компиляции только тогда, когда будет определен параметр DEBUG_ON.

#include <stdio.h>
#include <iostream>

#define MY_TEST1 1
#define MY_TEST2 2
int ifirst_arg = 13;

using namespace std;

int main()
{
/* оператор сравнения */
#undef MY_TEST1
//#undef MY_TEST2
#if defined(MY_TEST1)
	printf("\nMY_TEST1 is defined (%d)", MY_TEST1);
	#if !defined(MY_TEST2)
		printf("\nMY_TEST2 is NOT defined");
	#else
		printf("\nMY_TEST2 is defined (%d)", MY_TEST2);
	#endif
#else
	printf("\nMY_TEST1 is NOT defined");
	#if defined(MY_TEST2)
		printf("\nMY_TEST2 is defined (%d)", MY_TEST2);
	#else
		printf("\nMY_TEST2 is NOT defined");
	#endif
#endif

#define MY_TEST3 3
int ifirst_arg = 1;

#undef MY_TEST3
#define MY_TEST3 4
/* компилируемый оператор if */
if(MY_TEST3)
	printf("\nMY_TEST3 is defined (%d)", MY_TEST3);
else
	printf("\nMY_TEST3 is NOT defined");

printf("\n");
system("pause");
return 0;
}



Подобным образом можно управлять видимостью различной информации — не только исполняемыми операторами.

#if defined(DEBUG_ON)
	/***********************************************/
	/* Следующий фрагмент программы реализует */
	/* достаточно сложный алгоритм, требующий */
	/* комментариев и вывода отладочной информации */
	/***********************************************/
	printf(" debug code goes here "); /* далее следует */
#endif /* отладочный код */

В данном примере имеется не только условный оператор для вывода отладочной информации, но и предусматриваются пояснительные комментарии. Некоторое дополнительное время, необходимое для написания условно-компилируемого кода, компенсируется простотой отладки программы и небольшим размером исполняемого кода.

        16.7. Дополнительные операции препроцессора.
Существуют три операции, которые можно использовать только в директивах препроцессора: подстановка строки (#), конкатенация (##) и подстановка символа (#@).

            7.1.10. Операция подстановки строки (#).
Если перед параметром макроса используется символ #, то компилятор вместо значения этого параметра подставляет его имя. В результате имя аргумента преобразуется в строку. Эта операция необходима потому, что параметры не заменяются, если они входят в литеральную строку, записанную в макросе в явном виде. Следующий пример иллюстрирует синтаксис операции подстановки строки:

#define STRINGIZE(ivalue) printf(#ivalue " is: %d",ivalue)
...
...
...
int ivalue = 2;
	STRINGIZE(ivalue);

Результат работы макроса:

ivalue is: 2

Если перед параметром макроса указана операция подстановки символа (#), то компилятор при раскрытии макроса вместо параметра подставит его имя. Как и любая строка, результат этой операции может объединяться со смежными строками, если отделяется он них только пробелами. Рассмотрим пример:

#include <stdio.h>
#include <iostream>
using namespace std;

#define SHOWVAL(val)\
	printf(#val "= %d \n", (int)(val))

int main()
{
	setlocale(LC_ALL, "Rus");
	int icount = 10;
	//...
	SHOWVAL(icount);

	getchar(); 	getchar();
	return 0;
}

При выполнении программа выводит на экран:

icount = 10;




            7.1.11. Операция конкатенации (##).
Одно из применений операции конкатенации — динамическое создание имен переменных и макроопределений. Операция объединяет синтагмы, и, удаляя все пробелы, образует новое имя. Если операция ## используется в макроопределении, то она обрабатывается после подстановки параметров макроса, перед тем, как этот макрос проверяется на наличие каких-либо дополнительных операций. Например, в следующем примере показано, как создавать имена переменных с помощью команд препроцессора:

#define IVALUE_NAMES(icurrent_number) ivalue ## icurrent_number;
...
...
...
int IVALUE_NAMES(1);
Компилятор получит следующее объявление:
int ivalue1;

Заметим, что препроцессор удалил пробелы; поэтому ivalue1 не будет выглядеть как ivalue1. Эту операцию можно объединять с другими директивами препроцессора для получения сложных определений. В следующем примере операция конкатенации используется для создания имени макроопределения, по которому препроцессор вызывает соответствующий макрос:

#define MACRO1 printf("MACR01 invoked.")
#define MACR02 printf("MACR02 invoked.")
#define MAKE_MACRO(n) MACRO ## n
...
...
...
MAKE_MACRO(1);

Результат выполнения этого примера следующий:

MACRO1 invoked. // вызван MACR01

Операция конкатенации (или склейки) ## вызывает объединение двух строк в одну. Перед объединением строк удаляются разделяющие их пробелы. Если для полученной в результате склейки строки существует макроопределение, препроцессор выполняет раскрытие макроса. Например:

#define MACRO1 printf ("Вызов MACRO1.")
#define MACRO2 printf("Вызов MACRO2.")
#define CREATE_MACRO(n) MACRO ## n
//... CREATE_MACRO(1);

В результате раскрытия макроса препроцессором компилятор получит следующую инструкцию:

printf("Вызов MACRO1.");

Если операция конкатенации используется в макроопределении, то вначале препроцессор выполняет подстановку аргументов вместо формальных параметров, затем выполняет операцию конкатенации. После этого выполняются остальные операции макроопределения. Например:

#define DEFVAL(i) int var ## i
//…
DEFVAL(1);

В результате раскрытия макроса препроцессором компилятор получит следующую инструкцию:

int var1;

            7.1.12. Операция подстановки символа (#@).
Операция подстановки символа предшествует формальным параметрам в макроопределении. При этом фактический параметр рассматривается как отдельный символ, заключенный в простые кавычки. Например:

#define CHARIZEIT(cvalue) #@cvalue
...
...
...
cletter = CHARIZEIT(z);

Компилятор получит следующее выражение:

cletter = 'z';

        16.8. Обработка ошибок: perror().
Среди многих интересных функций, имеющих прототипы в файле stdio.h, есть функция с именем реrrоr(). Эта функция выводит в поток stderr системное сообщение о последней ошибке, произошедшей при вызове библиотечной процедуры. Для этого используются переменные errno и _sys_errlist, предопределенные в файле stdlib.h. Массив _sys_erriist представляет собой массив строк сообщений об ошибках. Переменная errno — это индекс массива строковых сообщений, который автоматически устанавливается равным номеру возникшей ошибки. Число элементов в массиве определяется другой константой, _sys_nerr, также определенной в файле stdlib.h.
Функция реrrоr() имеет единственный параметр — строку символов. Обычно передаваемый аргумент — это строка, идентифицирующая файл или функцию, где произошла ошибка. Использовать эту функцию просто; это показано в следующем примере:

/*14PERROR.C
Программа на С, демонстрирующая функцию perror(), имеющую прототип
в файле STDIO.H*/
#include <stdio.h>
void main(void)
{
	FILE *fpinfile;
	fpinfile = fopen("input.dat", "r");
	if (!fpinfile)
		/* Невозможно открыть input.dat в файле main() : */
		perror("Could not open input.dat in file main() :");
}

Печатается следующее сообщение:



        16.9. Модели памяти.
Компилятор Visual C/C++ поддерживает шесть стандартных моделей памяти — tiny (миниатюрная), small (малая), medium (средняя), compact (компактная), large (большая) и huge (гигантская) — а также пользовательскую модель, которая используется в тех приложениях, где имеются особые требования к хранению данных и кода. Тщательно выбирая подходящую модель памяти для приложения, можно улучшить степень использования системных ресурсов и скорость выполнения программы. Ниже кратко описываются отличительные особенности каждой из шести стандартных моделей памяти.
Существует ограниченное число задач, решение которых требует минимального доступа к системным ресурсам вычислительного средства. На практике чаще всего приходится учитывать особенности архитектуры компьютера с тем, чтобы разрабатываемое приложение было максимально гибким. Основные ограничения на использование системных средств ЭВМ накладывает организация памяти.
Память компьютеров на базе процессоров семейства Intel 80x86 представляется в виде сегментов или частей от 0 байт до 64 Кбайт.
Как известно, в состав процессора входят регистры - быстро доступные ячейки собственной памяти. Для различных арифметических операций используются регистры общего назначения: АН. AL, BH, BL, СН. CL, DH и DL, которые в случае необходимости могут группироваться в сдвоенные: АХ (из АН и AL), ВХ (из ВН и BL). СХ (из СН и CL) и DX (из DH и DL).
Доступ к ячейке оперативной памяти организован через обращение к значению сегмента и указание смещения внутри данного сегмента. Процессор имеет четыре сегментных регистра, посредством которых осуществляется манипулирование памятью:
    • CS (сегмент кода) предназначен для обеспечения адресации к сегменту, содержащему исполняемые программные коды;
    • DS (сегмент данных) используется ятя адресации глобальных и статических переменных;
    • ES (дополнительный сегментный регистр), как и DS. содержит сегментное значение для доступа к глобальным и статическим переменным, является вспомогательным регистром;
    • SS (сегмент стека) служит для адресации к сегментному значению стека программы и, как следствие, к локальным переменным;

При адресации памяти в DOS процессор преобразует значение сегментного регистра и смещения в линейный адрес. В случае работы в операционной системе Windows сегментный регистр служит в качестве селектора дескрипторной таблицы, содержащей действительный адрес.
К счастью, компиляторы ведущих фирм предусматривают так называемые расширения языка, помогающие обходить те или иные ограничения системы. В этой главе мы познакомимся с основными из их них.
Доступ к переменным или функциям в программе также осуществляется через сегментные регистры. В регистр DC заносится базовое значение, после чего процессору тем или иным способом передается значение смещения. Поскольку размер сегмента не должен превышать 64 Кбайт, очень вероятно, что в реальности коды или данные будут располагаться в различных сегментах. Таким образом, каждый раз при обращении к переменным, расположенным в различных сегментах, программе необходимо будет загружать в регистр DC новое значение сегмента. Совершенно очевидно, что для обращения к разным сегментам требуется гораздо больше времени, так как каждый раз приходится загружать новое базовое значение. В лучшем случае все данные или все коды программы будут умещаться в один единственный сегмент и для доступа к любой переменной или функции будет достаточно загрузить смещение лишь один раз. Однако в данном случае размер программы был бы ограничен величиной одного сегмента, то есть 64 Кбайтами. В настоящее время такое ограничение неприемлемо за редким исключением, да чаще всего и не нужно.
Для того чтобы имелась возможность выбора оптимальной конфигурации конечного программного продукта. C++ предлагает к использованию различные модели памяти. Модели памяти служат для управления выделением ресурсов при выполнении разработанного приложения. Существует шесть моделей памяти: Tiny, Small, Medium, Compact, Large и Huge.
DOS приложения могут использовать любую из перечисленных моделей, в то время программы, разработанные для функционирования в 16-разрядной ОС Windows (например, Windows 3.11) - только одну из четырех: Small, Medium, Compact или Large. В сущности, выбор одной из них задается определенным ключом компилятора, однако может меняться для той или иной функции или переменной опционально в программе (по мере надобности). Помимо определения требований, предъявляемых разрабатываемой программой к объему памяти, выбор определенной модели влияет на размер указателей, динамической памяти, а для DOS программ - еще и на размер области стека. В связи с вышеизложенным указатели бывают ближними и дальними.
Ближний указатель содержит только значение смещения, в то время как значение сегмента адреса находится в сегментном регистре. Этот тип указателей используется по умолчанию в моделях с ближней динамической памятью Tiny, Small и Medium. При этом сегментная часть адреса данных размещается в регистре СS. Программный код размером до 64 Кбайт применяет модель с короткими указателями кода (Tiny, Small или Compact), размещая сегментную часть адреса в регистре CS. Таким образом, функция или переменная будет доступна только в том сегменте кода, в котором она откомпилирована.
Дальние указатели содержат как сегментную часть адреса, так и смещение. Этот тип указателей используется по умолчанию в моделях памяти Compact, Large и Huge - для данных, и в Medium, Large и Huge - для кодов программы.
В модели Tiny в регистры CS, DS, SS и ES заносится одинаковое значение сегментной части адреса. Код программы, статические, динамические данные и стек в общей сложности могут занимать всего лишь 64 Кбайта. По умолчанию переменная типа указатель в такой модели памяти занимает два байта (ближний указатель) и содержит смещение внутри данного сегмента памяти. Очень небольшое число задач может решаться при использовании такой модели - ее применяют при существенном недостатке памяти.
Модель Small предусматривает код программы размером до 64 Кбайт (один сегмент) и еще один сегмент под статические, динамические данные и стек. Указатели в такой модели также занимают два байта и содержат смещение внутри используемого сегмента. Эта модель применяется для решения небольших и средних задач.
В модели Medium код разрабатываемого приложения может занимать до 1 Мбайта (1024 Кбайт), в то время как данные и стек размещаются в пределах одного сегмента. Таким образом, в коде программы используются дальние указатели, занимающие четыре байта. Адресация данных подразумевает использование ближних указателей (по два байта). Эту модель следует использовать при разработке больших приложений, оперирующих с небольшим количеством данных.
Модель Compact отводит под код программы один сегмент (до 64 Кбайт) и по одному сегменту под статические данные и стек. Для адресации в коде программы задействуют, в то время как адресация данных осуществляется посредством дальних указателей. Компактная модель разработке небольших и средних приложений, большого объема статических данных.
В модели Large код программы занимает до 1 Мбайта, а статические данные со стеком - по одному сегменту до 64 Кбайт. В модели используются дальние четырехбайтные указатели и для адресации кода и для адресации данных. Модель Large часто используют на практике при решении больших задач.
Модель Huge допускает превышение статическими данными объема 64 Кбайт. В остальном эта модель аналогична модели Large и использует четырехбайтные дальние указатели.

Таблица. Модели памяти 16-разрядных приложений

DOS
Модель
Код
Данные
Стек
Указатель по умолчанию
Tiny
код + данные + стек + динамическая память до 64 Кбайт
near
Small
64 Кбайт
данные + стек + динамическая память до 64 Кбайт
near
Medium
1 Мбайт
данные + стек + динамическая память до 64 Кбайт
near
Compact
64 Кбайт
64 Кбайт
64 Кбайт
fаr
Large
1 Мбайт
64 Кбайт
64 Кбайт
fаr
Huge
1 Мбайт
> 64 Кбайт
64 Кбайт
fаr
16-bit Windows EXE
Small
64 Кбайт
данные + стек + динамическая память до 64 Кбайт
near
Medium
1 Мбайт
данные + стек + динамическая память до 64 Кбайт
near
Compact
64 Кбайт
данные + стек до 64 Кбайт
fаr
Large
1 Мбайт
данные + стек до 64 Кбайт
far
16-bit Windows DLL
Small
64 Кбайт
64 Кбайт
__
far
Medium
1 Мбайт
64 Кбайт
—
far
Compact
64 Кбайт
64 Кбайт
—
far
Large
1 Мбайт
64 Кбайт
—
far
32-bit Windows
Flat
1 Гбайт
1 Мбайт
1 Мбайт 
far

Для изменения длины указателей, применяемой по умолчанию, используются модификаторы:

near - для генерирования компилятором ближних вызовов;
far - для генерирования дальних вызовов.

Следует понимать, что ближний указатель всегда может быть преобразован компилятором в дальний, однако дальний указатель не может быть преобразован в ближний. Синтаксис спецификаторов вызова имеет следующий вид:

тип near *имя_переменной;
тип far *имя_переменной;

что читается как "объявить указатель *имя_переменной типа 'тип' как ближний / дальний". Если же поместить модификатор дальнего или ближнего вызова между символом звездочка (*) и именем переменной, компилятор поймет такую запись в ином контексте и в результате объявит указатель на переменную в том же (near) или обязательно в другом (far) сегменте (то есть модификатор в этом случае влияет на месторасположение указателя, а не на его размер).
Необходимо отметить, что модификаторы в библиотеках компиляторов различных фирм могут в синтаксисе включать ведущие символы подчеркивания (один или два). Так модификаторы:

near
_nеar
__near

подразумевают одно и то же. В дальнейшем изложении данного материала нет жесткой привязки к какому-либо типу написания, однако, следует иметь этот факт в виду и руководствоваться при разработке приложений технической документацией к конкретному компилятору. Кроме того, модификаторы с одним ведущим символом подчеркивания зачастую используются компилятором для внутренних нужд, и пользоваться ими не рекомендуется.

Ниже приводится несколько вариантов применения модификатора:
// Символьная переменная в сегменте
// по умолчанию:
char А = 'а';
// Символьная переменная в дальнем
// сегменте данных:
char far В = 'b';
// Указатель на символьную переменную,
// размешается в сегменте по умолчанию:
char* рА = &A;
// Дальний указатель на символьную
// переменную А, размещается
// в сегменте данных по умолчанию:
char far* pfA = &A;
// Обычный указатель на символьную
// переменную, размещаемый в дальнем
// сегменте данных:
char* far pBl = &B;
// Дальний указатель на символьную
// переменную, размещаемый в дальнем
// сегменте данных:
char far* far pB2 = &B;

            7.1.13. Модель tiny.
При использовании модели памяти tiny создаются программные файлы с расширением .СОМ. Такие программы содержат один 64 Кб сегмент для кода и данных. Доступ ко всем объектам кода и данных осуществляется при помощи near (ближних) адресов. Эти программы не могут использовать библиотеки, содержащие far-функции, например, библиотеки графики. Файлы с расширением .СОМ можно запускать только под DOS. Кроме этого, компилятор Microsoft Visual C/C++ не создает р-код для модели tiny. Программы с этой моделью памяти используют память аналогично описанным в следующем параграфе программам с моделью памяти small. Однако, при компоновке tiny-приложений объектный файл связывается с библиотекой CRTCOM.LIB; в результате исполняемый файл получается с расширением .СОМ, а не .ЕХЕ.

            7.1.14. Модель small.
Когда выбрана опция small, программа может иметь два сегмента: один для данных и один для кода. После компиляции программы с моделью памяти small получают расширение .ЕХЕ. Эта опция используется по умолчанию, когда не указана другая модель памяти. Размер обоих сегментов — данных и кода — ограничен 64 Кб. Длина программы с моделью памяти small не может превышать 128 Кб. По умолчанию в таких программах используются near-адреса как для кода, так и для данных.

            7.1.15. Модель medium.
Программа с моделью памяти medium может иметь один сегмент для данных, но множество сегментов — для кода. Поэтому такие программы могут содержать более 64 Кб кода, но не более 64 Кб данных. По мере необходимости программный код может занимать столько места, сколько необходимо, однако при этом размер всего блока данных не должен превышать 64 Кб. По умолчанию в программах с моделью памяти medium используются far (дальние) адреса для кода и near (ближние) адреса — для данных. Установки по умолчанию можно отменить при помощи ключевого слова _near.

            7.1.16. Модель compact.
При использовании модели памяти compact программы могут иметь несколько сегментов данных, но только один сегмент кода. Эта модель памяти наиболее подходит для тех приложений С, у которых большой объем данных, но короткий код. Модель памяти compact позволяет данным занимать столько места и сегментов, сколько нужно. По умолчанию в программах с этой моделью памяти используются near-адреса для кода и far-адреса для доступа к данным. В приложении можно переопределить эти установки при помощи ключевого слова	_near или _huge для данных и ключевого слова _far для кода.

            7.1.17. Модель large.
Как нетрудно догадаться, приложения с моделью памяти large могут иметь по несколько сегментов для кода и данных. Однако, размер отдельного объекта данных не должен превышать 64 Кб. Эта модель памяти подходит для основных программ, работающих с большими объемами данных. По умолчанию в программах с моделью памяти large far-адреса используются как для кода, так и для данных. Эти установки можно переопределить в приложении при помощи ключевого слова _near или _huge для данных и ключевого слова _far для кода.

            7.1.18. Модель huge.
Модели памяти huge и large схожи. Главное отличие заключается в том, что при использовании модели huge снимаются ограничения на размер отдельных объектов данных. Однако, имеются ограничения на размер элементов массива, если этот массив больше, чем 64 Кб. Элементы массива не могут пересекать границы сегментов — это гарантирует эффективную адресацию для каждого элемента. Поэтому размер отдельного элемента массива не может превышать 64 Кб. Кроме того, если массив больше 128 Кб, то размер каждого элемента в байтах должен быть равным степени числа 2. Однако, если размер массива равен 128 Кб или меньше, то его элементы могут иметь любую длину до 64 Кб максимум. Необходимую модель памяти можно устанавливать непосредственно в среде разработки. Для этого достаточно выбрать пункт главного меню Option Language Options, а затем указать С or C++ Compiler options.... Следующее диалоговое окно будет иметь пункт Memory Model. Для выбора нужно щелкнуть по стрелке вниз.
Если проводятся некоторые арифметические операции над указателями, они изменяют только значение смещения, оставляя значение сегмента неизменным. В этом случае для указателей, расположенных, например, в конце сегмента, возможна ситуация, когда при увеличении указателя, вместо того, чтобы обратиться к значению другого сегмента, произойдет переход через границу последнего и будет произведено обращение к нулевому смещению того же самого сегмента. То же утверждение верно для указателей, расположенных в начале сегмента. Для того чтобы компилятор сгенерировал код, позволяющий выходить указателям за текущий сегмент (нормализация указателя), применяется модификатор huge. В этом случае синтаксис имеет следующий вид:

тип huge *имя_указателя

Приведенный ниже пример демонстрирует использование модификатора huge.

#include <stdio.h>
int main ()
{
long huge *p = NULL;
for(int i=0; i<10; i++, p++)
printf("p содержит адрес %Fp\n", p);
return 0;
}

#include <math.h>
#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{
	//setlocale(LC_ALL, "Rus");
	long huge *p= NULL;
	for(int i= 0; i< 10; i++, p++)
		printf("p содержит адрес %Fp\n", p);

	getchar(); 	getchar();
	return 0;
}

В рассмотренной программе подключается заголовочный файл stdio.h, содержащий прототип функции форматированного вывода данных printf () - здесь с ее помощью производится отображение указателя в виде сегмент: смещение. Далее определяется указатель типа long huge и в цикле производится инкремент и вывод 10 значений адресов дальних указателей. Из результатов работы программы видно, что осуществляется нормализация указателя, и величина смещения не превышает значения 15, в то время как значение сегмента изменяется.
Во время выполнения приложения неизбежны вызовы каких-либо функций. Параметры функций и переменные, объявленные внутри, являются локальными объектами и располагаются внутри стека. Кроме того, в стеке хранится информация (например, адрес возврата, состояние программы до вызова функции, выполняющейся в текущий момент), необходимая программе при возврате из вызываемых функций.
Глобальные же объекты хранятся в сегменте данных, а так как размер данных для всех моделей памяти кроме huge не может превышать одного сегмента, количество глобальных переменных в программе ограничено. Если компилятор при сборке приложения указывает, что используется слишком много глобальных объектов, часть из них можно описать как дальние (far). Если же необходимо определить переменную, о которой изначально известно, что ее размер выходит за пределы 64 Кбайт, используют модификатор huge. Так, например, глобальный массив большого размера можно описать следующим образом:

long huge AKR[30000];

Таким образом, с помощью спецификаторов far и huge можно определять переменные, если изначально известно, что размер приложения будет выходить за рамки отведенных 64 Кбайт.

        16.10. Модификаторы функций.
В зависимости от того, какая модель памяти применяется, функции и указатели на функцию являются ближними или дальними. Как и в случае с указателями на переменные, размер указателя на функцию можно изменить с помощью модификаторов near и far. Так, например, функции, обращение к которым осуществляется операционной системой или драйвером какого-либо устройства, всегда должны быть объявлены как дальние (far) и, если используется модель памяти с короткими указателями для кода (Tiny, Small или Compact), такие функции должны специфицироваться с помощью модификатора far.
Рассмотрим пример использования модификаторов функций.

#include <iostream.h>
void __near PrintNear(char*);
void __far PrintFar(char*);
void (__near* nPrint)(char*) = PrintNear;
void (~far* fPrxnt) (char*) = PrintFar;
int main()
{
nPrint("NEAR");
fPrintC'FAR");
return 0;
}
void __near PrintNear(char* nMess)
{
cout<< nMess<<’\n’;
cout <<"вызов ближней функции \n";
}
void_ far PrintFar(char* fMess)
{
cout << fMess << ’\n’
cout << "Вызов дальней функции\n";
}

#include <stdio.h>
#include <iostream>
using namespace std;

void __near PrintNear(char*);
void __far PrintFar(char*);
void (__near* nPrint)(char*) = PrintNear;
void (~far* fPrint) (char*) = PrintFar;

int main()
{
	nPrint("NEAR");
	fPrint("FAR");
	return 0;
}

void __near PrintNear(char* nMess)
{
	cout << nMess << '\n';
	cout << "Вызов ближней функции \n";
}

void __far PrintFar(char* fMess)
{
	cout << fMess << '\n';
	cout << "Вызов дальней функции\n";
}

После объявления функций PrintNear() и PrintFar() следует определение указателей на эти функции короткого nPrint и длинного fPrint соответственно. Тело функции main() содержит вызов ближней и дальней функции через их указатели.

        16.11. Модификаторы cdecl и pascal.
Как уже доминалось ранее, при вызове некоторой функции ее параметры обычно помещаются в стек, а при возврате из функции параметры из стека удаляются. Помещение и удаление параметров из стека осуществляется в соответствии с определенными правилами. Существует два варианта помещения аргументов в стек; слева направо (соглашение о вызове языка Pascal) и справа налево (соглашение о вызове языка С). По умолчанию компилятор использует соглашение, указанное в параметрах (при вызове из командной строки или в опциях интегрированной среды разработки приложения), однако программист всегда может явно указать ятя каждой функции, какое из соглашений вызова необходимо применять. Это осуществляется с помощью модификаторов cdecl и pascal.
Оба модификатора соответствующим образом влияют на внутреннее имя функции при декорировании имен (будет рассматриваться позже), тем самым сообщая компилятору использовать то или иное соглашение о вызове.
Модификатор cdecl указывает компилятору на то, что параметры вызываемой функции должны помещаться в стек в порядке, обратном следованию при вызове, то есть справа налево (первым передается аргумент, стоящий последним в списке параметров, затем предыдущий и т.д.). При этом не делается никаких предположений об ответственности функции за очистку стека. Внутреннее имя функции эквивалентно объявляемому имени с добавлением символа подчеркивания и использованием соглашения языка С о различении верхнего и нижнего регистров:

MyFunction - имя из прототипа функции
_MyFunction - внутреннее имя функции

Модификатор pascal наоборот, требует прямой передачи параметров в стек, слева направо. Кроме того, данный спецификатор сигнализирует, что именно вызываемая функция ответственна за очистку стека. Данное соглашение используют на практике, если функция вызывается много раз из разных мест. Однако функции с переменным числом параметров не могут использовать данного соглашения. Внутреннее имя при использовании данного вида соглашения совпадает с именем прототипа, но с преобразованием в верхний регистр:

MyFunction - имя из прототипа функции
_MYFUNCTION - внутреннее имя функции

Если по умолчанию используется соглашение языка Pascal, следует об этом помнить, так как имя главной функции main() будет преобразовано не в _main, а в MAIN, что может вызвать сообщение компилятора об ошибке, обойти которую поможет использование модификатора cdecl:

int __cdecl main()
{
…
return 0;
}

Иногда необходимо ускорить вызов функции. Этого можно достичь путем передачи параметров функции не через стек, а непосредственно через регистры общего назначения, указав перед именем функции спецификатор fastcall. Поскольку число регистров ограничено, следует применять быстрый вызов только для функций, число параметров которых не больше трех. При этом тип аргументов должен соответствовать типу char, int или long, либо быть коротким указателем. Внутреннее имя функции совпадает с именем ее прототипа с добавлением символа @:

MyFunction - имя из прототипа функции
@MyFunction - внутреннее имя функции

С++ предлагает еще и использование стандартного соглашения о вызове, которое может применяться только в 32-разрядных приложениях. Это своеобразный конгломерат соглашений языков С и Pascal, который специфицируется с помощью модификатора stdcall. При стандартном соглашении о вызове параметры помещаются в стек справа налево, как в случае с cdecl, однако вызванная функция сама отвечает за очистку стека. Внутреннее имя функции полностью совпадает с именем, указанным в прототипе:

MyFunction - имя из прототипа функции
MyFunction - внутреннее имя функции

Другим способом ускорения работы той или иной части функции является использование встроенного ассемблерного кода. Ключевое слово asm определяет следующий за ним однострочный (до конца строки) или блочный (многострочный, заключенный в фигурные скобки) ассемблерный оператор, который имеет возможность взаимодействия с другими переменными, используемыми в программе. Ниже рассмотрен пример, позволяющий двум переменным быстро обменяться своим содержимым. Но вначале простой пример вставки ассемблерного кода в текст программы на языке c++

#include <iostream>
using namespace std;
int main()
{
	short a=0;
	__asm
	{
		mov ax, a
		inc ax
		mov a, ax
	}
	cout << a << "\n";  //1
	system("pause");
}




#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, "Rus");
	int var1 = 55;
	int var2 = 99;
	cout << "До обмена:\n";
	cout << var1 << '\n';
	cout << var2 << '\n';
	__asm
	{
		push var1
		push var2
		pop var1
		pop var2
	}
	cout << "После обмена:\n";
	cout << var1 << '\n';
	cout << var2 << '\n';
	system("pause");
	return 0;
}



В примере сначала объявляются и инициализируются две целочисленные переменные, а затем выводится их содержимое. Далее в блоке ассемблерной вставки первая, а затем и вторая переменная помещаются в стек, после чего в качестве первой переменной извлекается значение второй переменной (помещена в стек последней), а после этого из стека извлекается значение первой переменной с присвоением var2. Рис. 0601 иллюстрирует обмен значений переменных посредством стека.

Рис.0601 Обмен значений переменных через стек

Следует, однако, помнить, что операции с ассемблерными вставками небезопасны: если в них используется изменение содержимого регистров общего назначения, это может неожиданным образом повлиять на ход выполнения всей программы. Для использования тех или иных регистров правильно будет при входе в ассемблерную вставку предварительно сохранить, например, в стеке, значения изменяемых регистров, а на выходе восстановить исходное значение. Ниже рассмотрен тот же пример с использованием регистра общего назначения АХ:

#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, "Rus");
	short int var1 = 55;
	short int var2 = 99;
	cout << "До обмена:\n";
	cout << var1  << '\n';
	cout << var2 << '\n';
	__asm
	{
		// сохраняем в стеке первоначальное
		// значение регистра АХ:
		push ax
		// осуществляем обмен
		// значениями переменных
		mov ax, var1 
		push ax
		mov ax, var2
		mov var1, ax
		pop var2
		// восстанавливаем
		// первоначальное значение
		// регистра АХ:
		pop ax
	}
	cout << "После обмена:\n";
	cout << var1 << '\n';
	cout << var2 << '\n';
	system("pause");
	return 0;
}



C++ также предусматривает непосредственные операции над регистрами и флагами процессора без использования ассемблерной вставки. Для этого зарезервированы следующие ключевые слова:

_АХ
_АН
_AL
_BX
_BH
_BL
_CX
_CH
_CL
_DX
_DH
_DL
_SI
_DI
_BP
_SP
_ES
_SS
_CS
_DS
_FLAGS
Кроме этого, если в опциях компилятора разрешено использование инструкций процессора Intel 80x386. в программе также можно использовать дополнительные ключевые слова:

_ЕАХ
_ESI 
_ЕВХ
_EDI
_ЕСХ
_ESP
_EDX
_ЕВР

Ниже приведен пример, демонстрирующий использование псевдорегистров.

#include <iostream.h>
int main ()
{
int varl = 55;
cout << _AX << ' \n';
cout << '\n';
_AX = varl;
cout << _AX << '\n ';
return 0;
}

#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{
	int var1 = 55;
	cout << _AX << '\n';
	cout << '\n';
	_AX = var1;
	cout << _AX << '\n';
	return 0;
}

Первоначально значение регистра АХ неоднозначно, поэтому первый оператор вывода покажет какое-то неопределенное значение, далее идет присвоение регистру значения переменной varl и вывод этого значения на экран. Следует учесть, что псевдорегистры нужно использовать с осторожностью, так как многие операции могут менять значения регистров еще до того, как в программе следует использование последних. Так, например, если в вышеприведенный пример после присвоения

_АХ = var1;

добавить строку

cout << "Привет!";

значение регистра будет изменено и на экране второй оператор вывода отобразит неопределенное значение.
Внутри блока ассемблерной вставки можно помещать метки и вызовы других функций программы. При этом перед вызовом функции необходимо самостоятельно размещать аргументы в стеке, а после вызова может потребоваться его (стека) очистка.
Следующий пример иллюстрирует вызов внешней функции из ассемблерной вставки (для модели памяти Large).

#include <stdio.h>
#include <iostream>
using namespace std;

void ShowSum(int, int);

int main()
{
	int a = 2;
	int b = 3;
	__asm
	{
		// Поместить параметры в стек:
		push a
		push b
		// Вызов дальней функции
		// (модель Large!)
		//call far ptr ShowSum
		// Пример ближнего вызова:
		call near ptr ShowSum
		// Очистка стека:
		pop cx
	}
	system("pause");
	return 0;
}

void ShowSum(int x, int y)
{
	cout << (x + y);
}



Здесь в ассемблерной вставке следует помещение аргументов функции в стек, а также вызывается функция, выводящая сумму полученных аргументов.
В качестве иллюстрации использования ассемблерных вставок с метками рассмотрим пример, осуществляющий вывод на экран символов от А до Z:

#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{
	char letter = 'A';
	char stop = 'Z';
start:
	__asm
	{
		mov ah, letter
		mov al, stop
		cmp ah, al
		jle print
		jmp exit
	}
print:
	cout << letter;
	letter++;
	cout << " ";
	goto start;
	system("pause");
	exit;
	return 0;
}



В этом примере символьной переменной letter присваивается значение символа 'А', переменной stop - значение символа ' Z '. Далее в регистр ah заносится значение переменной letter, а в регистр al - значение переменной stop, после чего команда cmp ah, al сравнивает значения регистров между собой. Если ah <= al, осуществляется переход на метку print и переменная letter выводится на печать. Вслед за этим значение переменной letter увеличивается, и цикл повторяется с метки start. Если же значение ah больше значения al, следует выход из программы.

        16.12. Динамическое распределение памяти. Связанные списки.
Связанные списки зачастую являются наилучшим выбором при создании алгоритмов, эффективно использующих память. Во всех приведенных выше примерах, работающих с массивами структур, определялось общее количество структур. Например, константа MAX_BOATS устанавливалась равной 50. Это означает, что программа может обрабатывать данные для 50 катеров максимум. Если в реестре появятся 70 или 100 катеров, то для работы с таким количеством эту программу нужно модифицировать. Это вызвано тем, что память для структур выделяется статически (не нужно путать с модификатором класса памяти static). В этом контексте понятие "статически" относится к переменной, которая создается транслятором на этапе компиляции. Такие переменные существуют в своей области действия; при выполнении программы нельзя их уничтожить или создать еще несколько подобных переменных. Поэтому сразу же видны недостатки статического распределения памяти.
Один из способов решить данную проблему — задать количество структур больше, чем требуется. Если константа MAX_BOATS будет равна 5000, то это превысит количество катеров в любой компании. Однако, при этом компьютер должен выделить памяти в 100 раз больше, чем ранее; поэтому такой подход при программировании неэффективен.
Более приемлемый подход — выделять память динамически, по необходимости. При этом память для хранения структур запрашивается по мере роста списка. Для динамического распределения памяти можно использовать связанные списки.
Связанный список — это набор структур, каждая из которых имеет некоторый элемент, или указатель, ссылающийся на другую структуру в этом списке. Указатель служит для связи между структурами. Эта концепция напоминает массив, однако она позволяет динамически увеличивать список. На рисунке показан простой связанный список для программы, работающей с реестром катеров фирмы Nineveh Boat Sales.



Реализация стандартного связанного списка

Связанный список для данного примера включает указатель на следующий катер в реестре:

struct stboat {
	char sztype[15];
	char szmodel[15] ;
	char sztitie[20] ;
	char szcomment[80];
	int iyear;
	long int lmotor_hours;
	float fretail;
	float fwholesale;
	struct stboat *nextboat;
} Nineveh, *firstboat,*currentboat;

Пользовательский структурный тип stboat называется ссылочной структурой, поскольку он имеет поле, содержащее адрес другой, аналогичной структуры. Указатель nextboat (следующий катер) хранит адрес следующей связанной структуры. Это позволяет указателю *nextboat первой структуры ссылаться на вторую структуру и так далее. Такова концепция связанного списка структур.

            7.1.19. Особенности использования связанных списков.
Для того чтобы прикладная программа динамически отслеживала размер данных, необходимо иметь средства для выделения памяти каждому новому элементу, добавляемому в список. В С для выделения памяти используется функция malloc(); в C++ — new(). В следующем параграфе программа выделяет память для первой структуры при помощи оператора

	firstboat=(struct stboat *) new (struct stboat);

Следующий фрагмент программы показывает, как аналогичный оператор можно применить для последующего выделения памяти каждой дополнительной структуре. Процесс продолжается в цикле while до тех пор, пока имеются данные для обработки:

while (datain(&Nineveh) == 0)
{
	currentboat -> nextboat = (struct stboat *) new (struct stboat);
	if (currentboat -> nextboat == NULL) return(1);
	currentboat = currentboat -> nextboat;
	*currentboat = Nineveh;
}

Для того чтобы продемонстрировать передачу структуры в качестве параметра, в начале цикле while адрес структуры stboat, &Nineveh, передается в функцию datain(). Эта функция заносит в структуру действительные данные или возвращает значение 1, если пользователь нажал символ "Q", означающий окончание ввода. Если функция datain() не возвращает 1, то указателю currentboat->nextboat присваивается адрес динамически созданной структуры stboat. Обратим внимание на то, что выполняется приведение типа (struct stboat *) адреса, возвращаемого функцией new(), для того, чтобы согласовать его с типом принимающей переменной. Оператор if проверяет, был ли успешным вызов функции new(). (При ошибке new() возвращает значение null.)
Назначение переменной currentboat — хранить адрес последней действительной структуры stboat в списке; поэтому оператор, следующий за if, присваивает переменной currentboat адрес нового элемента списка, а именно — новый адрес nextboat.
Последний оператор в цикле копирует содержимое структуры Nineveh типа stboat в новую динамически созданную структуру, на которую ссылается указатель *currentboat. Указатель в последней структуре списка установлен на null — это означает конец связанного списка. Найдите соответствующее место в приведенной ниже программе.

            7.1.20. Простой связанный список.
В следующей программе показано, как реализовать пример с реестром катеров фирмы Nineveh Boat Sales при помощи связанных списков. Сравните эту программу с той, что была приведена ранее в теме "Создание массива структур". Пример на С аналогичен этому, за исключением того, что в нем реализован статический массив. Проанализируйте оба листинга и определите, какие элементы изменились, а какие нет.

// 14LIST.CPP
// Программа на С++ - простой пример связанного списка
#include "stdafx.h"
#include <stdio.h>
#include <strstream>
#include <iostream>

using namespace std;

//#include <stdlib.h>
//#include <iostream.h>

struct stboat
{
	char sztype[15];
	char szmodel[15];
	char sztitle[20];
	char szcomment[80];
	int iyear;
	long int lmotor_hours;
	float fretail;
	float fholesale;
	struct stboat *nextboat;
} Nineveh, *firstboat, *currentboat;

void boatlocation(struct stboat *node);
void output_data(struct stboat *boatptr);
int datain(struct stboat *Ninevehptr);

int main(void)
{
	firstboat = (struct stboat *) new (struct stboat);
	if(firstboat == NULL) exit(1);
	if(datain(&Nineveh) != 0) exit(1);
	*firstboat = Nineveh;
	currentboat = firstboat;
	while(datain(&Nineveh) == 0)
	{
		currentboat -> nextboat = (struct stboat *) new (struct stboat);
		if(currentboat -> nextboat == NULL) return(1);
		currentboat = currentboat -> nextboat;
		*currentboat = Nineveh;
	}
	currentboat -> nextboat = NULL; // указывает на конец списка
	boatlocation(firstboat);
	return(0);
}

void boatlocation(struct stboat *node)
{
	do
	{
	output_data(node);
	} while ((node = node -> nextboat) != NULL);
}

void output_data(struct stboat *boatptr)
{
	cout << "\n\n\n";
	cout << "The model year for the boat: " << boatptr -> iyear << "\n"
		<< "The make of the boat: " <<boatptr -> sztype << "\n"
		<< "The model of the boat: " << boatptr -> szmodel << "\n"
		<< "The number of hours on the boat motor: " << boatptr -> lmotor_hours << "\n";
	cout << "The comment about the boat: " << boatptr -> szcomment << ".\n";
	cout << "Grab the deal by asking your Nineveh selesperson for ";
	cout << boatptr->sztitle << " ONLY! $"
		<< boatptr -> fretail << ".\n";
}

int datain(struct stboat *Ninevehptr)
{
	char newline;
	cout << "\n[Enter new boat information - a Q quits]\n\n";
	cout << "Enter the make of the boat.\n";
	cin >> Ninevehptr -> sztype;
	if(*(Ninevehptr -> sztype) == 'Q') return (1);
	cout << "Enter the model of the boat.\n";
	cin >> Ninevehptr -> szmodel;
		cout << "Enter the title number for the boat.\n";
		cin >> Ninevehptr -> sztitle;
	cout << "Enter the model year for the boat.\n";
	cin >> Ninevehptr -> iyear;
		cout << "Enter the number of hours on the boat motor.\n";
		cin >> Ninevehptr -> lmotor_hours;
	cout <<"Enter the retail price of the boat.\n";
	cin >> Ninevehptr -> fretail;
		cout << "Enter the wolesale price of the boat.\n";
		cin >> Ninevehptr -> fholesale;
	cout << "Enter a one line comment about the boat.\n";
	cin.get(newline);
	cin.get(Ninevehptr -> szcomment,80,'.');
	cin.get(newline); // Обрабатывает возврат коретки
	return(0);
}



Обратите внимание на то, что указатели на структуру stboat передавались всем трем функциям:

void boatlocation(struct stboat *node);
void output_data(struct stboat *boatptr);
int datain(struct stboat *Ninevehptr);

Функция boatlocation() проверяет наличие данных в связанном списке, после чего вызывает функцию output_data(). Это происходит в цикле do...while, который заканчивается тогда, когда указателю node присваивается null-адрес. Это происходит только при попытке обращения к элементу, следующему за последней структурой stboat в списке. Функция output_data() осуществляет форматированный вывод каждой структуры из связанного списка.
Во многих языках высокого уровня связанные списки позволяют создавать программы, весьма эффективно использующие память; зачастую эти программы — самые сложные для отладки. Однако, как вы узнаете далее, объектно-ориентированные классы C++ обеспечивают еще большую эффективность.

Что вы должны были узнать.
Как определять символьные константы директивой #define:

#define FINGERS 10

Как включать другие файлы: #include "albanian.h"
Как определить макрофункцию: #define NEG(X) (-(X))
Когда использовать символические константы: часто.
Когда использовать макрофункции: иногда.
Опасность применения макрофункций: побочные эффекты.

Вопросы и ответы.
Вопросы.
    1. Ниже приведены группы операторов, содержащих по одному и более макроопределений, за которыми следуют строки исходных кодов, использующих эти макроопределения. Какой результат получается в каждом случае? Правилен ли он?
        a. #define FPM 5280 /* футов в миле */
dist = FPM * miles;

        b. #define FEET 4
# define POD FEET + FEET
plort = FEET * POD;

        c. # define SIX = 6;
nex = SIX;

        d. # define NEW(X) X + 5
у = NEW(y);
berg = NEW(berg) * lob;
est = NEW(berg) / NEW(y);
nilp = lob * NEW(-berg);

    2. Подправьте определение в вопросе 1.г, чтобы сделать его более надежным.
    3. Определите макрофункцию, которая возвращает минимальное из двух значений.
    4. Задайте макроопределение, в котором есть функция whitesp(c), считающая в программе пустые символы. Определите макрофункцию, которая печатает представления и значения двух целых выражений.

Ответы.
    1. 
        e. dist = 5280 * miles; правильно.
        f. plot = 4 * 4 + 4; правильно, но если пользователь на самом деле хотел иметь 4 * (4 + 4), то следовало применять директиву #define POD (FEET + FEET).
        g. nex == 6; неправильно; очевидно, пользователь забыл, что он пишет для препроцессора, а не на языке Си.
        h. у = у + 5; правильно, berg = berg + 5 * lob; правильно, но, вероятно, это нежелательный результат.
est = berg + 5/y + 5; то же самое.
nilp = lob-berg + 5; то же самое.
    2. #define NEW(X) ( (X) + 5)
    3. #define MIN(X,Y) ( (X) < (Y) ? (X) : (Y) )
    4. #define WHITESP(C) ( (C) == ' ' || (C) == '\n' || (C) == '\t')
    5. #define PR2(X,Y) printf("X равно %d и Y равно %d.\n", X, Y)
Так как в этом макроопределении X и Y никогда не используются никакими другими операциями (такими, как умножение), мы не должны ничего заключать в скобки.

Упражнение.
Создайте заголовочный файл определений препроцессора, которые вы хотите применять.

17. Библиотека языка С и ввод-вывод.
17.1. Стандартные библиотеки С и C++.
17.2. Доступ в библиотеку языка Си.
17.2.1. Автоматический доступ.
17.2.2. Включение файла.
17.2.3. Включение библиотеки.
17.3. Потоковый ввод-вывод.
17.4. Связь с файлами.
17.5. Понятие файла.
17.5.1. Текстовые и бинарные (двоичные) файлы
17.6. Потоковые функции.
17.6.1. Потоковый ввод-вывод. Стандартные потоки
17.6.2. Открытие потоков.
17.6.3. Файлы.
17.6.4. Текстовые файлы с буферизацией.
17.6.5. Переназначение ввода и вывода.
17.6.6. Изменение буфера потока.
17.6.7. Закрытие потоков.
17.6.8. Функции, осуществляющие ввод-вывод в файловый поток
17.7. Низкоуровневый ввод и вывод в С.
17.8. Ввод и вывод символов.
17.8.1. Использование функций getc(), putc(), fgetc() и fputc().
17.8.1.1. Простая программа сжатия файла.
17.8.2. Использование функций getchar(), putchar(),fgetchar() и fputchar().
17.8.3. Использование функций getch() и putch().
17.9. Определение строк в программе.
17.9.1. Строковые константы.
17.9.2. Массивы символьных строк и их инициализация.
17.9.3. Различия: массив и указатель.
17.9.4. Явное задание размера памяти.
17.9.5. Массивы символьных строк.
17.9.6. Указатели и строки.
17.10. Ввод и вывод строк.
17.10.1. Выделение памяти.
17.10.2. Использование функций gets(), puts(), fgets() и fputs().
17.11. Функции, работающие со строками.
17.11.1. Функция strlen().
17.11.2. Функция strcat().
17.11.3. Функция strcmp().
17.11.4. Функция strcpy().
17.12. Создание собственных функций ввода/вывода.
17.13. Проверка и преобразование символов.
17.14. Преобразования символьных строк: atoi(), atof().
17.15. Ввод и вывод целых чисел.
17.15.1. Использование функций getw() и putw().
17.16. Форматированный вывод.
17.16.1. Использование функций printf() и fprintf().
17.17. Использование функций fread и fwrite, fseek(), ftell() и rewind().
17.17.1. Использование встроенного отладчика.
17.18. Форматированный ввод.
17.19. Использование функций scanf(), fscanf() и sscanf().
17.20. Распределение памяти: malloc() и calloc().
17.21. Другие библиотечные функции.

    17. Библиотека языка С и ввод-вывод.
Всякий раз, когда нам нужно использовать такие функции, как printf(), getchar() и strlen(), мы обращаемся в библиотеку языка Си. Она содержит множество функций и макроопределений. Библиотеки меняются от системы к системе, но есть ядро функций (называемое стандартной библиотекой), которое используется чаше всего. Здесь мы рассмотрим пятнадцать наиболее общих из этих функций, уделяя больше внимания функциям ввода-вывода и использованию файлов.
Однако сначала давайте поговорим о том, как пользоваться библиотекой.

        17.1. Стандартные библиотеки С и C++.
Некоторые действия постоянно выполняются во многих программах и программируются практически всеми разработчиками. Для примера можно  взять операцию извлечения квадратного корня. В математических функциях для извлечения квадратного корня используются комбинации основных арифметических операций: сложения, вычитания, умножения и деления.
Каждому программисту бессмысленно создавать собственную процедуру для вычисления корня и затем встраивать ее в программу. Подобные проблемы решены в С и C++ при помощи библиотек функций для выполнения подобных вычислений. Имея библиотеку, достаточно написать один оператор с вызовом нужной функции.
В этом разделе рассматриваются функции, обычно поставляемые с компилятором С и C++. Чаще всего эти функции существуют не в виде исходного текста, а в скомпилированном виде. При выполнении компоновки для получения законченной программы код библиотечных функций объединяется с откомпилированным кодом, написанным программистом.
Библиотечные функции выполняют не только математические действия, но и другие, часто встречающиеся операции. Например, имеются библиотечные функции для чтения и записи файлов на дисках, управления памятью, ввода/вывода и множества других операций. Библиотеки не являются частью стандартного С или C++, но практически каждая система проектирования предлагает определенные библиотечные функции.
Большинство библиотечных функций написаны так, что они используют информацию, содержащуюся в определенных файлах, поставляемых с системой. Следовательно, при использовании библиотек эти файлы должны быть   включены   в   программу   и   обрабатываться   компилятором   Visual C/C++. Обычно подобные файлы имеют расширение .h и называются заголовочными файлами. В табл. 6.7 перечислены заголовочные файлы, поставляемые с Microsoft Visual C/C++.

Таблица 6.7. Заголовочные файлы Microsoft Visual C/C++

Название заголовочного файла
Описание 
assert.h
Макрос отладчика assert
bios.h
Сервисные функции BIOS
cderr.h
Коды ошибок окон диалога
colordlg.h
Идентификационные (ID) номера цветов управляющих элементов окон диалога
commdlg.h
Функции, типы и описания окон диалога
conio.h
Функции консоли и портов ввода/вывода
cpl.h
Описание панели управления и DLL
ctype.h
Классификация символов
custcntl.h
Библиотека пользовательских элементов управления
dde.h
Динамический обмен данными
ddeml.h
Интерфейс прикладного программирования DDEML
direct.h
Управление каталогами
dlgs.h
Идентификационные номера элементов окон диалога
dos.h
Интерфейс MS-DOS
drivinit.h
Устаревший — используйте print.h
errno.h
Описания переменной errno (код ошибки)
excpt.h
Структурированная обработка исключительных ситуаций
fcntl.h
Флаги, используемые в _open и _sopen
float.h
Константы, используемые автоматическими функциями
fpieee.h
Обработка исключительных ситуаций  для чисел с плавающей точкой в стандарте IEEE
fstream.h
Функции для классов filebuf и fstream
graph.h
Низкоуровневая графика и шрифты
io.h
Управление файлами и низкоуровневый ввод/вывод
iomanip.h
Параметрические манипуляторы для iostream
ios.h
Функции для класса  ios
iostream.h
Функции для классов iostream
istream.h
Функции для класса istream
limits.h
Диапазоны целых чисел и символов
locale.h
Функции локализации
lzdos.h
Устаревший — заменен при помощи #define lib на #include<lzexpand.h>
lzexpand.h
Интерфейс Public для lzexpand.dll
malloc.h
Функции выделения памяти
math.h
Математические функции для чисел с плавающей точкой
memory.h
Функции работы с буферами
mmsystem.h
Интерфейс прикладного программирования для мультимедиа
new.h
Функции выделения памяти С++
ntimage.h
Структуры изображений
ntsdexts.h
Расширения отладчика NTSD и KD
ole.h
Функции, типы и описания OLE
ostream.h
Функции для класса ostream
penwin.h
Функции, типы и описания для оконных перьев
penwoem.h
Интерфейсы API  для распознавания оконных перьев
pgchart.h
Презентационная графика
print.h
Функции печати, типы и описания
process.h
Управление процессами
rpc.h
Приложения RPC (Remote Procedure Call — вызов удаленных процедур)
rpcdce.h
Интерфейсы API для выполнения RPC в среде распределенных вычислений (DCE)
rpcdcep.h
Интерфейсы  API для выполнения частных  (private) RPC 
rpcndr.h
Преобразование чисел с плавающей точкой и чисел двойной длины для RPC
rpcnsi.h
Данные интерфейса API, независимого от службы имен 
rpcnsip.h
Описания типов и функций для средств автоматической настройки при выполнении RPC
rpcnterr.h
 Коды ошибок компилятора и выполнения RPC
scmsave.h
Директивы define и описания хранителей экрана Windows 3.1
search.h
Функции поиска и сортировки
setjmp.h
Функции setjmp и longjmp
share.h
Флаги, используемые в _sopen
shellapi.h
Функции, типы и описания для shell.dll
signal.h
Константы, используемые функцией signal
stdarg.h
Макросы для функций со списком аргументов переменной длины
stddef.h
Общие типы данных и значения
stdio.h
Стандартный ввод/вывод
stdiostr.h
Функции для классов stdiostream и stdiobuf
stdlib.h
Общие библиотечные функции
streamb.h
Функции для класса streambuf
stress.h
Функции ударения
string.h
Обработка строк
strstrea.h
Функции для классов strstream  и strstreambuf
tchar.h
Общие интернациональные функции
time.h
Функции времени
toolhelp.h
Функции, типы и описания для toolhelp.dll
varargs.h
Функции списка аргументов переменной длины
ver.h
Функции, типы и описания для управлениями версиями
vmemory.h
Виртуальная память
wchar.h
Широкие символы
wfext.h
Расширения для Диспетчера Файлов Windows
winbase.h
Базовые 32-разрядные Windows интерфейсы API
wincon.h
Подсистема консоли NT
windef.h
Базовые типы окон
windows.h
Функции, типы и описания Windows
windowsx.h
Макросы интерфейсов API
winerror.h
Коды ошибок для интерфейсов API win32
wingdi.h
Данные компоненты интерфейса графического устройства GDI
winioctl.h
Коды управления вводом/выводом для 32-разрядных устройств Windows
winmem32.h
Прототипы и общие определения для winmem32.dll
winmm.h
Приложения мультимедиа
winnetwk.h
Стандартный заголовочный файл winnet для nt-win32
winnls.h
Процедуры, константы и макросы для компоненты NLS (National Language Support — поддержка национальных языков)
winnt.h
32-разрядные типы и константы Windows
winperf.h
Данные для утилиты Performance Monitor
winreg.h
Данные интерфейса API 32-разрядных регистров Windows
winsock.h
Используется для  winsock.dll
winspool.h
API-интерфейсы печати
winsvc.h
Диспетчер служб
winuser.h
Процедуры, константы и макросы для пользовательских компонентов
winver.h
Для использования с ver.dll
sys/locking.h
Установка флагов функций
sys/stat.h
Статус файлов
sys/timeb.h
Функция времени
sys/types.h
Типы статусов файла и времени
sys/utime.h
Функция времени выполнения 

В общем, различные библиотечные функции требуют разных заголовочных  файлов. Заголовочные файлы, необходимые для некоторой функции, перечислены в ее описании. Например: для функции sqrt() необходимы объявления, находящиеся в заголовочном файле math.h. Все библиотечные  функции и связанные с ними заголовочные файлы описаны в справочнике  Microsoft Visual C/C++ Run-Time Library Reference.
Далее приведен краткий список библиотек компилятора Visual C/C++,  объединенных в функциональные группы:
    • Функции классифицирующие
    • Функции преобразования типов
    • Функции управления каталогами
    • Функции диагностики
    • Функции графики
    • Функции ввода/вывода
    • Функции интерфейсов (DOS, 8086, BIOS)
    • Функции манипулирования с данными
    • Функции математические
    • Функции выделения памяти
    • Функции управления процессами
    • Функции стандартные
    • Функции отображения текстовых окон
    • Функции времени и дат

Посмотрите в вашем справочном руководстве детальное описание отдельных функций, имеющихся в каждой библиотеке. После чтения этой главы вы должны разбираться в основных типах данных и операциях языка С.

        17.2. Доступ в библиотеку языка Си.
Получение доступа к библиотеке зависит от системы, поэтому вам нужно посмотреть в своей системе, как применять наиболее распространенные операторы. Во-первых, есть несколько различных мест расположения библиотечных функций. Например, getchar() обычно задают как макроопределение в файле stdio.h, в то время как strlen() обычно хранится в библиотечном файле. Во-вторых, различные системы имеют разные способы доступа к этим функциям. Вот три из них.

            1.1.1. Автоматический доступ.
Во многих больших системах UNIX вы только компилируете программы, а доступ к более общим библиотечным функциям выполняется автоматически.

            1.1.2. Включение файла.
Если функция задана как макроопределение, то можно директивой #include включить файл, содержащий ее определение. Часто подобные функции могут быть собраны в соответствующим образом названный заголовочный файл. Например, некоторые системы имеют файл ctype.h, содержащий макроопределения, задающие тип символа: прописная буква, цифра и т. д.

            1.1.3. Включение библиотеки.
На некотором этапе компиляции или загрузки программы вы можете выбрать библиотеку. В нашей системе, например, есть файл lc.lib, содержащий скомпилированную версию библиотечных функций, и мы предлагаем редактору связей IBM PC использовать эту библиотеку. Даже система, которая автоматически контролирует свою стандартную библиотеку, может иметь другие библиотеки редко применяемых функций, и эти библиотеки следует запрашивать явно, указывая соответствующий признак во время компиляции.
Очевидно, мы не сможем рассмотреть все особенности всех систем, но эти три примера должны показать, что вас ожидает. Теперь мы готовы к рассмотрению некоторых функций.
Добавим функции открытия и закрытия файлов, связи с файлами, проверки и преобразования символов, преобразования строк, функцию выхода и функции распределения памяти.

        17.3. Потоковый ввод-вывод.
Многие широко используемые языки высокого уровня имеют механизмы ввода/вывода, позволяющие создавать нетривиальные алгоритмы для получения и отображения сложных структур данных. Это не относится к языку С, в котором имеется весьма развитая библиотека функций ввода/вывода, хотя, исторически, ввод/вывод никогда не являлся частью самого языка С. Если вы пользуетесь только простыми операторами ввода/вывода, подобными операторам Паскаля readln и writeln, то такая ситуация может вас удивить. Здесь описываются более 20 различных способов организации ввода/вывода в С.
Библиотека стандартных функций ввода/вывода С позволяет считывать данные и записывать их в файлы и устройства. Однако в самом языке С отсутствуют какие-либо предопределенные файловые структуры. В С все данные обрабатываются как последовательность байт. Имеется три основных типа функций ввода/вывода: потоковые, работающие с консолью и портами, низкоуровневые.
В потоковых функциях ввода/вывода файлы или объекты данных рассматриваются как поток отдельных символов. Выбирая соответствующую потоковую функцию, вы можете обрабатывать данные любого необходимого размера или формата, начиная от отдельных символов и заканчивая большими, сложными структурами данных.
На техническом уровне, когда программа открывает файл для ввода/вывода при помощи потоковых функций, открытый файл связывается с некоторой структурой типа FILE (предопределенной в stdio.h), содержащей базовую информацию об этом файле. После открытия потока возвращается указатель на файловую структуру. Указатель файла, иногда называемый указателем потока или потоком, используется для ссылки к файлу при всех последующих операциях ввода/вывода.
Все потоковые функции ввода/вывода обеспечивают буферизированный, форматированный или неформатированный ввод и вывод. Буферизированный поток обеспечивает место для промежуточного хранения всей информации, вводимой из потока или записываемой в поток.
Поскольку дисковый ввод/вывод занимает довольно много времени, буферизация потока разгружает приложение. Вместо того чтобы вводить данные из потока по одному символу или по одному элементу данных, потоковые функции ввода/вывода получают данные поблочно. Когда приложению необходимо обработать введенную информацию, оно просто обращается к буферу, что гораздо быстрее. Когда буфер становится пустым, выполняется считывание с диска другого блока.
Во многих языках высокого уровня существует одна проблема с буферизированным вводом/выводом, которую нужно принимать во внимание. Например: если ваша программа выполнила несколько операторов вывода, которые не заполнили буфер вывода, и запись на диск не произошла, то по завершении программы эта информация будет потеряна. Для решения этой проблемы обычно выполняется вызов соответствующей функции для очистки буфера. В отличие от других языков высокого уровня, в языке С данная проблема с буферизированным вводом/выводом решается путем автоматической очистки содержимого буфера по завершении программы. Конечно, хорошо написанное приложение не должно рассчитывать на эти автоматические действия; все действия программы должны описываться в явном виде. Дополнительное замечание: если вы используете потоковый ввод/вывод и приложение заканчивается с аварийным остановом, то буферы вывода могут оказаться неочищенными, что приведет к потере данных.
Аналогичным образом выглядят процедуры, работающие с консолью и портами; их можно рассматривать как расширенные потоковые функции. Они позволяют читать и писать на терминал (консоль) или в порт ввода/вывода (например, в порт принтера). Функции портов ввода/вывода выполняют простое побайтное считывание и запись. Функции ввода/вывода на консоль обеспечивают несколько дополнительных возможностей. Например, можно определить: введен ли с консоли символ или имеют ли вводимые символы эхо-отображение на экране. Последним типом ввода и вывода является низкоуровневый. Функции низкоуровнего ввода/вывода не выполняют никакой буферизации и форматирования; они непосредственно обращаются к средствам ввода и вывода операционной системы. Эти функции позволяют обращаться к файлам и периферийным устройствам на более низком уровне, чем это делают потоковые функции. При открытии файла на этом уровне возвращается описатель файла (file handle), представляющий собой целое число, использующееся затем для обращения к этому файлу при последующих операциях. В общем случае не рекомендуется смешивать функции потокового ввода/вывода с низкоуровневыми. Поскольку потоковые функции являются буферизированными, а низкоуровневые — нет, при обращении к файлу или устройству при помощи двух разных способов возможны рассогласование или даже потеря данных в буферах. Поэтому для каждого конкретного файла необходимо использовать либо потоковые, либо низкоуровневые функции. В табл. 17.1 перечислены наиболее часто используемые в С функции потокового ввода/вывода.

Таблица 17.1. Функции С потокового ввода и вывода

Функция
Описание
clearer()
Сбрасывает индикатор ошибок потока и устанавливает в ноль индикатор конца файла (end-of-file)
fclose() 
Закрывает поток
fcloseall()
Закрывает все потоки
fdopen()
Открывает поток, используя его описатель (handle), полученный при помощи creat, dup, dup2 или open
feof()
Проверяет поток на признак конца файла
ferror()
Проверяет поток на признак конца файла
fflush()
Проверяет поток на признак конца файла
fgetc()
Считывает символ из потока
fgetchar()
Считывает символ из потока stdin
fgetpos()
Возвращает текущий указатель файла
fgets()
Возвращает строку из потока
filelength()
Возвращает размер потока в байтах
fileno()
Возвращает описатель файла, связанного с потоком
flushall()
Очищает буферы всех потоков
fopen()
Открывает поток
fprintf()
Выполняет форматированную запись в поток
fputc() 
Записывает символ в поток
fputchar()
Записывает символ в stdout
fputs()
Записывает строку в поток
fread()
Считывает неформатированные данные из потока
freopen()
Переназначает указатель потока
fscanf()
Считывает форматированные данные из потока
fseek()
Позиционирует указатель файла в указанную позицию
fsetpos()
Позиционирует указатель файла потока
fstat()
Возвращает информацию об открытом файле
ftell()
Возвращает положение текущего указателя файла
fwrite()
Записывает неформатированные данные в поток
getc()
Этот макрос считывает символ из потока
getchar()
Этот макрос считывает символ из stdin
gets()
Возвращает строку из stdin
getw ()
Считывает целое число из потока
perror()
Выдает системную ошибку на stderr
printf()
Записывает форматированные данные в stdout
putc()
Этот макрос записывает символ в поток
putchar()
Этот макрос записывает символ в stdout 
puts()
Записывает строку в stdout
putw()
Записывает целое число в поток
remove()
Удаляет файл
rename()
Переименует файл
rewind()
Позиционирует указатель файла на начало потока
scanf()
Сканирует и вводит форматированные данные из stdln
setbuf()
Отменяет автоматическую буферизацию, позволяя приложению определить собственный буфер для потока
setvbuf()
То же самое, что и setbuf(); позволяет также определить размер буфера
sprintf()
Записывает форматированные данные в строку
sscanf()
Сканирует и вводит форматированные данные из строки
tmpnam()
Создает в заданном подкаталоге файл с уникальным именем
ungetch()
Засылает символ в буфер клавиатуры
vfprintf()
Записывает форматированные данные в поток, используя указатель на форматирующую строку
vfscanf()
Сканирует и форматирует ввод из потока, используя указатель на форматирующую строку
vprintf()
Записывает форматированные данные в stdout, используя указатель на форматирующую строку
vscanf()
Сканирует и форматирует ввод из stdin, используя указатель на форматирующую строку
vsprintf()
Записывает форматированные данные в строку, используя указатель на форматирующую строку
vsscanf()
Сканирует и форматирует ввод строки, используя указатель на форматирующую строку

        17.4. Связь с файлами.
Часто нам бывает нужна программа получения информации от файла или размещения результатов в файле. Один способ организации связи программы с файлом заключается в использовании операций переключения < и >. Этот метод прост, но ограничен. Например, предположим, вы хотите написать диалоговую программу, которая спрашивает у вас названия книг (звучит фамильярно?), и вы намерены сохранить весь список в файле. Если вы используете переключение как, например, в

books > bklist

то ваши диалоговые приглашения также будут переключены на bklist. И тогда не только нежелательная чепуха запишется в bklist, но и пользователь будет избавлен от вопросов, на которые он, как предполагалось, должен отвечать.
К счастью, язык Си предоставляет и более мощные методы связи с файлами. Один подход заключается в использовании функции fopen(), которая открывает файл, затем применяются специальные функции ввода-вывода для чтения файла или записи в этот файл и далее используется функция fclose() для закрытия файла. Однако прежде чем исследовать эти функции, нам нужно хотя бы кратко познакомиться с сущностью файла.

        17.5. Понятие файла.
Интуитивное определение файла звучит примерно так. Файл -- именованная область на жестком диске. На самом деле с точки зрения ОС UNIX это совсем не так. В ОС UNIX файл -- очень удобная абстракция. С точки зрения UNIX файлом называется "что-нибудь", из чего можно считывать информацию или во что можно записывать информацию. Файлы это:
    • Файлы в обычном смысле: файлы, которые хранятся на жестком диске (можно считывать из них и запиcывать в них информацию);
    • Экран монитора: файл, в который можно выводить информацию (отобразится на экране монитора);
    • Клавиатура: файл, из которого можно считывать информацию;
    • Принтер: файл, в который можно выводить информацию (печать текста);
    • Модем: файл, из которого можно считывать информацию и в который можно записывать информацию (обмен информации по сети);

Файл -- это всё, что предназначено для ввода или вывода информации.
С этой точки зрения файлы бывают разными: принтер может только выводить информацию, а клавиатура -- только вводить. У такого рода файлов есть много особенностей. У файла на жестком диске есть понятие конца файла. Мы можем его считывать до тех пор, пока он не кончится. Тогда как у клавиатуры нет конца.
Неправильно думать, что между сущностями "файл" и "название файла" есть взаимно однозначное соответствие.
Можно привести аналогию из жизни: если представить, что файл -- это банка с некоторым содержимым, то название файла -- это этикетка на этой банке. Логично предположить, что у банки может быть несколько этикеток.
С точки зрения UNIX:



Правильно говорить, что у названия есть файл. И наоборот: неправильно говорить, что у файла есть название. Никакого эффективного способа узнать имя файла не существует (но можно перебрать все файлы файловой системы).

Чтение и запись: printf и scanf
Всем хорошо известная функция printf:

printf("Hello!") -- печать текста на экран;
printf("N = %d", N) -- форматированный вывод на экран: вывести число N в десятичной записи;
printf("N = %x", N) -- форматированный вывод на экран: вывести число N в шестнадцатеричной записи;

Аналогично парная функция scanf:

scanf("%d", &N) -- считывание с клавиатуры значения переменной N в десятичной записи;
char *ptr = new char[10];
scanf("%s", ptr); -- считывание с клавиатуры строки в массив *ptr

Тут могут возникать различные проблемы.

    1. Проблема безопасности:

char *ptr = new char[10];
scanf("%s", ptr);

Тут налицо потенциальная проблема переполнения буфера (в данном примере в буфере всего 10 байт).
Никогда не следует пользоваться scanf-ом для чтения строк.

scanf + "%s" -- запрещенная комбинация!

    2. Форматная строка не компилируется: она будет разбираться в момент исполнения программы. Это обозначает проблему быстродействия. scanf -- не предназначен для чтения большого количества информации. Аналогично printf -- тоже сравнительно медленный (однако существенно быстрее, чем scanf).
    3. Проблема безопасной работы со стеком:

printf("%d %d", N);

Проблема состоит в том, что форматная строка "%d %d" будет проанализирована в момент исполнения. В данном случае произойдет ошибка при работе со стеком: во время исполнения будет взят лишний int.
Перечисленные недостатки означают, что использование функций printf и scanf небезопасно и малоэффективно. Существенным плюсом этих функций является возможность простого форматированного ввода и вывода.

Для нас файл является частью памяти, обычно на диске, со своим именем. Мы считаем, например, stdio.h именем файла, содержащего некоторую полезную информацию. Для операционной системы файл более сложен, но это системные проблемы, а не наши. Однако мы должны знать, что означает файл для программы на языке Си. В предлагаемых для обсуждения функциях, работающих с файлами, язык Си «рассматривает» файл как структуру. Действительно, файл stdio.h содержит определение структуры файла. Вот типичный пример, взятый из IBM-версии компилятора Lattice С:

struct _iobuf
{
	char *_ptr; /* текущий указатель буфера */
	int _cnt; /* текущий счетчик байтов */
	char *_ base; /* базовый адрес буфера ввода-вывода*/
	char _ flag; /* управляющий признак */
	char _ file; /* номер файла */
};

#define FILE struct _iobuf /* краткая запись */

Здесь мы не собираемся разбираться детально в этом определении. Главное состоит в том, что файл является структурой, и что краткое наименование шаблона файла — FILE. (Многие системы используют директиву typedef для установления этого соответствия.) Таким образом, программа, имеющая дело с файлами, будет использовать тип структуры FILE, чтобы делать так.
Имея это в виду, мы сможем лучше понять операции над файлами.

Чтение и запись файлов: FILE*, fopen, fprintf, fscanf
Есть несколько способов работы с файлами c использованием языков C и C++.
Самый распространенный связан со структурой FILE (это не класс, потому что сущность языка C). Эта структура определена в заголовочном файле стандартной библиотеки <stdio.h>. Размер этой структуры и ее поля зависят от ОС и от версии компилятора. Поэтому никто не пользуется структурой FILE. Обычно пользуются указателем на эту структуру: FILE*. Например:

FILE *f = fopen("file1.txt", "r");

fopen -- функция из стандартной библиотеки. Первый параметр -- имя файла (в текущем каталоге). Второй параметр задает режим открытия файла; в данном случае "r" означает, что файл будет открыт только для чтения. Эта функция возвращает ненулевой указатель, если открытие прошло успешно; и возвращает NULL, если произошла ошибка. Ошибка может возникать в следующих ситуациях:
    • не существует файла;
    • у программы недостаточно прав доступа для работы с файлом;

Для дальнейшей корректной работы следует писать примерно такой код:

if (f == NULL) {
  // файл не удалось открыть
}
else {
  // Работа с файлом
}

Допустим, что нам удалось открыть файл, т.е. f != NULL. Тогда для того, чтобы считывать файл, можно использовать функцию:

fscanf(f, "%s", ptr);

Эта функция работает аналогично функции scanf. Поэтому использовать эту функцию небезопасно! Все проблемы, перечисленные для scanf-а, имеют место и при работе с fscanf-ом.
Если мы хотим записать в файл что-то, то мы должны сначала открыть его на запись:

FILE *f = fopen("file2.html", "w");

Тут "w" означает, что мы открываем файл на запись (от write). Если файл не существовал, то он создастся и откроется на запись, а если он существовал, то он сначала будет уничтожен, а затем создан заново, и потом файл будет открыт на запись.
Еще один способ открыть файл -- это открыть его на дозапись. Это можно сделать с помощью параметра "a" (от append). Если файл не существовал, то он создастся и откроется на запись, а если он существовал, то он откроется на запись, и запись будет производится в конец файла.
Затем можно использовать функцию fprintf(f, ...)

            1.1.4. Текстовые и бинарные (двоичные) файлы
Язык С++ унаследовал от языка C библиотеку стандартных функций ввода-вывода. Функции ввода-вывода объявлены в заголовочном файле <stdio.h>. Операции ввода-вывода осуществляются с файлами. Файл может быть текстовым или бинарным (двоичным). Различие между ними заключается в том, что в текстовом файле последовательности символов разбиты на строки. Признаком конца строки является пара символов CR (возврат каретки) и LF (перевод строки) или, что то же самое - '\г' + '\n'. При вводе информации из текстового файла эта пара символов заменяется символом CR, при выводе, наоборот, - символ CR заменяется парой символов CR и LF. Бинарный (или двоичный) файл - это просто последовательность символов. Обычно двоичные файлы используются в том случае, если они являются источником информации, не предполагающей ее непосредственного представления человеку. При вводе и выводе информации в бинарные файлы никакого преобразования символов не производится.

Текстовые и бинарные файлы; что меняет опция t/b
Рассмотрим строку:

fopen(f, "file1.txt", "w");

Почему второй параметр "w" является строкой, а не символом?
На самом деле бывает много способов прочитать/записать файл. Например:

fopen("file1.txt", "wt") -- откроет файл как текстовый файл;
fopen("file1.txt", "wb") -- откроет файл как бинарный файл.

Но в чем отличие? Разница заключается лишь в том, что символы переноса строк запишутся по разному. Рассмотрим пример в UNIX и Windows.

Исходная строка кода выглядит так:

fprintf("Hello\n");

    1. Откроем в Windows файл на запись с параметром "wb" (как бинарный файл). Это означает, что в него запишется в точности то, что мы передали в функции fprintf. Тогда в файл запишутся ровно 6 байт: 

Hello\10

    2. А теперь мы откроем в Windows файл на запись с параметром "wt" (как текстовый файл). Тогда в файл запишутся ровно 7 байт:

Hello\10\13

Тут \10\13 означает символы перевода строки в ОС Windows.

    3. Откроем в UNIX файл на запись с параметром "wt" или "wb". Тогда в файл запишутся ровно 6 байт:

Hello\10

Тут \10 означает символы перевода строки в ОС UNIX.

В ОС UNIX разницы все-таки нет.

Различие между "wt" и "wb" объясняется тем, что в разных операционных системах символы перевода строки разные. При чтении файла, т.е. при открытии файла с параметрами "rt" или "rb", проблема следующая. Если мы поставим параметр "rb", то при чтении файла символ \10 будет восприниматься как перевод строки. А если поставим параметр "rt", то при чтении файла пара символов \10\13 будет восприниматься как символ перевода строки.

http://rsdn.org/forum/cpp/2277645.hot
Двоичные файлы
Двоичные и текстовые файлы — это, как говорят в Одессе, «две большие разницы». Обмен данными между программой и двоичным потоком выполняется без всякого преобразования, поэтому работает быстрее. Двоичный ввод выполняется функцией fread(), имеющей следующий прототип:

size_t fread(void *buffer, size_t size, size_t n, FILE *stream);

Тип size_t обычно определен как unsigned int. Первый параметр часто определяет массив (или указатель на динамический массив), в который будет прочитана информация; третий параметр задает размер одного элемента данных в байтах, а второй — количество читаемых элементов. Четвертый параметр определяет двоичный файл, из которого информация вводится. Общее количество считанных байтов равно size*n. Однако возвращает функция количество корректно прочитанных элементов, а не байтов.
Вывод в двоичный файл выполняется функцией fwrite(), которая имеет совершенно аналогичный прототип:

size_t fwrite(const void *buffer, size_t size, size_t n, FILE *stream);

Функция записывает n элементов размера size в двоичный файл stream из буфера, указатель на который задается в качестве первого аргумента. Общее количество выводимых байтов равно size*n. Однако возвращает функция количество корректно записанных элементов, а не байтов.
В качестве элементов могут использоваться любые переменные любых типов, в том числе и динамические. Даже массив может быть одним-единственным элементом! Рассмотрим несколько простых примеров, аналогичных примерам для текстовых файлов. Создадим на диске C: каталог BinFiles и все двоичные файлы будем размещать в нем. Переделаем пример создания файла

//Создание и чтение двоичных файлов
#include <cstdio>
#include <cstdlib>
#include <ctime>
int main()
{    int m[10]={0};
    srand((unsigned)time(NULL));        // инициализация датчика случайных чисел
    FILE *stream;
/* открываем двоичный файл для записи */
    //if((stream = fopen("c:/binfiles/number1.bin", "wb" )) == NULL) 
    if((stream = fopen("number1.bin", "wb" )) == NULL) 
        return 1;                        // ошибка при открытии
/* заполняем массив m числами */
    for(int i = 0; i < 10; i++)
      m[i] = rand()%10;                    // случайные числа от 0 до 9
// заполняем файл number1.bin элементами-числами
    for(int i = 0; i < 10; i++)
      fwrite(&m[i], 1, sizeof(int), stream);    
    fclose(stream);                        // закрываем файл
/* открываем другой файл для записи */
    //if((stream = fopen("c:/binfiles/number2.bin", "wb" )) == NULL) 
    if((stream = fopen("number2.bin", "wb" )) == NULL) 
        return 1;                        // ошибка при открытии
// заполняем файл number2.bin элементом-массивом
    fwrite(m, 1, sizeof(m), stream);    // массив - один элемент
    fclose(stream);                        // закрываем файл
// вывод второго двоичного файла на экран 
// открываем файл для чтения 
    //if((stream = fopen("c:/binfiles/number2.bin", "rb" )) == NULL) 
    if((stream = fopen("number2.bin", "rb" )) == NULL) 
        return 1;                        // ошибка при открытии
    int a = 0;                             // сюда вводим
// читаем второй файл поэлементно
// правильный цикл
	printf("number2.bin\n");
    fread(&a, 1, sizeof(int), stream);    // предварительное чтение
    while(!feof(stream))                // пока не конец файла
    { printf("%d\n", a);
      fread(&a, 1, sizeof(int), stream);
    }
    fclose(stream);
// открываем первый файл в режиме чтения
	printf("number1.bin\n");
    //if((stream = fopen("c:/binfiles/number1.bin", "rb" )) == NULL) 
    if((stream = fopen("number1.bin", "rb" )) == NULL) 
        return 1;    
    int t[10] = {0};                    // массив для чтения
// читаем первый файл как массив
    fread(t, 1, sizeof(t), stream);        
    for(int i = 0; i < 10; i++)            // выводим поэлементно
        printf("%d\n",t[i]);
    fclose(stream);
char ch = getchar();
return 0;
}



        17.6. Потоковые функции.
Для того чтобы использовать потоковые функции, в программу должен быть включен файл stdio.h. В этом файле содержатся описания констант, типов и структур, используемых в потоковых функциях, а также — прототипы и макроопределения этих функций.
Многие константы, предопределенные в файле stdio.h, могут быть полезны для вашей программы. Например: EOF определяется как значение, возвращаемое функциями ввода при обнаружении конца файла; NULL определяется как указатель на null. Кроме того: FILE определяет структуру используемую для хранения информации о потоке, a BUFSIZ определяет размер по умолчанию буферов потока.

            1.1.5. Потоковый ввод-вывод. Стандартные потоки
Термин поток происходит из представления процесса ввода-вывода в файл в виде последовательности или потока байтов. Над потоком можно выполнять следующие операции:
    • Считывание блока данных из потока в оперативную память;
    • Запись блока данных из оперативной памяти в поток;
    • Обновление блока данных в потоке;
    • Считывание записи из потока;
    • Занесение записи в поток.

Вес потоковые функции ввода-вывода обеспечивают буферизированный, форматированный или не форматированный ввод и вывод.
Когда начинается выполнение программы, автоматически открываются следующие потоки:
    • stdin - стандартное устройство ввода;
    • stdout - стандартное устройство вывода;
    • stderr - стандартное устройство сообщений об ошибках;
    • stdprn - стандартное устройство печати;
    • stdaux - стандартное вспомогательное устройство.

Все они называются стандартными (или предопределенными) потоками ввода-вывода. По умолчанию стандартным устройством ввода, вывода и сообщений об ошибках является пользовательский терминал. Поток стандартного устройства печати относится к принтеру, а поток стандартного вспомогательного устройства - к вспомогательному порту компьютера. По умолчанию при открытии все стандартные потоки, за исключением потоков stderr и stdaux, буферизуются.
В современных операционных системах клавиатура и дисплей рассматриваются как файлы (притом текстовые!), поскольку с клавиатуры может считываться информация в программу, а на дисплей - выводиться. При запуске программы на выполнение ей можно переназначить стандартное устройство ввода (клавиатуру) или стандартное устройство вывода (дисплей), назначив вместо этих устройств текстовый файл. При этом говорят, что происходит переадресация ввода или, соответственно, вывода. Для переназначения ввода используется символ "<", а для переназначения вывода - символ ">". Если выполняемая программа называется example.exe, следующая строка используется для переназначения ввода с клавиатуры на файл sample.dat:

example < sample.dat

Переназначение вывода с дисплея на вывод в файл осуществляется с помощью следующей строки:

example > output.dat

Наконец, следующая строка осуществляет одновременное переназначение ввода и вывода:

example < sample.dat > output.dat

Можно также осуществить соединение выходного потока одной программы с входным потоком другой. Это называется конвейерной пересылкой. Если имеются две выполнимые программы example1 и example2, то конвейерная пересылка между ними организуется с помощью символа вертикальной черты ‘|’. Следующая строка организует конвейерную пересылку между example1 и example2:

example1 | example2

Организацию конвейерной пересылки обеспечит операционная система.

            1.1.6. Открытие потоков.
Перед тем, как выполнять операции ввода и вывода в файловый поток, нужно его открыть с помощью функции fopen(). Эта функция имеет следующий прототип:

FILE *fopen(const char *filename, const char *mode);

Она открывает файл с именем filename и связывает с ним поток. Функция fopen() возвращает указатель, используемый для идентификации потока в последующих операциях. Параметр mode является строкой, задающей режим, в котором открывается файл. Он может принимать значения, указанные в таблице.

Режимы открытия файла
Значение
Описание
R
Файл открывается только для чтения
W
Файл создается для записи. Если файл с этим именем уже существует, он будет перезаписан.
A
Режим добавления записей (Append): файл открывается для записи в конец (начиная с EOF) или создается для записи, если он еще не существует.
r+
Существующий файл открывается для обновления (считывания и записи).
w+
Создается новый файл для обновления (считывания и записи). Если файл с этим именем уже существует, он будет перезаписан.
a+
Файл открывается для добавления (т.е. записывания, начиная с EOF): если файл еще не существует, он создается.

Чтобы указать, что данный файл открывается или создается как текстовый, добавьте символ t в строку режима открытия (например, rt, w+t и т.д.). Аналогичным образом, чтобы сообщить, что файл открывается или создается как бинарный, добавьте в строку режима открытия символ b (например, wb, a+b и т.д.) Функция fopen() также позволяет вставить символы t или b между буквой и символом (+) в строке режима открытия (например, строка rt+ эквивалентна строке r+t). Когда файл открывается для обновления, можно вводить и выводить данные в результирующий поток. Однако вывод не может осуществляться непосредственно после ввода, если ему не предшествует вызов функции fseek() или rewind(). В случае успеха fopen() возвращает указатель на открытый поток; в случае ошибки — указатель NULL.
Например:

FILE* stream = fopen(“Install.dat”, “r”);

Указатель на открытый файловый поток используется во всех последующих функциях работы с потоком.
Перед тем как выполнять операции ввода и вывода для потока, можно с помощью одной из трех функций открыть этот поток: fopen(), fdopen() или freopen(). В момент открытия потока задаются режим файла и способ доступа. Файл потока может открываться для считывания, записи или для считывания/записи в текстовом или двоичном режиме.
Все три функции возвращают указатель на файл, который используется для обращения к потоку. Например: после выполнения следующего оператора можно использовать указатель на файл pfinfile для ссылки на поток:

pfinfile = fopen("input.dat","r");

Когда начинается выполнение приложения, автоматически открываются пять следующих потоков: стандартное устройство ввода (standard input — stdin), стандартное устройство вывода (standard output — stdout), стандартное устройство сообщений об ошибках (standard error — stderr), стандартное устройство печати (standard printer — stdprn) и стандартное вспомогательное устройство (standard auxiliary — stdaux).
Эти пять файловых указателей можно использовать во всех функциях, которые имеют в качестве параметра указатель на поток. Некоторые функции, например getchar() и putchar(), автоматически используют stdin или stdout. Поскольку указатели stdin, stdout, stderr, stdprn и stdaux являются константами, а не переменными, нельзя присвоить им новое значение указателя на поток.

            1.1.7. Файлы.
Чтобы показать элементарные примеры использования файлов, мы составили небольшую программу, которая читает содержимое файла, названного test, и выводит его на экран. Вы найдете наши пояснения сразу после программы.

/* расскажите, что находится в файле "test" */
#include <stdio.h>
void main()
{
FILE *in; /* описываю указатель на файл */
int ch;
if ( (in = fopen("test.txt" , "r")) != NULL)
/* открываю test для чтения, проверяя, существует ли он */
/* указатель FILE ссылается теперь на test */
{
while ( (ch = getc(in) )!= EOF) /* получаю символ из in */
	putc(ch, stdout); /* посылаю на стандартный вывод */
fclose(in); /* закрываю файл */
}
else
	printf("I couldn't open file  \"test\" \n");
}



Функцией fopen() управляют три основных параметра. Первый — имя файла, который следует открыть. Он является и первым аргументом fopen(); в нашем случае это " test" .
Второй параметр [и второй аргумент fopen()] описывает, как должен использоваться файл. Вот три основных применения файла:
"r" : файл нужно считать
"w* : файл нужно записать
"а" : файл нужно дополнить

Некоторые системы предоставляют еще дополнительные возможности, но мы будем придерживаться этих. Заметим, что используемые нами коды являются строками, а не символьными константами; следовательно, они заключаются в двойные кавычки. При применении "r" открывается существующий файл. При двух других применениях тоже будет открываться существующий файл, но если такого файла нет, он будет создан.
Внимание: Если вы используете "w" для существующего файла, то старая версия его стирается, и ваша программа начинает на "чистом месте".
Третий параметр является указателем на файл; это значение возвращается функцией:

FILE *in;
in = fopen("test", "r");

Теперь in является указателем на файл "test". С этого момента программа ссылается на файл при помощи указателя in, а не по имени test.
Если вы очень сообразительны, то теперь можете задать такой вопрос: «Если fopen() возвращает указатель на ' FILE' в качестве аргумента, то почему мы не должны объявить fopen() как функцию указателя на ' FILE' ?» Хороший вопрос. Ответ заключается в том, что это описание сделал для нас файл stdio.h, который содержит строку

FILE *fopen();

Есть еще один важный момент относительно функции fopen(), которую мы использовали. Если fopen() не способна открыть требуемый файл, она возвращает значение 'NULL' (определенное в stdio.h как 0). Почему она не смогла открыть файл? Вы можете попросить ее считать файл, который не существует. Вот почему мы имеем в программе строку

if ( (in = fopen("test", "r") )!= NULL)

Заполнение диска, использование запрещенного имени или некоторые другие причины могут препятствовать открытию файла. Поэтому побеспокойтесь, чтобы их не было — маленькая ошибка может увести вас очень далеко.
Закрыть файл проще.
Рано или поздно в программе потребуется ввод или вывод не через клавиатуру или дисплей, а непосредственно из файлов. В следующем примере показано, как объявлять и использовать простые файлы данных:

/*В данной программе на С показано, как объявлять и использовать
файлы для ввода и вывода. Программа считывает значение order_price
из файла customer.txt и вычисляет значение billing_price,
записываемое в файл billing.txt*/
#include <stdio.h>
#define MIN_DISCOUNT 0.97 
#define MAX_DISCOUNT 0.95 
main ()
{
	float forder_price, fbilling_price; 
	FILE *fin,*fout;
	 fin=fopen ("customer.txt", "r") ;
	fout=fopen ("billing.txt", "w") ;
while (fscanf(fin,"%f",&forder_price) != EOF) {
	fprintf(fout,"Your order of \t\t$%8.2f\n", forder_price);
	 if (forder_price < 10000)
		fbilling_price = forder_price * MIN_DISCOUNT;
	 else fbilling_price = forder_price * MAX_DISCOUNT;
	 fprintf(fout,"is discounted to \t$%8.2f.\n\n",
		fbilling_price);
}
return(0);
}

Каждый файл в программе на С должен быть связан с некоторым указателем файла (file pointer). Указатель файла указывает на информацию, описывающую различные атрибуты файла, включая путь к файлу, его имя и статус. Указатель файла представляет из себя переменную-указатель типа FILE, описанную в stdio.h. В данном операторе, взятом из нашего примера, объявляется два файла *fin и *fout:

FILE  *fin,   *fout;

Следующие операторы программы открывают два различных потока и связывают каждый файл с соответствующим потоком:

fin=fopen ("a: \\customer.dat", "r") ;
fout=fopen("a:\\billing.dat", "w");

При переходе от чтения к записи и наоборот не забывайте позиционировать указатель файла при помощи fsetpos(), fseek() или rewind()
Сам С автоматически закрывает файлы при окончании программы. Иногда, однако, требуется самим управлять закрытием файлов. В следующем листинге приведена та же программа, но с включением необходимых вызовов функций закрытия файлов:

/*В данной программе на С показано, как объявлять и использовать
файлы для ввода и вывода. Программа считывает значение order_price
из файла customer.txt и вычисляет значение billing_price,
записываемое в файл billing.txt*/
#include <stdio.h>
#include<iomanip.h>
#define MIN_DISCOUNT .97
#define MAX_DISCOUNT .95
main ()
{
	float forder_price, fbilling_price; 
	FILE *fin,*fout;
fin=fopen ("customer.txt", "r") ;
	fout=fopen ("billing.txt", "w") ;
while (fscanf(fin,"%f",&forder_price) != EOF) {
	fprintf(fout,"Your order of \t$%8.2f\n", forder_price);
	 if (forder_price < 10000)
		fbilling_price = forder_price * MIN_DISCOUNT;
	 else fbilling_price = forder_price * MAX_DISCOUNT;
fprintf(fout,"is discounted to \t$%8.2f.\n\n", fbilling_price);
}	
fclose(fin);
fclose(fout);
return(0);
}

Следующая программа выполняет те же функции, что и предыдущая, но на языке C++:


//	В данной программе на C++ показано, как объявлять и использовать
//	файлы для ввода и вывода. Программа считывает значение order price
//	из файла customer.dat и вычисляет значение billing_price,
//	записываемое в файл billing.dat
	#include <fstream.h>
     #include <stream.h>
	#include <iomanip.h>
	#define MIN_DISCOUNT 97
	#define MAX_DISCOUNT 95
	main()
{
	float forder_price, fbilling_price;
	lfstream fin ("a:\\customer.dat") ;
	of stream fout ("a:\\billmg.dat") ;
 {	fin >> forder_price;
	while (!fin.eof()) {
		fout << setiosflags(ios::fixed);
		fout << "Your order of \t\t$" << setprecision \
			<< setw(8) << forder_price << "\n";
		if (forder_price < 10000)
			fbilling_price = forder_price * MIN_DISCOUNT;
		else fbilling_price = forder_price * MAX_DISCOUNT;
		fout << "is discounted to \t$" << setprecision \
			<< setw(8) << fbilling_price << ".\n\n";
		fin >> forder_price;
	}
	fin. close ();
	fout.close(); 
	return(0);
}

Ввод/вывод дисковых файлов в C++ немного отличается от соответствующего ввода/вывода в С. В C++ имеются два средства в библиотеке потоков: объект streambuf и потоки. Одна и та же модель выполняет ввод/вывод как для клавиатуры и терминала, так и для диска. Одни и те же операторы и операции выполняются аналогичным образом. Это значительно упрощает программирование, в котором всегда были сложности и разночтения. Для упрощения дискового файлового ввода/вывода в библиотеке потоков описан объект filebuf, производный от стандартного типа streambuf. Так же как и родительский класс, объект filebuf управляет буфером, только в последнем случае буфер связан с дисковым файлом.

            1.1.8. Текстовые файлы с буферизацией.
Важность буфера при работе с файлами
Рассмотрим следующую ситуацию. Программа пишет протокол своих действий в файл (например, с помощью функции fprintf). Допустим, что программа сломалась. Понятно, что скорее всего получится так, что в файл последний fprintf (последний протокол действий) не запишется. Причина тому -- это буфер. Чтобы "протолкнуть" буфер в файл, используется функция

fflush(f)

В коде это выглядит примерно так:

fprintf(file, "%d", data); //данные записались в буфер
fflush(file); //данные из буфера "проталкнулись" в файл

Функции fopen() и fclose() работают с текстовыми файлами с «буферизацией». Под буферизацией мы понимаем, что вводимые и выводимые данные запоминаются во временной области памяти, называемой буфером. Если буфер заполнился, содержимое его передается в блок, и процесс буферизации начинается снова. Одна из основных задач fclose() заключается в том, чтобы «освободить» любые частично заполненные буфера, если файл закрыт.
Текстовым считается файл, в котором информация запоминается в виде символов в коде ASCII (или аналогичном). Он отличается от двоичного файла, который обычно используется для запоминания кодов машинного языка.
Функции ввода-вывода, о которых мы собираемся рассказать, предназначены только для работы с текстовыми файлами.

            1.1.9. Переназначение ввода и вывода.
Современные операционные системы рассматривают клавиатуру и видео-дисплей как файлы. Это имеет смысл постольку, поскольку система может читать с клавиатуры так же, как она читает из дискового или ленточного файла; то же можно сказать и о видеодисплее.
Предположим, что программа читает с клавиатуры и пишет на дисплей. Допустим, что вы хотите, чтобы ввод шел из файла с именем SAMPLE.DAT. Ту же самую программу можно использовать, если указать системе заменить ввод с клавиатуры, рассматриваемой как файл, на ввод из другого файла, а именно — файла SAMPLE.DAT. Процесс изменения стандартного устройства ввода или вывода называется переназначением (или переадресацией — redirection) ввода или вывода. Переназначение ввода и вывода не представляет трудностей. Для переназначения ввода используется символ <, а для переназначения вывода >. Допустим, что выполняемая программа называется REDIRECT. Следующая системная команда запускает программу REDIRECT и использует для ввода вместо клавиатуры файл SAMPLE.DAT:

redirect < sample.dat

В следующей команде переназначаются и ввод (SAMPLE.DAT), и вывод (SAMPLE.BAK):

redirect < sample.dat > sample.bak

Последняя команда переназначает только вывод (SAMPLE.BAK):

redirect > sample.bak

Заметим, однако, что стандартный файл ошибок STDERR переназначать нельзя.
Имеются два метода управления связью между стандартным файлом и физическим файлом или устройством: переназначение и конвейерная пересылка. Конвейерной пересылкой называется непосредственное соединение стандартного вывода одной программы со стандартным вводом другой программы. Управление переназначением и конвейерной пересылкой обычно происходит вне программы; эта задача и ставится, так как в этом случае самой программе не нужно знать, откуда реально поступают данные и куда пересылаются.
Для того чтобы соединить стандартный вывод одной программы со стандартным вводом другой программы, нужно назначить между ними конвейерную пересылку при помощи символа вертикальной черты "|". Следовательно, для связи стандартного вывода программы PROCESS 1 со стандартным вводом программы PROCESS2 достаточно указать:

Process1 | process2

Операционная система обеспечит все операции физической пересылки данных с выхода PROCESS 1 на вход PROCESS2.

            1.1.10. Изменение буфера потока.
По умолчанию все файлы, открытые при помощи потоковых функций (stdin(), stdout() и stdprn()), буферизируются. Исключение составляют открытые потоки stderr и stdaux, которые по умолчанию не буферизируются, кроме случаев, когда они используются с группой функций printf() или scanf() — тогда им назначается временный буфер. Можно задать буферизацию потоков stderr и stdaux при помощи функций setbuf() или setvbuf(). Потоки stdin, stdout и stdprn очищаются автоматически при их заполнении. При помощи двух функций setbuf() и setvbuf() можно сделать буферизированный поток небуферизированным и наоборот. Обращаем внимание на то, что буферы, выделяемые системой, недоступны для пользователя, а буферы, которые назначаются при помощи функций setbuf() и setvbuf(), именуются пользователем, и с ними можно работать как с переменными. Буферы потоков, определяемые пользователем, очень полезны для проверки ввода и вывода до того, как возникнут какие-либо системные ошибки.
Можно назначить буфер любого размера; при использовании функции setbuf() размер определяется константой BUFSIZ, описанной в файле stdio.h. Синтаксис функции setbuf() выглядит так:

void setbuf(FILE *stream, char *buffer);

В следующем примере setbuf() и BUFSIZ используются для описания и назначения буфера потоку stderr. Буферизация stderr предоставляет программе больше возможностей для управления обработкой исключительных ситуаций. Выполните пошаговую трассировку начального варианта программы при помощи встроенного отладчика.

/*Программа на С, демонстрирующая описание и назначение буфера
потоку stderr*/
#include "stdafx.h"
#include "E:\LECTURE\AlgorithmProgramming\AlgorithmProgramming 02\Universal_HederFile.h"

void StopWait(void);

char cmyoutputbuffer[BUFSIZ];
main(void)
{
	/* связь буфера с небуферизированным выходным потоком */
	setbuf(stderr, cmyoutputbuffer); /* строка, которую нужно */ /*ЗАКАМЕНТИРУЙ для 2 варианта*/
	/* заполнение буфера выходного потока */
	fputs("Sample output inserted into the\n",stderr); /*"Пример вывода в" */
	fputs("output stream buffer.\n",stderr); /* "буфер выходного потока." */
	/* вывод буфера выходного потока */
	fflush(stderr);

	StopWait(); /* Wait a little */
	return (0);
}

Попробуйте запустить программу второй раз, закомментировав оператор setbuf(). В этом случае программа не будет связывать буфер с stderr. Вы увидите различие после запуска программы? Когда stderr не буферизируется, встроенный отладчик выдает сообщение каждого оператора fputs() сразу же после выполнения оператора.
В следующей программе используется функция setvbuf(); ее синтаксис выглядит следующим образом:

int setvbuf (FILE *stream, char *buffer, int buftype, size_t bufsize);

В этом примере размер буфера задается явно, а не при помощи константы BUFSIZ, описанной в файле stdio.h:

/*Программа на С, демонстрирующая использование функции setvbuf()*/
#include "stdafx.h"
#include "E:\LECTURE\AlgorithmProgramming\Universal_HederFile.h"
void StopWait(void);

#define MYBUFSIZ 512

main (void)
{
	char ichar, cmybuffer[MYBUFSIZ];
	FILE *pfinfile, *pfoutfile;
	pfinfile = fopen("E:\\LECTURE\\AlgorithmProgramming\\sample.in", "r");
	pfoutfile = fopen("E:\\LECTURE\\AlgorithmProgramming\\sample.out", "w");
	if (setvbuf(pfinfile, cmybuffer, _IOFBF, MYBUFSIZ) != 0)
		printf("pfinfile buffer allocation error\n"); /* ошибка назначения */
	else /* буфера */
		printf("pfinfile buffer created\n"); /* буфер создан */
	if (setvbuf(pfoutfile, NULL, _IOLBF, 132) != 0)
		printf("pfoutfile buffer allocation error\n"); /* ошибка назначения*/
	else
		/* буфера */
		printf("pfoutfile buffer created\n");
		/* буфер создан */
	while(fscanf(pfinfile,"%c",&ichar) != EOF)
		fprintf(pfoutfile,"%c",ichar);
	fclose(pfinfile);
	fclose(pfoutfile);

	StopWait(); /* Wait a little */
	return (0);
}

В программе создается доступный пользователю буфер, на который указывает pfinfile, и автоматически выделенный (malloc()) буфер, на который указывает pfoutfile. Последний из двух буферов описан как buftype, _IOLBF или строчный буфер. Другие опции, описанные в файле stdio.h: _IOFBF — полная буферизация и _IONBF — отсутствие буферизации. Напоминаем, что при использовании функций setbuf() и setvbuf() вместо автоматически выделяемого буфера для ввода/вывода используется buffer, назначенный пользователем. Если в случае использования setbuf() пара-метр buffer равен null, то ввод/вывод будет небуферизированным. В противном случае он буферизируется полностью.
Если в случае использования setvbuf() параметр buffer равен null, то буфер выделяется при помощи функции malloc(). При создании buffer функция setvbof() использует параметр bufsize, который определяет количество выделяемой и автоматически освобождаемой при закрытии памяти.

            1.1.11. Закрытие потоков.
По завершении работы с потоком он должен быть закрыт. Это осуществляется с помощью функции fclose(), которая имеет следующий прототип:

int fclose(FILE *stream);

Все буферы, связанные с потоком, освобождаются перед закрытием потока. В случае успеха fclose() возвращает 0; в случае ошибки - EOF. Если ваша программа не закрывает поток с помощью явного вызова fclose (), то он закрывается автоматически по ее завершению.
Две функции fclose() и fcloseall() используются для закрытия потока или всех потоков, соответственно. Функция fclose() закрывает отдельный файл, а функция fcloseall() закрывает все открытые потоки, за исключением stdin, stdout, stderr, stdprn и stdaux. Однако, если ваша программа не закрывает поток явно, то он закрывается автоматически по ее завершению. Поскольку количество потоков, открытых одновременно, ограничено, то желательно закрывать поток по окончанию работы с ним.
Наш пример показывает, как закрывать файл:

fclose(in);

Просто используйте функцию fclose(). Заметим, что аргументом ее является in, указатель на файл, а не test, имя файла.
Для программы, более серьезной, чем эта, следовало бы посмотреть, успешно ли закрыт файл. Функция fclose() возвращает значение 0, если файл закрыт успешно, и — 1 в противном случае.

Зачем нужно закрывать файлы
    • Зададимся вопросом: "Что надо сделать после того, как мы поработали с файлом?"
Формальный ответ: "Закрыть файл." Это можно сделать с помощью функции:

fclose(f);

Но зачем это делать?

Ввиду механического устройства жесткого диска, данные в файл попадают не сразу. Сначала данные записываются в так называемый буфер (область оперативной памяти), и когда он переполнится, то данные из буфера будут записаны в файл. Такая схема придумана для ускорения работы с файлами. На самом деле, буфер -- это поле структуры FILE: указатель на массив char-ов.
Если мы напишем fprintf(...), то запись произведется в буфер. И только тогда, когда буфер будет заполнен до конца, он будет сразу весь записан на жесткий диск. По этой причине, если мы не закроем файл функцией fclose(f), то последние данные из буфера не запишутся в файл. Отсутствие этой команды может привести к потере данных в файле, который был открыт для записи (дозаписи).

    • А зачем закрывать файлы, открытые только на чтение?
Если не закрывать файлы (которые открыты даже для чтения), то это может привести к ограничению доступа к файлу для других программ. Какие именно ограничения наложатся - это зависит от ОС. Но в ОС Windows если файл открыт на чтение и не закрывается, то из другой программы его нельзя удалить.

    • В любой ОС есть ограничение на количество одновременно открытых файлов. И это еще одна причина для закрытия файлов.







            1.1.12. Функции, осуществляющие ввод-вывод в файловый поток
Рассмотрим теперь функции, осуществляющие ввод-вывод в файловый поток.
Функция fgetc() имеет следующий прототип:

int fgetc(FILE *stream);

Она осуществляет ввод символа из файлового потока stream. В случае успеха функция преобразует прочитанный символ в тип int без учета знака. Если делается попытка прочесть конец файла или произошла ошибка, функция возвращает EOF. Как видим, эта функция во всем аналогична функции getc(), за исключением того, что чтение осуществляется из файлового потока. Более того, как мы уже отмечали, на самом деле getc() — это макрос, реализованный с помощью fgetc(). То же самое относится и к следующим функциям: все они имеют уже рассмотренные нами аналоги.
Функция fputc() имеет следующий прототип:

int fputc(int с, FILE *stream);

Она осуществляет вывод символа в файловый поток и во всем аналогична функции putc().
Функция fgets() имеет следующий прототип:

char *fgets(char *s, int n, FILE *stream);

Она осуществляет чтение строки символов из файлового потока в строку s. Функция прекращает чтение, если прочитано n — 1 символов или встретился символ перехода на новую строку ‘\n’. Если встретился символ перехода на новую строку, он сохраняется в переменной s. В обоих случаях в переменную s добавляется символ ‘\0’, который знаком завершения строковой переменной, функция возвращает строку, на которую указывает параметр s. Если делается попытка чтения конца файла или произошла ошибка, она возвращает NULL.
Функция fputs() имеет следующий прототип:

int fputs(const char *s, FILE *stream);

Она осуществляет вывод строки в файловый поток. Символ перехода на новую строку не добавляется, и завершающий строку нуль-символ в файловый поток не копируется. В случае успеха fputs() возвращает неотрицательное значение. В противном случае она возвращает EOF.
Функция fscanf() имеет следующий прототип:

int fscanf(FILE *stream,
const char *format[, address,...]);

Она во всем аналогична функции scanf(), за исключением того, что форматированный ввод осуществляется не со стандартного устройства ввода, а из файлового потока.
Функция fprintf() имеет следующий прототип:

int fprintf(FILE *stream,
const char *format[, argument,...]);

Она во всем аналогична функции printf(), но осуществляет форматированный вывод не на стандартное устройство вывода, а в файловый поток.
Функция feof() является на самом деле макросом и позволяет осуществлять проверку на достижение символа конца файла при операциях ввода-вывода. Она имеет следующий прототип.

int feof(FILE *stream);

Она возвращает ненулевое значение, если был обнаружен конец файла при последней операции ввода в поток stream и 0, если конец файла еще не достигнут.
Рассмотрим пример файлового ввода и вывода:

#include <stdio.h>
using namespace std;

int main()
{
	setlocale(LC_ALL, "Rus");
	FILE *in, *out;
	if ((in = fopen("C:\\AUTOEXEC. BAT", "rt"))	== NULL){
		fprintf(stderr,
			"Cannot open input file.\n");
		getchar(); 	getchar();
		return 1;
	}
	if ((out = fopen("C:\\AUTOEXEC.BAK", "wt")) == NULL){
		fprintf(stderr,
			"Cannot open output file.\n");
		getchar(); 	getchar();
		return 1;
	}
	while (!feof(in))
		fputc(fgetc(in), out);
	fclose(in);
	fclose(out);
	fprintf(stderr,
		"The file is copied successfully.\n");

	getchar(); 	getchar();
	return 0;
}



Две следующие функции предназначены для осуществления неформатированного ввода и вывода в файловые потоки. Функция fread() имеет следующий прототип:

size_t
fread(void *ptr, size_t size,
size_t n, FILE *stream);

Эта функция считывает из потока stream в буфер, указанный параметром ptr, n блоков данных, каждый из которых содержит size байтов. В случае успеха функция возвращает число прочитанных блоков. Если прочитан конец файла или произошла ошибка, она возвращает число полностью прочитанных блоков или 0.
Функция fwrite() имеет следующий прототип:

size_t
fwrite(const void *ptr, size_t size,
size_t n, FILE *stream);

Она записывает в выходной поток stream из буфера, указанного параметром ptr, n блоков данных, каждый из которых содержит size байтов. В случае успеха функция возвращает число записанных блоков. В случае ошибки она возвращает число полностью записанных блоков или 0.
Приведем пример, демонстрирующий работу с этими функциями:

#include <string.h>
#include <stdio.h>
using namespace std;

struct Client{
	int Num;
	char SurName[27];
	char Name[21];
	char SecName[21];	
};

int main(void)
{
	setlocale(LC_ALL, "Rus");
	FILE *stream;
	Client AClient, RClient;
	//Открываем файл для вывода
	if ((stream = fopen("SAMPLE.DAT", "wb"))== NULL){
		printf("Cannot open output file.\n");
		getchar(); 	getchar();
		return 1;
	}
	AClient.Num = 1;
	strcpy(AClient.SurName,"Petrov");
	strcpy(AClient.Name, "Petr");
	strcpy(AClient.SecName, "Petrovich");
	//Запись структуры в файл
	fwrite(&AClient, sizeof(AClient), 1, stream);
	//Закрываем файл
	fclose(stream);
	//Открываем файл для чтения
	if ((stream = fopen("SAMPLE.DAT", "rb")) == NULL){
		printf("Cannot open input file.\n");
		getchar(); 	getchar();
		return 2;
	}
	fread(&RClient, sizeof(RClient), 1, stream);
	//Закрываем файл fclose(stream);
	printf("The structure contains:\n");
	printf("Num = %d SurName = %s "
		"Name = %s SecName = %s",
	RClient.Num, RClient.SurName,
	RClient.Name, RClient.SecName);

	getchar(); 	getchar();
	return 0;
}

В этом примере вначале файл открывается для записи в него значений полей из структуры AClient, затем этот файл открывается для чтения содержащейся в нем информации в структуру RClient. После чего поля этой структуры выводятся на экран. При выполнении программа выводит на экран:

The structure contains:
Num = 1 SurName = Petrov Name = Petr
SecName = Petrovich




        17.7. Низкоуровневый ввод и вывод в С.
В следующем списке перечислены наиболее часто используемые в про-граммах функции низкоуровневого ввода и вывода:

Функция 
Описание
close()
Закрывает дисковый файл
lseek()
Поиск указанного байта в файле
open()
Открывает дисковый файл
read()
Читает данные в буфер
unlink()
Удаляет файл из подкаталога
write()
Записывает буфер данных

Функции низкоуровневого ввода и вывода не буферизируют и не форматируют данные. Доступ к файлам, открываемых функциями нижнего уровня, осуществляется при помощи описателя файла (handle — целое число, используемое операционной системой для обращения к файлу). Для открытия файлов используется функция ореn(). Для открытия файла с атрибутами совместного использования (sharing) можно использовать макрос sopen().
Низкоуровневые функции отличаются от своих аналогов — потоковых функций — тем, что они не требуют включения заголовочного файла stdio.h. Однако, могут быть полезны некоторые часто используемые константы, предопределенные в stdio.h: например, EOF и NULL. Объявления низкоуровневых функций дается в заголовочном файле io.h.
Первоначально данная система дискового ввода/вывода была создана для операционной системы UNIX. Поскольку комитет по стандарту ANSI С решил не стандартизовывать эту UNIX-подобную систему небуферизированного, низкоуровневого ввода/вывода, то ее нельзя рекомендовать для дальнейшего использования. Для всех новых разработок рекомендуется использовать стандартизованную систему буферизированного ввода/вывода.

File descriptors. Open, close, read, write
В языке C есть много способов работы с файлами. Помимо структуры FILE можно использовать так называемые дескрипторы файла (file descriptors). Дескриптор файла -- целое неотрицательное число. Оно обозначает номер открытого файла в таблице открытых файлов операционной системы. Использование дескрипторов файла -- более низкий уровень, чем нежели ипользование струкруты FILE. Структура FILE -- сущность языка C и его стандартной библиотеки, тогда как дескриптор файла -- сущность операционной системы. Например, при работе со структурой FILE автоматически создается буфер, и программист работает с более высокоуровневой абстракцией. А при работе с дескрипторами файла программист должен позаботится о буферизации вручную.
Пример работы с дескрипторами файла довольно прост и почти в точности повторяет процесс работы со структурой FILE:

int fd = open("...");

Сходство работы с дескрипторами файла с работой со структурой FILE заключается в том, что в названии функций отсутствует буква "f". Иногда параметры функций незначительно отличаются.
Структуру FILE полезно использовать при работе с настоящими "файлами" (которые находятся на жестком диске). Ипользовать дескрипторы файла полезно в случаях работы со специальными "файлами". В этом подходе есть своя специфика работы, но сейчас просто полезно знать, что такой подход существует.
Аналогами stdin, stdout и stderr в дескрипторах файла являются числа 0, 1 и 2 соответственно. Стандарт POSIX.1 обозначил числа 0, 1, 2 символическими константами STDIN_FILENO, STDOUT_FILENO и STDERR_FILENO соответственно.

Memory mapping. Функция mmap
Следующий способ работы с файлами удобен в тех случаях, когда приходится читать файл нелинейно: надо "ходить" вперед и назад. В предыдущих подходах такие ситуации оказывались неудобными с точки зрения программирования: получился бы громоздкий код.
В языке C был придуман удобный способ работы в таких ситуациях, который называется memory mapping. Соответствующая функция:

char *ptr = mmap("...");

Работает эта функция примерно так. Мы указываем этой функции файл на диске, и она "отображает" этот файл в такую-то область в памяти. В результате работы функции мы получаем указатель на начало файла. И потом мы можем работать с этим файлом как с обычным указателем на какую-то область памяти: можем "ходить" вперед и назад по этому файлу.
Можно "отобразить" не весь файл целиком, а, например, отдельную часть файла: с 3-его килобайта по 4-ый килобайт.

Win32 API: FileCreate, FileRead, etc.
При работе с файлами в ОС Windows можно использовать все те функции, которые были описаны выше. В ОС Windows есть своя большая стандартная библиотека Win32 API. В этой библиотеке также есть функции для работы с файлами: например, функции FileCreate(...) или FileOpen(...). Они по своей работе похожи на функции из стандартной библиотеки C, но отличия также присутствуют. Они заключаются в параметрах этих функций и небольших "хитростях", которые мы здесь опустим.
Если вы программируете под ОС Windows и пишите программу для работы в ОС Windows, то стоит пользоваться библиотекой Win32 API для работы с файлами.

        17.8. Ввод и вывод символов.
Во всех компиляторах С имеются несколько описанных в стандарте ANSI С функций, предназначенных для ввода и вывода символов. Эти функции обеспечивают стандартный ввод и вывод и рассматриваются как высокоуровневые процедуры (в отличие из низкоуровневых функций, которые более непосредственно обращаются к аппаратному обеспечению компьютера). Ввод/вывод в С реализован не при помощи ключевых слов, являющихся частью языка, а с использованием функций, поставляемых разработчиками компилятора.

            1.1.13. Использование функций getc(), putc(), fgetc() и fputc().
Две функции getc() и putc() работают аналогично функциям getchar() и putchar(). Разница заключается в том, что вы должны сообщить новичкам, какой файл следует использовать. Таким образом, наш «старый дружище»

ch = getchar();

предназначен для получения символа от стандартного ввода, а 

ch = getc(in);

— для получения символа от файла, на который указывает in. Аналогично функция

putc(ch, out);

предназначена для записи символа ch в файл, на который ссылается указатель out типа FILE. В списке аргументов функции putc() этот символ стоит первым, а затем указатель файла. В нашем примере мы использовали

putc(ch, stdout);

где stdout является указателем на стандартный вывод. Таким образом, этот оператор эквивалентен

putchar(ch);

Действительно, оператор putchar(ch) определен директивой #define так же как функция putc(ch, stdout) определена в файле stdio.h. Этот ужасный файл к тому же определяет в директиве #define указатели stdout и stdin на стандартный вывод и стандартный ввод системы.
Наиболее общими из всех функций ввода/вывода являются те, которые работают с отдельными символами. Функция getc() вводит один символ из указанного файлового потока:

int ic;
ic = getc(stdin);

Символ вводится при указании имени функции getc(), и затем возвращаемое значение присваивается переменной ic. Если же вас удивит, почему переменная ic не имеет тип char, то это объясняется тем, что функция getc() согласно прототипу возвращает тип int. Это нужно для того, чтобы можно было иметь системно-зависимый размер указателя конца файла, который может не совпадать с размером отдельного байта типа char.
Функция getc() преобразует целое число в беззнаковый символ. Использование беззнакового символа вместо целого числа гарантирует, что ASCII-символы, имеющие значение > 127, не будут представляться как отрицательные значения. Следовательно, отрицательные значения можно использовать для представления нестандартных ситуаций, например, ошибок и конца входного файла. К примеру: конец файла обычно представляется значением -1, хотя в стандарте ANSI С записано, что только константа EOF может иметь некоторое отрицательное значение.
Поскольку getc() возвращает целое число, то переменные, использующие результат функции getc(), также должны быть описаны как целые. Хотя использование целых чисел в символьной функции может показаться не-удобным, на самом деле в языке С символы и целые числа отличаются очень мало. Когда вместо целого подставляется символ, он автоматически преобразуется в целое число.
Эта группа функций ввода-вывода на самом деле реализована в виде макросов.
Макрос getc() возвращает следующий символ из заданного входного потока и увеличивает указатель входного потока так, чтобы он указывал на следующий символ. В случае успеха getc () возвращает считанный символ, преобразованный в тип int без знака. Если прочитан конец файла или произошла ошибка, он возвращает EOF. Прототип этого макроса следующий:

int getc(FILE *stream);

Символ EOF определяется следующим образом:

#define EOF (-1)

В операциях ввода-вывода он служит для обозначения и проверки конца файла.
Подразумевается, что этот символ имеет тип signed char, еcли в операциях ввода-вывода участвуют символы типа unsigned char, то использовать EOF нельзя. Следующий пример демонстрирует использование этого макроса:

#include <stdio.h>
using namespace std;

int main ()
{
	setlocale(LC_ALL, "Rus");
	char ch;
	printf("Bвод символа:");
	//Чтение символа из стандартного
	//входного потока
	ch = getc(stdin);
	printf("Был введен символ: '%c'\n", ch);

	getchar(); 	getchar();
	return 0;
}



Дополнением к функции getc() служит putc(). Макрос putc() имеет следующий прототип:

int putc(int с, FILE *stream);

Он выводит символ в поток, заданный параметром stream. В случае успеха putc () возвращает выводимый символ с. преобразованный к типу int; в случае ошибки - EOF.
Макрос putchar () имеет следующий прототип:

int putchar(int с);

Этот макрос определяется как putc(с, stdout). В случае успеха он возвращает символ с, преобразованный к типу int. В случае ошибки он возвращает EOF.
Функция putc() выдает один символ в файловый поток, представленный заданным указателем файла. Для вывода введенного выше символа на стандартное устройство вывода используется следующий оператор:

putc(ic,stdout);

Функция getc() обычно буферизируется, и когда приложение запрашивает символ, управление не передается программе до тех пор, пока в стандартном входном файловом потоке не будет введен символ возврата каретки. Все символы, введенные до символа возврата каретки, хранятся в буфере и передаются последовательно в программу, которая повторно вызывает функцию getc() до тех пор, пока буфер не опустеет. После того, как при помощи getc() символ возврата каретки передан в программу, следующий запрос символов вызывает накопление символов в буфере до тех пор, пока опять не будет введен символ возврата каретки. Это означает, что функцию getc() нельзя использовать для обработки одиночных клавиш, когда не требуется дополнительного нажатия клавиши возврата каретки. И одно последнее замечание: на самом деле getc() и putc() являются не истинными функциями, а макросами. Функции fgetc() и fputс() идентичны их аналогам макросам getc() и putc().

    2. Простая программа сжатия файла.
В нашем примере имя файла, который следовало открыть, было записано в программе. Мы не обязаны считаться с этим ограничением. Используя аргументы командной строки, можно сообщить нашей программе имя файла, который хотим считать. В нашем следующем примере так и происходит. С помощью, примитивного приема сжимается содержимое — остается только каждый третий символ. Наконец, сжатая версия размещается в новый файл, имя которого состоит из старого имени с добавкой .red (сокращение слова reduced). Обычно весьма важны первый и последний элементы (аргумент командной строки и добавка к имени файла). Само же сжатие имеет более ограниченное применение, но, как вы увидите, им можно пользоваться.

/* сожмите ваши файлы в 2—3 раза! */

#include <stdio.h>
#include<string.h>
void main(int argc, char *argv[])
{
FILE *in, *out; /* описывает два указателя типа FILE */
int ch;
static char name [20]; /* память для имени выходного файла */
int count = 0;
if ( argc < 2) /* проверяет, есть ли входной файл */
	printf("Sory, i need the title of the file.\n" );
else
{
	if ( (in = fopen(argv[1], "r")) != NULL)
	{
		strcpy(name, argv[1]); /* копирует имя файла в массив */
		strcat(name, " .red"); /* добавляет .red к имени */
		out = fopen(name, " w"); /* открывает файл для записи */
		while ( (ch = getc(in)) ! = EOF)
			if ( count++ %3 ==0)
				putc(ch, out); /* печатает каждый третий символ */
		fclose(in);
		fclose(out);
	}
	else
		printf(" Я не смогла открыть файл\" %s\" \n", argv[1]);
}
}



Мы поместили программу в файл, названный reduce и применили эту программу к файлу, названному eddy, который содержал одну единственную строку

Даже Эдди нас опередил с детским хором.

Была выполнена команда

reduce eddy

и на выходе получен файл, названный eddy .red, который содержит

Дед спел тихо

Какая удача! Наш случайно выбранный файл сделал осмысленное сокращение.
Вот некоторые замечания по программе.
Вспомните, что argc содержит определенное количество аргументов, в число которых входит имя программного файла. Вспомните также, что с согласия операционной системы argv[0] представляет имя программы, т. е. в нашем случае reduce. Вспомните еще, что argv[1] представляет первый аргумент, в нашем случае eddy. Так как сам argv[1] является указателем на строку, он не должен заключаться в двойные кавычки в операторе вызова функции.
Мы используем argc, чтобы посмотреть, есть ли аргумент. Любые избыточные аргументы игнорируются. Помещая в программу еще один цикл, вы могли бы использовать дополнительные аргументы — имена файлов и пропускать в цикле каждый из этих файлов по очереди.
С целью создания нового имени выходного файла мы используем функцию strcpy() для копирования имени eddy в массив name. Затем применяем функцию strcat() для объединения этого имени с .red.
Программа требует, чтобы два файла были открыты одновременно, поэтому мы описали два указателя типа ' FILE'. Заметим, что каждый файл должен открываться и закрываться независимо от другого. Существует ограничение на количество файлов, которые вы можете держать открытыми одновременно. Оно зависит от типа системы, но чаще всего находится в пределах от 10 до 20. Можно использовать один и тот же указатель для различных файлов при условии, что они не открываются в одно и то же время. Мы не ограничиваемся использованием только функций getc() и putc() для файлов ввода-вывода. Далее мы рассмотрим некоторые другие возможности.

            2.1.1. Использование функций getchar(), putchar(),fgetchar() и fputchar().
Макрос getchar() имеет следующий прототип:

int getchar();

Этот макрос определен как getc(stdin). С помощью этого макроса из стандартного входного потока stdin считывается очередной символ и его значение преобразуется в тип int без учета знака. Если переадресация стандартного входного потока не производилась, то ввод осуществляется с клавиатуры. В противном случае ввод будет осуществляться из файла, назначенного для входного потока и указанного в командной строке при вызове программы.
На самом деле два макроса getchar() и putchar() являются особыми реализациями макросов getc() и putc(), соответственно. Они всегда связаны со стандартными устройствами ввода (stdin) и вывода (stdout). Единственный способ их использования с другими файловыми потоками — переназначить стандартный ввод или стандартный вывод вне программы.
Два приведенных выше примера можно записать иначе, используя две рассматриваемые функции:

int ic;
ic = getchar() ;

и

putchar(ic);

Так же, как и getc() и putc(), getchar() и putehar() реализованы как макросы. В случае ошибки функция putchar() возвращает значение EOF. Следующий фрагмент можно использовать для проверки ошибки вывода. Использование EOF для вывода может показаться немного сомнительным, однако это — технически корректно.

if(putchar(ic) =- EOF)
printf("An error has occurred writing to stdout"); /* При выводе на stdout произошла ошибка */

Макросам getchar() и putchar() эквивалентны функции fgetchar() и fputehar().

            2.1.2. Использование функций getch() и putch().
Функции getch() и putch() являются полноценными низкоуровневыми функциями, тесно связанными с аппаратным обеспечением, — поэтому они не подпадают под стандарт ANSI С. В персональных компьютерах (ПК) эти функции не буферизируются; это означает, что они сразу же вводят символ, нажатый на клавиатуре. Однако, их можно переназначать, и поэтому они связаны не только с клавиатурой.
Функции getch() и putch() используются так же, как и getchar() и putchar(). Обычно программы, работающие на ПК, используют getch() для перехвата клавиш, которые игнорирует функция getchar(), например, PGUP, PGDN, HOME и END. Функция getch() видит символ, введенный с клавиатуры, сразу же после нажатия клавиши; символ возврата каретки для передачи введенного символа в программу не требуется. Эта возможность позволяет использовать getch() для обработки однократных нажатий клавиш, что невозможно с функциями getc() или getchar().
На ПК функция getch() работает совершенно по-другому, чем getc() и getchar(). Частично это объясняется тем, что в ПК легко можно распознать нажатие отдельной клавиши на клавиатуре. В других системах, подобных DEC и VAX С, аппаратура не может отслеживать отдельные нажатия клавиш. Обычно в этих системах выполняется эхо-отображение введенного символа и требуется нажатие клавиши возврата каретки, причем программа не видит нажатия этой клавиши до тех пор, пока не будут введены другие символы, и тогда при ее нажатии возвращается null-символ или десятичный ноль. Кроме того, функциональные клавиши не доступны, и при их нажатии результаты не достоверны.

        17.9. Определение строк в программе.
Символьные строки представляют один из наиболее полезных и важных типов данных языка Си. Хотя до сих пор все время применялись символьные строки, мы еще не все знаем о них. Конечно, нам уже известно самое главное: символьная строка является массивом типа char, который заканчивается нуль-символом ('\0'). Здесь мы больше узнаем о структуре строк, о том, как описывать и инициализировать строки, как их вводить или выводить из программы, как работать со строками.
Ниже представлена работающая программа, которая иллюстрирует несколько способов создания строк, их чтения и вывода на печать. Мы .используем две новые функции: gets (), которая получает строку, и puts (), которая выводит строку. (Вы, вероятно, заметили сходство их имен с функциями getchar () и putchar ().) В остальном программа выглядит достаточно привычно.

/* работа со строками */
#include  <stdio.h>
#define MSG " У вас, наверное, много талантов. Расскажите о некоторых."
/* константа символьной строки */
#define NULL 0
#define LIM 5
#define LINLEN 81 /* максимальная длина строки + 1 */
char m1[] = "Только ограничьтесь одной строкой.";
/* инициализация внешнего символьного массива */
char *m2 = " Если вы не можете вспомнить что-нибудь, придумайте.";
/* инициализация указателя внешнего символьного массива */
void main ()
{
char name[LINLEN];
static char talents [LINLEN];
int i;
int count = 0;
char *m3 = " \n Достаточно обо мне-- Как вас зовут?";
/* инициализация указателя */
static char *mytal[LIM] = {"Быстро складываю числа", "Точно умножаю", "Записываю данные", "Правильно выполняю команды" , "Понимаю язык Си"};
/* инициализация массива строк */
printf(" Привет! Я Клайд, компьютер. У меня много талантов\n");
printf(" %s\n", " Позвольте рассказать о некоторых из них.");
puts(" Каковы они? Ах да, вот их неполный перечень.");
for (i = 0; i < LIM; i++)
	puts(mytal[i]); /* печатает перечень талантов компьютера */
puts(m3);
gets(name);
printf (" Хорошо, %s, %s\n" , name, MSG);
printf (" %s\n%s\n", m1, m2);
gets(talents);
puts(" Давайте, посмотрим, получил ли я этот перечень:");
puts(talents);
printf (" Спасибо за информацию, %s.\n", name);
}

Чтобы помочь вам разобраться в том, что делает эта программа, мы приводим результат ее работы:



Тщательно исследуем программу. Но вместо того чтобы просматривать строку за строкой, применим более общий подход. Сначала рассмотрим способы определения строк в программе. Затем выясним, что нужно для чтения строки в программе. И, наконец, изучим способы вывода строки.

            2.1.3. Строковые константы.
Вы, вероятно, заметили, когда читали программу, что есть много способов определения строк. Попытаемся теперь рассмотреть основные: использование строковых констант, массивов типа char, указателей на тип char и массивов, состоящих из символьных строк. В программе должно быть предусмотрено выделение памяти для запоминания строки, и мы еще вернемся к этому вопросу.
Всякий раз, когда компилятор встречается с чем-то, заключенным в двойные кавычки, он определяет это как строковую константу. Символы, заключенные в кавычки, плюс, завершающий символ '\0', записываются в последовательные ячейки памяти. Компилятор подсчитывает количество символов, поскольку ему нужно знать размер памяти, необходимой для запоминания строки. Наша Программа использует несколько таких строковых констант, чаще всего в качестве аргументов функций printf () и puts (). Заметим также, что мы можем определять строковые константы при помощи директивы #define
Если вы хотите включить в строку символ двойной кавычки, ему должен предшествовать символ обратной дробной черты:

printf("\"Беги, Спот, беги!\" — сказал Дик\n");

В результате работы этого оператора будет напечатана строка:

"Беги, Спот, беги! — " сказал Дик.

Строковые константы размещаются в статической памяти. Вся фраза в кавычках является указателем на место в памяти, где записана строка. Это аналогично использованию имени массива, служащего указателем на расположение массива. Если это действительно так, то как выглядит оператор, который выводит строку?

/* строки в качестве указателей */
#include <stdio.h>
 void main ()
{
printf("%s, %u, %c\n", "We", "love", *"figs");
}

Итак, формат %s выводит строку We. Формат %u выводит целое без знака. Если слово "love" является указателем, то выдается его значение, являющееся адресом первого символа строки. Наконец, *"figs" должно выдать значение, на которое ссылается адрес, т. е. первый символ строки "figs". Произойдет ли это на самом деле? Да, мы получим следующий текст:



Ну, вот! Давайте теперь вернемся к строкам, находящимся в символьных массивах.

            2.1.4. Массивы символьных строк и их инициализация.
При определении массива символьных строк необходимо сообщить компилятору требуемый размер памяти. Один из способов сделать это — инициализировать массив при помощи строковой константы. Так как автоматические массивы нельзя инициализировать, необходимо для этого использовать статические или внешние массивы. Например, оператор

char m1[] = "Только ограничьтесь одной строкой,";

инициализировал внешний (по умолчанию) массив m1 для указанной строки. Этот вид инициализации является краткой формой стандартной инициализации массива

char m1[] = {' Т', ' о', ' л', ' ь', ' к', ' о', ' ', 'о', 'г',
			'р', 'а', 'н', 'и', 'ч', 'ь', 'т', 'е', 'с', 'ь',
			' ', 'о', 'д', 'н', 'о', 'и', ", 'с', 'т',
			'р', 'о', 'к', 'о', 'и', '.', '\0'

(Обратите внимание на замыкающий нуль-символ. Без него мы имеем массив символов, а не строку.) Для той и другой формы (а мы рекомендуем первую) компилятор подсчитывает символы и таким образом получает размер массива.
Как и для других массивов, имя m1 является указателем на первый элемент массива:

m1 == &m1[0], *m1 == 'Т', и *(m1 + 1) == m1[1] == 'о'

Действительно, мы можем использовать указатель для создания строки. Например:

char *m3 = " \n Достаточно обо мне — как вас зовут?";

Это почти то же самое, что и

static char m3[] = " \n Достаточно обо мне — как вас зовут?";

Оба описания говорят об одном: mЗ является указателем строки со словами " Как вас зовут?". В том и другом случае сама строка определяет размер памяти, необходимой для ее размещения. Однако вид их не идентичен.

            2.1.5. Различия: массив и указатель.
В чем же разница между этими двумя описаниями?
Описание с массивом вызывает создание в статической памяти массива из 38 элементов (по одному на каждый символ плюс один на завершающий символ ' \0'. Каждый элемент инициализируется соответствующим символом. В дальнейшем компилятор будет рассматривать имя mЗ как синоним адреса первого элемента массива, т. е. &m3[0]. Следует отметить, что mЗ является константой указателя. Вы не можете изменить m3, так как это означало бы изменение положения (адрес) массива в памяти. Можно использовать операции, подобные mЗ + 1, для идентификации следующего элемента массива, однако не разрешается выражение ++m3. Оператор увеличения можно использовать с именами переменных, но не констант.
Форма с указателем также вызывает создание в статической памяти 38 элементов для запоминания строки. Но, кроме того, выделяется еще одна ячейка памяти для переменной m3, являющейся указателем. Сначала эта переменная указывает на начало строки, но ее значение может изменяться. Поэтому мы можем использовать операцию увеличения; ++m3 будет указывать на второй символ строки (Д). Заметим, что мы не объявили *m3 статической переменной, потому что мы инициализировали не массив из 38 элементов, а одну переменную типа указатель. Не существует ограничений на класс памяти при инициализации обычных переменных, не являющихся массивом.
Существенны ли эти отличия? Чаще всего нет, но все зависит от того, что вы пытаетесь делать.
Посмотрите несколько примеров, а мы возвращаемся к вопросу выделения памяти для строк.
Массив и указатель: различия
В нижеследующем тексте мы обсудим различия в использовании описаний этих двух видов

static char heart[] = "Я люблю Тилли";
char *head = " Я люблю Милли'",

Основное отличие состоит в том, что указатель heart является константой, в то время как указатель head — переменной. Посмотрим, что на самом деле дает эта разница.
Во-первых, и в том и в другом случае можно использовать операцию сложения с указателем

for (i = 0, i < 6, i++ )
	putchar(*(heart + i) );
putchar( \n');
for (i = 0, i < 6, i++)
	putchar(*(head + i) );
putchar('\n'),

результате получаем

Я люблю
Я люблю

Но только в случае с указателем можно использовать операцию увеличения:

while ( *(head) != ' \0' ) /* останов в конце строки */
	putchar( *(head++ ) ); /* печать символа и перемещение указателя */

дают в результате

Я люблю Милли!

Предположим, мы хотим заменить head на heart. Мы можем сказать

head = heart /* теперь head указывает на массив heart */ 

но теперь мы можем сказать

heart = head, /* запрещенная конструкция */

Ситуация аналогична х = 3 или 3 = х, левая часть оператора присваивания должна быть именем переменной. В данном случае head = heart, не уничтожит строку Милли, а только изменит адрес, записанный в head. Вот каким путем можно изменить обращение к heart и проникнуть в сам массив

heart [8] = 'М';

или

*(heart + 8) = 'М';

Элементы массива (но не имя) являются переменными

            2.1.6. Явное задание размера памяти.
Иной путь выделения памяти заключается в явном ее задании. Во внешнем описании мы могли бы сказать:

char m1[44] = "Только ограничьтесь одной строкой.";

вместо

char m1[] = "Только ограничьтесь одной строкой." ;

Можно быть уверенным, что число элементов, по крайней мере, на один (это снова нуль-символ) больше, чем длина строки. Как и в других статических или внешних массивах, любые неиспользованные элементы автоматически инициализируются нулем (который в символьном виде является нуль-символом, а не символом цифры нуль).



Отметим, что в нашей программе массиву name задан размер: 

char name[81];

Поскольку массив name должен читаться во время работы программы, у компилятора нет другого способа узнать заранее, сколько памяти нужно выделить для массива. Это не символьная константа, в которой компилятор может посчитать символы. Поэтому мы предположили, что 80 символов будет достаточно, чтобы поместить в массив фамилию пользователя.

            2.1.7. Массивы символьных строк.
Обычно бывает удобно иметь массив символьных строк. В этом случае можно использовать индекс для доступа к нескольким разным строкам. Покажем это на примере:

static char *myta1[LIM] = {" Быстро складываю числа",
							" Точно умножаю",
							" Записываю данные" ,
							" Правильно выполняю команды",
							" Понимаю язык Си" };

Разберемся в этом описании. Вспомним, что LIM имеет значение 5, мы можем сказать, что mytal является массивом, состоящим из пяти указателей на символьные строки. Каждая строка символов, конечно же, представляет собой символьный массив, поэтому у нас есть пять указателей на массивы. Первым указателем является mytal [0], и он ссылается на первую строку. Второй указатель mytal[1] ссылается на вторую строку. Каждый указатель, в частности, ссылается на первый символ своей строки:

*myta1[0] == 'Б', *myta1[1] == 'Т', myta1[2] == 'З'
и т. д.

Инициализация выполняется по правилам, определенным для массивов. Тексты в кавычках эквивалентны скобочной записи

{{...}, {...}, ..., {...}};

где многоточия подразумевают тексты, которые мы поленились напечатать. В первую очередь мы хотим отметить, что первая последовательность, заключенная в двойные кавычки, соответствует первым парным скобкам и используется для инициализации первого указателя символьной строки. Следующая последовательность в двойных кавычках инициализирует второй указатель и т. д. Запятая разделяет соседние последовательности.
Кроме того, мы могли бы явно задавать размер строк символов, используя описание, подобное такому:

static char myta1[LIM][LINLIM];

Разница заключается в том, что второй индекс задает «прямоугольный» массив, в котором все «ряды» (строки) имеют одинаковую длину. Описание

static char *myta1[LIM]

однако, определяет «рваный» массив, где длина каждого «ряда» определяется той строкой, которая этот «ряд» инициализировала. Рваный массив не тратит память напрасно.



            2.1.8. Указатели и строки.
Возможно, вы заметили периодическое упоминание указателей в нашем рассказе о строках. Большинство операций языка Си, имеющих дело со строками, работает с указателями. Например, рассмотрим приведенную ниже бесполезную, но поучительную программу

/* указатели и строки */
#include<stdio.h>
#define PX(X) printf("X = %s; значение = %u; &X = %u\n" , X, X, &Х)
void main ()
{
static char *mesg = " He делай глупостей!";
static char *copy;
copy = mesg;
printf("%s\n" , copy);
PX(mesg);
PX(copy);
}
Взглянув на эту программу, вы можете подумать, что она копирует строку «Не делай глупостей!», и при беглом взгляде на вывод вам может показаться правильным это предположение:

Не делай глупостей!
mesg = Не делай глупостей!, значение = 14, &mesg = 32
сору = Не делай глупостей!, значение = 14, &сору = 34

Но изучим вывод РХ(). Сначала X, который последовательно является mesg и сору, печатается как строка (%s). Здесь нет сюрприза. Все строки содержат «Не делай глупостей!».
Далее ... вернемся к этому несколько позднее.
Третьим элементом в каждой строке является &Х, т. е. адрес X. Указатели mesg и сору записаны в ячейках 32 и 34 соответственно.
Теперь о втором элементе, который мы называем значением. Это сам X. Значением указателя является адрес, который он содержит. Мы видим, что mesg ссылается на ячейку 14, и поэтому выполняется сору.
Смысл заключается в том, что сама строка никогда не копируется. Оператор сору = mesg; создает второй указатель, ссылающийся на ту же самую строку.
Зачем все эти предосторожности? Почему бы не скопировать всю строку? Хорошо, а что эффективнее — копировать один адрес или, скажем, 50 отдельных элементов? Часто бывает, что адрес — это все, что необходимо для выполнения работы.
Теперь, когда мы обсудили определение строк в программе, давайте займемся вводом строк.

        17.10. Ввод и вывод строк.
Во многих приложениях более естественно выполнять ввод и вывод информации не посимвольно, а большими последовательностями. Например, файл торговых работников может иметь по одной записи в строке, а одна запись может содержать четыре поля: имя торгового работника, основная зарплата, комиссионные и количество проданного товара; при этом поля разделяются пробелами. В этом случае очень неудобно использовать символьный ввод/вывод.
Процесс ввода строки выполняется за два шага: выделение памяти для запоминания строки и применение функции ввода для получения строки.

            2.1.9. Выделение памяти.
Сначала следует определить место для размещения строки при вводе. Как было отмечено раньше, это значит, выделить память, достаточную для размещения любых строк, которые мы предполагаем читать. Не следует надеяться, что компьютер подсчитает длину строки при ее вводе, а затем выделит для нее память. Он не будет этого делать (если только вы не напишите программу, которая должна это выполнять). Если вы попытаетесь сделать что-то подобное

static char *name;
scanf(" %s", name);

компилятор, вероятно, выполнит нужные действия. Но при вводе имя будет записываться на данные или текст вашей программы. Большинство программистов считает это очень забавным, но только в чужих программах.
Проще всего включить в описание явный размер массива:

char name[81];

Можно также использовать библиотечные функции языка Си, которые распределяют память, и мы рассмотрим их позднее.
В нашей программе для name использовался автоматический массив. Мы смогли это сделать, потому что не требовалось инициализации массива.
Как только выделена память для массива, можно считывать строку. Мы уже упоминали, что программы ввода не являются частью языка. Однако большинство систем имеют две библиотечные функции scanf() и gets(), которые могут считывать строки. Чаще всего используется функция gets(), поэтому мы вначале расскажем о ней.

            2.1.10. Использование функций gets(), puts(), fgets() и fputs().

Функция gets() имеет следующий прототип:

char *gets(char *s);

Она выполняет считывание строки символов из стандартного входного потока и помешает их в переменную s. Символ перехода на новую строку '\n' заменяется символом '\0' при помещении в строку s. При использовании этой функции следует соблюдать осторожность, чтобы число символов, считанных из входного потока, не превысило размер памяти, отведенной для строки s.
Функция puts() имеет следующий прототип:

int puts(const char *s);

Она выводит строку в стандартный выводной поток и добавляет символ перевода на новую строку '\n'. В случае успеха puts () возвращает неотрицательное значение. В противном случае она возвращает EOF.
Приведем пример использования функции вывода строк:

#include <stdio.h>
using namespace std;

int main ()
{
	setlocale(LC_ALL, "Rus");
	char* string = "Выводимая строка";
	puts(string);

	getchar(); 	getchar();
	return 0;
}



Функция fgets() имеет три аргумента, в то время как gets() имеет один.
Хороший способ чтения из файла дает функция fgets() (от "get string"):

char *fgets(char *buffer, size_t length, FILE *file);

Тут
    • buffer -- это указатель на буфер, в который мы читаем;
    • length -- это размер буфера;
    • file -- это файл, из которого мы читаем (если читаем с клавиатуры, то разумно использовать stdin).

Функция возвращает строку. Эта функция делает примерно следующее. Она читает из файла file в буфер buffer не больше length-1 символов. Функция может прочитать не все length-1 символов в том случае, если она встретит конец строки, либо конец файла. Функция читает length-1 символ потому, что последний символ функция добавляет сама -- '\0'
Налицо быстрота и безопасность. Главное отличие от scanf-а заключается в том, что функция перестанет читать в тот момент, когда закончится буфер. Быстрота обусловлена тем, что функция scanf должна в момент выполнения разобрать форматную строку, в то время как fgets просто читает строку.
Вот пример ее использования:

/* считывает файл строка за строкой */
#include <stdio.h>
#define MAXLIN 80
void main()
{
FILE *f1;
char string[MAXLIN];
f1 = fopen("story.txt", "r");
while ( fgets(string, MAXLIN, f1) != NULL)
	puts(string);
}

Первый из трех аргументов функции fgets() является указателем на местоположение считываемой строки. Мы располагаем вводимую информацию в символьный массив string.
Второй аргумент содержит +. Функция прекращает работу после считывания символа новой строки или после считывания символов общим числом MAXLIN — 1 (в зависимости от того, что произойдет раньше). В любом случае нуль-символ (' \0') добавляется в самый конец строки.
Третий аргумент указывает, конечно, на файл, который будет читаться.
Разница между gets() и fgets() заключается в том, что gets() заменяет символ новой строки на ' \0', в то время как fgets() сохраняет символ новой строки.
Подобно gets() функция fgets() возвращает значение NULL, если встречает символ EOF. Это позволяет вам проверить, как мы и сделали, достигли ли вы конца файла.
Функция fputs() очень похожа на puts(). Оператор

fputs(* Вы были правы.", fileptr);

передает строку " Вы были правы." в файл, на который ссылается указатель fileptr типа FILE. Конечно, сначала нужно открыть файл при помощи функции fopen(). В самом общем виде это выглядит так

status = fputs(указатель строки, указатель файла); 

где status является целым числом, которое устанавливается в EOF, если fputs() встречает EOF или ошибку.
Подобно puts() эта функция не ставит завершающий символ '\0' в конец копируемой строки. В отличие от puts() функция fputs() не добавляет символ новой строки в ее вывод.
Есть еще одно средство, которое может оказаться полезным, и мы его сейчас обсудим.
В соответствии со структурой файла лучше рассматривать каждую запись как символьную строку и единицу информации при считывании и записи. Для этого пригодна функция fgets(), которая считывает не отдельные символы, а целые строки. Вдобавок к функции fgets() и ее дополнению fputs() имеются аналогичные макросы gets() и puts().
Функция fgets() имеет три параметра: адрес массива, в котором хранится строка символов, максимальное число хранимых символов и указатель на считываемый файл. Эта функция считывает символы в массив до тех пор, пока количество введенных символов не будет на единицу меньше указанного размера (все символы, включая символ перевода строки) или не будет обнаружен признак конца файла.
Если fgets() считывает символ перевода строки, то он запоминается в массиве. Если считывается хотя бы один символ, то функция автоматически добавляет признак конца строки — null-символ \0. Предположим, что файл BOATSALE.DAT выглядит следующим образом:

Pat Pharr 32767 0.15 30 Beth Mollen 35000 0.12 23 Gary Kohut 40000 0.15 40

Если предположить, что максимальная длина строки равна 40 символам включая символ перевода строки, то следующая программа будет читать записи из файла и записывать их на стандартное устройство вывода:

/*Программа на С, демонстрирующая считывание записей при помощи
функции fgets и их вывод на stdout при помощи функции fputs*/
#include "stdafx.h"
#include "E:\LECTURE\AlgorithmProgramming\Universal_HederFile.h"
void StopWait(void);

#define INULL_CHAR 1
#define IMAX_REC_SIZE 40

main()
{
	FILE *pfinfile;
	char crecord[IMAX_REC_SIZE + INULL_CHAR];
	pfinfile=fopen("E:\\LECTURE\\AlgorithmProgramming\\boatsale.dat", "r");
	while(fgets(crecord,IMAX_REC_SIZE +INULL_CHAR,pfinfile) != NULL)
		fputs(crecord,stdout);
	fclose(pfinfile) ;

	StopWait(); /* Wait a little */
	return (0);
}

Поскольку максимальный размер записи равен 40, то необходимо зарезервировать 41 ячейку в памяти; дополнительная ячейка должна хранить null-символ \0. Программа не использует при печати записей дополнительный символ перевода строки; расчет делается на символ перевода строки, считанный в символьный массив функцией fgets(). Функция fputs() печатает содержимое символьного массива crecord в файл stdout, на который указывает указатель файла.
Если программа обращается к файлу в каталоге, отличном от того, в котором располагается компилятор, то в имени файла нужно указать полный путь. Обратите на это внимание в приведенном примере; две обратные наклонные черты (\\) синтаксически необходимы для указания подкаталога. Напоминаем, что одна наклонная черта (\) обычно указывает на то, что далее следует управляющая последовательность или продолжение строки.
Хотя функции gets() и fgets() используются аналогичным образом, функции puts() и fputs() работают по-разному. Функция fputs() записывает в файл и имеет два параметра: адрес символьной строки, заканчивающейся null-символом, и указатель на файл; fputs() просто копирует строку в указанный файл. Символ перевода строки в конце строки не добавляется.
Однако макрос puts() не требует указателя на файл, поскольку вывод автоматически назначается на stdout; в конце выводимой строки автоматически добавляется символ перевода строки.
Функция считывания строки gets() очень удобна для диалоговых систем. Она получает строку от стандартного устройства ввода вашей системы, которым, как мы предполагаем, является клавиатура. Поскольку строка не имеет заранее заданной длины, функция gets() должна знать, когда ей прекратить работу. Функция читает символы до тех пор, пока ей не встретится символ новой строки (' \n'), который вы создаете, нажимая клавишу [ввод]. Функция берет все символы до (но не включая) символа новой строки, присоединяет к ним нуль-символ ('\0') и передает строку вызывающей программе. Вот простой способ использования функции:

/* получение имени1 */
#include <stdio.h>
void main ()
{
char name[81]; /* выделение памяти */
printf("Privet, kak vas zovyt?\n");
gets(name); /* размещение введенного имени в строку "name" */
printf("Horoshee imya, %s.\n", name);
}



Функция примет любое имя (включая пробелы) длиной до 80 символов. (Не забудьте запасти один символ для ' \0' .)
Отметим, что мы хотели при помощи функции gets() воздействовать на нечто (name) в вызывающей программе. Значит, нужно использовать указатель в качестве аргумента; а имя массива, конечно, является его указателем.
Функция gets () обладает большими возможностями, чем показано в последнем примере. Взгляните на эту программу:

/* получение имени2 */
#include <stdio.h>
void main ()
{
char name [80];
char *ptr, *gets (char *string);
printf(" Привет, как вас зовут?\n");
ptr = gets(name);
printf(" %s? Ax! %s!\n", name, ptr);
}

Получился диалог:



Функция gets () предоставляет вам два способа ввода строки!
    • Использует метод указателей для передачи строки в name.
    • Использует ключевое слово return для возврата строки в ptr. Напомним, что ptr является указателем на тип char. Это означает, что gets() должна вернуть значение, которое является указателем на тип char. И в приведенном выше изложении вы можете увидеть, что мы так и описали gets ().

Описание вида

char *gets ();

говорит о том, что gets() является функцией (отсюда круглые скобки) типа «указатель на тип char» (поэтому * и char). В примере получение имени1 мы обходились без этого описания, потому что мы никогда не пытались использовать возвращенное значение функции gets().
Между прочим, вы можете также описать указатель на функцию. Это выглядело бы следующим образом:

char (*foop) ();

и foop был бы указателем на функцию типа char. Мы расскажем немного подробнее о таких причудливых описаниях позднее.
Структура функции gets() выглядела бы примерно так:

char *gets(s);
char *s;
{
char *p;
...
return (p);
}

На самом деле структура немного сложнее, и для gets () есть две возможности возврата. Если все идет хорошо, она возвращает считанную строку, как мы уже сказали. Если что-то неправильно или если gets() встречает символ EOF, она возвращает NULL, или нулевой адрес. Таким образом gets () включает разряд проверки ошибки.
Поэтому данная функция удобна для использования в конструкциях, подобных

while (gets(name) != NULL)

где NULL определен в файле stdio.h как 0. При помощи указателя массиву name присваивается значение. Наличие возврата позволяет присваивать значение всей gets(name) и выполнять проверку на EOF. Этот двоякий подход более компактен, чем использование функции getchar(), которая имеет возврат без аргумента.

while ( (ch = getchar ()) ! = EOF)

Мы должны полагаться на библиотечные функции, которые могут немного изменяться от системы к системе. Функции puts() и printf() — две рабочие лошадки, используемые при выводе строк.
Это очень простая функция; у нее есть только один аргумент, являющийся указателем строки. Нижеследующий пример иллюстрирует некоторые из многих способов ее применения.

/* простые выдачи */
#include <stdio.h>
#define DEF "Я строка #define."
void main ()
{
static char str1[] = "Массив инициализирован мной ." ;
static char *str2 = "Указатель инициализирован мной.";
puts(" Я аргумент функции puts ().");
puts(DEF);
puts(str1);
puts(str2);
puts(&str1[4]);
puts(str2+4);
}


В результате работы программы получаем



Этот пример напоминает нам, что фразы в кавычках и имена строк символьных массивов являются указателями. Обратите внимание на два последних оператора. Указатель &str1[4] ссылается на пятый элемент массива str1. Этот элемент содержит символ 'и', и функция puts () использует его в качестве начальной точки. Аналогично str2 + 4 ссылается на ячейку памяти, содержащую 'а' в «указателе», и с нее начинается вывод строки.
Как puts () узнает, когда остановиться? Она прекращает работу, если встречает нуль-символ, поэтому лучше, чтобы он был. Не пытайтесь делать так!

/* нет строки1 */
main ()
{
static char dont[] = ('H', 'I' , '!','!');
puts(dont); /* dont не является строкой */
}

Поскольку в dont отсутствует завершающий нуль-символ, она не является строкой. Так как нуль-символ отсутствует, puts () не знает, когда ей останавливаться. Она будет просто перебирать ячейки памяти, следующие за dont до тех пор, пока не найдет где-нибудь нуль-символ. Если повезет, она, может быть, найдет его в ближайшей ячейке, но может и не повезти.
Обратите внимание, что любая строка, вводимая функцией puts(), начинается с новой строки. Если puts() в конце концов находит завершающий нуль-символ, она заменяет его символом «новой строки» и затем выводит строку.

        17.11. Функции, работающие со строками.
Большинство библиотек языка Си снабжено функциями, работающими со строками. Рассмотрим четыре наиболее полезных и распространенных: strlen (), strcat (), strcmp () и strcpy().
Мы уже применяли функцию strlen (), которая находит длину строки. Используем ее в нижеследующем примере функции, укорачивающей длинные строки.

            2.1.11. Функция strlen().

/* Функция Прокруста */
fit(string, size)
char *string;
int size;
{
if (strlen(string) > size)
	*(string + size) = ' \0';
}

Проверьте ее в «деле» в этой тестовой программе:

/* тест */
main ()
{
static char mesg[] = "Ну, теперь держитесь, компьютероманы.";
puts(mesg);
fit(mesg, 10);
puts(mesg);
}

Текст программы имеет вид:

#include<stdio.h>
#include <string.h>
void fit(char *string, int size);
void main ()
{
static char mesg[] = "Ну, теперь держитесь, компьютероманы.";
puts(mesg);
fit(mesg, 10);
puts(mesg);
}
void fit(char *string,int size)
{
if (strlen(string) > size)
	*(string + size) = ' \0';
}



Наша функция помешает символ '\0' в одиннадцатый элемент массива, заменяя символ пробела. Остаток массива остается на старом месте, но puts () прекращает работу на первом нуль-символе и игнорирует остаток массива.

            2.1.12. Функция strcat().
Вот что умеет делать функция strcat ():

/* объединение двух строк */
#include <stdio.h>
#include<string.h>
void main ()
{
static char flower [80];
static char addon[] = "ы пахнут старыми ботинками.";
puts(" Назовите ваш любимый цветок.");
gets(flower);
strcat(flower, addon);
puts(flower);
}

Получаем на экране:



Очевидно, что strcat () (string concatenation) использует в качестве аргументов две строки. Копия второй строки присоединяется к концу первой, и это объединение становится новой первой строкой. Вторая строка не изменяется.
Внимание! Эта функция не проверяет, умещается ли вторая строка в первом массиве. Если вы ошиблись при выделении памяти для первого массива, то у вас возникнут проблемы. Конечно, можно использовать strlen () для определения размера строки до объединения.

/* Объединение двух строк, проверка размера первой */
#include< stdio.h>
#include<string.h>
#define SIZE 80
void main ()
{
static char flower [SIZE];
static char addon[] = "ы пахнут старыми ботинками.";
puts("Назовите ваш любимый цветок.");
gets(flower);
if ( (strlen(addon) + strlen(flower) + 1) < SIZE)
	strcat(flower, addon);
puts(flower);
}



Мы добавляем 1 к объединенной длине для размещения нуль-символа.

            2.1.13. Функция strcmp().
Предположим, что вы хотите сравнить чей-то ответ со строкой, находящейся в памяти:

/* Будет ли это работать? */
#include <stdio.h>
#include <string.h>
#define ANSWER "Grant"
main ()
{
char chance [40];
puts("Who was buried in the Grant's grave?");
gets(chance);
while(chance != ANSWER)
{
	puts(" No, incorrectly. Try again, please.");
	gets(chance);
}
puts (" You all right!");
}



Хотя эта программа и смотрится неплохо, она не будет работать правильно,chance и ANSWER на самом деле являются указателями, поэтому сравнение (chance != ANSWER) спрашивает не о том, одинаковы ли эти две строки, а одинаковы ли два адреса, на которые ссылаются chance и ANSWER. Так как ANSWER и chance запоминаются в разных ячейках, эти два указателя никогда не могут быть одним и тем же, и пользователю всегда сообщается, что программа неверна. Такие программы обескураживают людей.
Нам нужна функция, которая сравнивает содержимое строк, а не их адреса. Можно было бы придумать ее, но это уже сделала за нас функция strcmp () (string comparision).
Теперь исправим нашу программу:

/* это будет работать */
#include <stdio.h>
#include <string.h>
#define ANSWER "Grant"
void main ()
{
char chance [40];
puts("Who was buried in the Grant's grave?");
gets(chance);
while (strcmp(chance, ANSWER) != 0)
{
	puts(" No, incorrectly. Try again, please.");
	gets(chance);
}
puts(" You all right!");
}



Так как ненулевые значения интерпретируются всегда как «true», мы можем сократить оператор while до while (strcmp(chance, ANSWER)).
Из этого примера можно сделать вывод, что strcmp () использует два указателя строк в качестве аргументов и возвращает значение 0, если эти две строки одинаковы. Прекрасно, если вы придете к такому выводу.
Хорошо, что strcmp() сравнивает строки, а не массивы. Поэтому, хотя массив chance занимает 40 ячеек памяти, а " Grant" — только 6 (не забывайте, что одна нужна для нуль-символа), сравнение выполняется только с частью try, до его первого нуль-символа. Такую функцию Strcmp () можно использовать для сравнения строк, находящихся в массивах разной длины.
А что если пользователь ответил " GRANT" или "grant" или "Улиссес С. Грант"? Хорошо, если пользователю сказали, что он ошибся? Чтобы сделать программу гибкой, вы должны предусмотреть несколько допустимых правильных ответов. Здесь есть некоторые тонкости. Вы могли бы в операторе #define определить в качестве ответа "GRANT" и написать функцию, которая превращает любой ответ только в это слово. Это устраняет проблему накопления, но остаются другие поводы для беспокойства.
Между прочим, какое значение возвращает strcmp(), если строки не одинаковы? Вот пример:

/* возвраты функции strcmp */
#include <stdio.h>
#include<string.h>
void main ()
{
printf("%d\n" , strcmp("A" , "A"));
printf("%d\n" , strcmp("A" , "B"));
printf("%d\n" , strcmp("B" , "A"));
printf(" %d\n", strcmp("C" , "A"));
printf(" %d\n" , strcmp("apples" , "apple"));
}



В результате получаем

0
-1
1
2
115

Как мы и предполагали, сравнение "А" с самим собой возвращает 0. Сравнение "А" с "В" дает -1, а "В" с "А" дает 1. Это наводит на мысль, что strcmp() возвращает отрицательное число, если первая строка предшествует второй в алфавитном порядке, или положительное число, если порядок иной. Кроме того, сравнение "С" с "А" дает 2 вместо 1. Картина проясняется: функция возвращает разницу между двумя символами в коде ASCII. В более общем смысле strcmp() передвигается вдоль строк до тех пор, пока не находит первую пару несовпадающих символов; затем она возвращает разницу в кодах ASCII. Например, в самом последнем примере "apples" и "apple" совпадают, кроме последнего символа 's', в первой строке. Он сопоставляется с шестым символом в "apple", который является нуль-символом (0 в ASCII).
Возвращается значение

's' - '\0' = 115 - 0 = 115, 

где 115 является кодом буквы 's' в ASCII.
Обычно вам не нужно точно знать возвращаемое значение. Чаще всего вы только хотите знать, нуль это или нет, т. е. было ли совпадение. Или, может быть, вы пытаетесь отсортировать строки в алфавитном порядке и хотите узнать, в каком случае сравнение дает положительный, отрицательный или нулевой результат.
Можно использовать эту функцию, чтобы проверить, остановится ли программа, читая вводимую информацию:

/* Начало какой-то программы */
#include < stdio.h>
#define SIZE 81
#define LIM 100
#define STOP " "/* нулевая строка */
main ()
{
static char input [LIM] [SIZE];
int ct = 0;
while(gets(input[ct]) != NUL && strcmp(input[ct], STOP) != 0 && ct++ < LIM)
...
}

Программа прекращает чтение вводимой строки, если встречает символ EOF [в этом случае gets () возвращает NULL], или если вы нажимаете клавишу [ввод] в начале строки (т. е. введете пустую строку), или если вы достигли предела LIM. Чтение пустой строки дает пользователю простой способ прекращения ввода.
Давайте перейдем к последней из обсуждаемых нами функций, работающих со строками.

            2.1.14. Функция strcpy().
Мы уже говорили, что если pts1 и pts2 являются указателями строк, то выражение

pts2 = pts1;

копирует только адрес строки, а не саму строку. Предположим, что вы все же хотите скопировать строку. В этом случае можно использовать функцию strcpy (). Она работает примерно так:

/* демонстрация strcpy () */
#include <stdio.h>
#include <string.h>
#define WORDS "Проверьте, пожалуйста, вашу последнюю запись. "
void main ()
{
static char *orig = WORDS;
static char copy [40];
puts(orig);
puts(copy);
strcpy(copy, orig);
puts(orig);
puts(copy);
}

Вот результат:



Очевидно, что строка, на которую указывает второй аргумент (orig) функции strcpy (), скопирована в массив, на который указывает первый аргумент (сору). Порядок аргументов функции такой же, как в операторе присваивания: строка, получающая значение, стоит слева. (Пустая строка является результатом печати массива сору до копирования, и она говорит о том, что статические массивы инициализируются нулями, т. е. нуль-символами в символьном виде.)
Нужно обеспечить, чтобы размер массива, принимающего строку, был достаточен для ее размещения. Поэтому мы используем описание

static char copy [40];

а не

static char *copy; /* не выделяет память для строки */

Короче говоря, strcpy() требует два указателя строк в качестве аргументов. Второй указатель, ссылающийся на исходную строку, может быть объявленным указателем, именем массива или строковой константой. А первый указатель, ссылающийся на копию, должен ссылаться на массив или часть массива, имеющего размер, достаточный для размещения строки.
Теперь, когда мы описали несколько функций, работающих со строками, рассмотрим целую программу, работающую со строками.

Пример: сортировка строк.
Возьмем реальную задачу сортировки строк в алфавитном порядке. Эта задача может возникнуть при подготовке списка фамилий, при создании алфавитного указателя и во многих других ситуациях. В такой программе одним из главных инструментов является функция strcmp(), так как ее можно использовать для определения старшинства двух строк. Последовательность наших действий будет состоять из считывания массива строк, их сортировки и последующего вывода. Совсем недавно мы показали последовательность действий для считывания строк, и сейчас мы начнем программу таким же образом.

/* считывает строки и сортирует их */
#include <stdio.h>
#define SIZE 81 /* предельная длина строки, включая\0 */
#define LIM 20 /* максимальное количество считываемых строк */
#define HALT " " /* нулевая строка для прекращения ввода */
main ()
{
static char input [LIM] [SIZE]; /* массив для запоминания вводимых строк */
char *ptstr[LIM]; /* массив переменных типа указатель */
int ct = 0; /* счетчик вводимых строк */
int k; /* счетчик выводимых строк */
printf(" Введите до %d строк и я их отсортирую.\n" , LIM);
printf(" Для прекращения ввода нажмите клавишу [ввод] в начале строки\n");
while( ( gets(input[ct]) != NULL) && strcmp(input[ct], HALT) != 0&& ct++ < LIM)
	ptstr[ct - 1] = input [ct - 1]; /указывает на еще не отсортированный ввод */
stsrt(ptstr, ct); /* сортировка строк */
puts(* \nВот отсортированный список строк:\n");
for (k = 0; k < ct; k++ )
	puts(ptstr[k]); /* указатели на отсортированные строки */
}

/* функция сортировки строк с использованием указателей */
stsrt(strings, num)
char *strings[];
int num;
{
char *temp;
int top, seek;
for (top = 0; top < num - 1; top++ )
	for (seek = top + 1; seek < num; seek++)
		if (strcmp(strings[top], strings[seek]) > 0)
		{
			temp = strings [top];
			strings [top] = strings [seek];
			strings [seek] = temp;
		}
}

Исходный текст программы будет иметь вид:
/* считывает строки и сортирует их */
#include <stdio.h>
#include <string.h>
#define SIZE 81 /* предельная длина строки, включая\0 */
#define LIM 20 /* максимальное количество считываемых строк */
#define HALT " " /* нулевая строка для прекращения ввода */
void stsrt(char *strings[], int num)
{
char *temp;
int top, seek;
for (top = 0; top < num - 1; top++ )
	for (seek = top + 1; seek < num; seek++)
		if (strcmp(strings[top], strings[seek]) > 0)
		{
			temp = strings [top];
			strings [top] = strings [seek];
			strings [seek] = temp;
		}
}

void main ()
{
static char input [LIM] [SIZE]; /* массив для запоминания вводимых строк */
char *ptstr[LIM]; /* массив переменных типа указатель */
int ct = 0; /* счетчик вводимых строк */
int k; /* счетчик выводимых строк */
printf(" Введите до %d строк и я их отсортирую.\n" , LIM);
printf(" Для прекращения ввода нажмите клавишу [ввод] в начале строки\n");
while( ( gets(input[ct]) != NULL) && strcmp(input[ct], HALT) != 0&& ct++ < LIM)
	ptstr[ct - 1] = input [ct - 1]; /*указывает на еще не отсортированный ввод */
stsrt(ptstr, ct); /* сортировка строк */
puts(" \nВот отсортированный список строк:\n");
for (k = 0; k < ct; k++ )
	puts(ptstr[k]); /* указатели на отсортированные строки */
}



Вывод строк на печать не составляет проблемы, а для сортировки можно взять тот же алгоритм, который использовался раньше для чисел. Сейчас мы применим один хитрый трюк: посмотрим, сможете ли вы его заметить.
Для проверки возьмем детский стишок.

Введите до %d строк и я их отсортирую.
Для прекращения ввода нажмите клавишу [ввод] в начале строки
Жил на свете человек
Скрюченные ножки
И гулял он целый век
По скрюченной дорожке

Вот отсортированный список строк
Жил на свете человек
И гулял он целый век
По скрюченной дорожке
Скрюченные ножки 

Детские стишки не кажутся слишком искаженными после сортировки их по алфавиту.
Трюк состоит в том что вместо перегруппировки самих строк мы перегруппировали их указатели. Разберемся в этом. В начале ptrst[0] ссылается на input[0] и т. д. Каждый input[] является массивом из 81 элемента, а каждый элемент ptrst[] является отдельной переменной. Процедура сортировки перегруппировывает ptrst, не трогая input. Если, например, input[1] стоит перед input[0] по алфавиту, то программа переключает указатели ptrst, в результате чего ptrst[0] ссылается на input[1], a ptrst[1] на input[0]. Это гораздо легче, чем, используя strcpy (), менять местами две введенные строки. Просмотрите еще раз этот процесс на рисунке.
И наконец, давайте попытаемся заполнить пробелы, оставшиеся в нашем описании, а именно «пустоту» между скобками в функции main().

        17.12. Создание собственных функций ввода/вывода.
Не ограничивайте себя при вводе и выводе только этими библиотечными функциями. Если у вас нет нужной функции, или она вам не нравится, можно создавать свои собственные версии, используя для этого getchar() и putchar().
Предположим, у вас нет функции puts(). Вот один из путей ее создания:

/* put1---- печатает строку */
put1 (string);
char *string;
{
while(*string != ' \0')
	putchar(*string++ );
putchar(' \n');
}

Символьный указатель string вначале ссылается на первый элемент вызванного аргумента. После печати его содержимого указатель увеличивается и ссылается уже на следующий элемент. Это продолжается до тех пор, пока указатель не дойдет до элемента, содержащего нуль-символ. Затем в конце строки будет поставлен символ новой строки.
Предположим, у вас есть puts(), но вам нужна функция, которая, кроме того, сообщает, сколько напечатано символов. Эту возможность легко добавить:

/* put2-----печатает строку и считывает символы */
put2 (string);
char *string;
{
int count = 0;
while (*string != ' \0')
{
	putchar(*string ++);
	count ++;
}
putchar(' \n');
return(count);
}

Вызов

put2("пицца");

печатает строку пицца, в то время как оператор

num = puts("пицца");

передаст, кроме того, количество символов в num; в данном случае это число 5. Вот несколько более сложный вариант, показывающий вложенные функции:

/* вложенные функции */
#include <stdio.h>
main ()
{
put1 ("Если бы я имел столько денег, сколько могу потратить,");
рrintf("Я считаю %d символа\n",
	put2 ("Я никогда бы не жаловался, что приходится чинить старые стулья."));
}

Исходный текст программы будет иметь следующий вид:

/* вложенные функции */
#include <stdio.h>
/* put1---- печатает строку */
void put1 (char *string)
{
while(*string != '\0')
	putchar(*string++ );
putchar(' \n');
}
/* put2-----печатает строку и считывает символы */
int put2 (char *string)
{
int count = 0;
while (*string != '\0')
{
	putchar(*string ++);
	count ++;
}
putchar(' \n');
return(count);
}

void main ()
{
put1 ("If I had so much money, how much I could spent,");
printf("I count %d simbols\n",	put2 ("I would never complain about needs to repair old chairs."));
}

(Мы включили в программу при помощи директивы #include файл Stdio.h, потому что в нашей системе в нем определена функция putchar(), а она используется в нашей новой функции.)
Да-а, мы используем функцию printf() для печати значения put2(), но в процессе нахождения значения put2() компьютер должен сначала заставить ее поработать — напечатать строку. Вот что получается при этом:



Теперь вы можете построить работающую версию функции gets (); она должна быть похожа на нашу функцию getint (), но гораздо проще ее.
        17.13. Проверка и преобразование символов.
Заголовочный файл ctype.h содержит несколько функций макроопределений, которые проверяют, к какому классу принадлежат символы. Функция isalpha(c), например, возвращает ненулевое значение (истина), если с является символом буквы, и нуль (ложь), если символ не является буквой. Таким образом,

isalpha('S') != 0, но isalpha('#') ==0

Ниже перечислены функции, чаще всего находящиеся в этом файле. В каждом случае функция возвращает ненулевое значение, если с принадлежит к опрашиваемому классу, и нуль в противном случае.
ФУНКЦИЯ	ПРОВЕРЯЕТ, ЯВЛЯЕТСЯ ЛИ c
isalpha(c)	буквой
isdigit(c)	цифрой
islower(c)	строчной буквой
isspace(c)	пустым символом (пробел, табуляция или новая строка)
isupper(c)	прописной буквой

Ваша система может иметь дополнительные функции, такие как
ФУНКЦИЯ	ПРОВЕРЯЕТ, ЯВЛЯЕТСЯ ЛИ c
isalnum(c)	алфавитно-цифровым (буква или цифра)
isascii(c)	кодом ASCII (0—127)
iscntrl(c)	управляющим символом
ispunct(c)	знаком пунктуации

Еще две функции выполняют преобразования:

toupper(c)	преобразует с в прописную букву
tolower(c)	преобразует с в строчную букву

В некоторых системах преобразование выполняется только в случае, если символ находится в регистре (прописных или строчных букв), противоположном тому, с которого следует начинать. Однако надежнее предварительно проверить регистр.
Ниже дана программа, использующая некоторые из этих функций для преобразования всего файла в прописные, или строчные буквы, по вашему желанию. Для получения небольшого разнообразия используем диалоговый подход, вместо того чтобы применять аргументы командной строки для снабжения программы информацией.

/* преобразование строчных букв в прописные и обратно */
#include <stdio.h>
#include < ctype.h> /* включает файл макроопределений */
#define. UPPER 1
#define LOWER 0
main()
{
int crit; /* для установки регистра прописных или строчных букв */
char file1[14], file2[14]; /* имена входного и выходного файлов */
crit = choose(); /* выбирает прописные или строчные буквы */
getfiles(file1, file2); /* получает имена файлов */
conv(file1, file2, crit); /* выполняет преобразование */
}

choose()
{
int ch;
printf(" Программа преобразует весь файл в прописные буквы или \n");
printf(" в строчные буквы. Вводит U, если нужны прописные буквы\n");
printf(" или вводит L, если нужны строчные буквы.\n");
while ( (ch = getchar()) != 'U' && ch != 'u' && ch ! = 'L' && ch !='!')
	printf(" Введите, пожайлуста, U или L.\n");
while (getchar() != '\n')
; /* сбрасывает последний символ новой строки */
if ( ch == 'U' || ch == 'u')
{
	printf(" Все в порядке, есть регистр прописных букв.");
	return(UPPER);
}
else
{
	printf(" Все в порядке, есть регистр строчных букв." );
	return(LOWER);
}
}

getfiles(name1, name2);
char *name1, name2;
{
	printf(" Какой файл вы хотите преобразовать? \n" );
	gets(name1);
	printf(" Это\" %s\" \n", name1);
	printf(" Какое имя вы хотите выбрать для преобразуемого файла? \n");
	while ( strcmp(gets(name2), name1) == NULL)
		printf(" Выберите другое имя\n" );
	printf(" Ваш выходной файл\" %s\" \n", name2);
}

conv(name1, name2, crit)
char *name1, name2;
int crit;
{
int ch;
FILE *f1, *f2;
if ( (f1 = fopen(name1, "r")) == NULL)
	printf("Извините, я не могу открыть %s. До свидания.\n" , name1);
else
{
	puts(" Итак, начнем!");
	f2 = fopen(name2, "w");
	while ( (ch = getc(f1)) != EOF)
	{
		if (crit == UPPER)
			ch = islower(ch) ? toupper(ch) : ch;
		else
			ch = isupper(ch) ? tolower(ch) : ch;
		putc(ch, f2);
	}
	fclose(f2);
	fclose(f1);
	puts(" Сделано!");
}
}

Мы разделили программу на три части: получение от пользователя указания о виде преобразования, получение имени входного и выходного файлов и выполнение преобразования. Чтобы осуществить все это, мы создали разные функции для каждой -части.
Функция choose() довольно проста за исключением, может быть, цикла

while( getchar() ! = ' \n')
;

Этот цикл включен для решения проблемы, с которой мы столкнулись раньше. Когда пользователь отвечает на вопрос о виде преобразования, скажем, буквой U, он нажимает клавишу U, а затем клавишу [ввод], которая передает ' \n'. Первоначальная функция getchar() извлекает U, но оставляет ' \n' для следующего чтения строки. Функция gets(), входящая в getnames(), интерпретировала бы ' \n' как пустую строку, поэтому мы использовали малый цикл while, чтобы избавиться от символа «новая строка». Действительно, простая getchar(), сделала бы это, если бы пользователь непосредственно за U нажимал бы [ввод]. Но наша версия, кроме того, предусматривает возможность нажать на клавишу пробела несколько раз перед [ввод].
В функции getnames() для вас не должно быть сюрпризов. Учтите, что мы запрещаем пользователю применять одинаковые имена для выходного и входного файлов. Стандартная версия функции fopen() не позволяет вам и читать и записывать один и тот же файл, если вы открыли его один раз.
Функция conv() является функцией копирования с выполнением преобразования. Значение crit используется для определения требуемого преобразования. Работа выполняется простым условным оператором, таким как

ch = islower(ch) ? toupper(ch) : ch;

Он проверяет, является ли ch строчной буквой. Если да, то символ преобразуется в прописную букву. Если нет, остается как есть.
Макрофункции файла ctype.h предоставляют удобные и полезные средства для программирования. Теперь давайте займемся некоторыми более сложными функциями преобразования.

        17.14. Преобразования символьных строк: atoi(), atof().
Использование scanf() для считывания цифровых значений не является самым надежным способом, поскольку scanf() легко ввести в заблуждение ошибками пользователей при вводе чисел с клавиатуры. Некоторые программисты предпочитают считывать даже числовые данные как символьные строки и преобразовывать строку в соответствующее числовое значение. Для этого используются функции atoi() и atof(). Первая преобразует строку в целое, вторая — в число с плавающей точкой. Вот образец их использования:

/* включение atoi() */
#include <stdio.h>
#include <windows.h>
#include<ctype.h>
#define issign(c) ( ((c) =='-' || (c) =='+')? (1) : (0))
#define SIZE 10
#define YES 1
#define NO 0
void main()
{
char ch;
static char number [SIZE];
int value;
int digit = YES;
int count = 0;
puts(" Enter integer number.");
gets(number);
if (number[SIZE - 1] != '\0')
	{
	puts(" Too many numbers; You killed me.");
	exit(1);
	}
while ( (ch = number [count]) != '0' && digit == YES)
	if( !issign(ch) && !isdigit(ch) && !isspace(ch) )
		digit = NO;
	if ( digit == YES)
	{
		value = atoi(number);
		printf("The number was %d.\n" , value);
	}
	else
		printf(" It doesn't look like integer.");
}

Мы предусмотрели проверку некоторых ошибок.
Во-первых, следует посмотреть, умещается ли входная строка в предназначенном для нее массиве. Поскольку number является статическим символьным массивом, он инициализируется нулями. Если последний элемент массива не является нулем, значит что-то неверно, и программа прекращает работу. Здесь мы использовали библиотечную функцию exit(), которая выводит нас из программы. Немного позже мы расскажем кратко об этой функции.
Затем посмотрим, не содержит ли строка что-нибудь кроме пробелов, цифр и алгебраических знаков. Функция отвергает такие строки, как «дерево» или «1.2Е2». Ее устраивает смесь, подобная «3 - 4 + 2», но atoi() будет выполнять дальнейший отбор. Вспомним, что ! является операцией отрицания, поэтому !isdigit(c) означает: «с не является цифрой».
Строка

value = atoi(number);

показывает, как используется функция atoi(). Ее аргумент является указателем символьной строки; в этом случае мы применили имя массива number. Функция возвращает целое значение для такой строки. Таким образом, «1234» является строкой из четырех символов и переводится в 1234 — единое число типа int.
Функция atoi() игнорирует ведущие пробелы, обрабатывает ведущий алгебраический знак, если он есть, и обрабатывает цифры вплоть до первого символа, не являющегося цифрой. Поэтому наш пример «3 - 4 + 2» был бы превращен в значение 3.
Функция atof() выполняет подобные действия для чисел с плавающей точкой. Она возвращает тип double, поэтому должна быть описана как double в использующей ее программе.
Простые версии atof() будут обрабатывать числа вида 10.2, 46 и —124.26. Более мощные версии преобразуют также экспоненциальную запись, т. е. числа, подобные 1.25Е — 13.
Ваша система может также иметь обратные функции, работающие в противоположном направлении. Функция itоа() будет преобразовывать целое в символьную строку, а функция ftoa() преобразовывать число с плавающей точкой в символьную строку.

В то время как фунция fgets читеат обычную строку, функция scanf может читать и различные другие типы (целые, вещественные числа).
В языке C есть семейство функций - atoi (a -- ASCII, i -- integer):

N = atoi(string);

Функция принимает единственный параметр строку и пытается ее привести в типу int. Надо заметить, что функция atoi безопасная, но не очень удобная. Безопасная в том смысле, что не сломается: atoi("25a") == 25. "Неудобства" заключаются в том, то если мы передаем в качестве параметра строку, в которой есть не только числа, нужно быть очень внимательным и знать, как работает эта функция. Функция atoi никак не проинформирует нас, если преобразование прошло неудачно.
Например, atoi("abc") == 0, что на самом деле не совсем соответствует действительности. Использовать функцию atoi нужно лишь в том случае, когда вы уверены, что в строке есть число.
Родственные функции: atol, atoll, atof, strtol.
Им соответствуют функции для преобразования в типы long, long long и float.

Рассмотрим подробнее strtol:

long strtol(char *buffer, char **endPtr, int base);

Тут
buffer -- это указатель на буфер, из которого мы читаем;
endPtr -- это переменная, которая используется для того, чтобы сообщить нам насколько успешно произошло преобразование; это указатель на char *, в котором записан первый символ, который не смог проинтерпретироваться с помощью функции strtol;
Применение выглядит примерно так:

char *end;
char *ptr = "25a";
int N = strtol(ptr, &end, 10);

Теперь end указывает на "a".

if (ptr == end) {
    // ничего не получилось прочитать
}

    • base -- это основание системы счисления, с которой мы работаем (от 2 до 36);
    • Функция возвращает целое число типа long.

Более мощное средство
Есть более мощное средство, чем нежели fgets + atoi. Речь идет о функции sscanf. Вместо использования функции fscanf(f, "%d", &N) можно использовать связку:

fgets(ptr, 100, f);
sscanf(ptr, "%d", &N);

В чем преимущество и мощность такого подхода?

    • Мы знаем длину того, что мы прочитали;
    • Рассмотрим следующую ситуацию: мы хотим прочитать какие-то данные, но не смогли из-за ошибки.

Используя такой подход, мы можем передать пользователю сообщение об ошибке и ту строчку, которую нам не удалось прочитать: ptr. С использованием fscanf-а это невозможно.
С помощью fscanf-а мы можем только узнать, сколько переменных было успешно прочитан. А именно: посмотреть на возвращаемое значение.
При таком подходе, осталась невысокая скорость работы, однако надежность есть.



        17.15. Ввод и вывод целых чисел.
В некоторых программах возникает необходимость ввода и вывода в поток (или в буфер) целочисленной информации. Для этого в С имеется две функции: getw() и putw().

            2.1.15. Использование функций getw() и putw().
Дополняющие друг друга функции getw() и putw() весьма похожи на функции getc() и putc(); отличие в том, что они работают с целыми числами, а не с символами. Функции getw() и putw() можно использовать только с файлами, открытыми в двоичном режиме. Следующая программа открывает файл в двоичном режиме, записывает в него десять целых чисел, закрывает файл, а затем заново открывает файл на считывание и распечатывает числа:

/*Программа на С, использующая функции getw и putw с файлом,
открытом в двоичном режиме*/
#include "stdafx.h"
#include "E:\LECTURE\AlgorithmProgramming\Universal_HederFile.h"
void StopWait(void);

#define ISIZE 10

int main()
{
	FILE *pfi;
	int ivalue,ivalues[ISIZE],i;
	pfi = fopen("E:\\LECTURE\\AlgorithmProgramming\\integer.dat", "wb");
	if (pfi = NULL)
	{
		printf("File could not be opened"); /* Файл невозможно открыть */
		exit(1);
		for(i = 0; i < ISIZE; i++)
		{
			ivalues [i]=i- NULL ;
			putw (ivalues [i] ,pfi) ;
		}
		fclose (pfi) ;
		pfi=fopen("E:\\LECTURE\\AlgorithmProgramming\\integer.dat", "r+b");
		if(pfi = NULL)
		{
			printf("File could not be re-opened");	/* Файл невозможно открыть */
															/* заново */
			exit(1);
		}
		while (!feof (pfi))
		{
			ivalue = getw(pfi);
			printf("%3d",ivalue) ;
		}
	}

	StopWait(); /* Wait a little */
	return (0);
}

Посмотрите на результат работы программы и определите, что неправильно:

1 2 3 4 5 6 7 8 9 10 -1

Поскольку целое значение, считываемое в последнем цикле, может иметь значение EOF, для проверки признака конца файла в программе используется функция feof(). Однако, эта функция не выполняет опережающего считывания, как делается в подобных функциях в некоторых других языках высокого уровня. В С для определения этого условия необходимо реально выполнить операцию считывания значения "конец файла".
Для того чтобы исправить эту ситуацию, программу нужно переписать, используя так называемый оператор предварительного считывания:

/*Программа на С, использующая функции getw и putw с файлом,
открытом в двоичном режиме*/
#include "stdafx.h"
#include "E:\LECTURE\AlgorithmProgramming\Universal_HederFile.h"
void StopWait(void);

#define ISIZE 10

main()
{
	FILE *pfi;
	int ivalue,ivalues[ISIZE],i;
	pfi = fopen("E:\\LECTURE\\AlgorithmProgramming\\integer.dat ", "w+");
	if (pfi == NULL)
	{
		printf("File could not be opened"); /* Файл невозможно открыть */
		exit(1) ;
	}
	for(i = 0; i < ISIZE; i++)
	{
		ivalues[i]=i+1;
		putw(ivalues[i],pfi);
	}
	fclose (pfi);

	pfi=fopen("E:\\LECTURE\\AlgorithmProgramming\\integer.dat ", "r+");
	if(pfi == NULL)
	{
		printf("File could not be re-opened");	/* Файл невозможно открыть */
														/* заново */
		exit(1);
	}
	while(!feof(pfi))
	{
		ivalue=getw(pfi);
		printf("%3d",ivalue);
	}

	StopWait(); /* Wait a little */
	return (0);
}

Перед тем как в программе начинается последний цикл while, выполняется предварительное считывание для того, чтобы определить, не пустой ли файл, и, если это так, то действующее целое значение запоминается в переменной ivalue. Однако, если файл пустой, то функция feof() распознает это, и цикл while не выполняется.
Обратите также внимание на то, что предварительное считывание вызывает перестановку операторов внутри цикла while. При входе в цикл переменная ivalue содержит действующее целое значение. Если бы операторы в цикле оставались теми же, что и в предыдущей программе, то сразу же выполнился бы второй вызов функции getw() и при этом было бы потеряно первое целое значение. Из-за наличия предварительного считывания первым оператором в цикле while должен быть оператор вывода, за которым следует вызов функции getw() для считывания следующего значения.
Предположим, что цикл while выполнился девять раз. К концу девятого прохода выполнилась эхо-печать целых чисел от 1 до 8 и переменной ivalue присвоено значение 9. При следующем проходе цикла печатается 9 и вводится значение 10. Поскольку значения 10 и EOF не совпадают, цикл повторяется снова, в результате чего печатается значение 10 и считывается EOF. В этот момент цикл прекращается, поскольку функция feof() распознает условие конца файла.
Два приведенных примера иллюстрируют необходимость в соблюдении осторожности при написании программ с функцией feof(). Это — специфическая программистская проблема, так как каждый язык высокого уровня может трактовать условие конца файла по-своему. В некоторых языках при считывании данных выполняется предварительный анализ возможного на следующем этапе условия конца файла; в других языках, таких как С, этого не происходит.

        17.16. Форматированный вывод.
Богатый ассортимент средств управления форматом вывода в С позволяет легко создавать печатные графики, отчеты или таблицы. Двумя основными функциями, выполняющими этот форматированный вывод, являются printf() и эквивалентная функция для файлов — fprintf(). Эти функции могут использовать любые символы преобразования, показанные в табл. 11.2. Спецификация формата имеет следующий вид:

%[флаги] [ширина] [.точность] [{h | 1 | L}]тип

Таблица 11.2. Символы преобразования для функций printf() и fprintf()

ПОЛЕ “ТИП”
Сим-
вол
Тип
Формат вывода
c
int или wint_t
printf—означает однобайтный символ
wprintf—означает широкий символ
C
int или wint_t
printf—означает широкий символ
wprintf—означает однобайтный символ
d
int
Десятичное целое зо знаком
e
double
Число со знаком в виде [-]d.ddd e [знак]ddd,где d-отдельная десятичная цифра, ddd-одна или несколько десятичных цифр, ddd-ровно четыре десятичные цифры и знак “+” или ”-”
E
double
То же что и “е”, за исключением того, что перед экспонентой стоит “E”
f
double
Число со знаком в виде [-]ddd.ddd, где d-одна или несколько десятичных цифр. Число цифр после десятичной точки зависит от точности 
g
double
Число со знаком в формате ”f” или ”e”. Используется наиболее компактная форма. Отсутствуют нули в младших разрядах. Нет десятичной точки, если за ней отсутствуют цифры 
G
double
То же что и “g”, за исключением того, что перед экспонентой стоит “G”
i
int
Десятичное целое со знаком
n
Указатель на целое
Количество символов, записанных в поток или буфер. Адрес буфера, определяемого целочисленным аргументом
o
Int
Восьмеричное число без знака
p
Указатель на void
Печатается адрес(определяемый аргументом)
s
строка
printf – определяет строку однобайтных символов
wprintf - определяет строку широких символов(печать в NULL или с максимальной точностью)
S
строка
printf – определяет строку широких символов
wprintf - определяет строку однобайтных символов (печать в NULL или с максимальной точностью)
u
строка
Десятичное целое без знака
x
int
Шестнадцатеричное целое без знака (используются символы нижнего регистра)
X
int
Шестнадцатеричное целое без знака (используются символы верхнего регистра)

Таблица 11.2 Символы преобразования для функций printf() и fprintf() (продолжение)

Флаг
Значение
#
Перед ненулевыми значениями ставиться 0, 0x, или 0X (по умолчанию пробелы отсутствуют)
.
Для форматов “e”, “E”, или “f” символ “#” указывает на наличие в выходном значении десятичной точки во всех случаях (по умолчанию точка появляется тогда, когда за ним следуют цифры)
-
Если число введенных символов оказывается меньше указанного, результаты выравниваются по левому краю поля вывода(по умолчанию принято правостороннее выравнивание
+
При вводе знаковых чисел знак отображается всегда(по умолчанию знак устанавливается только перед отрицательными числами)
0
Если значению поля ширина предшествует символ ‘0’, выводимое число дополняется ведущими нулями до минимальной ширины поля вывода(по умолчанию в качестве заполнителей применяются пробелы); при левостороннем выравнивании игнорируется
пробел
Если выводится положительное знаковое число, перед ним ставится пробел(по умолчанию пробел в таких случаях не ставится); игнорируется при наличии флага +

Поле спецификации является символом или числом, которое задает опцию форматирования. Простейший случай — знак процента и тип: например, %f. Поле "тип" используется для того, чтобы определить, что аргумент должен интерпретироваться как символ, строка или число. Поле "флаги" используется для управления печатью знаков, пробелов, десятичных точек, основания системы счисления выходных значений и так далее. Поле "ширина" указывает минимальное число печатаемых символов. Поле "точность" указывает максимальное число символов, печатаемых при выводе. Символы h | l | L являются необязательными префиксами, определяющими размер аргумента.

            2.1.16. Использование функций printf() и fprintf().
Мы уже обсуждали функцию printf() довольно основательно. Подобно puts(), она использует указатель строки в качестве аргумента. Функция printf() менее удобна, чем puts(), но более гибка. Разница заключается в том, что printf() не выводит автоматически каждую строку текста с новой строки. Вы должны указать, что хотите выводить с новых строк. Так,

printf(" %s\n" , string); 

дает то же самое, что и

puts(string);

Вы можете видеть, что первый оператор требует ввода большего числа символов и большего времени при выполнении на компьютере. С другой стороны, printf () позволяет легко объединять строки для печати их в одной строке. Например: 

printf(" Хорошо, %s, %s\n", name, MSG);

объединяет " Хорошо" с именем пользователя и с символьной строкой MSG в одну строку.

Функции ввода-вывода fprintf() и fscanf() работают почти как printf() и scanf(), но им нужен дополнительный аргумент для ссылки на сам файл. Он является первым в списке аргументов. Вот пример, иллюстрирующий обращение к этим функциям:

/* образец использования fprintf() и fscanf() */
#include <stdio.h>
void main()
{
FILE *fi; 
int age;
fi = fopen("sam.txt" , "r"); /* считывание */
fscanf( fi, " %d", &age); /* fi указывает на sam */
fclose(fi);
fi = fopen("data.txt" , "a"); /* дополнение */
fprintf( fi, "sam is %d.\n", age); /* fi указывает на data */
fclose(fi);
}

Заметим, что можно было использовать fi для двух различных файлов, потому что мы закрыли первый файл, прежде чем открыть второй.
В отличие от getc() и putc() эти две функции получают указатель типа FILE в качестве первого аргумента. Две другие, описанные ниже, получают его в качестве последнего аргумента.
В следующем примере описываются переменные четырех типов: символьная, массив символов, целочисленная и вещественная; затем показано, как для каждой переменной использовать соответствующие средства управления форматированием. Исходный текст программы подробно прокомментирован, и для максимальной простоты использована нумерация строк вывода, связывающая выводимое значение и оператор, обеспечивающий это значение:

/*Программа на С, демонстрирующая развитые средства преобразования
и форматирования*/
#include "stdafx.h"
#include "E:\LECTURE\AlgorithmProgramming\Universal_HederFile.h"
void StopWait(void);

main()
{
	char c =	'A',
	psz1[] = "In making a living today many no ",
				/* Для того, чтобы жить, сегдня многие */
	psz2[] = "longer leave any room for life.";
				/* не ыыходят из комнат в течение всей жизни. */
	int iln = 0,
	ivalue = 1234;
	double dPi = 3.14159265;

	/* преобразования */
	printf("\n[%2d] %c",++iln,c); /*01*//* печать символа с */
	printf("\n[%2d] %d",++iln,c); /*02*//* печать ASCII-кода символа с */
	printf("\n[%2d] %c",++iln,90); /*03*//* печать символа с ASCII-кодом 90 */
	printf("\n[%2d] %o",++iln,ivalue); /*04*//* печать ivalue в восьмеричном виде */
	printf("\n[%2d] %x",++iln,ivalue); /*05*//* печать шестнадцатеричного числа буквами нижнего регистра */
	printf("\n[%2d] %X",++iln,ivalue); /*06*//* печать шестнадцатеричного числа буквами верхнего регистра */

	/* опции преобразования и форматирования */
	printf("\n[%2d] %c",++iln,c); /*07*//* минимальная ширина 1*/
	printf("\n[%2d] %5c",++iln,c); /*08*//* минимальная ширина 5, выравнивание вправо */
	printf("\n[%2d] %-5c",++iln,c); /*09*//* минимальная ширина 5, выравнивание влево */
	printf("\n[%2d] %s",++iln,psz1); /*10*//* 33 не-null символа с автоматическим определением ширины */
	printf("\n[%d] %s",++iln,psz2); /*11*//* 31 не-null символ с автоматическим определением ширины */
	printf("\n[%d] %5s",++iln,psz1); /*12*//* минимальная ширина 5 переопределена, автоматическая — 33 */
	printf("\n[%d] %38s",++iln,psz1);/*13*//* минимальная ширина 38, выравнивание вправо */
	printf("\n[%d] %-38s",++iln,psz2);/*14*//* минимальная ширина 38, выравнивание влево */
	printf("\n[%d] %d",++iln,ivalue);/*15*//* ширина ivalue по умолчанию 4 */
	printf("\n[%d] %+d",++iln,ivalue);/*16*//* печать ivalue со знаком "+" */
	printf("\n[%d] %3d",++iln,ivalue);/*17*//* минимальная ширина 3 переопределена, автоматическая — 4 */
	printf("\n[%d] %10d",++iln,ivalue);/*18*//* минимальная ширина 10, выравнивание вправо */
	printf ("\n[%d] %-10d",++iln,ivalue); /*19*//* минимальная ширина 10, выравнивание влево */
	printf ("\n[%d] %010d", ++iln, ivalue) ; /*20*//* выравнивание влево с дополнением пробелов */
	printf("\n[%d] %f",++iln,dPi); /*21*//* использование количества цифр по умолчанию */
	printf("\n[%d] %20f",++iln,dPi); /*22*//* минимальная ширина 20, выравнивание вправо */
	printf("\n[%d] %020f",++iln,dPi); /*23*//* выравнивание вправо с ведущими нулями */
	printf("\n[%d] %-20f",++iln,dPi); /*24*//* минимальная ширина 20, выравнивание влево */

	/* дополнительная точность при форматировании */
	printf("\n[%d] %19.19s",++iln,psz1); /*25*//* минимальная ширина 19, печать всех 19 */
	printf("\n[%d] %.2s",++iln,psz1); /*26*//* печать первых 2-х символов */
	printf("\n[%d] %19.2s",++iln,psz1); /*27*//* печать 2-х символов, выравнивание вправо */
	printf("\n[%d] %-19.2s",++iln,psz1); /*28*//* печать 2-х символов, выравнивание влево */
	printf("\n[%d] %*.*s",++iln,19,6,psz1); /*29*//* использование аргументов printf */
	printf("\n[%d] %10.8f",++iln,dPi); /*30*//* ширина 10; 8 справа от '.' */
	printf("\n[%d] %20.2f",++iln,dPi); /*31*//* ширина 20; 2 до правой границы выравнивания */
	printf("\n[%d] %-20.4f",++iln,dPi); /*32*//* 4 десятичных позиций, выравнивание влево */
	printf("\n[%d] %20.4f",++iln,dPi); /*33*//* 4 десятичных позиций, выравнивание вправо */
	printf("\n[%d] %20.2e",++iln,dPi); /*34*//* ширина 20, экспоненциальное представление */

	StopWait(); /* Wait a little */
	return (0);
}


Результат работы программы выглядит следующим образом:



Изучив приведенный пример, вы сможете легко форматировать выходные данные вашей программы и выбирать те комбинации, которые соответствуют типам данных вашего приложения.

        17.17. Использование функций fread и fwrite, fseek(), ftell() и rewind().
На самом деле не все файлы выглядят как текст. В файле могут быть записаны числовые данные.

size_t fread(void *ptr, size_t size, size_t nelts, FILE *f);

void *ptr - указатель на ту область памяти, в которую мы читаем;
size_t size - размер элемента, который мы читаем;
size_t nelts - максимальное количество элементов, которые можно записать;
FILE *f - файл, из которого читаем;
size_t fread() - сама функция возвращает количество элементов, которые удалось прочитать.

Есть парная функция:

size_t fwrite(const void *ptr, size_t size, size_t nelts, FILE *F);

Аналогично fread эта функция возвращает количество элементов, которые удалось записать. Тут параметр nelts просто показывает, сколько элементов надо вывести.





Когда файл открывается для записи или чтения, с ним связывается структура FILE, определенная в заголовочном файле <stdio.h>. Эта структура связывает с каждым открытым файлом счетчик положения текущей записи. Сразу после открытия файла его значение равно 0. Каждая операция вызывает приращение значения этого счетчика на число записанных или прочитанных из файла байтов. Функции позиционирования — fseek(), ftell() и rewind() позволяют изменять или получать значение счетчика, связанного с файлом.
Функция ftell() возвращает текущее значение счетчика связанного с файлом. Она имеет следующий прототип:

long int ftell(FILE *stream);

В случае ошибки она возвращает -1L.
Функция fseek() имеет следующий прототип:

int fseek(FILE *stream, long offset,
int from);

Эта функция изменяет позиционирование файлового потока stream (изменяя значение указанного счетчика) на offset относительно позиции, определяемой параметром from. Для потоков в текстовом режиме параметр offset должен быть равен 0 или значению, возвращаемому функцией ftell(). Параметр from может принимать следующие значения:

SEEK_SET (=0) начало файла;
SEEK_CUR (=1) текущая позиция в файле;
SEEK_END (=2) конец файла.

Функция возвращает 0, если указатель текущей позиции в файле успешно изменен, и отличное от нуля значение в противном случае.
Функция rewind() имеет следующий прототип:

void rewind(FILE *stream);

Она устанавливает файловый указатель позиции в начало потока.
Рассмотрим пример, демонстрирующий работу этих функций:

#include <string.h>
#include <stdio.h>
using namespace std;

struct Client{
	int Num;
	char SurName[27];
	char Name[21];
	char SecName[21];
};

int main(void)
{
	setlocale(LC_ALL, "Rus");
	FILE *stream;
	Client AClient, RClient;
	long int pos;
	//Открываем файл для вывода
	if ((stream = fopen("SAMPLE.DAT", "wb")) == NULL){
		printf("Cannot open output file.\n");
		getchar(); 	getchar();
		return 1;
	}
	AClient.Num = 1;
	strcpy(AClient.SurName,"Petrov");
	strcpy(AClient.Name, "Petr");
	strcpy(AClient.SecName, "Petrovich");
	//Запись структуры в файл
	fwrite (&AClient, sizeof (AClient), 1, stream);
	pos = ftell(stream);
	//Выводим позицию файла и длину структуры
	printf("The file pos = %d "
	"structure length = %d\n", pos, sizeof(AClient));
	//Репозиционируем файл
	rewind(stream);
	//Открываем файл для чтения
	if ((stream = fopen("SAMPLE.DAT", "rb"))== NULL){
		printf("Cannot open input file.\n");
		getchar(); 	getchar();
		return 2;
	}
	fread (&RClient, sizeof (RClient), 1, stream);
	//Закрываем файл
	fclose(stream);
	printf("The structure contains:\n");
	printf("Num = %d SurName = %s Name = %s"
		"SecName = %s",
	RClient.Num, RClient.SurName,
	RClient.Name, RClient.SecName);

	getchar(); 	getchar();
	return 0;
}



Этот пример представляет собой модификацию предыдущего примера. Здесь файл открывается лишь однажды, и после записи в него структуры на экран выводится значение указателя позиции и длины структуры. При выполнении программа выводит на экран:

The file pos = 76 structure length = 76
The structure contains:
Num = 1 SurName = Petrov Name = Petr
SecName = Petrovich

Функция fseek() позволяет нам обрабатывать файл подобно массиву и непосредственно достигать любого определенного байта в файле, открытом функцией fорen().

fseek и ftell
Для файлов, которые открыты на чтение есть полезные функции. Одна из них это:

int fseek(FILE *f, long offset, int flag);

    • FILE *f - файл, в котором передвигаемся;
    • long offset - количество байтов для отступа, отступ производится в соответствии с 3-м параметром;
    • int flag - позиция, от которой будет совершен отступ; в стандартной библиотеке C для этого параметра определены 3 константы:

SEEK_SET -- начало файла;
SEEK_CUR -- текущас позиция;
SEEK_END -- конец файла;

int fseek() -- сама функция возвращает ноль, если операция прошло успешно, иначе возвращается ненулевое значение.
Еще одна полезная функция может определить текущее положение в файле (который открыт для чтения):

long int ftell(FILE *f);

Вот простой пример, показывающий, как она работает. Как и в наших предыдущих примеpax, функция использует аргумент командной строки для получения имени файла, с которым она работает. Заметим, что fseek() имеет три аргумента и возвращает значение типа int.

/* использование fseek() для печати содержимого файла */
#include <stdio.h>
void main(int number,char *names []) /* не следует использовать argc и argv */
{
FILE *fp;
long offset = 0L; /* обратите внимание, что это тип long */
if ( number < 2)
	puts ("I need a name of file as an argument");
else
{
if ((fp = fopen(names[1], "r")) == 0)
	printf(" I can't open file %s.\n" , names[1]);
else
{
	while( fseek(fp, offset++ , 0) == 0)
		putchar(getc(fp) );
	fclose(fp);
}
}
}



Первый из трех аргументов функции fseek() является указателем типа FILE на файл, в котором ведется поиск. Файл следует открыть, используя функцию fopen().
Второй аргумент назван "offset" (вот почему мы выбрали данное имя для переменной). Этот аргумент сообщает, как далеко следует передвинуться от начальной точки (см. ниже); он должен иметь* значение типа long, которое может быть положительным (движение вперед) или отрицательным (движение назад).
Третий аргумент является кодом, определяющим начальную точку:
Код	Положение в файле
0	начало файла
1	текущая позиция
2	конец файла

Функция fseek() возвращает 0, если все хорошо, и -1, если есть ошибка, например попытка перемещаться за границы файла.
Теперь мы можем разъяснить наш маленький цикл:

while ( fseek(fp, offset ++ , 0) == 0)
	putchar(getc(fp) );

Поскольку переменная offset инициализирована нулем, при первом прохождении через цикл мы имеем выражение

fseek(fp, 0L, 0)

означающее, что мы идем в файл, на который ссылается указатель fp, и находим байт, отстоящий на 0 байт от начала, т. е. первый байт. Затем функция putchar() печатает содержимое этого байта. При следующем прохождении через цикл переменная offset увеличивается до 1L, печатается следующий байт. По существу, переменная offset действует подобно индексу для элементов файла. Процесс продолжается до тех пор, пока offset не попытается попасть в fseek() после конца файла. В этом случае возвращает значение — 1 и цикл прекращается.
Этот последний пример чисто учебный. Нам не нужно использовать fseek(), потому что getc() так или иначе проходит через файл байт за байтом; fseek() приказала getc() «посмотреть» туда, куда она сама уже собиралась посмотреть.
Вот пример, в котором выполняется что-то несколько более необычное (Мы благодарим Вильяма Шекспира за этот пример в пьесе «Двенадцатая ночь»).

/* чередование печати в прямом и обратном направлениях */
#include <stdio.h>
void main(int number,char *names[] ) /* вам не нужно применять argc и argv */
{
FILE *fp;
long offset = 0L;
if ( number < 2)
	puts(" Мне нужно имя файла в качестве аргумента.");
else
{
if ( (fp = fopen(names[1], "r")) ==0)
	printf(" Я не могу открыть %s.\n", names[1]);
else
{
	while ( fseek(fp, offset ++ , 0) == 0)
	{
		putchar(getc(fp));
		if ( fseek(fp,-(offset + 3), 2) == 0)
			putchar(getc(fp));
	}
	fclose(fp);
}
}
} 



Применение этой программы к файлу, содержащему имя «Мальволио», дает такой приятный результат:

МоаилльоввоьллиаоМ

Наша программа печатает первый символ файла, затем последний, затем второй, затем предшествующий последнему и т. д. Мы только добавили вот эти строки в последнюю программу:

if ( fseek(fp,-(offset + 3), 2) == 0)
	putchar(getc(fp));

Код 2 в операторе предполагает, что мы будем считать позиции от конца файла. Знак минус означает счет в обратном направлении. + 3 стоит здесь потому, что мы начинаем с последнего регулярного символа файла и пропускаем несколько символов «новая строка» и EOF в самом конце файла. (Точное значение этой корректировки зависит от типа системы. Наши файлы имеют в конце по два символа новой строки, за которыми следуют два EOF, поэтому мы как раз их и обходим.)
Таким образом, эта часть программы чередует печать в обратном направлении и печать в прямом направлении. Следует заметить, что в некоторых системах может не предусматриваться код 2 для fseek().
Функции fseek(), ftell() и rewind() можно использовать для определения или изменения местоположения маркера файла. Функция fseek() смещает маркер файла, на который указывает pf, на число ibytes байтов либо относительно начала файла (ifrom=()), либо относительно текущего положения маркера (ifrom=1), либо относительно конца файла (ifrom=2). В С имеется три предопределенных константы, которые можно использовать вместо переменной ifrom: SEEK_SET (смещение относительно начала файла), SEEK_CUR (текущее положение маркера) и SEEK_END (смещение относительно конца файла). Функция fseek() возвращает ноль, если операция была успешной, и EOF — в противном случае. В общем виде синтаксис функции fseek() следующий: fseek(pf, ibytes, ifrom) ;
Функция ftell() возвращает текущее положение маркера файла, на который указывает pf. Это положение представляет собой смещение в байтах от на-чала файла. Синтаксис функции ftell() следующий:

long_variable=ftell(pf);

Значение, возвращаемое ftell(), можно использовать при последующем вызове функции fseek().
Функция rewind() просто устанавливает маркер файла, на который ссылается pf, в начало этого файла. Синтаксис функции rewind() выглядит следующим образом:

rewind(pf);

В следующей программе на С иллюстрируется использование функций fseek(), ftell() и rewind():

/*Программа на С, иллюстрирующая использование функций fseek,
ftell и rewind*/
#include "stdafx.h"
#include "E:\LECTURE\AlgorithmProgramming\TestProg\Universal_HederFile.h"
void StopWait(void);

main()
{
	FILE *pf;
	char c;
	long llocation;
	pf=fopen("E:\\LECTURE\\AlgorithmProgramming\\TestProg\\test.dat","r+");
	c=fgetc(pf);
	putchar(c);
		c=fgetc(pf);
		putchar(c);
	llocation=ftell(pf);
	c=fgetc(pf);
	putchar(c);
	fseek(pf,llocation,0);
		c=fgetc(pf);
		putchar(c);
	fseek(pf,llocation,0);
	fputc('E',pf);
	fseek(pf,llocation,0);
		c=fgetc(pf);
		putchar(c);
	rewind(pf);
	c=fgetc(pf);
	putchar(c);

	StopWait(); /* Wait a little */
	return (0);
}

По определению переменная llocation имеет тип long. Это вызвано тем, что С поддерживает файлы длиннее, чем 64К. Входной файл TEST.DAT содержит строку "ABCD". После того как программа открывает этот файл, при первом обращении к функции fgetc() считывается символ "А", который затем печатается на дисплее. Следующая пара операторов считывает и печатает символ "В".
После вызова функции ftell() переменная llocation становится равной текущему положению маркера файла. Оно измеряется как смещение в байтах от начала файла. Поскольку символ "В" уже обработан, llocation содержит 2. Это означает, что маркер файла указывает на третий символ, который на 2 байта отстоит от первого символа — "А".
После этого другая пара операторов ввода/вывода считывает и печатает на дисплее символ "С". После выполнения этих операторов маркер файла смещен на 3 байта от начала файла и указывает на четвертый символ — "D".
В этой точке программы вызывается функция fseek(). Она должна сместить маркер на хранящееся в llocation число байт (то есть на 2 байта) относительно начала файла (поскольку третий параметр функции fseek() — ноль; это объяснялось выше). В результате этой операции маркер файла устанавливается на третий символ в файле. Переменной с опять присваивается значение символа "С", которое печатается во второй раз.
При повторном вызове функции fseek() используются те же параметры, что и при первом. Функция fseek() устанавливает маркер на третий символ —
"С" (смещение 2 байта от начала). Однако следующий оператор не читает символ "С" в третий раз, а записывает вместо него новый символ — "Е". Поскольку после этого маркер смещается за это новое значение, функция fseek() вызывается еще раз для того, чтобы проверить запись этого символа в файл.
Следующая пара операторов считывает новое значение, "Е", и печатает его на дисплее. После этого программа вызывает функцию rewind(), которая снова перемещает указатель pf к началу файла. Затем, когда вызывается функция fgetc(), считывается символ "А" и печатается на экране. Результат работы программы выглядит так:

АВССЕА

Эти же принципы, проиллюстрированные на простом примере, можно использовать для создания файла записей со свободным доступом. Пред положим, что для записи в файл персонала имеется следующая информация: номер социальной страховки, имя и адрес. Допустим, что для номера страховки выделено 11 символов в формате ddd-dd-dddd, а имя и адрес занимают дополнительно 60 символов (или байт). Тогда каждая запись будет иметь длину 11 + 60 = 71 байт.
Заполненными могут быть не все возможные последовательные записи в дисковом файле со свободным доступом; нужно, чтобы запись имела некий флаг, указывающий на использование данной дисковой записи. Для этого к записи нужно добавить еще один байт и 2 дополнительных байта для номера записи; длина записи для одного человека в итоге составит 74 байта. Отдельная запись может выглядеть следующим образом:

1 U111-22-3333Linda Lossannie, 521 Alan Street, Anywhere, USA

Запись номер 1 в файле будет занимать байты с нулевого по 73-й; запись 2 занимает байты с 74 по 147; запись 3 занимает байты с 148 по 221; и так далее. Если использовать номер записи в сочетании с функцией fseek(), то на диске можно найти любую запись. Например, для того чтобы найти начало записи 2, можно использовать следующие операторы:

loffset=(iwhich_record - 1) * sizeof(stA_PERSON); fseek(pfi,loffset,0);

После того как маркер перемещен к началу выбранной записи, информация из этой записи может считываться или обновляться при помощи раз-личных функций ввода/вывода, подобных fread() и fwrite().
За исключением символов комментария /* и */ и заголовочного файла stdio.h описанная программа может работать и в C++. Достаточно заменить символом // оба разделителя /* и */ , а файл stdio.h заменить на iostream.h.
В заключение заметим, что библиотека стандартных функций ввода-вывода содержит много других, не рассмотренных здесь функций.

            2.1.17. Использование встроенного отладчика.
Попробуйте ввести следующую программу и после запроса на поиск 25-й записи распечатать значение переменной stcurrent_person.irecordnum:

/*Программа на С, обрабатывающая файл с произвольным доступом при
помощи функций fseek, fread и fwrite*/
#include "stdafx.h"
#include "E:\LECTURE\AlgorithmProgramming\TestProg\Universal_HederFile.h"
void StopWait(void);

#define iFIRST 1
#define iLAST 50
#define iSS_SIZE 11
#define iDATA_SIZE 60
#define cVACANT 'V'
#define cUSED 'U'
typedef struct strecord
{
	int irecordnum;
	char cavailable; /* V - свободна, U - используется */
	char csoc_sec_num[iSS_SIZE];
	char cdata[iDATA_SIZE ];
} stA_PERSON;

main()
{
	FILE *pfi;
	stA_PERSON stcurrent_person;
	int i,iwhich_record;
	long int loffset;
	pfi=fopen("E:\\LECTURE\\AlgorithmProgramming\\TestProg\\sample.fil","r+");
	for(i = iFIRST; i <= iLAST; i++)
	{
		stcurrent_person.cavailable=cVACANT;
		stcurrent_person.irecordnum=i;
		fwrite(&stcurrent_person,sizeof(stA_PERSON),1,pfi);
	}
	/* Пожалуйста, введите номер записи для поиска */
	printf("Please enter the record you would like to find.");
	/* "Возможны значения от 1 до 50:" */
	printf("\nYour response must be between 1 and 50: ");
	scanf("%d",&iwhich_record);
	loffset=(iwhich_record - 1) * sizeof(stA_PERSON);
	fseek(pfi,loffset,0);
	fread(&stcurrent_person,sizeof(stA_PERSON),1,pfi);
	fclose (pfi) ;

	StopWait(); /* Wait a little */
	return (0);
}

Ключевое слово typedef определяет stA_PERSON как структуру, имеющую следующие поля: 2-байтный номер записи irecordnum, однобайтный символьный флаг доступности записи cavailable, 11-байтный массив символов для хранения номера страховки csoc_sec_num и 60-байтное поле данных cdata. В результате общий размер структуры равен 2 + 1 + 11 + 60 = 74 байтам.
После того как программа открыла текстовый файл в режиме "считывание/запись", она создает и запоминает 50 записей, каждая из которых имеет уникальный номер irecordnum; все записи помечены как "свободные" — cVACANT. Для выполнения оператора fwrite() нужно знать адрес записываемой структуры, размер в байтах записываемой информации, количество выводимых блоков и указатель на файл вывода. После всего этого программа запрашивает у пользователя номер записи, которую он хочет найти.
Поиск записи осуществляется в два этапа. Во-первых, нужно вычислить смещение относительно начала файла. Например, первая запись запоминается в байтах с нулевого по 73-й, вторая — с 74 по 148 и так далее. После вычитания единицы из номера записи, введенного пользователем, программа умножает это значение на число байтов, занимаемых каждой структурой и определяет значение смещения loffset. Например, для нахождения второй записи выполняются следующие вычисления: (2-1) х 74. В результате получается, что вторая запись начинается со смещением 74. После вычисления этого значения выполняется вызов функции fseek(), которая перемещает маркер файла на loffset байт.
Пока выполняется трассировка программы при поиске записей от 1 до 10, все идет нормально. Однако, что происходит, когда вы просите найти одиннадцатую запись? Получается "мусор". Причина этого кроется в том, что программа открыла файл в текстовом режиме. Записи с 1 по 9 точно равны 74 байтам, однако записи с 10-й и далее имеют длину 75 байт. Следовательно, десятая запись имеет соответственно вычисленное смещение loffset, однако в файле занимает на один байт больше. Поэтому одиннадцатая запись начинается с адреса, полученного в результате следующего мо-дифицированного выражения:

loffset=((iwhich_record - 1) * sizeof(stA_PERSON)) + 1;

Однако эти вычисления не будут работать с первыми девятью записями. Решение проблемы — открыть файл в двоичном режиме:

pfi=fopen("А:\\sample.fil","r+b");

В текстовом режиме любое число из двух цифр трактуется как два отдельных символа, в результате чего записи с номерами из двух цифр удлиняются на 1. В двоичном режиме целое значение номера записи интерпретируется правильно. Нужно обращать внимание на режим открываемого для ввода/вывода файла.

        17.18. Форматированный ввод.
В программах на С форматированный ввод обеспечивают весьма гибкие функции scanf() и fscanf(). Главное отличие между ними заключается в том, что для последней функции необходимо явно указывать входной файл, из которого считываются данные. В табл. 11.3 перечислены все возможные управляющие символы, которые можно использовать с функция-ми scanf(), fscanf() и sscanf().

Таблица 11.3. Управляющие символы для функций scanf(), fscanf() и sscanf()

Символ 
Представление
Пример ввода
Тип принимающего адресного параметра
c
Символ
W
char
s
Строка
William
char
d
int
23
int
hd
short
-99
short
id
long
123456
long
o
octat
1727
int
ho
short восьмеричное
1727
short
io
long восьмеричное
1727
long
x
шестнадцатеричное
265
int
hx
short шестнадцатеричное
265
short
tx
long шестнадцатеричное 
265
long
e
float как float
3.14159e+03
float
f
То же, что “e”

double
ie
float как double
3.14159e+03
double
if
То же, что “ie”


[A-Za-z]
Строки из одних символов
Test string
char
[0-9]
Строки из одних цифр
098231345
char

        17.19. Использование функций scanf(), fscanf() и sscanf().
Все три функции, scanf(), fscanf() и sscanf(), можно использовать для ввода чрезвычайно сложных данных. Взгляните, например, на следующий оператор:

scanf("%2d%5s%4f",&ivalue,psz,&fvalue);

Этот оператор вводит целое число из двух цифр, строку из пяти символов и вещественное число, занимающее максимально четыре позиции (2.97, 12.5 и так далее). Сможете ли вы определить, что выполняет следующий оператор:

scanf ("%*[ \t\n] \"%[^A-Za-z] %[^\"] \"",ps1,ps2);

Вначале оператор считывает, но не запоминает любой пустой символ (пробел). Это выполняется при помощи следующей спецификации форма-та: "%*[ \t\n]". Символ (*) указывает функции, что она должна получить указанные данные, но не запоминать их ни в одной переменной. Если во входной строке содержатся только символы пробела, табуляции или перевода строки, то функция scanf() продолжает считывание до тех пор, пока не встретит двойную кавычку ("). Для этого используется спецификатор формата \", который указывает на то, что введенное значение должно совпадать с заданным символом. Символ двойной кавычки, однако, не вводится. огда функция scanf() обнаружила двойную кавычку, она получает указание вводить все символы, являющиеся цифрами, в переменную ps1. Для этого в спецификации формата %[^A-Za-z] используется модификатор — знак вставки (^), который указывает на то, что можно вводить любые символы, за исключением заглавных букв от "А" до "Z" и строчных букв от "а" до "z". Если бы знака вставки не было, то строка должна была бы содержать только буквенные символы. Знак тире между двумя символами "А" и "Z" и "а" и "z" говорит о том, что нужно рассматривать весь диапазон значений.
Мы уже использовали ранее функцию scanf() и формат %s для считывания строки. Основное различие между scanf() и gets() заключается в том, как они определяют, что достигли конца строки; scanf () предназначена скорее для получения слова, а не строки. Функция gets (), как мы уже видели, принимает все символы до тех пор, пока не встретит первый символ «новая строка». Функция scanf () имеет два варианта. Для любого из них строка начинается с первого встретившегося непустого символа. Если вы используете формат %s, строка продолжается до (но не включая) следующего пустого символа (пробел, табуляция или новая строка). Если вы определяете размер поля как %10s, то функция scanf() считает не более 10 символов или же считает до любого пришедшего первым пустого символа.
Функция scanf () возвращает целое значение, равное числу считанных символов, если ввод прошел успешно, или символ EOF, если он встретился.

/* scanf () и подсчет количества */
#include <stdio.h>
void main ()
{
static char name1[40], name2[11];
int count;
printf(" Введите, пожалуйста, 2 имени.\n");
count = scanf(" %s %10s", name1, name2);
printf(" Я считал %d имен %s и %s.\n", count, name1, name2);
}



Вот два примера работы программы:

Введите, пожалуйста, два имени.
Джессика Джукс
Я считал 2 имени Джессика и Джукс.
Введите, пожалуйста, 2 имени.
Лиза Апплеботтхэм
Я считал 2 имени Лиза и Апплеботтх.

Во втором примере были считаны только первые 10 символов от Апплеботтхэм, так как мы использовали формат %10s.
Если вы получаете только текст с клавиатуры, лучше применять функцию gets(). Она проще в использовании, быстрее и более компактна. Функция scanf () предназначена в основном для ввода смеси типов данных в некоторой стандартной форме. Например, если каждая вводимая строка содержит наименование инструмента, количество его на складе и стоимость каждого инструмента, вы можете использовать функцию scanf () или можете создать свою собственную функцию, которая выполняет проверку некоторых ошибок при вводе.
Следующая спецификация формата, %[^\"], сообщает функции ввода, что необходимо читать все оставшиеся символы, исключая двойные кавычки, в переменную ps2. Последняя спецификация, \", указывает на то, что строка должна закончиться двойной кавычкой. Одни и те же символы форматирования ввода можно использовать с функциями fscanf() и sscanf(). Различие между функциями scanf() и fscanf() заключается лишь в том, что для последней необходимо указывать файл ввода. Функция sscanf() аналогична scanf(), за исключением того, что она читает данные из массива, а не из файла.
Следующий пример показывает, как можно использовать функцию sscanf() для преобразования строки (состоящей из цифр) в целое число. Если ivalue имеет тип int, a psz является массивом типа char, содержащим строку цифр, то при помощи следующего оператора можно преобразовать строку psz в тип int и запомнить его в переменной ivalue:

sscanf(psz,"%d",&ivalue);

Очень часто функции gets() и sscanf() используются совместно, так как функция gets() читает целую входную строку, а функция sscanf(0 просматривает строку и преобразует ее согласно спецификациям формата.
Часто при работе с функцией scanf(), если программисты пытаются использовать ее в сочетании с другими функциями символьного ввода, такими как getc(), getch(), getchar(), gets() и так далее, возникает одна проблема. Типичная последовательность действий выглядит так: функция scanf() используется для ввода символов и преобразования их в данные других типов. Затем используется какая-нибудь функция символьного ввода, например, getch(), и оказывается, что она работает не так как ожидалось. Это происходит потому, что иногда функция scanf() считывает не все предназначенные для ввода данные, а оставшиеся (не введенные) данные ошибочно считываются другими функциями ввода (в том числе и следующей функцией scanf()). Если вы используете функцию scanf() в программе, то в целях безопасности не используйте в той же программе другие функции ввода.

        17.20. Распределение памяти: malloc() и calloc().
Ваша программа должна предоставить достаточный объем памяти для запоминания используемых данных. Некоторые из этих ячеек памяти распределяются автоматически. Например, мы можем объявить

char place [] = " Залив Свиной печенки" ;

и будет выделена память, достаточная для запоминания этой строки.
Или мы можем быть более конкретны и запросить определенный объем памяти:

int plates[100];

Это описание выделяет 100 ячеек памяти, каждая из которых предназначена для запоминания целого значения.
Язык Си не останавливается на этом. Он позволяет вам распределять дополнительную память во время работы программы. Предположим, например, вы пишете диалоговую программу и не знаете заранее, сколько данных вам придется вводить. Можно выделить нужный вам (как вы считаете) объем памяти, а затем, если понадобится, потребовать еще. Ниже дан пример, в котором используется функция malloc(), чтобы сделать именно это. Кроме того, обратите внимание на то, как такая программа применяет указатели.

/* добавляет память, если необходимо */
#include <stdio.h>
#define STOP /* сигнал прекращения ввода */
#define BLOCK 100 /* байты памяти */
#define LIM 40 /* предельная длина вводимой строки */
#define MAX 50 /* максимальное число вводимых строк */
#define DRAMA 20000 /* большая задержка времени */
main()
{
char store[BLOCK]; /* исходный блок памяти */
char symph[LIM]; /* приемник вводимых строк */
char *end; /* указывает на конец памяти */
char *starts[MAX]; /* указывает на начала строк */
int index = 0; /* количество вводимых строк */
int count; /* счетчик */
char *malloc(); /* распределитель памяти */
starts [0] = store;
end = starts [0] + BLOCK - 1;
puts(" Назовите несколько симфонических оркестров." );
puts(" Вводите по одному: нажмите клавишу [ввод] в начале");
puts(" строки для завершения вашего списка. Хорошо, я готова.");
while( strcmp(fgets(symph,LIM, stdin), STOP) != 0 && index < MAX)
{
	if ( strlen(symph) > end - starts [index])
	{ /* действия при недостатке памяти для запоминания вводимых данных*/
		puts(" Подождите секунду. Я попробую найти дополнительную память.");
		starts [index] = malloc(BLOCK);
		end = starts [index] + BLOCK - 1;
		for( count = 0; count < DRAMA; count++ );
		puts(" Нашла немного!" );
	}
	strcpy(starts[index], symph);
	starts [index + 1] = starts [index] + strlen(symph) + 1;
	if (++index < MAX)
		printf("Это %d. Продолжайте, если хотите\n", index);
}
puts(" Хорошо, вот что я получила:");
for( count = 0; count < index; count++)
puts(starts [count]);
}

Вот образец работы программы:

Назовите несколько симфонических оркестров.
Вводите их по одному; нажмите клавишу [ввод] в начале
строки для завершения вашего списка. Хорошо, я готова.
Сан-францисский симфонический
Это 1. Продолжайте, если хотите.
Чикагский симфонический
Это 2. Продолжайте, если хотите.
Берлинский филармонический
Это 3. Продолжайте, если хотите.
Московский камерный
Это 4. Продолжайте, если хотите.
Лондонский симфонический
Это 5. Продолжайте, если хотите.
Венский филармонический
Подождите секунду. Я попробую найти дополнительную память
Нашла немного!
Это 6. Продолжайте, если хотите.
Питтсбургский симфонический
Это 7. Продолжайте, если хотите.

Хорошо, вот что я получила:
Сан-францисский симфонический
Чикагский симфонический
Берлинский филармонический
Московский камерный
Лондонский симфонический
Венский филармонический
Питтсбургский симфонический

Сначала давайте посмотрим, что делает функция malloc(). Она берет аргумент в виде целого без знака, которое представляет количество требуемых байтов памяти. Так, malloc(BLOCK) требует 100 байт. Функция возвращает указатель на тип char в начало нового блока памяти. Мы использовали описание

char *malloc();

чтобы предупредить компилятор, что malloc() возвращает указатель на тип char. Поэтому мы присвоили значение этого указателя элементу массива starts [index] при помощи оператора

starts[index] = malloc(BLOCK);

Хорошо, давайте теперь рассмотрим проект программы, заключающийся в том, чтобы запомнить все исходные строки подряд в большом массиве store. Мы хотим использовать starts[0] для ссылки на начало первой строки, starts[1] — второй строки и т. д. На промежуточном этапе программа вводит строку в массив symph. Мы использовали fgets() вместо gets(), чтобы ограничить входную строку длиной массива symph.



Прежде чем копировать symph в store, мы должны проверить, достаточно ли для нее оставшегося места. Указатель end ссылается на конец памяти, а текущее значение starts[index] ссылается на начало неиспользованной памяти. Таким образом, мы можем сравнить разницу между этими двумя указателями с длиной symph и определить, достаточно ли осталось памяти.
Если места недостаточно, вызываем malloc(), чтобы подготовить дополнительную память. Мы устанавливаем starts[index] на начало нового блока памяти, a end — на конец нового блока. Заметим, что у нас нет имени этой новой памяти. Она не является, например, расширением store. У нас есть только обозначения указателей, ссылающихся на новую область памяти.
Когда программа работает, на каждую новую строку ссылается элемент массива указателей starts. Некоторые строки находятся в Store, другие — в одной или нескольких новых областях памяти.
Но пока у нас есть указатели, мы можем работать со строками, как показывает нам часть программы, выполняющая вывод на печать.
Таким образом, используется malloc(). Но предположим, что вы хотите работать с памятью типа int, а не char. Можете и здесь использовать malloc(). Вот как это делается:

char *malloc(); /* по-прежнему описываем как указатель на char */
int *newmem;
newmem = (int *) malloc (100); /* используем операцию приведения типа */

Снова требуется 100 байт. Операция приведения типа преобразует значение, возвращенное указателем на тип char, в указатель на тип int. Если, как в нашей системе, int занимает два байта памяти, это значит, что newmem + 1 будет увеличивать указатель на два байта, т. е. передвигать его к следующему целому. Это также означает, что 100 байт можно использовать для запоминания 50 целых чисел.
Другую возможность распределения памяти дает нам применение функции calloc():

char *calloc();
long * newmem;
newmem = (long *) calloc(100, sizeof(long));

Подобно malloc() функция calloc() возвращает указатель на char. Нужно использовать оператор приведения типа, если вы хотите запомнить другой тип. Эта новая функция имеет два аргумента, и оба они должны быть целыми без знака. Первый аргумент содержит количество требуемых ячеек памяти. Второй аргумент — размер каждой ячейки в байтах. В нашем случае long использует четыре байта, поэтому оператор выделит 100 четырехбайтных элементов, используя в целом 400 байтов памяти.
Применяя sizeof (long) вместо 4, мы сделали эту программу более мобильной. Она будет работать на системах, где long имеет размер, отличный от четырех.
Функция calloc() имеет еще одну особенность; она обнуляет содержимое всего блока.
Ваша библиотека языка Си, вероятно, предоставляет несколько других функций управления памятью, и вы можете захотеть проверить их.

        17.21. Другие библиотечные функции.
Большинство библиотек будут выполнять и ряд дополнительных функций в тех случаях, которые мы рассмотрели. Кроме функций, распределяющих память, есть функции, освобождающие память после работы с нею. Могут быть другие функции, работающие со строками, например такие, которые ищут в строке определенный символ или сочетание символов.
Некоторые функции, работающие с файлами, включают ореn(), close(), create(), fseek(), read() и write(). Они выполняют почти те же самые задачи, что и функции, которые мы обсудили, но на более фундаментальном уровне. Действительно, функции, подобные fopen(), обычно пишутся с применением этих более общих функций. Они немного более трудны в использовании, но могут работать с двоичными файлами так же, как и с текстовыми.
Ваша система может иметь библиотеку математических функций. Обычно такая библиотека будет содержать функции квадратного корня, степенные, экспоненциальные, различные тригонометрические функции и функцию получения случайных чисел.
Вам нужно время, чтобы освоить то, что предлагает ваша система. Если у нее нет того, что вам нужно, создайте свои собственные функции. Это часть языка Си. Если вы полагаете, что можете улучшить работу, скажем, функции ввода, сделайте это! А когда вы усовершенствуете и отшлифуете свои методы программирования, вы перейдете от обычного языка Си к блестящему языку Си.

Что вы должны были узнать.
    • Что такое библиотека языка Си и как ее использовать.
    • Как открывать и закрывать текстовые файлы: fopen() и fclose()
    • Что такое тип FILE
    • Как читать из файла и записывать в файл: getc(), putc(),
    • fgets(), fputs(), fscanf(), fprintf()
    • Как проверять классы символов: isdigit(), isalpha() и т. д.
    • Как превращать строки в числа: atoi() и atof()
    • Как осуществлять быстрый выход: ехit()
    • Как распределять память: malloc(), calloc()

Вопросы и ответы.
Вопросы.
    1. Что неправильно в этой программе?

main()
{
int *fp;
int k;
fp = fopen(" желе" );
for (k = 0; k < 30; k++ )
	fputs(fp, " Нанетта ест желе.");
fclose(" желе");
}

    2. Что будет делать следующая программа?

#include <stdio.h>
#include <ctype.h>
main(argc, argv)
int argc;
char *argv[];
{
int ch;
FILE *fp;
if ( (fp = fopen(rag[1], " r")) == NULL)
	exit(1);
while ( (ch = getc(fp)) != EOF)
	if( isdigit(ch) )
		putchar(ch);
fclose (fp);
}

    3. Все ли правильно в выражении isalpha(c[i]), где с является массивом типа char? Что можно сказать о isalpha(c[i++])?
    4. Используйте функции классификации символов для подготовки выполнения atoi().
    5. Как вы могли бы распределить память для размещения массива структур?

Ответы.
    1. Должна быть директива #include <stdio.h> для определения ее файлов. Следует описать указатель fp файла: FILE *fp; функция fopen() должна иметь вид: fopen ("желе" , "w"), или, может быть, включать "а" . Порядок аргументов в fputs() должен быть обратным. Функция fclose() требует указателя файла, а не имени файла: fclose(fp).
    2. Она будет открывать файл, заданный как аргумент командной строки, и выводить на печать все цифры в файле. Программа должна проверять (но не делает этого), не аргумент ли это командной строки.
    3. Первое выражение правильно, так как c[i] имеет значение типа char. Второе выражение не выводит компьютер из строя, но может давать непредсказуемый результат. Причина в том, что isalpha() является макроопределением, у которого, по всей вероятности, аргумент появляется дважды в определяющем выражении (проверка на принадлежность к регистру строчных букв, а затем — прописных букв) и это дает в результате два увеличения i. Лучше всего избегать использования оператора увеличения в аргументе макрофункции.

#include < stdio.h>
#include < ctype.h>
#define issign(c) ( ((c) == '-' || (c) == '+') ? (1) : (0) )
atoi(s);
char *s;
{
int i = 0;
int n, sign;
while ( isspace(s[i] ) )
	i++ ; /* пропуск пустого символа */
sign = 1;
if (issign(s[i]) ) /* установка необязательного знака */
	sign = (s[i++ ] == '+') ? 1 : -1;
for (n = 0; isdigit(s[i] ); i++ )
	n = 10*n + s[i] - '0';
return( sign * n);
}

    4. Предположим, что wine является именем структуры. Эти операторы, надлежащим образом расположенные в программе, будут выполнять данную работу.

struct wine *ptrwine;
char *calloc();
ptrwine = (struct wine *) calloc (100, sizeof (struct wine));

Упражнения.
    1. Напишите программу копирования файла, которая использует имена исходного файла и копируемого файла как аргументы командной строки.
    2. Напишите программу, которая будет принимать все файлы, заданные рядом аргументов командной строки, и печатать их один за другим. Используйте argc для создания цикла.
    3. Модифицируйте вашу программу инвентаризации книг так, чтобы информация, которую вы вводите, добавлялась в файл, названный my books.
    4. Используйте gets( ) и atoi( ) для создания функции, эквивалентной нашей getint().
    5. Перепишите нашу программу, считающую слова, используя макроопределения ctype.h и аргумент командной строки для обработки файла.

Что вы должны были узнать.
    • Как объявить строку символов: static char fun[] и т. д.
    • Как инициализировать строку символов: static char *p0 = "0!"
    • Как использовать gets () и puts ()
    • Как использовать strlen(), strcmp (), strcpy() и strcat ()
    • Как использовать аргументы командной строки.
    • В чем сходство и различие описателей char *bliss и char bliss []
    • Как создать строковую константу: «используя кавычки».

Вопросы и ответы.
Вопросы.
    1. Что неправильно в этой попытке описания символьной строки?

main ()
{
char name[] = {'F', 'e', 's', 's'};

    2. Что напечатает эта программа?

#include <stdio.h>
main ()
{
static char note[] = " До встречи в буфете.”
char *ptr,
ptr = note;
puts(ptr);
puts(++ptr);
note[7] = '\0';
puts(note);
puts(++ptr);
}

    3. Что напечатает эта программа?

main ()
{
static char food[] = "Йумми";
char *ptr;
ptr = food + strlen(food);
while( -- ptr >= food)
	puts(ptr);
}

    4. Что напечатает нижеследующая программа?

main ()
{
static char goldwyn[28] = "аз я считываю"
static char samuel[40] = “Каждый p" ;
char *quote = " часть строки.";
strcat(goldwyn, quote);
strcat(samuel, goldwyn);
puts(samuel);
}

    5. Создайте функцию, которая использует указатель строки в качестве аргумента и возвращает указатель, ссылающийся на первый пробел в строке в указанном месте или после него. Если она не находит ни одного пробела, то пусть возвращает NULL-указатель.

Ответы.
    1. Класс памяти должен быть extern или static; инициализация должна включать символ ' \0'.
    2. До встречи в буфете.
о встречи в буфете.
До вст
вст
    3. и
ми
мми
умми
Йумми
    4. Каждый раз я считываю часть строки
    5. 
char *strblk(string)
char *string;
{
while(*string != ' ' && *string != '\0')
string++ ; /* останавливается на первом пробеле или нуль-символе */
if(*string = = '\0')
return(NULL); /* NULL = 0 */
else
return(string);
}

Упражнения.
    1. Создайте функцию, которая считывает очередные n символов при вводе, включая символы пробелов, табуляции и новой строки.
    2. Модифицируйте последнюю функцию таким образом, чтобы она останавливалась после ввода n символов или после первого символа пробела, табуляции или новой строки независимо от того, какой из них идет первым [только не используйте функцию scanf ()].
    3. Создайте функцию, которая считывает очередное слово при вводе, определите слово как последовательность символов, не включающую символы пробела, табуляции или новой строки
    4. Создайте функцию, которая ищет первое появление определенного символа в определенной строке. Функция должна возвращать указатель, ссылающийся на этот символ, в случае успешного поиска или NULL, если символ в строке не найден.

18. Структуры и другие типы данных.
18.1. Структуры С и C++.
18.1.1. Структуры С и C++: синтаксис и правила.
18.1.2. Создание простой структуры. Типовая задача 2 – инвентаризация книг.
18.1.3. Создание простой структуры. Типовая задача 2 – учет катеров.
18.1.4. Структуры C++: расширения синтаксиса и правил.
18.1.5. Доступ к элементам структуры.
18.1.6. Инициализация структуры.
18.1.7. Передача структур в функции.
18.2. Массив структур.
18.2.1. Описание массива структур.
18.2.2. Определение элементов массива структур.
18.2.3. Масив структур. Типовая задача 2.
18.3. Вложенные структуры.
18.3.1. Структуры внутри структур. Типовая задача 2.
18.4. Использование указателей на структуры.
18.4.1. Описание и инициализация указателя на структуру.
18.4.2. Доступ к элементу структуры при помощи указателя.
18.4.3. Использование указателя. Типовая задача 2:
18.5. Структуры и функции.
18.5.1. Передача структур по значению.
18.5.2. Передача структур посредством указателей.
18.5.3. Передача структур посредством ссылок.
18.5.4. Передача элементов структуры.
18.5.5. Передача массива структур.
18.5.5.1. Передача информации о структурах функциям. Использование массива. Типовая задача 2 на С.
18.5.5.2. Передача информации о структурах функциям. Использование массива. Типовая задача 2 на C++.
18.5.6. Функция – член структуры
18.5.6.1. Особенность возврата const.
18.5.7. Возврат структуры из функции
18.6. Структуры и битовые поля.
18.7. Структуры. Их дальнейшее использование.
18.8. Объединения.
18.8.1. Объединения: синтаксис и правила.
18.8.2. Создание простого объединения.
18.9. Вспомогательные средства.
18.9.1. Использование typedef.
18.9.2. Использование enum.
18.10. Сложные формы данных.
18.11. Функции работы с датой и временем.

    18. Структуры и другие типы данных.
Успех программы часто зависит от удачного выбора способа представления данных, с которыми она должна работать. В этом отношении языку Си очень повезло (и не случайно), так как он обладает очень мощными средствами представления сложных данных. Этот тип данных, называемых «структурой», не только достаточно гибок для представления разнообразных данных, но, кроме того, он позволяет пользователю создавать новые типы. Если вы знакомы с «записями» языка Паскаль, вам должны быть удобны структуры.
Здесь вы познакомитесь с несколькими сложными типами С и C++, такими как структуры, объединения и битовые поля, а также с некоторыми другими темами. Вы узнаете, как создавать и использовать структуры в программах, как передавать структуры в функции при помощи указателей на структуры, как создавать и использовать объединения; также вы познакомитесь с другими важными средствами, такими как typedef и перечисляемые типы (enum).
Основное внимание здесь уделено двум важным средствам, общим для С и C++: структурам и объединениям. Структура С или C++ аналогична массиву или вектору тесно связанных атрибутов. Однако, в отличие от массива или вектора структура позволяет иметь смешанные атрибуты различных типов данных.
Структуры очень важны в С и C++, они являются предшественниками более совершенного типа C++, называемого классом. После детального знакомства со структурами намного проще разбираться с классами C++. Это объясняется тем, что классы C++ содержат и дополняют многие свойства структур.
Еще один сложный тип, объединения, позволяет хранить различные типы данных в одной области памяти. Эти сложные типы данных служат основой для большинства программ электронных таблиц и баз данных.
В последующем вы узнаете, как создавать простые структуры и массивы структур, как передавать структуры и массивы структур в функции и как обращаться к элементам структуры при помощи указателей.

        18.1. Структуры С и C++.
Структурированные данные весьма распространены в повседневной жизни. Картотека, содержащая адреса знакомых, номера телефонов и прочую информацию, является структурой связанных атрибутов. Список любимых компакт-дисков или пластинок также является структурой; каталог диска — структура. В этих примерах используются структуры, но что же это такое? Структуру буквально можно рассматривать как набор переменных различных типов, образующих единый объект. Этот отдельный объект и является структурой.

            1.1.1. Структуры С и C++: синтаксис и правила.
В языках С или C++ структура создается при помощи ключевого слова struct, за которым следуют необязательное поле тега (tag) и список элементов структуры. Поле тега используется для создания других переменных данного структурного типа. Синтаксис структуры с необязательным полем тега выглядит следующим образом:

struct поле_тега {
	тип_элемента элемент 1;
	тип_элемента элемент 2;
	тип_элемента элемент З;
	...
	...
	...
	тип_элемента_элемент N;
};

Описание структуры заканчивается точкой с запятой, поскольку на самом деле оно является оператором С и C++.

struct stuff {
			int numb;
			char code [4];
			float cost;
};




Долее в примерах будет использоваться две структуры (упрощенная типовая задача 1) и  подобная следующей (типовая задача 2):

struct stboat {	// катер
	char sztype [iSTRING15 + iNULL_CHAR];	//тип
	char szmodel[iSTRING15 + iNULL_CHAR];	//модель
	char sztitle[iSTRING20 + iNULL_CHAR];	//бортовой номер
	int iyear;		// год выпуска
	long int lmotor_hours;	// ресурс двигателя
	float fsaleprice;	// продажная стоимость
};

Данная структура создана при помощи ключевого слова struct, за которым следует поле тега или тип структуры. В этом примере stboat является теговым полем структуры.
Объявление этой структуры содержит несколько элементов: sztype, szmodel и sztitle являются строками заданной длины, заканчивающимися null-символом. За ними следуют целое iyear, длинное целое lmotor_hours и число с плавающей точкой fsaleprice. Эта структура используется для хранения коммерческой информации о катере или лодке.
Таким образом описан новый гипотетический структурный тип stboat. Однако, с этой структурой не связана никакая переменная; для этого в программе можно использовать следующий оператор:

Типовая задача 1
struct book libry;

Типовая задача 2
struct stboat stused_boat;

Этот оператор описывает переменную stused_boat, имеющую тип struct stboat. Обратите внимание на то, что в объявлении нужно использовать поле тега структуры. Если данный оператор располагается в некоторой функции, то структура stused_boat имеет локальную область действия внутри этой функции. Если оператор находится в программе вне всех функций, то структура имеет глобальную область действия. Также можно объявить структурную переменную, используя следующий синтаксис:

Типовая задача 1
struct book {
			char title [MAXTIT];
			char author [MAXAUT];
			float value;
} libry; /* присоединяет имя переменной к шаблону */

Типовая задача 2
struct stboat {
	char sztype [iSTRING15 + iNULL_CHAR];
	char szmodel[iSTRING15 + iNULL_CHAR];
	char sztitle[iSTRING20 + iNULL_CHAR];
	int iyear;
	long int lmotor_hours;
	float fsaleprice;
} stused_boat;

Объявление переменной заключено между фигурной скобкой, закрывающей структуру (}), и обязательной точкой с запятой. В обоих примерах переменная stused_boat объявляется как структура типа stboat. На практике, если со структурным типом связывается только одна переменная, поле тега можно убрать, поэтому предыдущий пример можно записать и так:

Типовая задача 1
struct { /* без имени типа структуры */
		char title [MAXTIT];
		char author [MAXAUT];
		float value;
} libry;

Типовая задача 2
struct {
	char sztype [iSTRING15 + iNULL_CHAR];
	char szmodel[iSTRING15 + iNULL_CHAR];
	char sztitle[iSTRING20 + iNULL_CHAR];
	int iyear;
	long int lmotor_hours;
	float fsaleprice;
} stused_boat;

Заметьте, что в этом объявлении структуры отсутствует поле тега и создается так называемый анонимный структурный тип. Поскольку оператор описывает единственную переменную, stused_boat, то нигде в приложении нельзя создать другую переменную такого же типа. Если поле тега структуры отсутствует, то такой синтаксис не позволяет ссылаться на этот новый тип. Однако, с одним структурным типом можно связать несколько переменных, не указывая поле тега; это показано в следующем примере:

Типовая задача 1
struct { /* без имени типа структуры */
		char title [MAXTIT];
		char author [MAXAUT];
		float value;
} libry1, libry2, libry3;

Типовая задача 2
struct {
	char sztype [iSTRING15 + iNULL_CHAR];
	char szmodel[iSTRING15 + iNULL_CHAR];
	char sztitle[iSTRING20 + iNULL_CHAR];
	int iyear;
	long int lmotor_hours;
	float fsaleprice;
} stboat1, stboat2, stboat3;

Форма с именем типа структуры удобнее, если вы используете структурный шаблон более одного раза.
Так же, как и для любых других переменных, компиляторы С и C++ выделяют необходимую память для элементов структуры. Чтобы определить, нужно ли поле тега в объявлении структуры, нужно ответить на следующие вопросы: "Нужно ли где-нибудь в программе создавать другие переменные такого структурного типа?" и "Нужно ли передавать структурный тип в функции?" Если на какой-нибудь из вопросов имеется положительный ответ, то поле тега — необходимо.
Как правило, объекты, представляемые в программе, обладают рядом разнообразных и, что очень важно, разнотипных свойств. Конструирование таких объектов на С++ предусматривает использование структур и объединений.
Структура может быть представлена как некоторый набор разнотипных и/или однотипных данных, совокупность которых рассматривается как совершенно новый, пользовательский тип данных. Структура объявляется с помощью ключевого слова struct, за которым следует необязательное имя тела для создания нового типа данных и указываемый в фигурных скобках шаблон, по которому будут создаваться переменные структурного типа. Шаблон содержит указываемые через точку с запятой объявления полей или членов структуры. Объявление поля состоит из указания типа и имени переменной:

struct NewType
{
type1 Name1;
type2 Name2;
…
typeN NameN;
};

Синтаксис описания структуры заканчивается символом точка с запятой (;).
Использование структурированных данных в теле программы возможно в том случае, если будет объявлен какой-нибудь объект вновь созданного типа. Например, для приведенного выше синтаксиса можно указать:

NewType Variable;

Таким образом, будет создан структурированный объект Variable типа NewType. Кроме того, объект Variable мог быть создан непосредственно при объявлении структуры:

struct NewType
{
type1 Name1;
type2 Name2;
typeN NameN;
} Variable;

Инициализация элементов структуры может быть произведена непосредственно при объявлении. При этом присваиваемые значения указываются через запятую в фигурных скобках, например:

struct MyStruct
{
int iVariable;
long iValue;
char Str[10];
} mystruct = {10, 300L, "Hello"};

Поясним вышесказанное на примере. Предположим, в программе создается база данных (подробно базы данных рассмотрены в книге "Базы данных. Учебный курс", изд. "Фолио"), содержащая информацию о жилых домах микрорайона. Изначально известно, что для дальнейшего использования потребуются данные о номере микрорайона, названии улицы, номере дома, количестве этажей, числе квартир, наличии прилегающей стоянки. Разработаем структуру, отвечающую указанным требованиям. Пусть под номер микрорайона отводится беззнаковое короткое целое, название улицы может быть закодировано строкой из 50-ти символов, номер дома представим как строку из пяти символов (на случай, если номер дома дополнительно содержит букву), количество этажей и число квартир - беззнаковое короткое целое, а информация о наличии стоянки - логическая переменная. В конечном итоге получится что-то вроде:

struct HOUSE
{
	unsigned short RegNum;
	char Street[51]; // с учетом '\0'
	char HouseNum[6];
	unsigned short MaxFloorNum;
	unsigned short MaxFlatNum;
	bool Parking;
};

Для использования полученного типа HOUSE объявим соответствующую переменную House:

HOUSE House;

Следующий важный момент - доступ к элементам структуры. Чтобы записать или прочитать данные структуры, после имени объекта ставится символ точки (.), за которым следует имя члена структуры. Вся подобная конструкция рассматривается как единая переменная. В качестве примера заполним уже имеющийся объект House:

House.RegNum = 524;
strcpy(MyHouse.Street, "ул. Гоголя");
strcpy(MyHouse.HouseNum, "2-a");
House.MaxFloorNum = 7;
House.MaxFlatNum = 84;
House.Parking = true;

Как видно из примера, целочисленным и логическим данным производится обычное присвоение, а заполнение строковых членов структуры осуществлено с помощью функции работы со строками strcpy ().
Для определения размера структурированного объекта в памяти к нему применяют оператор (или функцию) sizeof. Таким образом, отдельный экземпляр структуры HOUSE будет занимать, например, 64 байта:

int i = sizeof(HOUSE);

Однако очень часто структуры помогают экономить память благодаря использованию так называемых битовых полей. В этом случае объявление поля структуры имеет вид:

объявление поля : константное_выражение;

где
объявление поля - объявление типа и имени поля структуры;
константное выражение определяет длину поля в битах.

Тип поля должен быть целочисленным (int, long, unsigned, char) объявление_поля может отсутствовать. В этом случае в шаблоне структуры пропускается указанное после двоеточия чисто битов. Таким образом, если разработчик знает наверняка, что элемент структуры может принимать, скажем, всего два значения (0 или 1), для него можно отвести один бит. Дальнейшая работа с таким элементом структуры ведется с использованием поразрядных логических операций. Реализация битовых полей тесно связана с аппаратной платформой, на которой функционирует компилятор. Поэтому, детали использования битовых полей следует уточнить в документации, поставляемой с вашим компилятором.
Рассмотрим небольшой пример. Допустим, необходимо создать структуру, содержащую информацию о дате и времени некоторых событий. Этого можно добиться следующим путем:

struct DATETIME
{
unsigned short Year; // год
unsigned short Month; // месяц
unsigned short Date; // дата
unsigned short Hour; // часы
unsigned short Minute; // минуты
unsigned short Second; // секунды
}

Таким образом, объект типа DATETIME в памяти будет занимать 6(элементов) х 2(байта) = 12 байт. Нетрудно заметить, что в описании такой структуры присутствует значительная избыточность, так как год может принимать значения от 0 до 99 (задействуется всего 7 бит), месяц - от 1 до 12 (4 бита), дата - от 1 до 31 (5 бит), часы, минуты и секунды - от 0 до 59 (по 6 бит на каждый элемент). Применяя битовые структуры, приведенная выше структура примет вид:

struct DATETIME2
{
unsigned Year: 7 // год
unsigned Month: 4 // месяц
unsigned Date:5 // дата
unsigned Hour: 6 // часы
unsigned Minute: 6 // минуты
unsigned Second: 6 // секунды
}

Экземпляр модифицированного типа DATETIME2 будет занимать не 64, а 5 байт (так как 34 бита могут быть размещены только в пяти байтах).

            1.1.2. Создание простой структуры. Типовая задача 2 – инвентаризация книг.
Гвен Гленн хочет напечатать опись своих книг. Она хотела бы занести в нее различную информацию о каждой книге: ее название, фамилию автора, издательство, год издания, число страниц, тираж и цену. Теперь некоторые из этих элементов, такие, как название, можно записать в массив строк. Другие элементы требуют массив целого типа или массив типа float. Если работать с семью различными массивами и следить за всей содержащейся в них информацией, можно сойти с ума, особенно если Гвен желает иметь несколько списков — список, упорядоченный по названиям, список, упорядоченный по авторам, по цене и т. д. Гораздо лучше было бы использовать один массив, в котором каждый элемент содержал бы всю информацию о книге.
Но какой тип данных может содержать строки и числа одновременно и как-то хранить эту информацию раздельно? Ответом должна быть, конечно, тема этого материала — структура. Чтобы посмотреть, как создается структура и как она работает, начнем с небольшого примера. Для упрощения задачи введем два ограничения: первое — мы включим в опись только название книги, фамилию автора и цену; второе — ограничим опись до одной книги. Если у вас больше книг, не беспокойтесь; мы покажем, как расширить эту программу.
Сначала посмотрите на программу и ее результат, а потом мы рассмотрим основные вопросы.

/* инвентаризация одной книги */
#include <stdio.h>
#define MAXTIT 41 /* максимальная длина названия +1 */
#define MAXAUT 31 /* максимальная длина фамилии автора +1 */
/* шаблон первой структуры: book является именем типа структуры */
struct book {
			char title [MAXTIT]; /* символьный массив для названия */
			char author [MAXAUT]; /* символьный массив для фамилии автора */
			float value; /* переменная для хранения цены книги */
			}; /* конец шаблона структуры */
void main()
{
struct book libry; /* описание переменной типа book */
printf(" Enter the name of a book, please.\n");
gets(libry.title); /* доступ к элементу title */
printf(" Now enter surname of the author.\n");
gets(libry.author);
printf(" And now, enter the price\n");
scanf(" %f", &libry.value);
printf(" %s, %s: %.2f rub.\n", libry.title, libry.author, libry.value);
printf("%s: \" %s \" \(%.2f rub.\) \n", libry.author, libry.title, libry.value);
}

Вот образец работы программы:



Созданная нами структура состоит из трех частей: одна для названия, другая для фамилии автора и третья для цены.

            1.1.3. Создание простой структуры. Типовая задача 2 – учет катеров.
В следующем примере используется структура, аналогичная описанной выше структуре stboat. Для того чтобы определить, понимаете ли вы, как в программе обрабатываются различные элементы структуры, проанализируйте следующий листинг программы:

/*Программа на С, иллюстрирующая создание структуры.
Программа запоминает информацию о вашем катере в некоторой структуре С */
#include <stdio.h>
#define iSTRING15 15
#define iSTRING20 20
#define iNULL_CHAR 1
struct stboat {
	char sztype [iSTRING15 + iNULL_CHAR];
	char szmodel[iSTRING15 + iNULL_CHAR];
	char sztitle[iSTRING20 + iNULL_CHAR];
	int iyear;
	long int Imotor_hours;
	float fsaleprice;
} stused_boat;

int main(void)
{
	printf ("\nPlease enter the type of the boat: "); /* Введите, пожалуйста, тип катера: */
	gets (stused_boat.sztype);
	printf ("\nPlease enter the model of the boat: "); /* Введите, пожалуйста, модель катера: */
	gets(stused_boat.szmodel);
	printf("\nPlease enter the title number for the boat: "); /* Введите, пожалуйста, бортовой номер катера: */
	gets(stused_boat.sztitle);
	printf("\nPlease enter the model year for the boat: "); /* Введите, пожалуйста, год выпуска модели 	катера: */
	scanf("%d",&stused_boat.iyear);
	printf("\nPlease enter the current hours on "); /* Введите, пожалуйста, количество часов, отработанных 	двигателем катера: */
	printf("the motor for the boat: ");
	scanf("%d",&stused_boat.Imotor_hours);
	printf("\nPlease enter the purchase price of the boat: "); /* Введите, покупную стоимость катера */
	scanf("%f",&stused_boat.fsaleprice);
	printf("\n\n\n");
	printf("A %d %s %s with title number #%s\n", stused_boat.iyear, stused_boat.sztype,
stused_boat.szmodel,stused_boat.sztitle);  /* Катер ... с бортовьм номером .*/
	printf("currently has %d motor hours", stused_boat.Imotor_hours); /* в настоящий момент отработал ... часов */
	printf(" and was purchased for $%8.2f\n",stused_boat.fsaleprice);	/* и был куплен за ...*/

	return (0);
}
Результат работы программы показывает, как информация обрабатывается в структуре:

А 1952 Chris Craft with title number #CC1011771018C
currently has 34187 motor hours and was purchased for $68132.98



Вы можете заметить, что переменная stused_boat имеет глобальную область действия в файле, поскольку она была объявлена вне всяких функций.


            1.1.4. Структуры C++: расширения синтаксиса и правил.
Во многих случаях С можно считать подклассом языка C++. В общем, это означает, что все программы на С будут работать в среде C++.
ПРИМЕЧАНИЕ. Если использовать методы проектирования С в программах на C++, то зачастую можно упустить более развитые и простые возможности C++.
Описанные выше примеры объявлений структуры работают с компиляторами С и C++. В C++, однако, имеется еще один способ объявления переменной некоторого структурного типа. В этой краткой записи, имеющейся только в C++, отсутствует необходимость повторять ключевое слово struct. Это тонкое различие отражено в следующем примере:

/* Объявление структуры, допустимое в С и C++ */
struct stboat stused_boat;

// Объявление структуры, возможное только в C++
stboat stused_boat;

            1.1.5. Доступ к элементам структуры.
Для обращения к отдельным элементам структуры можно использовать "точку" — операцию обращения к члену структуры (.). Синтаксис операции:

stname.mname

В этой записи stname является переменной, связанной со структурным типом, а mname — это имя любой переменной-члена структуры.
Например, в С можно записать информацию в элемент szmodel при помощи следующего оператора:

gets(stused_boat.szmodel);

В этом операторе stused_boat — имя структуры, a szmodel — переменная-член структуры. Аналогичным образом для печати элемента структуры можно использовать функцию printf():

printf("%1d",stused_boat.lmotor_hours);

Доступ к элементам структуры в C++ по сути такой же:

cin >> stused_boat.sztype;

Этот оператор выполняет считывание типа катера stused_boat в символьный массив; следующий оператор выводит на экран продажную стоимость stused_boat

cout << stused_boat.fsaleprice;

Элементы структуры обрабатываются так же, как и любые другие переменные С или C++; необходимо только всегда использовать операцию "точка".

            1.1.6. Инициализация структуры.
Мы видели, как инициализируются переменные и массивы:

int count = 0;
static int fibo [] = {0, 1, 1, 2, 3, 5, 8};

Можно ли инициализировать и структурную переменную? Да, если структурная переменная будет внешней или статической. Здесь следует иметь в виду, что принадлежность структурной переменной к внешнему типу зависит от того, где определена переменная, а не где определен шаблон. В нашем примере (1) шаблон book является внешним, а переменная libry — внутренней, так как она определена внутри функции и по умолчанию располагается в классе автоматической памяти. Предположим, мы создали такое описание:

static struct book libry; (создание структурной переменной)

В этом случае используется статическая память, и можно инициализировать структуру следующим способом:

static struct book libry = {
			"Пират и девица",
			"Рене Вивот",
			1р.95 // Работает студенческая соображалка?
};

Чтобы сделать ассоциации более явными, мы дали каждому элементу свою собственную строку для инициализации, хотя компилятору требуются только запятые, чтобы отделить инициализацию одного элемента от инициализации следующего.

            1.1.7. Передача структур в функции.
Очень часто необходимо передать в функцию информацию о структуре; при этом информация передается по значению. Поскольку передается только копия информации, функция не может изменить содержимое исходной структуры. Структуру можно передать в функцию при помощи, следующей синтаксической конструкции:

fname(stvariable);

Если переменная stused_boat описана как локальная для main() и ее объявление передается в функцию, то эту переменную можно передать в функцию с именем vprint_data() при помощи оператора:

vprint_data(stused_boat);

Как можно догадаться, в прототипе функции vprint_data() нужно объявить тип принимаемой структуры:

/* Объявление структуры, допустимое в С и C++ */
void vprint_data(struct stboat stany_boat);

// Объявление структуры, возможное только в C++//
void vprint_data(stboat stany_boat);

Если передавать полные копии структур в функции, то нередко можно снизить эффективность программы. В приложениях, критичных ко времени, лучше использовать указатели. Если стоит вопрос об экономии памяти при обработке связанных списков, то вместо статически выделяемой памяти зачастую используется функция malloc(), динамически выделяющая память для структур. Долее вы увидите, как это делается. В следующем примере показано, как структура передается в функцию целиком. Обратите внимание на то, что это — простая модификация предыдущего примера. В следующих четырех примерах используется та же самая идея. В каждой программе модифицируется только та часть алгоритма, которая необходима для прояснения конкретного вопроса. Такой подход позволит вам легко анализировать текст программ и изменения синтаксиса, необходимые для реализации конкретных возможностей языка. Просмотрите листинг программы и обратите внимание на то, как структура stused_boat передается в функцию vprint_data().

/* Программа на С, показывающая передачу структуры в функцию */
#include <stdio.h>
#define iSTRING15 15
#define iSTRING20 20
#define iNULL_CHAR 1

struct stboat {
	char sztype [iSTRING15 + iNULL_CHAR];
	char szmodel[iSTRING15 + iNULL_CHAR];
	char sztitle[iSTRING20 + iNULL_CHAR];
	int iyear;
	long int lmotor_hours;
	float fsaleprice;
};

void vprint_data(struct stboat stany_boat);
int main(void)
{
	struct stboat stused_boat;

	printf("\nPlease enter the type of the boat: ");
	gets(stused_boat.sztype);

	printf("\nPlease enter the model of the boat: ");
	gets(stused_boat.szmodel);

	printf("\nPlease enter the title number for the boat: ");
	gets(stused_boat.sztitle);

	printf("\nPlease enter the model year for the boat: ");
	scanf("%d",&stused_boat.iyear);

	printf("\nPlease enter the current hours on ");
	printf("the motor for the boat: ");
	scanf("%ld",&stused_boat.lmotor_hours);

	printf("\nPlease enter the purchase price of the boat: ");
	scanf("%f",&stused_boat.fsaleprice);

	vprint_data(stused_boat);
	return (0);
}

void vprint_data(struct stboat stany_boat)
{
	printf("\n\n");
	printf("A %d %s %s with title number #%s\n",stany_boat.iyear,
	stany_boat.sztype,stany_boat.szmodel,stany_boat.sztitle);
	printf("currently has %ld motor hours", stany_boat.lmotor_hours);
	printf(" and was purchased for $%8.2f\n", stany_boat.fsaleprice);
}



В приведенном примере структура целиком пересылается (вызов по значению) в функцию. Вызывающая процедура просто обращается к функции и передает ей в качестве параметра структурную переменную stused_boat. Обратите внимание на то, что в прототипе и при объявлении функции vprint_data() необходимо поле тега структуры stboat. Как вы увидите ниже, можно также передавать в функцию (вызов по значению) отдельные элементы структуры. Результат на выходе программы аналогичен тому, который был в предыдущем примере.

        18.2. Массив структур.
Структуру можно рассматривать как аналогию отдельной карточки в картотеке. Реальные достоинства структур проявляются тогда, когда используются набор структур, называемый массивом структур. Массив структур подобен целой картотеке, содержащей большое количество отдельных картотек. На основе такого массива можно разработать информационную базу данных, содержащую самые разные объекты.
Сама по себе одна единственная запись типа структуры в большинстве случаев вряд ли может вызывать повышенный интерес. Однако в случае, когда структурированные данные объединяются в массивы, речь идет уже не о единичном объекте, а о целой базе данных.
Объявление массива структур отличается от объявления обычных массивов лишь тем, что в качестве типа создаваемого массива указывается вновь образованный тип структуры. Таким образом, для создания базы данных, содержащей информацию о тридцати домах микрорайона, можно объявить следующий массив:

HOUSE mDistr[30];

Доступ к элементам такого массива осуществляется обычным способом, например, по индексу (индексация ведется, начиная с нуля). Следующий фрагмент кода осуществляет в цикле упорядоченное заполнение номеров домов структуры HOUSE, а затем выводит записанные данные в столбик на экран:

HOUSE mDistr[30];
for(int i=0; i<30; i++)
	itoa(i+l,mDistr[i], HouseNum,10);
for(int i=0; i<30; i++)
	cout << mDistr[i].HouseNum << ' \n ';

Напомним, что для работы функции преобразования целого числа в строку символов itoa() необходимо подключить модуль stdlib. h.
Поскольку запись структуры очень часто имеет внушительный размер (может включать в себя массивы элементов, другие структуры и т.д.), следует принимать во внимание ограничения по памяти при выборе соответствующей модели.

            1.1.8. Описание массива структур.
Процесс описания массива структур совершенно аналогичен описанию любого другого типа массива:

struct book libry [MAXBKS];

Этот оператор объявляет libry массивом, состоящим из MAXBKS-элементов. Каждый элемент массива представляет собой структуру типа book. Таким образом, libry[0] является book-структурой, libry[1] — второй book-структурой и т. д. Имя libry само по себе не является именем структуры; это имя массива, содержащего структуры.



            1.1.9. Определение элементов массива структур.
При определении элементов массива структур мы применяем те же самые правила, которые используются для отдельных структур: сопровождаем имя структуры операцией получения элемента и именем элемента:

libry [0].value	value — первый элемент массива
libry [4].title		title — пятый элемент массива

Заметим, что индекс массива присоединяется к libry, а не к концу имени:

libry.value[2]		/* неправильно */
libry[2].value		/* правильно */

Мы используем libry[2].value, потому что libry[2] является именем структурной переменной точно так же, как libry[1] является именем другой структурной переменной.
Между прочим, что бы это значило? 

libry[2].title[4]

Это был бы пятый элемент элемента title (т. е. title [4]) структуры типа book, описанный третьей структурой (т. е. libry[2]). Это означает, что индексы, находящиеся справа от операции ".", относятся к отдельным элементам, в то время как индексы, расположенные слева от операции, относятся к массивам структур.
Настроим нашу программу инвентаризации книг на обработку, если потребуется, двух или трех (или, может быть, даже большего числа) книг. Очевидно, каждую книгу можно описать структурной переменной типа book. Для описания двух книг нам нужны две такие переменные и т. д. Для обработки нескольких книг потребуется массив таких структур, и мы его создали в программе

/* инвентаризация большого количества книг */
#include <stdio.h>
#include <string.h>
#define MAXTIT 40
#define MAXAUT 40
#define MAXBKS 100 /* максимальное количество книг */
#define STOP " " /* нулевая строка прекращает ввод */
struct book { /* создание шаблона типа book */
			char title [MAXTIT];
			char author [MAXAUT];
			float value;
};
void main ()
{
struct book libry[MAXBKS]; /* массив структур типа book */ 
int count = 0; 
int index;
printf (" Please, enter the name of a book\n");
printf (" Push the buttom [enter] at the beginning of the string for stop.\n");
while (strcmp(gets(libry[count].title), STOP)!=0 && count<MAXBKS)
{
	printf (" Enter now surname of the author\n");
	gets (libry [count].author);
	printf (" Enter now the price\n");
	scanf ("%f", &libry[count++].value);
	while (getchar() != '\n'); /* очистите строку ввода */
		if (count < MAXBKS)
			printf (" Enter the title of the next book.\n");
}
printf (" There is the list of your books:\n");
for (index = 0; index < count; index++)
	printf (" %s, %s: %.2f rub.\n" , libry [index]. title, libry[index] .author, libry[index] .value);
}

Вот пример работы программы:

Введите, пожалуйста, название книги.
Нажмите клавишу [ввод] в начале строки для останова.
Искусство программирования
Введите теперь фамилию автора
Д.Кнут
Введите теперь цену.
5р.67
Введите название следующей книги

... еще вводы ...



Вот список ваших книг:
Искусство программирования для ЭВМ, Д Кнут: 5р.б7
ПЛ/1 для программистов, Скот Р., Сондак Н.: 1р 08
Программирование на языке Паскаль, П.Грогоно: 1р.30
Язык Фортран 77, Г Катцан: 0р.80
Операционные системы, Г.Катцан: 2р. 25



Следует обратить внимание на два важных момента, относящихся к массивам структур, — как описывать и как обращаться к отдельным их элементам.
Главное отличие ее от нашей первой программы заключается в том, что теперь создается цикл для считывания названий книг. Мы начинаем цикл с while-условия:

while (strcmp (gets (libry [count].title), STOP) != 0 && count < MAXBKS)

Выражение gets (libry [count].title) считывает вводимую строку, содержащую название книги. Функция strcmp () сравнивает эту строку со STOP, которая является " ", т. е. пустой строкой. Если пользователь нажмет клавишу [ввод] в начале строки, то перепишется пустая строка и цикл закончится. Мы также должны проверять, не превысило ли число считанных на текущий момент книг предельного размера массива.
В программе есть странная строка

while (getchar () ! = '\n'); /* очистить строку ввода */

Она включена для того, чтобы использовать особенность функции scanf(), которая игнорирует символы пробела и новой строки. Когда вы отвечаете на запрос об элементе value в структуре book, то вводите что-нибудь вроде

12.50 [ввод]

При этом передается последовательность символов

12.50\n

Функция scanf() собирает символы 1, 2, . , 5, 0, но опускает символ \n, стоящий там, и ожидает, что следом придет еще какой-нибудь оператор чтения. Если пропустить нашу странную строку, то следующим оператором чтения будет gets (libry [count].title) в операторе управления циклом. Он прочел бы оставшийся символ новой строки как первый символ, и программа решила бы, что мы послали сигнал останова. Поэтому мы и вставили такую странную строку. Если вы поняли это, то увидите, что она «проглатывает» символы до тех пор, пока не найдет и не получит символ новой строки. Функция ничего не делает с данным символом, только принимает его от устройства ввода. Это приводит к тому, что функция gets() снова начинает работать. Вернемся теперь к изучению структур.

            1.1.10. Масив структур. Типовая задача 2.
Массив структур мог бы, к примеру, содержать информацию о всех категориях местного флота. Такой файл оказался бы полезным для дилера, занимающегося катерами, который смог бы выбрать из базы данных и выставить на продажу все катера не дороже 45000 долларов или все катера, имеющие минимум одну каюту. Изучите следующий пример и обратите внимание на изменения кода программы по сравнению с предыдущими примерами:

/* Программа на С, использующая массив структур.
В этом примере создается "реестр подержанных катеров" для фирмы
Nineveh Boat Sales. */
#include <stdio.h>
#define iSTRING15 15
#define iSTRING20 20
#define iNULL_CHAR 1
#define iMAX_BOATS 50

struct stboat {
	char sztype [iSTRING15 + iNULL_CHAR];
	char szmodel[iSTRING15 + iNULL_CHAR];
	char sztitle[iSTRING20 + iNULL_CHAR];
	char szcomment [80];
	int iyear;
	long int lmotor_hours;
	float fretail;
	float fwholesale;
};

int main(void)
{
	int i, iinstock;
	struct stboat astNineveh[iMAX_BOATS];

	printf("How many boats in inventory? "); /* Сколько катеров в реестре */
	scanf("%d",&iinstock);

	for (i=0; i<iinstock; i++) {
		flushall(); /* очистить буфер клавиатуры */
	printf("\nPlease enter the type of the boat: ");
	gets(astNineveh[i].sztype);

	printf("\nPlease enter the model of the boat: ");
	gets(astNineveh[i].szmodel);

	printf("\nPlease enter the title number for the boat: ");
	gets(astNineveh[i].sztitle);

	printf("\nPlease enter a one line comment about the boat: "); /* Введите, пожалуйста, строку комментария: */
	gets(astNineveh[i].szcomment);

	printf("\nPlease enter the model year for the boat: ");
	scanf("%d",&astNineveh[i].iyear);

	printf("\nPlease enter the current hours on ");
	printf("the motor for the boat: ");
	scanf("%ld",&astNineveh[i].lmotor_hours);

	printf("\nPlease enter the retail price of the boat :"); /* Введите, пожалуйста, розничную цену катера: */
	scanf("%f",&astNineveh[i].fretail);

	printf("\nPlease enter the wholesale price of the boat :"); /* Введите, пожалуйста, оптовую цену катера: */
	scanf("%f",&astNineveh[i].fwholesale);
	}

	printf("\n\n\n");
	for (i=0; i<iinstock; i++) {
		printf("A %d %s %s beauty with %1d low hours.\n",
					astNineveh[i].iyear,astNineveh[i].sztype, astNineveh[i].szmodel,
					astNineveh[i].lmotor_hours);
		printf("%s\n", astNineveh[i].szcomment);

		printf ("Grab the deal by asking your Nineveh salesperson for\n");	
		/* Поторопитесь связаться с дилером фирмы Nineveh насчет */

		printf (" #%s ONLY! $%8.2f.\n",astNineveh[i] .sztitle, astNineveh[i].fretail);
		printf("\n\n");
	}
	return (0);
}

С помощью этой программы фирма Nineveh Boat Sales может создать массив структур, предназначенный для хранения информации о всех катерах, которыми она располагает.

Вводимые значения имеют вид:



Переменная astNineveh[iMAX_BOATS], связанная со структурой struct stboat, на самом деле является массивом. В данном случае константа iMAX_BOATS задает максимальный размер массива, равный 50. Это означает, что в массиве структур может храниться информация о 50 катерах. Теперь необходимо занести данные о тех катерах, которые вам нужны. Первый элемент массива имеет нулевой индекс. Следовательно, к информации о первом катере, хранящейся в массиве структур, можно обратиться при помощи такого оператора:

gets(astNineveh[0].sztitle);

Изучая программу, обратите внимание на то, что доступ к элементам массива осуществляется в цикле. В этом случае для доступа к элементам нужно написать следующее:

gets(astNineveh[i].sztitle);

Оператор flushall() в цикле for необходим для того, чтобы удалить символ перевода строки, оставшийся во входном потоке от предыдущих операторов scanf() (оператора, расположенного перед циклом, и последнего оператора scanf() в цикле). Если бы не было flushall(), то оператор gets() был бы пропущен. Напоминаем, что gets() считывает все символы до перевода строки, включая сам этот символ. Операторы scanf() оставляют символы перевода строки во входном потоке. Если flushall() убрать, то оператор gets() будет перехватывать символ перевода строки из входного потока и передавать его следующему выполняемому оператору. На выходе приведенной программы можно увидеть небольшую часть списка катеров, имеющихся в распоряжении фирмы Nineveh Boat Sales. Также можно понять, как организовать вывод информации, хранящейся в структуре:

А 1957 Chris Craft Dayliner 124876 low hours.
A great riding boat owned by a salesperson.
Grab the deal by asking your Nineveh salesperson for
#BS12345BFD ONLY! $36234.00.
A 1988 Starcraft Weekender a beauty with 27657 low hours.
Runs and looks great. Owned by successful painter.
Grab the deal by asking your Nineveh salesperson for
#BG7774545AFD ONLY! $18533.99.
A 1991 Scarab a wower with 1000 low hours.
A cheap means of transportation. Owned by grandfather.
Grab the deal by asking your Nineveh salesperson for
#156AFG4476 ONLY! $56999.99.



При работе с массивами структур необходимо учитывать ограничения по памяти, имеющиеся в системе программирования; при статическом выделении памяти для массивов структур может потребоваться большое количество системной памяти.

        18.3. Вложенные структуры.
Иногда бывает удобно, чтобы одна структура содержалась или была «вложена» в другую. Например, Шалала Пироски строит структуру, содержащую информацию о ее друзьях. Один элемент структуры — это, конечно, имя друга. Однако имя можно представить самой структурой с разными элементами для имени и фамилии. Здесь приведен сокращенный пример деятельности Шалалы.

/* пример вложенной структуры */
#include <stdio.h>
#define LEN 20
#define M1 " Thank you for a beautiful evening,"
#define M2 " You, certainly, right, that"
#define M3 "-original guy. We should get together"
#define M4 " to taste very good"
#define M5 " and enjoy a little bit."
struct names { /*первый структурный шаблон */
			char first[LEN];
			char last[LEN];
};
struct guy
			{ /* второй шаблон */
			struct names handle; /* вложенная структура */
			char favfood[LEN];
			char job[LEN];
			float income;
};
void main()
{
static struct guy fellow = { /* инициализация переменной */
			{"Franco", "Otel"},
			" eggplant",
			" knitter of doormat",
			15435.00
			};
printf (" Dear %s, \n \n", fellow.handle.first);
printf (" %s %s.\n", M1, fellow.handle.first);
printf (" %s %s\n", M2, fellow.job);
printf (" %s\n", M3);
printf (" %s%s%s\n\n", M4, fellow.favfood, M5);
printf (" %40s%s\n" , " " , " See you later," );
printf (" %40s%s\n", " " , "Shalala");
}

Вот результат работы программы:



Во-первых, следует рассказать о том, как поместить вложенную структуру в шаблон. Она просто описывается точно так же, как это делалось бы для переменной типа int:

struct names handle;

Это означает, что handle является переменной типа struct names. Конечно, файл должен также содержать шаблон для структуры типа names.
Во-вторых, следует рассказать, как мы получаем доступ к элементу вложенной структуры. Нужно дважды использовать операцию ".":

fellow.handle.first = = "Франко" ;

Мы интерпретируем эту конструкцию, перемещаясь слева направо:

(fellow.handle).first

То есть первым находим элемент fellow, далее элемент handle структуры fellow, а затем его элемент first.

            1.1.11. Структуры внутри структур. Типовая задача 2.
Допускаются объявления вложенных структур. Это означает, что структура может содержать один или несколько элементов структурного типа. Предположим, что следующая структура может быть включена в другую:

struct strepair {	// ремонт
	int ioilchange;	// замененное масло
	int iplugs;	// втулки
	int lairfilter;	// воздушный фильтр
	int ibarnacle_cleaning; // ветошь для чистки
};

Структуру strepair можно включить в главную структуру следующим образом:

struct stboat {
	char sztype [iSTRING15 + iNULL_CHAR];
	char szmodel[iSTRING15 + iNULL_CHAR];
	char sztitle[iSTRING20 + iNULL_CHAR];
	char szcomment[80];
	struct strepair strepair_record;
	int iyear;
	long int lmotor_hours;
	float fretail;
	float fwholesale;
} astNineveh[iMAX_BOATS] ;

Для доступа к некоторому элементу структуры strepair_record можно использовать такой оператор:

printf("%d\n",astNineveh[0].strepair_record.ibarnacle_cleaning);

        18.4. Использование указателей на структуры.
Любители указателей будут рады узнать, что указатели можно использовать и для структур. Это хорошо по крайней мере по трем причинам. Во-первых, точно так же как указатели на массивы, они легче в использовании (скажем, в задаче сортировки), чем сами массивы, а указателями на структуры легче пользоваться, чем самими структурами. Во-вторых, структура не может использоваться в качестве аргумента функции, а указатель на структуру может. В-третьих, многие удобные представления данных являются структурами, содержащими указатели к другим структурам.

            1.1.12. Описание и инициализация указателя на структуру.
Вот самое простое описание, какое только может быть:

struct guy *him;

Первым стоит ключевое слово struct, затем слово guy, являющееся именем структурного шаблона, далее * и за нею имя указателя. Синтаксис тот же, как для описаний других указателей, которые мы видели.
Теперь можно создать указатель him для ссылок на любые структуры типа guy. Мы инициализируем him, заставляя его ссылаться на fellow[0]; заметим, что мы используем операцию получения адреса:

him = &fellow[0];

Первые две выведенные строки показывают результат этого присваивания. Сравнивая две строки, мы видим, что him ссылается на fellow [0], a him + 1 — на fellow[1]. Заметим, что добавление 1 к him прибавляет 84 к адресу. Это происходит потому, что каждая guy-структура занимает 84 байта памяти: первое имя — 20, последнее имя — 20, favfood — 20, job — 20 и income — 4 байта (размер элемента типа float в нашей системе).

            1.1.13. Доступ к элементу структуры при помощи указателя.
В предыдущем разделе him ссылается на структуру fellow [0]. Каким образом можно использовать him для получения значения элемента структуры fellow[0]? Третья выведенная строка дает для этого два способа.
Первый способ, наиболее общий, использует новую операцию - >. Она заключается в вводе дефиса  (-) и следующего за ним символа «больше чем» (>). Пример помогает понять смысл сказанного:

him - > income — это fellow[0].income, если him = &fellow[0]

Другими словами, структурный указатель, за которым следует операция - >, работает так же, как имя структуры с последующей операцией ".". (Мы не можем сказать him.income, потому что him не является именем структуры.)
Очень важно отметить, что him — указатель, а him - > income — элемент структуры, на которую делается ссылка. Таким образом, в этом случае him - > income является переменной типа float.
Второй способ определения значения элемента структуры вытекает из последовательности:

если him == &fellow[0], то *him == fellow[0].

Это так, поскольку & и * — взаимообратные операции. Следовательно, после подстановки

fellow[0]. income = = (*him). income

Круглые скобки необходимы, поскольку операция "." имеет приоритет выше, чем *.
Отсюда можно сделать вывод, что если him является указателем на структуру fellow [0], то следующие обозначения эквивалентны:

fellow[0]. income == (*him).income == him-> income

Следующий короткий пример показывает, как определять указатель на структуру и как использовать его для получения элементов структуры.

/* указатель на структуру */
#include<stdio.h>
#define LEN 20
struct names {
			char first [LEN];
			char last [LEN];
};
struct guy {
			struct names handle;
			char favfood [LEN];
			char job [LEN];
			float income;
};
void main()
{
static struct guy fellow [2] = {
	{
			{"Franco", "Otel"},
			"eggplant",
			"knitter of doormat",
			15435.00
	},
	{	
			{"Rodney", "Svilbely"},
			"salmon mousse",
			"interior decorator",
			35000.00
	}
};
struct guy *him; /* ЭТО------указатель на структуру */
printf ("address #1: %u #2: %u\n", &fellow[0], &fellow[1]);
him = &fellow [0]; /* сообщает указателю, на что ссылаться */
printf ("pointer #1: %u #2: %u\n", him, him+1);
printf ("him->income $%.2f: (*him).income $%.2f\n", him->income, (*him).income);
him++; /* указывает на следующую структуру */
printf ("him->favfood is %s: him->names.last is %s\n",him->favfood, him->handle.last);
}

Вот, пожалуйста, ее выход:



Сначала посмотрим, как мы создали указатель на структуру guy. Затем научимся определять отдельные элементы структуры при помощи указателей.

            1.1.14. Использование указателя. Типовая задача 2:
В следующей программе создается массив структур; в этом отношении этот пример аналогичен предыдущему. Для доступа к отдельным элементам структуры в данном примере используется операция "стрелка" (arrow). Эту операцию можно использовать только тогда, когда создан указатель на структуру.

/* Программа на С, использующая указатель на массив структур.
Опять взят пример реестр катеров фирмы Nineveh Boat Sales */
#include <stdio.h>
#define iSTRING15 15
#define iSTRING20 20
#define iNULL_CHAR 1
#define iMAX_BOATS 50

struct stboat {
	char sztype [iSTRING15 + iNULL_CHAR];
	char szmodel[iSTRING15 + iNULL_CHAR];
	char sztitle[iSTRING20 + iNULL_CHAR];
	char szcomment[80];
	int iyear;
	long int lmotor_hours ;
	float fretail;
	float fwholesale;
};
int main(void)
{
	int i, iinstock;
struct stboat astNineveh[iMAX_BOATS], *pastNineveh;
	pastNineveh=&astNineveh[0];
	printf("How many boats in inventory? ");
	scanf("%d",&iinstock) ;

	for (i=0; i<iinstock; i++) {
		flushall(); /* очистить буфер клавиатуры */
		printf("\nPlease enter the make of the boat: ");
		gets(pastNineveh->sztype);

		printf("\nPlease enter the model of the boat: ");
		gets(pastNineveh->szmodel);

		printf("\nPlease enter the title number for the boat: ");
		gets(pastNineveh->sztitle);
		printf("\nPlease enter a one line comment about the boat: ");
		gets(pastNineveh->szcomment);

		printf("\nPlease enter the model year for the boat: ");
		scanf("%d",&pastNineveh->iyear);

		printf("\nPlease enter the current hours on ");
		printf("the motor for the boat: ");
		scanf("%d",&pastNineveh->lmotor_hours); 
		
		printf("\nPlease enter the retail price of the boat: ");
		scanf("%f",&pastNineveh->fretail);

		printf("\nPlease enter the wholesale price of the boat: ");
		scanf("%f",&pastNineveh->fwholesale);
		pastNineveh++;
	}
	pastNineveh =&astNineveh[0];
	printf("\n\n\n") ;

	for (i=0; i < iinstock; i++) {
		printf("A %d %s %s beauty with %d low hours.\n",pastNineveh->iyear,
pastNineveh->sztype,pastNineveh->szmodel,pastNineveh->lmotor_hours);
		printf("%s\n",pastNineveh->szcomment);
		printf("Grab the deal by asking your Nineveh salesperson for:");
		printf("\n#%s ONLY! $ %.2f \n",pastNineveh->sztitle, pastNineveh->fretail);
		printf("\n\n");
		pastNineveh++;
	}
	return (0);
}



Переменная-массив astNineveh[iMAX_BOATS] и указатель *pastNineveh связаны со структурой при помощи следующего оператора:

struct stboat astNineveh[iMAX_BOATS],*pastNineveh;

Адрес массива astNineveh копируется в переменную-указатель pastNineveh при помощи оператора

pastNineveh=&astNineveh[0];

Хотя синтаксис и не запрещает обращаться к элементам массива при помощи следующего оператора, однако этот метод не рекомендуется:

gets ((*pastNineveh).sztype);

С учетом приоритета операций для того, чтобы операция обращения к члену структуры (.) выполнялась после операции разыменования указателя *pastNineveh, необходимы дополнительные круглые скобки. Лучше использовать операцию "стрелка", делающую весь оператор намного проще:

gets (pastNineveh->sztype);

Хотя этот пример и очень простой, он иллюстрирует использование операции косвенного обращения к члену структуры "стрелка". Данный пример подводит вас к пониманию главного преимущества указателей — их использованию для передачи массива структур в функцию.

        18.5. Структуры и функции.

            1.1.15. Передача структур по значению.
Зачастую в тело функции необходимо передать информацию, структурированную по определенному принципу. При этом в качестве параметра в прототипе функции указывается пользовательский тип данных, сформированный при объявлении структуры. Так, если была объявлена структура

struct ALLNUMB
{
int nVar;
long lVar;
short shVar;
unsigned int uiVar;
}

прототип функции будет, например, иметь вид:

void Punc (ALLNUMB);

При этом происходит передача в тело функции параметра типа структуры по значению. Таким образом, оригинал структурированного объекта модификации не подлежит. Функция может также возвращать объект типа структуры:

ALLNUMB Func2 (ALLNUMB);

В этом случае модифицированные данные при выходе из функции не потеряются, а будут переданы в точку вызова функции.
Рассмотрим пример передачи в функцию описанной ранее структуры House для вывода на экран названия улицы и номера дома, содержащихся в ней.

#include <iostream>
using namespace std;

struct HOUSE
{
	unsigned short RegNum;
	char Street[51]; // с учетом '\0'
	char HouseNum[6];
	unsigned short MaxFloorNum;
	unsigned short MaxFlatNum;
	bool Parking;
};

void OutAddress(HOUSE);

int main ()
{
	setlocale(LC_ALL, "Rus");
	HOUSE MyHouse;
	MyHouse.RegNum = 524;
	strcpy(MyHouse.Street, "ул. Гоголя");
	strcpy(MyHouse.HouseNum, "2-a");
	MyHouse.MaxFloorNum = 7;
	MyHouse.MaxFlatNum = 84;
	MyHouse.Parking = true;
	OutAddress(MyHouse);

	getchar(); 	getchar();
	return 0;
}

void OutAddress(HOUSE house)
{
	cout << house.Street << ",";
	cout << house.HouseNum << '\n';
}

Вызов функции OutAddress (MyHouse) передает в тело сформированную структуру, доступ к членам которой осуществляется в соответствии с описанным выше правилом, через символ 'точка' (.). В результате на экран будет выведено:

ул. Гоголя, 2-а




            1.1.16. Передача структур посредством указателей.
Разработчик ПО на C++ имеет возможность обращаться к элементам структуры через указатели. Для этого должна быть объявлена соответствующая переменная типа указателя на структуру, синтаксис которой может быть представлен в виде:

тип структуры* идентификатор_указателя;

Доступ к элементам структуры через указатель осуществляется с использованием не точки, а символа стрелки (->) Например, создадим указатель на структуру house:

HOUSE *pHouse;
pHouse = &MyHouse;

Теперь запишем в структуру информацию о наличии автостоянки около дома посредством объявленного указателя и выведем записанную информацию:

pHouse->Parking = true;
cout << MyHouse.Parking;
// или так: cout << pHouse->Parking;

Мы будем решать ту же самую задачу, что и прежде, но при этом использовать адрес структуры в качестве аргумента. Это хорошо, поскольку адрес представляет собой только одно число. Так как функция должна работать со структурой funds, она тоже должна использовать шаблон funds.

/* передача адреса структуры в функцию */
#include<stdio.h>
struct funds {
			char *bank;
			float bankfund;
			char *save;
			float savefund; } stan = {
						"Senior tomatoes Bank",
						1023.43,
					"Savings and lendings of Snoopy",
						4239.87
						};
float sum(struct funds *);
void main()
{
float total;
total=sum(&stan);
printf ("Stan has only %.2f dollars.\n", total );
}

float sum(struct funds *money)
{
	return ( money->bankfund + money->savefund);
}
Эта программа тоже выдает

У Стэна всего 5263.30 долл.



Функция sum() имеет указатель (money) на структуру fund. Передача адреса &stan в функцию заставляет указатель money ссылаться на структуру stan. Затем используем операцию - > для получения значений элементов stan .bankfund и stan.savefund.
Эта функция также имеет доступ к названиям учреждений, хотя их не использует.
Заметим, что мы должны применять операцию & для получения адреса структуры. В отличие от имени массива имя структуры само по себе не является синонимом своего адреса.

            1.1.17. Передача структур посредством ссылок.
Помимо использования указателей возможно применение ссылок на структуры. Объявление такой ссылки имеет следующий синтаксис:

тип структуры &имя_ссылки =  имя_переменной;

Как и ссылка на обычную переменную, ссылка на структуру должна быть инициализирована именем объекта, на который она указывает (в данном случае это имя_переменной).
Ссылки и указатели на структуры данных могут быть переданы в качестве аргументов в тело функции. При этом значительно снижается время (в сравнении с передачей по значению), за которое данный параметр передается в функцию, а также экономится стековая память.
Синтаксис прототипа функции при передаче структур посредством указателей и ссылок идентичен синтаксису обычной передачи параметров через указатели и ссылки:

// Пример передачи указателя и ссылки на
// целочисленную переменную:
bool Func(int* ptr, int& ref);
// Передача указателя и ссылки на
// структуру типа HOUSE:
char Func2 (HOUSE* pMh, HOUSES rMh);

Таким образом, в функцию Func2 будут переданы не сами значения структур, а соответствующие адреса, что в значительной степени экономит стековую память.

            1.1.18. Передача элементов структуры.
Поскольку элемент структуры является переменной с единственным значением (т. е. типа int или одного из его «родственников» — char, float, double или указатель), он может быть передан как аргумент функции. Простая программа финансовых расчетов, которая прибавляет взнос клиента к его счету, иллюстрирует этот способ. Заметим, между прочим, что мы объединили определение шаблона, описание переменной и инициализацию в один оператор.

/* передача элементов структуры как аргументов функции */
#include<stdio.h>
struct funds {
			char *bank;
			float bankfund;
			char *save;
			float savefund; } stan = {
						"Senior tomatoes Bank",
						1023.43,
						"Savings and lendings of Snoopy",
						4239.87
									};
float sum(float x, float y);
void main()
{
float total;
extern struct funds stan; /* необязательное описание */
total=sum(stan.bankfund, stan.savefund);
printf ("Stan has only %.2f dollars.\n", total);
}

/* складывает два числа типа float */
float sum(float x, float y)
	{
		return x+y;
	}
	
Результат выполнения этой программы:



Вот это да, она работает. Заметим, что функция sum() «не знает», или же ей безразлично, являются ли элементами структуры фактические аргументы; она только «требует», чтобы они имели тип float.
Конечно, если вы хотите, чтобы программа воздействовала на значение элемента в вызывающей программе, можно передать ей адрес этого элемента:

modify(&stan.bankfund);

и тогда получилась бы функция, которая изменила бы банковский счет в структуре Stan.
Второй способ передачи информации о структуре заключается в возможности сообщить суммирующей функции, что она имеет дело со структурой.


            1.1.19. Передача массива структур.
Предположим, у нас есть массив структур. Имя массива является синонимом его адреса, поэтому его можно передать функции. С другой стороны, функции будет необходим доступ к структурному шаблону. Чтобы показать, как такая программа работает, мы расширим нашу программу таким образом, чтобы она обслуживала двух человек, а мы, следовательно, имели бы массив двух структур funds.

/* передача массива структур в функцию */
#include<stdio.h>
struct funds {
			char *bank;
			float bankfund;
			char *save;
			float savefund; } jones[2] ={
						{
							"Senior tomatoes Bank",
							1023.43,
							"Savings and lendings of Snoopy",
							4239.87
							},
							{
							"Honest Jack's Bank",
							976.57,
							"Accumulation by prior plan",
							1760.13
							}
						};
float sum(struct funds *);
void main()
{
float total;
total=sum(jones);
printf ("Jonsons have only %.2f dollars.\n" , total);
}

float sum (struct funds *money)
{
float total;
int i;
for( i = 0, total = 0; i < 2; i++ , money++)
	total+= money->bankfund + money->savefund;
return(total);
}
Программа выдает



(Что за круглая сумма! Можно подумать, что эти цифры взяты с потолка.)
Имя массива Jones является указателем на массив. В частности, оно ссылается на первый элемент массива, который является структурой jones[0]. Таким образом, в начале указатель money задается через

money = &jones[0];

Затем использование операции — > позволяет нам добавить два вклада для первого Джонса. Это действительно очень похоже на последний пример. Далее, цикл for увеличивает указатель money на 1. Теперь он ссылается на следующую структуру, jones[1], и остаток вкладов может быть добавлен к total.
Вот два основных замечания:
    1. Имя массива можно использовать для передачи в функцию указателя на первую структуру в массиве.
    2. Затем можно использовать арифметическую операцию над указателем, чтобы передвигать его на последующие структуры в массиве. Заметим, что вызов функции

sum(&jones[0])

дал бы тот же самый эффект, что и применение имени массива, так как оба они ссылаются на один и тот же адрес. Использование имени массива является просто косвенным способом передачи адреса структуры.

    2. Передача информации о структурах функциям. Использование массива. Типовая задача 2 на С.
Ранее уже говорилось о том, что передача указателя на структуру выполняется быстрее, чем простое копирование структуры в функцию. Этот факт становится еще очевиднее при частом использовании структур в программе. Ниже показано, как при помощи указателя функция может получить доступ к массиву структур:

/* Программа на С, иллюстрирующая обращение функции к массиву
структур с использованием указателя
Опять используется реестр катеров фирмы Nineveh Boat Sales! */
#include <stdio.h>
#define iSTRING15 15
#define iSTRING20 20
#define iNULL_CHAR 1
#define iMAX_BOATS 50

int iinstock;
struct stboat {
	char sztype [iSTRING15 + iNULL_CHAR];
	char szmodel[iSTRING15 + iNULL_CHAR];
	char sztitle[iSTRING20 + iNULL_CHAR];
	char szcomment[80];
	int iyear;
	long int lmotor_hours;
	float fretail;
	float fwholesale;
};
void vprint_data(struct stboat *stany_boatptr);
int main(void)
{
	int i;
	struct stboat astNineveh[iMAX_BOATS], *pastNineveh;
	pastNineveh=&astNineveh[0];
	printf("How many boats in inventory?\n");
	scanf("%d",&iinstock);

	for (i=0; i < iinstock; i++) {
		flushall(); /* очистить буфер клавиатуры */
		printf("\nPlease enter the make of the boat: ");
		gets(pastNineveh->sztype);

		printf("\nPlease enter the model of the boat: ");
		gets(pastNineveh->szmodel);

		printf("\nPlease enter the title number for the boat: ");
		gets(pastNineveh->sztitle);

		printf("\nPlease enter a one line comment about the boat: ");
		gets(pastNineveh->szcomment);

		printf("\nPlease enter the model year for the boat: ");
		scanf("%d",&pastNineveh->iyear);

		printf("\nPlease enter the current hours on ");
		printf("the motor for the boat: ");
		scanf("%d",&pastNineveh->lmotor_hours);

		printf("\nPlease enter the retail price of the boat: ");
		scanf("%f",&pastNineveh->fretail);

		printf("\nPlease enter the wholesale price of the boat: ");
		scanf("%f",&pastNineveh->fwholesale);

		pastNineveh++;

	}

	pastNineveh = &astNineveh[0];
	vprint_data(pastNineveh);

	return (0);
}

void vprint_data(struct stboat *stany_boatptr)
{
	int i;

	printf("\n\n\n");
	for (i=0; i < iinstock; i++) {
		printf("A %d %s %s beauty with %ld low hours.\n", stany_boatptr->iyear, 
stany_boatptr->sztype, stany_boatptr->szmodel, stany_boatptr->lmotor_hours);
		printf ("%s\n",stany_boatptr->szcomment);
		printf ("Grab the deal by asking your Nineveh salesperson for\n");
		printf ("#%s ONLY! $%8.2f.\n",stany_boatptr->sztitle, stany_boatptr->fretail);
		printf("\n\n");
		stany_boatptr++;
	}
}



Первое отличие данной программы от предыдущей касается прототипа функции vprint_data():

void vprint_data(struct stboat *stany_boatptr);

Эта функция в качестве параметра получает указатель на описанную выше структуру. В функции main() массив astNineveh[iMAX_BOATS] и указатель *pastNineveh связываются со структурой при помощи следующего оператора:

struct stboat astNineveh[iMAX_BOATS], *pastNineveh;

После того как информация для реестра катеров введена, она передается в функцию vprint_data() посредством указателя:

vprint_data(pastNineveh);

Одним из главных преимуществ от использования указателей при передаче массива структур в функцию является то, что в этом случае массив вызывается по имени или по ссылке. Это означает, что функция обращается к исходному массиву, а не к его копии. При использовании данного метода вызова любые изменения массива структур внутри функции имеют глобальную область действия. Результат работы этой программы такой же, как и для предыдущего примера.

    3. Передача информации о структурах функциям. Использование массива. Типовая задача 2 на C++.
Далее следует программа на C++, похожая на последнюю программу на С. Если говорить о синтаксисе, то оба языка обрабатывают структуры одинаково. Однако, в этом примере используются преимущества более компактных синтаксических конструкций C++:

// Программа на C++, иллюстрирующая использование указателей при
// обращении к данным в структуре из функции.
// Примечание: Строка комментария заканчивается точкой (.)
#include <iostream.h>
#define iSTRING15 15
#define iSTRING20 20
#define iNULL_CHAR 1
#define iMAX_BOATS 50
int iinstock;
struct stboat {
	char sztype [iSTRING15 + iNULL_CHAR];
	char szmodel[iSTRING15 + iNULL_CHAR];
	char sztitle[iSTRING20 + iNULL_CHAR];
	char szcomment[80];
	int iyear;
	long int lmotor_hours;
	float fretail;
	float fwholesale;
};

void vprint_data(stboat *stany_boatptr);
int main(void)
{
	int i;
	char newline;
	stboat astNineveh[iMAX_BOATS],*pastNineveh;

	pastNineveh=&astNineveh[0];
	cout << "How many boats in inventory? ";

	cin >> iinstock;

	for (i=0; i<iinstock; i++) {
		cout << "\nPlease enter the make of the boat: ";
		cin >> pastNineveh->sztype;

		cout << "\nPlease enter the model of the boat: ";
		cin >> pastNineveh->szmodel;

		cout << "\n Please enter the title number for the boat: ";
		cin >> pastNineveh->sztitle;

		cout << "\nPlease enter the model year for the boat: ";
		cin >> pastNineveh->iyear;

		cout << "\nPlease enter the current hours on "<< "the motor for the boat: ";
		cin >> pastNineveh->lmotor_hours;

		cout << "\nPlease enter the retail price of the boat: ";
		cin >> pastNineveh->fretail;

		cout << "\nPlease enter the wholesale price of the boat: ";
		cin >> pastNineveh->fwholesale;

		cout << "\nPlease enter a one line comment about the boat: ";
		cin.get(newline); // обрабатывается возврат каретки
		cin.get(pastNineveh->szcomment,80,'.');
		cin.get(newline); // обрабатывается возврат каретки pastNineveh++;
	}
	pastNineveh=&astNineveh[0];
	vprint_data(pastNineveh);

	return (0);

}

void vprint_data(stboat *stany_boatptr)
{
	int i;
	cout << "\n\n\n";

	for (i=0; i<iinstock; i++) {
		cout << "A[{|"<< stany_boatptr->iyear <<"|}] [{|"<< stany_boatptr->sztype<<"|}] [{I"
<< stany_boatptr->szmodel <<"I}] beauty with [{|"<< stany_boatptr->lmotor_hours <<"|}] low hours.\n";
		cout << stany_boatptr->szcomment << endl;
		cout << "Grab the deal by asking your Nineveh "<< "salesperson for #";
		cout << stany_boatptr->sztitle << "ONLY! $"<< stany_boatptr->fretail << "\n\n";

		stany_boatptr++;
	}
}



Реальные различия между программами на С и C++ заключаются в том, как они управляют потоковым вводом/выводом. Обычно для замены стандартных функций С printfO и gets() можно использовать потоки C++ cout и cin. Например:

cout << "\nPlease enter the wholesale price of the boat: ";
cin >> pastNineveh->fwholesale;

Один из операторов программы предназначен для запроса комментария пользователя о каждом катере. В операторе ввода C++, необходимом для считывания строки комментария, используется другой метод ввода/вывода. Напомним, что поток cin считывает символьную информацию до первого разделительного символа. В нашем случае таким разделителем служит символ пробела между словами в комментарии. Если использовать cin, то только первое слово строки комментария можно запомнить в элементе структуры szcomment. Поэтому для ввода целой строки текста используется модифицированный вид потока cin:

cout << "\nPlease enter a one line comment about the boat: ";
cin.get(newline); // обрабатывается возврат каретки
cin.get(pastNineveh->szcomment,80, '.') ;
cin.get(newline); // обрабатывается возврат каретки

Сначала используется вызов cin.get(newline); он аналогичен вызову функции flushall() в предыдущих программах на С. В системах, где запросы от клавиатуры буферизируются, зачастую необходимо удалять символ перевода строки из входного буфера. Для этого существуют, конечно, и другие способы, однако они не более эффективны. Оператор cin.get(newline) считывает символ перевода строки и запоминает его в переменной newline, которая служит только для сбора информации и в программе фактически не используется. Строка комментария вводится при помощи следующего оператора:

cin.get(pastNineveh->szcomment,80,'.');

В этом операторе используется указатель на член структуры szcomment, затем указывается максимальная длина комментария (80) и следует символ окончания (.). В этом случае строка комментария заканчивается после ввода (n-1) или (80-1) символов или при вводе точки (последняя, n-ая позиция отводится под символ окончания строки null, \0). Символ точки не запоминается как часть комментария, поэтому он добавляется уже после вывода комментария. Найдите оператор, выполняющий эти действия.

            3.1.1. Функция – член структуры
При описании параметров некоторых объектов, например, человека, достаточно занести только конкретное значение, например, имя, фамилия, рост и так далее. Но некоторые параметры требуют выполнения процедур на момент их запроса, как-то: давление, температура и так далее.
Поэтому, как правило, описав новую структуру, приходится создавать набор функций, работающих с элементами этой структурой. Например, можно описать структуру трехмерной точки в декартовой системе или вектор. Пример.

struct _3d {
	double x, y, z;
} vect;

Было бы логично написать функцию, которая будет вычислять модуль вектора (длину). Пример.

double mod (_3d &V);

Это традиционный путь для программ как на языке С так и других. Описывается функция, вычисляющая модуль вектора, который передается ей через формальные параметры. Между тем, модуль — характеристика, присущая каждому вектору. Поэтому, будет логично, совместить описание вектора и его длину, то есть вектор будет, как бы, сам возвращать свою длину.
Для того чтобы функция стала членом структуры, достаточно поместить ее описание внутрь описания структуры. Пример.

struct _3d {
	double x, y, z;
	double mod ();
} vect;

Здесь функция mod () выступает как член структуры.
При описании реализации функции надо после типа возвращаемого значения указать имя шаблона структуры, членом которого является данная функция, и имя функции, отделив их знаком "::" (два двоеточия). Пример.

double _3d::mod()
{
	return sqrt (x * x + y * y + z * z);
}

Если текст функции короткий, то реализацию функции можно поместить непосредственно внутрь описания структуры.
Пример.

struct _3d {
	double х, у, z;
	double mod () { return sqrt (x * x + у * у + z * z); }
} vect;

В этом случае можно опустить имя структуры, а сама функция будет считаться inline.
В качестве преимуществ такой структуры отметим, что такая функция обращается к своим переменным (членам структуры) запросто по имени. То есть, если функция не использует посторонние данные (не члены структуры) для достижения результата и не возвращает результат через список параметров, то список параметров может быть пустым.
Помимо этого необходимо отметить, что каждая функция шаблона структуры представлена в единственном экземпляре и получает один скрытый параметр — указатель на ту переменную структуру, для которой она вызвана. К этому указателю можно обратиться непосредственно по его имени – this.
Обращаться к функциям-членам структуры (класса) следует также как и к переменным: указать имя структуры и функции через точку; указать имя указателя на структуру и функции через знак «->».
Пример

	_3d a, *b;
	double lenA, lenB, lenAB;
	b = new _3d;
	a.x = 1.;
…
	lenA = a.mod();
…
	b->x = 3.;
…
	lenB = b->mod();
…

Полный пример, который показывает, как использовать поля и функции переменной типа структуры и указателя на структуру

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

struct _3d {
	double x, y, z;
	double mod ();
} vect;

struct _3d {
	double х, у, z;
	double mod () { return sqrt (x * x + у * у + z * z); }
} vect;


double _3d::mod()
{
	return sqrt (x * x + y * y + z * z);
}

int main()
{
	_3d a, *b;
	double lenA, lenB, lenAB;
	b = new _3d;
	a.x = 1.;
	a.y = 2.;
	a.z = 3.;
	lenA = a.mod();
    printf("%f\n",a.x);
    printf("%f\n",a.y);
    printf("%f\n",a.z);
    printf("%f\n\n",lenA);

	b->x = 3.;
	b->y = 2.;
	b->z = 1.;
	lenB = b->mod();
    printf("%f\n",b->x);
    printf("%f\n",b->y);
    printf("%f\n",b->z);
    printf("%f\n\n",lenB);

	lenAB = a.mod() + b->mod();
    printf("%f\n\n",lenAB);

	
	system("PAUSE");
	return 0;
}



    4. Особенность возврата const.
Замечание
1. Расширение возможностей и/или обход установок выполняемых const можно осуществить с помощью ключевого слова mutable (тема «Классы С++» в ООП).
2. Полезно ознакомиться с вопросом «Сложные формы данных» этой темы

Немного теории. Прежде всего учитываем то, что

int*	- pointer на int
int const *	- pointer на const int
int * const	- const pointer на int
int const * const	- const pointer на const int

Теперь первый const может быть по обе стороны от типа:

const int * == int const *
const int * const == int const * const

Если вы хотите сойти с ума, вы можете делать такое:

int **	- pointer на pointer на int
int ** const	- const pointer на a pointer на int
int * const *	- pointer на const pointer на int
int const **	- pointer на pointer на const int
int * const * const	- const pointer на const pointer на int
...

И чтобы убедиться, что мы ясно понимаем значение const

const int* foo;
int *const bar; //обратите внимание, вам действительно нужно установить указатель 
                //здесь, потому что вы не можете изменить его позже

foo - переменный указатель на константу int. Это позволяет вам изменить то, на что вы указываете, но не значение, на которое вы указываете. Чаще всего это наблюдается для cstrings, где у вас есть указатель на const char. Вы можете изменить строку, на которую указываете, но вы не можете изменить содержимое этих строк. Это важно, когда сама строка находится в сегменте данных программы и не должна изменяться.

bar является константой или фиксированным указателем на значение, которое можно изменить. Это похоже на ссылку без дополнительного синтаксического излишества. Из-за этого, как правило, вы будете использовать ссылку, где вы будете использовать указатель T * const, если вам не нужно разрешать нулевые указатели.
Вот визуальная подсказка



    1. Постоянная ссылка:
Ссылка на переменную (здесь int), которая является постоянной. Мы передаем переменную как ссылку главным образом, потому что ссылки меньше по размеру, чем фактическое значение, но есть побочный эффект, и это потому, что он похож на псевдоним на фактическую переменную. Мы можем случайно изменить основную переменную через наш полный доступ к псевдониму, поэтому мы делаем его постоянным, чтобы предотвратить этот побочный эффект.

int var0 = 0;
const int &ptr1 = var0;
ptr1 = 8; // Error
var0 = 6; // OK

    2. Константные указатели
Как только постоянный указатель указывает на переменную, он не может указывать на какую-либо другую переменную.

int var1 = 1;
int var2 = 0;
int *const ptr2 = &var1;
ptr2 = &var2; // Error

    3. Указатель на константу
Указатель, через который нельзя изменить значение переменной, на которую он указывает, называется указателем на константу.

int const * ptr3 = &var2;
*ptr3 = 4; // Error

    4. Постоянный указатель на константу
Постоянным указателем на константу является указатель, который не может ни изменить адрес, на который он указывает, ни изменить значение, сохраненное на этом адресе, и не изменять его.

int var3 = 0;
int var4 = 0;
const int * const ptr4 = &var3;
*ptr4 = 1; // Error
ptr4 = &var4; // Error

С учетом теории, очевидными становятся примеры кода

Пример1

#include <iostream>
using namespace std;

int main() {

  int a,b;

  int* w;                       // read/write int, read/write pointer
  w= &b;                        // OK
  *w= 1;                        // OK

  int* const x = &a;            // read only pointer, read/write int 
  // x = &b;                    // compilation error
  *x = 0;                       // OK

  int const * y;                // read/write ptr, read only int 
  const int * y2;               // "    "    "
  y = &a;                       // OK
  // *y = 0;                    // compilation error
  y2 = &a;                      // OK
  // *y2 = 0;                   // compilation error

  int const * const z = &a;     // read only ptr and read only int 
  const int * const z2 = &b;    // "    "   "   "   
  // *z = 0;                    // compilation error
  // z = &a;                    // compilation error
  // *z2 = 0;                   // compilation error
  // z2 = &a;                   // compilation error

}

Пример2

#include <iostream>
using namespace std;

class A
{
public:
    A():member_()
    {
    }

    int hashGetter() const
    {
        state_ = 1;
        return member_;
    }
    int goodGetter() const
    {
        return member_;
    }
    int getter() const
    {
        //member_ = 2; // error
        return member_;
    }
    int badGetter()
    {
        return member_;
    }
private:
    mutable int state_;
    int member_;
};

int main()
{
    const A a1;
    //a1.badGetter(); // doesn't work
    a1.goodGetter(); // OK
    a1.hashGetter(); // OK

    A a2;
    a2.badGetter(); // OK
    a2.goodGetter(); // OK
    a2.hashGetter(); // OK
    system("PAUSE");
}

Пример3

#include <iostream>
using namespace std;

int main()
{
    int i1 = 0;
    int i2 = 10;

    const int *p = &i1;
    int const *p2 = &i1;
    const int const *p3 = &i1;

    p = &i2;
    p2 = &i2;
    p3 = &i2;

    cout << *p << endl
        << *p2 <<endl
        << *p3 <<endl;
    system("PAUSE");
    return 0;
}



Также имеет значение различия возвращаемых значений типа класса: если вы возвращаете T const, то вызывающий не может вызывать неконстантные функции по возвращаемому значению, например:

class Test
{
public:
    void f();
    void g() const;
};

Test ff();
Test const gg();

ff().f(); //  legal
ff().g(); //  legal
gg().f(); //  **illegal**
gg().g(); //  legal

Когда вы добавляете ключевое слово const в метод, то этот указатель будет по существу const, и поэтому вы не можете изменять какие-либо данные элемента. (Если вы не используете mutable, более подробно об этом позже).
Ключевое слово const является частью сигнатуры функций, что означает, что вы можете реализовать два похожих метода: тот, который вызывается, когда объект const, а другой - нет.

#include <iostream>
using namespace std;

class MyClass
{
private:
    int counter;
public:
    void Foo()
    { 
        cout << "Foo" << endl;
    }

    void Foo() const
    {
        cout << "Foo const" << endl;
    }

};

int main()
{
    MyClass cc;
    const MyClass& ccc = cc;
    cc.Foo();
    ccc.Foo();
    system("PAUSE");
}



В методе non-const вы можете изменить члены экземпляра, что вы не можете сделать в версии const. Если вы измените объявление метода в приведенном выше примере на код ниже, вы получите некоторые ошибки.

void Foo()
{
    counter++; //this works
    cout << "Foo" << endl;
}

void Foo() const
{
    counter++; //this will not compile
    cout << "Foo const" << endl;
}

Это не совсем так, потому что вы можете пометить элемент как измененный, а метод const затем может его изменить. Он в основном используется для внутренних счетчиков и прочее. Решением для этого будет приведенный ниже код.

#include <iostream>
using namespace std;

class MyClass
{
private:
    mutable int counter;
public:

    MyClass() : counter(0) {}

    void Foo()
    {
        counter++;
        cout << "Foo" << endl;
    }

    void Foo() const
    {
        counter++;
        cout << "Foo const" << endl;
    }

    int GetInvocations() const
    {
        return counter;
    }
};

int main(void)
{
    MyClass cc;
    const MyClass& ccc = cc;
    cc.Foo();
    ccc.Foo();
    //Вызывается экземпляр MyClass
    cout << "The MyClass instance has been invoked "
        << ccc.GetInvocations() << " times" << endl;
    system("PAUSE");
}



Становится очевидным, если вы считаете, что компилятор будет генерировать конструктор по умолчанию, конструктор копии по умолчанию и стандартный оператор присваивания копии для вас, если ваш struct/class не содержит ссылочные элементы. Затем подумайте, что стандарт позволяет вам вызывать методы-члены во временных рядах, то есть вы можете вызывать неконстантные члены в неконстантных временных рядах.
См. этот пример:

#include <iostream>
using namespace std;

struct MyS {
    int fn1() const { return 0xFEED; } // 65261
    int fn2()       { return 0xFEEA; } // 65258
};

//mys это моя функция типа const MyS
const MyS mys () {
    return MyS(); //запускается конструктор MyS() и возвращается объект MyS
}

int main () {
    cout << "mys().fn1()=" << mys().fn1() << "\n"; // okay, called const member method
    //cout << "mys().fn2()=" << mys().fn2(); // error, called non-const member of const temporary

    system("PAUSE");
    return 0;
}



Пример

#include <stdio.h>
#include <stdlib.h>

typedef struct Kernel {
  int a;
} Kernel;

Kernel* kernel_new() {
  return (Kernel*) malloc(sizeof(Kernel));
}

void kernel_delete(Kernel* kernel) {
  free(kernel);
}

void kernel_start(Kernel* kernel) {
  printf("%d\n", kernel->a);
}

int main(int argc, char* argv[]) {
  Kernel* kernel = kernel_new();
  kernel->a = 10;
  kernel_start(kernel);
  kernel_delete(kernel);

  system("PAUSE");
  return 0;
}



            4.1.1. Возврат структуры из функции

https://dev64.wordpress.com/2012/10/11/object-return-in-cpp/
Существует легенда, что возврат структуры по значению из функции в C++ — затратная процедура.

#include <stdio.h>
#include <string.h>
#include <iostream>
 
struct Object {
public:
    int a;
    int b;
    int c;
    char string[50];
};
 
Object func() {
    Object o;
        o.a = 1;
        o.b = 2;
        o.c = 3;
        strcpy(o.string, "Hello world!");
    return o;
}
 
int main() {
    Object o = func();
    printf("%d\n",o.a);
    printf("%d\n",o.b);
    printf("%d\n",o.c);
    printf("%s\n",o.string);

    system("PAUSE");
    return 0;
}



Что отсюда видно и что следует из  ассеблерного кода. Видно что в функции main() резервируется место в стеке под структуру Object o. А потом, как это не странно ссылка на эту выделенную память передается внутрь функции func(). И функция func не производя никакого выделения памяти самостоятельно, работает с полями структуры, предварительно загрузив адрес структуры в регистр eax.
Т.е. это означает, что никаких накладных расходов данный фрагмент не вызывает! Во первых нет ни одной операцией с «кучей». Всё выделяется в стеке вызывающей функции. Во-вторых адрес выделенной памяти передается скрытой ссылкой или указателем. Это как вам больше нравится. В ассеблере просто передается адрес.
Теперь проверим следующий, закономерный вопрос. А что если функция func сама является членом другого класса. Как компилятор поступит в этом случае. Провожу для этого второй эксперимент, аналогичный первому:

#include <stdio.h>
#include <string.h>
#include <iostream>
 
struct Object {
public:
    int a;
    int b;
    int c;
    char s[50];
};

class A {
  int a;
public:
  Object func();
};
 
Object A::func() {
  Object o;
  o.a=1;
  o.b=2;
  o.c=3;
  strcpy(o.s,"Hello world"); 
  a=5;
  return o;
}
 
int main(int argc, char ** argv) {
   A a;
   Object o = a.func();

   printf("%d\n",o.a);
   printf("%d\n",o.b);
   printf("%d\n",o.c);
   printf("%s\n",o.s);

   system("PAUSE");
   return 0;
}



Этот код показывает, что опять в функцию func() в качестве первого аргумента передается указатель на структуру Object o. Функция в данном случае загружает его адрес в регистр ebx и заполняет поля структуры. Затем загружает в регистр eax второй скрытый параметр, содержащий указатель на экземпляр класса, которому принадлежит функция, т.е. this.
Т.о. вывод при возврате структуры по значению никаких накладных расходов на его выделение не случается. Память выделяется в стеке вызывающей функции. В функцию передается скрытый указатель на выделенную память. В случае, если функция, возвращающая структуру является членом класса, тогда в нее передается не один, а два указателя. Один указатель на выделенную для возвращаемого значения память и второй указатель this (на экземпляр объекта класса, членом которого является функция). Функция по окончании работы в регистре eax возвращает указатель на объект, тот же, что ей передали в скрытом параметре. Это уже лишнее действие по сути. Но присвоение регистра — это не сильно затратная операция.
У вышеописанного поведения есть ограничения. У функции func() должен быть только один return, и др. См. статью. Если объект будет сложным (у его мемберов будут деструкторы или у объекта будет деструктор), тогда произойдет вызов оператора копирования и вызов деструктора. И операция обойдется дороже. Однако, если возвращается структура содержащая простые типы без деструкторов, тогда копирования делаться не будет. Из чтения статьи на wiki по описанному вопросу можно почерпнуть дополнительную информацию.

Еще один пример.
Очень часто требуется писать функции, которые принимают структуры в качестве аргумента или возвращают структуру. Например, если вам надо написать небольшую космическую армаду, вам может понадобится функция для инициализации нового противника:

struct EnemySpaceShip {
    int x_coordinate;
    int y_coordinate;
    int weapon_power;
};
EnemySpaceShip getNewEnemy();

Функция getNewEnemy должна возвращать структуру с инициализированными полями:

EnemySpaceShip getNewEnemy() {
    EnemySpaceShip ship;
    ship.x_coordinate = 0;
    ship.y_coordinate = 0;
    ship.weapon_power = 20;
    return ship;
}

На самом деле эта функция вернет копию созданной локальной переменной ship. Это значит, что каждое поле структуры будет скопировано в новую переменную. В нашем случае копирование малого количества полей не заметно, но когда вы работаете с большими объемами данных нужно избегать лишних действий, подробнее об этом поговорим в статье про указатели.
Таким образом, для получения новой переменной будем использовать следующий код:

    EnemySpaceShip enemy = getNewEnemy();

Теперь эту переменную можно использовать как обычную структуру.
Передавать структуры в функцию можно так:

EnemySpaceShip upgradeWeapons(EnemySpaceShip ship) {
    ship.weapon_power += 10;
    return ship;
}

Когда мы передаем структуру в функцию, она копируется, так же как и при возвращении структуры. Поэтому любые изменения сделанные внутри функции будут потеряны, поэтому мы возвращаем структуру после изменения.
Использование функции:

ship = upgradeWeapons(ship);

Когда вызывается функция, переменная ship копируется и изменяется в функции, а когда переменная возвращается, она снова копируется и перезаписывает поля оргинальной переменной.
И наконец, программа для создания и улучшения одного корабля:

#include <stdio.h>
#include <iostream>

struct EnemySpaceShip {
    int x_coordinate;
    int y_coordinate;
    int weapon_power;
};
 
EnemySpaceShip getNewEnemy() {
    EnemySpaceShip ship;
    ship.x_coordinate = 0;
    ship.y_coordinate = 0;
    ship.weapon_power = 20;
    return ship;
}
 
EnemySpaceShip upgradeWeapons(EnemySpaceShip ship) {
    ship.weapon_power += 10;
    return ship;
}
 
int main() {
    EnemySpaceShip enemy = getNewEnemy();
	printf("%d\n", enemy.x_coordinate);
	printf("%d\n", enemy.y_coordinate);
	printf("%d\n\n", enemy.weapon_power);

    enemy = upgradeWeapons(enemy);

	printf("%d\n", enemy.x_coordinate);
	printf("%d\n", enemy.y_coordinate);
	printf("%d\n", enemy.weapon_power);

	system("PAUSE");
	return 0;
}




        18.6. Структуры и битовые поля.
При описании полей структуры в явном виде можно указывать размер полей. Минимальный размер поля структуры – один бит. Общий синтаксис объявления структуры с явным указанием размеров полей имеет вид:

struct имя{
	тип_поля1 имя_поля1: размер1;
	тип_поля2 имя_поля2: размер2;
	...
	тип_поляN имя_поляN: размерN;
};

При этом для части полей можно указывать размер, а для других – нет. Если поле имеет размер в один бит, в качестве его типа указывается unsigned (у числа, реализованного с помощью одного бита, не может быть знака). Пример использования структуры с явно указанным размером полей приведен в листинге

#include <iostream>
using namespace std;
struct BitFields{
	unsigned int state:1;
	int n:2;
	int m;
} str;

int main(){
	cout<<"Enter a number: ";
	cin>>str.m;
	str.state=str.m%2;
	str.n=str.m%4-2;
	cout<<"state = "<<str.state<<endl;
	cout<<"n ="<<str.n<<endl;
	getchar();getchar();
	return 0;
}



У структуры BitFields три поля: однобитовое целочисленное поле state, двухбитовое целочисленное поле n и целочисленное поле m (размер поля не указан).
Поле state может принимать всего два значения: 0 или 1. Поле n принимает целочисленные значения в диапазоне от -2 до 1 включительно, т.е. всего 4 возможных значения: напомним, что старший бит определяет знак числа, поэтому двухбитовое число 11 соответствует числу -2, двухбитовое число 10 соответствует числу -1, число 00 соответствует нулю и число 01 соответствует числу 1.
В главном методе программы выводится запрос на ввод пользователем целого числа. Это число записывается в поле m переменной str структуры BitFields. В переменную state заносится остаток от деления этого числа на 2, а в переменную n записывается остаток от деления введенного пользователем числа на 4 минус 2. Значения полей переменной str структуры BitFields выводятся на экран. В результате можем получить нечто наподобие следующего:

Enter a number: 9
state = 1
n = -1

Таким образом, путем явного указания размеров полей структуры удалось добиться экономии системных ресурсов: для записи значений используется минимально необходимое количество бит. Возникает естественный вопрос: а что будет, если присваиваемое битовому полю (т.е. полю, для которого явно указан размер) значение, выходит за допустимые для этого поля пределы? Например, что будет, если полю n значение присваивать с по мощью команды str.n=str.m%4-4? Ответ такой: в указанных случаях происходит автоматическое отбрасывание лишних бит. В частности, если поле m равно 9, а поле n определяется как str.n=str.m%4-4, то этому полю будет присвоено значение 1. Поясним это. Так, остаток от деления 9 на 4 есть 1. Если отнять 4, получим -3. В двоичном представлении число -3 имеет вид (последние три бита, все старшие биты равны 1) 101. Старшие биты отбрасываются, и в результате в двухбитовом представлении получаем 01, что соответствует числу 1.

В С и C++ имеется возможность доступа к отдельным разрядам (битам) в некотором более крупном типе данных, например, в байте. Это полезно, к примеру, для изменения масок, используемых для системных целей и графики. Возможность доступа к разрядам строится на основе структур С и C++.
Рассмотрим для примера информацию, необходимую для изменения регистра статуса клавиатуры компьютера. Этот регистр в компьютерах IBM содержит следующую информацию:

	биты регистра
Статус клавиатуры:	76543210
Порт(417h)

где
bit 0 = RIGHT SHIFT не нажат (1)
bit 1 = LEFT SHIFT не нажат (1)
bit 2 = CTRL не нажат (1)
bit 3 = ALT не нажат (1)
bit 4 = SCROLL LOCK активен (1)
bit 5 = NUM LOCK активен (1)
bit 6 = CAPS LOCK активен (1)
bit 7 = INS активен (1)

Для доступа и управления этими данными можно создать структуру следующего вида:

struct stkeybits {
	unsigned char
		ucrshift: 1,	/* младший разряд */
		uclshift: 1,
		ucctrl: 1,
		ucalt: 1,
		ucscroll: 1,
		ucnumlock: 1,
		uccaplock: 1,
		ucinsert: 1;	/* старший разряд */
} stkey_register;


Биты в структуре начинаются с младшего и заканчиваются старшим. Можно указывать несколько битов, задавая их количество (вместо 1). В битовых полях можно использовать только целочисленные типы.
Обращение к элементам структуры битовых полей выполняется как обычно.

        18.7. Структуры. Их дальнейшее использование.
Мы не будем больше рассказывать о структурах, но хотелось бы отметить одно очень важное использование структур: создание новых типов данных. Пользователи компьютеров разработали новые типы данных, гораздо более эффективные для определенных задач, чем массивы и простые структуры, которые мы описали.
Эти типы имеют такие названия, как очереди, двоичные деревья, неупорядоченные массивы, рандомизированные таблицы и графы. Многие из этих типов создаются из «связанных» структур. Обычно каждая структура будет содержать один или два типа данных плюс один или два указателя на другие структуры такого же типа. Указатели служат для связи одной структуры с другой и для обеспечения пути, позволяющего вам вести поиск по всей структуре. Например, на рисунке показано двоичное дерево, в котором каждая отдельная структура (или «узел») связана с двумя, расположенными ниже.



Является ли эта разветвленная конструкция более эффективной чем массив? Рассмотрим случай дерева с 10 уровнями узлов. Если вы составите его, то найдете 1023 узла, в которых вы можете запомнить, скажем, 1023 слова. Если слова упорядочены, согласно некоторому разумному плану, вы можете начать с верхнего уровня и находить любое слово в лучшем случае за 9 перемещений, если ваш поиск идет сверху вниз с одного уровня на следующий. Если слова находятся в массиве, вам, может быть, придется перебрать все 1023 элемента, прежде чем вы найдете нужное слово.
Когда вас интересуют более прогрессивные структуры данных, обратитесь к литературе по вычислительной технике. Используя структуры языка Си, вы сможете создавать типы, о которых вы прочитали.
Это наше последнее слово о структурах. Далее мы хотим вкратце ознакомить вас с двумя другими средствами языка Си для работы с данными: объединением и функцией typedef.

        18.8. Объединения.
Объединение — еще один тип данных, который можно использовать различными способами. К примеру, некоторое объединение может рассматриваться как целое значение при выполнении одной операции и как число с плавающей точкой или двойной точности — при выполнении другой. По виду объединения напоминают структуры; однако, они сильно отличаются. Объединение, так же как и структура, может содержать несколько различных типов данных. Однако в объединении эти данные занимают одну и ту же область памяти! Таким образом, в отдельный момент времени объединение может хранить информацию только об одном типе данных. Во многих других языках высокого уровня данное языковое средство называется "записью с вариантами" (variant record).

            4.1.2. Объединения: синтаксис и правила.
В C++ имеется особая конструкция, объявление которой напоминает синтаксис объявления структуры, но имеющая совершенно другой физический смысл. Речь идет об объединениях (иногда называются союзами).
Объединение — это средство, позволяющее запоминать данные различных типов в одном и том же месте памяти. Типичным использованием его было бы создание таблицы, содержащей смесь типов в некотором порядке, который не является постоянным и не известен заранее. Объединение позволяет создавать массив, состоящий из элементов одинакового размера, каждый из которых может содержать различные типы данных.
Объединения устанавливаются таким же способом, как и структуры. Есть шаблон объединения и переменные объединения. Они могут определяться одновременно или, если используется имя объединения, последовательно за два шага.
Объединение служит для размещения в одной и той же области памяти (по одному и тому же адресу) данных различных типов. Очевидно, что в отдельный момент времени в памяти может находиться только один из указанных при объявлении объединения типов.
Объединение создается при помощи ключевого слова union и с использованием следующего синтаксиса:

union поле_тега {
	тип поле1;
	тип поле2;
	тип поле3;
	...
	…
	…
	тип полеN;
};

Объявление объединения начинается с ключевого слова union, за которым следует идентификатор и блок описания элементов различного типа, например:

union MyData
{
int iVar1;
unsigned long ulFreq;
char Symb[10];
}

При этом в памяти компилятором резервируется место для размещения самого большого элемента объединения, в данном случае - 10 байт под символьный массив. Чаше всего объединения включают в состав структур, а также служат для преобразования данных одного типа в другой. Доступ к элементам объединения производится с помощью операции 'точка' (.). Ниже приводится пример такого объединения.
В отличие от структур, переменная типа объединения может быть проинициализирована только значением первого объявленного члена (в данном случае - целочисленной переменной iVar1):

union MyData
{
int iVar1;
unsigned long ulFreq;
char Symb[10];
} myX = {25};

Обратите внимание на сходство синтаксисов объявлений структур и объединений в следующем примере:

union unmany_types {
	char с;
	int ivalue;
	float fvalue;
	double dvalue;
} unmy_union;

Объединение описывается при помощи ключевого слова union, за которым следует необязательное поле тега unmany_types. Поле тега объединения используется так же, как поле тега структуры. Данное объединение содержит несколько элементов: символ, целое число, число с плавающей точкой и число двойной точности. В отдельный момент времени это объединение позволяет хранить в unmany_types информацию только об одном типе данных.
С объединением связана переменная unmy_union. Если этот оператор расположен в функции, то область действия данного объединения является локальной для функции. Если оператор расположен за пределами всех функций, то область действия объединения — глобальная.
Подобно структурам, с одним объединением можно связать несколько переменных; можно также обращаться к членам объединения при помощи операции "точка" (.). Синтаксис очень простой:

unname.mname

В этой записи unname является переменной, связанной с типом объединения, а mname — имя любого элемента объединения.
Вот пример шаблона с именем объединения:

union holders {
				int digit;
				double bigfl;
				char letter;
};

А вот пример определения переменных объединения типа holdem:

union holdem fit; /* переменная объединения типа holdem */
union holdem save[10]; /* массив из 10 переменных объединения */
union holdem *pu; /* указатель на переменную типа holdem */

Первое описание создает одну переменную fit. Компилятор выделяет достаточно памяти для размещения самой большой из описанных переменных. В этом случае наибольшей из возможных является переменная double, для которой требуется в нашей системе 64 разряда или 8 байтов. Массив save имел бы 10 элементов, каждый по 8 байтов.
Вот как используется объединение:

fit.digit = 23; /* 23 записывается в fit; используется 2 байта */
fit.double = 2.0; /* 23 стирается, 2.0 записывается; используется 8 байтов */
fit.letter = 'h' ; /* 2.0 стирается, h записывается; используется 1 байт */

Вы применяете операцию получения элемента, чтобы показать, какие типы данных используются. В каждый момент времени запоминается только одно значение; нельзя записать char и int одновременно, даже если для этого достаточно памяти.
Вы сами должны следить за типом данных, записываемых в данный момент в объединение; приведенная ниже последовательность операторов показывает, что нельзя делать:

fit.letter = 'A';
flnum = 3.02*fit.double; /* ОШИБКА ОШИБКА ОШИБКА */

Ошибка заключается в том, что записано значение типа char, a следующая строка предполагает, что содержимое fit имеет тип double.
Можно использовать операцию —> с объединениями таким же образом, как это делалось для структур:

pu = &fit;
х = pu->digit; /* то же, что и х = fit.digit */

В качестве примера рассмотрим использование объединений и структур для неявного преобразования данных, представленных в десятичном формате, в двоично-десятичный код. Как известно, двоично-десятичные данные представляют собой разновидность упакованных значений, в которых для представления для представления десятичной цифры используется одна тетрада (четыре бита). Таким образом, двоично-десятичное число может принимать значения от 0х00 до 0х99 или в десятичном виде - от 0 до 153. Для решения поставленной задачи сконструируем объединение BCD, содержащее однобайтный член. В качестве другого элемента объединения создадим однобайтную структуру с применением битовых полей:

#include <iostream>
using namespace std;

union BCD
{
	unsigned char data;
	struct{
		unsigned char lo : 4;
		unsigned char hi : 4;
	} bin;
} bed;

int main()
{
	setlocale(LC_ALL, "Rus");
	bed.data = 152;
	cout << "\nHigh: " << (int) bed.bin.hi;
	cout << "\nLow : " << (int) bed.bin.lo;

	getchar(); 	getchar();
	return 0;
}

В теле функции main () производится инициализация двоично-десятичной переменной bed двоичным значением 152 с последующим ее разложением на старший и младший полубайт.




            4.1.3. Создание простого объединения.
Для того чтобы проиллюстрировать некоторые концепции объединений, в следующей программе на C++ создается объединение рассмотренного выше типа. Цель этого примера — показать, что объединение может содержать различные типы данных, но в конкретный момент времени оно содержит значение только для одного типа.

// Программа на C++, иллюстрирующая использование объединения.
// Создается объединение, содержащее несколько типов данных
#include <iostream.h>
union unmany_types {
	char c;
	int ivalue;
	float fvalue;
	double dvalue, j;
} unmy_union;

int main(void)
{
	// valid I/O
	unmy_union.c='b';
	cout << unmy_union.c << "\n";

	unmy_union.ivalue=1990;
	cout << unmy_union.ivalue << "\n";

	unmy_union.fvalue=19.90;
	cout << unmy_union.fvalue << "\n";

	unmy_union.dvalue=987654.32E+13;
	cout << unmy_union.dvalue << "\n";

	// неправильный ввод/вывод
	cout << unmy_union.c << "\n";
	cout << unmy_union. ivalue << "\n";
	cout << unmy_union.fvalue << "\n";
	cout << unmy_union.dvalue << "\n";
	// размер объединения
	cout << "The size of this union is: "<< sizeof(unmany_types) <<" bytes." << "\n";
	return (0);
}

Сначала программа просто вводит и распечатывает информацию из объединения. Эта часть работает, поскольку вызываемое объединение хранит в каждый момент времени только один тип данных. Однако во второй части программы делается попытка вывести каждый тип, существующий в объединении. Единственным верным значением будет число двойной точности, поскольку оно было последним значением, записанным в предыдущей части программы.



Объединения занимают память, необходимую для самого большого типа данных, хранящегося в них. Все другие типы данных в объединении используют совместно часть этой памяти или всю эту память.
При помощи встроенного отладчика вы можете посмотреть, что происходит с памятью внутри объединения.

        18.9. Вспомогательные средства.
Необходимо упомянуть еще две темы: объявления typedef и перечисляемые типы enum. При правильном использовании оба средства, typedef и enum, упрощают текст программы.

            4.1.4. Использование typedef.
Помимо структур и объединений разработчик программного обеспечения на C++ имеет возможность моделирования новых типов данных на базе уже имеющихся в его распоряжении типов. Формирование пользовательских типов осуществляется с использованием ключевого слова typedef, за которым указывается какой-либо из имеющихся типов данных и следующий за ним идентификатор, назначающий новое имя для выбранного типа. Фактически, таким образом, определяется синоним типа данных. Например, выражение

typedef unsigned char byte;

определяет новый тип данных byte, суть которого такая же, как и типа unsigned char. Следовательно, в программе возможно определение переменных типа byte, которые в памяти будут занимать один байт и смогут принимать значения от 0 до 255, например:

byte nlnput = 0xFF;
byte nOutput = 0;

Синтаксис объявления пользовательского типа для массива выглядит следующим образом:

typedef char Names[27];

В этом случае объявление переменной типа Names

Names name;

будет означать, что такая переменная представляет собой строку из 27-ми символов.
Наиболее часто переопределение типов данных используется совместно со структурами. Благодаря этому становится возможным создание новых типов данных, характерных для сложных объектов, объединяющих разнотипные характеристики. Например, создадим тип данных COORD, объекты которого будут нести информацию о трех координатах в пространстве:

typedef struct
{
double x;
double у;
double z;
} COORD;

Теперь можно объявить объект myPoint типа COORD:

COORD myPoint;

и обращаться к элементам так, если бы он был объявлен как соответствующая структура:

myPoint.x = 5.654;
myPoint.y = 0;
myPoint.z = 3.14;

При помощи typedef вы можете связать новые типы данных с существующими. К примеру, в математической программе может возникнуть необходимость в использовании типов данных fixed, whole, real или complex. Используя typedef, можно связать эти новые типы со стандартными типами С. В следующей программе создаются два новых типа:

/* Программа на С, иллюстрирующая использование typedef.
Создаются два новых типа, "whole" и "real",
которые можно использовать вместо "int" и "float" */
#include <stdio.h>
typedef int whole;
typedef float real;
int main(void)
{
	whole wvalue=123;
	real rvalue=5.6789;
	/* Целое число */
	printf("The whole number is %d.\n",wvalue);
	/* Вещественное число */
	printf("The real number is %.4f.\n",rvalue);
	return (0);
}



Будьте внимательны и не используйте слишком много новых типов; это может вызвать обратный эффект и ухудшить читаемость программы и усложнить ее. Используйте typedef с осторожностью.
Объявление typedef можно использовать для упрощения объявлений. Взгляните на два следующих примера; сможете ли вы заметить небольшое отличие, вызванное применением ключевого слова typedef:

struct stboat {
	char sztype [iSTRING15 + iNULL_CHAR];
	char szmodel[iSTRING15 + iNULL_CHAR];
	char sztitle[iSTRING20 + iNULL_CHAR];
	int iyear;
	long int lmotor_hours;
	float fsaleprice;
} stused_boat;

typedef struct {
	char sztype [iSTRING15 + iNULL_CHAR];
	char szmodel[iSTRING15 + iNULL_CHAR];
	char sztitle[iSTRING20 + iNULL_CHAR];
	int iyear;
	long int lmotor_hours;
	float fsaleprice;
} STBOAT;

Имеют место три главных отличия:
    • Исчезло необязательное поле тега. (Хотя поле тега вместе с typedef можно использовать по-прежнему; просто оно избыточно.)
    • Поле тега stboat превратилось в новый тип STBOAT и располагается там, где традиционно описывалась структурная переменная.
    • Объявление переменной stused_boat теперь отсутствует.

Достоинство описаний typedef — в способе их использования. После приведенного описания по всей программе можно описывать переменные типа STBOAT при помощи более простой синтаксической конструкции:

STBOAT STused_boat;

Синтаксически, использование заглавных букв в компиляторах C/C++ не обязательно; они, однако, подчеркивают важное соглашение, принятое в программе. Во всех возможных файлах, где объявляются идентификаторы, программисты на С традиционно используют заглавные буквы для описаний новых типов, констант, перечисляемых значений и макросов, определяемых обычно в заголовочном файле. Видимое различие между ключевыми словами, записываемыми строчными буквами, и пользовательскими идентификаторами, записываемыми заглавными буквами, позволяет быстрее понимать текст программы, поскольку заглавные буквы обычно означают: "Ищите это объявление в другом файле".
Функция typedef позволяет нам создать свое собственное имя типа. Это напоминает директиву #define, но со следующими тремя изменениями:
    1. В отличие от #define функция typedef дает символические имена, но ограничивается только типами данных.
    2. Функция typedef выполняется компилятором, а не препроцессором.
    3. В своих пределах функция typedef более гибка, чем #define.

Посмотрим, как она работает. Предположим, вы хотите использовать термин real для чисел типа float. Тогда вы определяете термин real, как если бы он был переменной типа float, и перед его определением ставите ключевое слово typedef:

typedef float real;

С этого момента вы можете использовать real для определения переменных:

real х, у[25], *рг;

Область действия такого определения зависит от расположения оператора typedef. Если определение находится внутри функции, то область действия локальна и ограничена этой функцией. Если определение расположено вне функции, то область действия глобальна.
Часто в этих определениях используются прописные буквы, чтобы напомнить пользователю, что имя типа является на самом деле символической аббревиатурой:

typedef float REAL;

В последнем примере можно было бы применить директиву #define. А здесь это делать нельзя:

typedef char *STRING;

Без ключевого слова typedef оператор определял бы STRING как указатель на тип char. С ключевым словом оператор делает STRING идентификатором указателей на тип char. Так,

STRING name, sign;

означает

char "name, *sign; 

Мы можем использовать typedef и для структур. Вот пример:

typedef struct COMPLEX {
						float real;
						float imag;
}

Кроме того, можно использовать тип COMPLEX для представления комплексных чисел.
Одна из причин использования typedef заключается в создании удобных, распознаваемых имен для часто встречающихся типов. Например, многие пользователи предпочитают применять STRING или его эквивалент, как это мы делали выше.
Вторая причина: имена typedef часто используются для сложных типов. Например, описание

typedef char *FRPTC () [5];

приводит к тому, что FRPTC объявляет тип, являющийся функцией, которая возвращает указатель на пятиэлементный массив типа Char.
Третья причина использования typedef заключается в том, чтобы сделать программы более мобильными. Предположим, например, что вашей программе нужно использовать 16-разрядные числа. В некоторых системах это был бы тип short, в других же он может быть типом int. Если вы использовали в ваших описаниях short или int, то должны изменить все описания, когда перейдете от одной системы к другой. Вместо этого сделайте следующее. В файле директивы #include есть такое определение:

typedef short TWOBYTE;

Используйте TWOBYTE в ваших программах для переменных типа short, которые должны быть 16-разрядными. Тогда если вы перемещаете программу туда, где необходимо использовать тип int, то следует только изменить одно определение в вашем файле директивы #include:

typedef int TWOBYTE;

Это пример того, что делает язык Си столь мобильным. При использовании typedef следует иметь в виду, что он не создает новых типов, он только создает удобные метки.

            4.1.5. Использование enum.
Перечисляемый тип данных enum имеет единственное назначение — сделать текст программы более читаемым. В других компьютерных языках этот тип называется пользовательским, есть определяемым пользователем. В общем, объявление перечисляемого типа выглядит так:

enum поле_тега { значение1,. . .значениеN } переменная;

Как вы уже, наверное, догадались — необязательное поле тега (op_tag_field) аналогично тому, что используется при объявлении структуры. Если это поле опускается, то после закрывающей фигурной скобки необходимо указать переменную (или переменные). При использовании поля тега можно объявлять в программе другие переменные такого же типа; при этом в C++ необязательно повторять ключевое слово enum.
Перечисляемые типы данных позволяют связать в единый тип легко понятные мнемонические идентификаторы: например, Понедельник, Вторник, Среда и так далее. Это помогает созданию самодокументирующегося текста программы. К примеру, вместо цикла, пробегающего значения от 0 до 4, можно написать цикл, имеющий диапазон от Понедельника до Пятницы (Monday — Friday):

enum eweekdays { Monday, Tuesday, Wednesday, Thursday, Friday };
/* Объявление переменной типа enum в С */
enum eweekdays ewToday;
/* To же объявление в C++ */
eweekdays ewToday;
/* Без перечисляемого типа */
for(i = 0; i <= 4; i++)
…
…
…
/* С использованием перечисляемого типа */
for(ewToday = Monday; ewToday <= Friday; ewToday++)

Как исторически сложилось, компиляторы С не делают различия между типами int и enum. Это означает, что программа может присвоить целое значение перечисляемому типу. При отсутствии явного приведения типа в C++ компилятор в подобной ситуации генерирует предупреждение:

/* Допустимо в С; недопустимо в C++ */
ewToday = 1;
/* Решение проблемы в C++ */
ewToday = (eweekdays)1;

Тип enum очень часто используется в программировании, когда информацию можно представить списком целых значений, подобных номерам месяцев в году или номерам дней недели. Такой список уже является перечислением.
В следующем примере имеется список всех месяцев в году. Они представляют собой перечисляемый список с тегом emonths. Co списком связана переменная emcompleted. Перечисляемые списки всегда начинаются с нуля (если не задано другого целого значения). В приведенном примере Январь (January) — первый месяц в году.

/* Программа на С, иллюстрирующая использование перечисляемых типов.
Программа определяет количество прошедших и остающихся месяцев
в году при помощи типа enum */
#include <stdio.h>
enum emonths {
	January=1,
	February,
	March,
	April,
	May,
	June,
	July,
	August,
	September,
	October,
	November,
	December
} emcompleted;

int main(void)
{
	int ipresent_month;
	int isum,idiff;
	/* Введите, пожалуйста, текущий месяц (от 1 до 12): */
	printf("\nPlease enter the present month (1 to 12): ");
	scanf("%d",&ipresent_month);
	emcompleted = December;
	isum = ipresent_month;
	idiff = (int)emcompleted - ipresent_month;
	/* ... месяцев прошло, ... месяцев остается. */
	printf("\n%d month(s) past, %d months to go.\n",isum,idiff);
	return (0);
}



В данной программе перечисляемый список — это список целых значений от 1 до 12. Поскольку имена эквивалентны последовательным целым значениям, то с ними можно выполнять целочисленные арифметические операции. Фактически, когда перечисляемой переменной emcompleted присваивается значение December, она становится равной 12.
Приведенная программа выполняет некоторые простые арифметические действия и выводит на экран следующий результат:

Please enter the current month (1 to 12) : 4
4 month(s) past, 8 months to go.

        18.10. Сложные формы данных.
Язык Си позволяет вам создавать сложные формы данных. Обычно мы придерживаемся более простых форм, но считаем своим долгом указать на потенциальные возможности языка. При создании описания мы используем имя (или «идентификатор»), которое можно изменять при помощи модификатора:
модификатор	значение
*	указатель
()	функция
[]	массив

Язык Си позволяет использовать одновременно более одного модификатора, что дает возможность создавать множество типов:

int board[8] [8];		/* массив массивов типа int */
int **ptr;				/* указатель на указатель на тип int */
int *risks[10];		/* 10-элементный массив указателей на тип int */
int (*wisks) [10];		/* указатель на 10-элементный массив типа int */
int *oof[3] [4];		/* 3-элементный массив указателей на 4-элементный массив типа int */
int (*uuf) [3] [4];		/* указатель на массив 3x4 типа int */

Для распутывания этих описаний нужно понять, в каком порядке следует применять модификаторы. Три правила помогут вам справиться с этим.
    1. Чем ближе модификатор стоит к идентификатору, тем выше его приоритет
    2. Модификаторы [] и () имеют приоритет выше, чем *.
    3. Круглые скобки используются для объединения частей выражения, имеющих самый высокий приоритет.

Давайте применим эти правила к описанию

int *oof[3] [4];

* и [3] примыкают к oof и имеют более высокий приоритет, чем [4] (правило 1). [3] имеет приоритет более высокий, чем * (правило 2). Следовательно, oof является 3-элементным массивом (первый модификатор) указателей (второй модификатор) на 4-элементный массив (третий модификатор) типа int (описание типа).
В описании

int (*uuf)[3] [4];

скобки говорят, что модификатор * должен иметь первый приоритет, а это делает uuf указателем, как показано в предыдущем описании.
Эти правила создают также следующие типы:

char *fump();		/* функция, возвращающая указатель на тип char */
char (*frump)();		/* указатель на функцию, возвращающую тип char */
char *flump() [3]	/* функция, возвращающая указатель на 3-элементный массив типа char */
char *flimp[3] ()		/* 3-элементный массив указателей на функцию, которая возвращает тип char */

Если вы примените структуры к этим примерам, то увидите, что возможности для описаний действительно растут причудливо. А применение ... так и быть, мы оставим для более опытных программистов.
Язык Си со структурами, объединениями и typedef дает нам средства для эффективной и мобильной обработки данных.
По окончанию этого материала вы готовы приступить к изучению основ объектно-ориентированного программирования.

        18.11. Отличие stract от class
Отличий class от struct несколько (основных всего два):
    • Member access control [class.access]
Члены класса, определенного с помощью ключевого слова class, по умолчанию являются private. Члены класса, определенного с помощью ключевого слова struct или union, по умолчанию являются public.

C имеет структуры, у него нет понятия инкапсуляции, поэтому все открыто. Публикация по умолчанию обычно считается плохой идеей при использовании объектно-ориентированного подхода, поэтому при создании формы C, которая естественным образом способствует OOP (вы можете делать OO на C, но это вам не поможет) которая была идеей в С++ (первоначально "C With Classes" ), имеет смысл сделать члены закрытыми по умолчанию.
Например, программа 1 не работает в компиляции, и программа 2 работает нормально.

// Program 1
#include <stdio.h>
class Test {
    int x; // x is private
};

int main()
{
  Test t;
  t.x = 20; // compiler error because x is private
  getchar();
  return 0;
}

//Run on IDE
// Program 2
#include <stdio.h>
struct Test {
    int x; // x is public
};

int main()
{
  Test t;
  t.x = 20; // works fine because x is public
  getchar();
  return 0;
}

В дополнение еще один пример

class A{    
public:    
    int i;      
};

class A2:A{};

struct A3:A{};

struct abc{    
    int i;
};

struct abc2:abc{};

class abc3:abc{};

int main()
{    
    abc2 objabc;
    objabc.i = 10;

    A3 ob;
    ob.i = 10;

    //A2 obja; //privately inherited
    //obja.i = 10;

    //abc3 obss;
    //obss.i = 10;
}

    • Accessibility of base classes and base class members [class.access.base]
При отсутствии спецификатора доступа (т.е. private/protected/public) у базового класса, базовый класс будет public если класс определен с помощью struct и private если класс определен с помощью class.
(Хотя union и является классом, он имеет много других отличий от class и struct.)

// Program 3
#include <stdio.h>

class Base {
public:
    int x;
};

class Derived : Base { }; // is equilalent to class Derived : private Base {}

int main()
{
  Derived d;
  d.x = 20; // compiler error becuase inheritance is private
  getchar();
  return 0;
}

//Run on IDE
// Program 4
#include <stdio.h>

class Base {
public:
    int x;
};

struct Derived : Base { }; // is equilalent to struct Derived : public Base {}

int main()
{
  Derived d;
  d.x = 20; // works fine becuase inheritance is public
  getchar();
  return 0;
}

    • отличие между структурами и классами, связанное с инициализацией по умолчанию.

struct Foo {
    int a;
};

class Bar {
    int a;
};

class Tester {
    Foo m_Foo = Foo();
    Bar m_Bar = Bar();

public:
    Tester() {}
};

int main() {
    auto myTester = Tester();
}

Запустите этот код и проверьте myTester. Вы обнаружите, что для m_Foo структура, m_Foo.a была инициализирована на 0, но для m_Bar класс m_Bar.a не инициализирован. Таким образом, существует разница в том, что делает конструктор по умолчанию для struct vs. class. Я вижу это с помощью Visual Studio.

Итак. Существует 3 основных различия между структурой и классом.
1St-память зарезервирована для структуры в стеке памяти (которая близка к языку программирования), независимо от того, зарезервированы ли для памяти класса в стеке только референт, а фактическая память зарезервирована в кучевой памяти.
2Nd. По умолчанию структура рассматривается как публикация, рассматриваемая классом как частная.
3Rd- не может повторно использовать код в структуре, но в классе мы можем повторно использовать один и тот же код за много времени, называемый inhertence

Использование
Есть популярное мнение, что для "расово правильных ООП классов" надо использовать только class, а для структур данных - только struct, и еще у struct не должно быть методов. Это не более чем вкусовщина, и подобные вещи должны быть закреплены в руководствах по стилю кодирования, как например это сделано в Google C++ Style Guide.
STRUCT - это тип абстрактного типа данных, который делит данный кусок памяти в соответствии со спецификацией структуры. Структуры особенно полезны при сериализации файлов/десериализации, поскольку структуру часто можно записать в файл дословно. (т.е. получить указатель на структуру, использовать макрос SIZE для вычисления количества байтов для копирования, а затем переместить данные в или из структуры.)
Классы - это другой тип абстрактных типов данных, которые пытаются обеспечить скрытие информации. Внутри могут быть различные махинации, методы, временные переменные, переменные состояния. и т.д., которые все используются для представления согласованного API для любого кода, который хочет использовать класс.
По сути, структуры относятся к данным, классы относятся к коду.
Однако вам нужно понять, что это просто абстракции. Совершенно возможно создавать структуры, которые очень похожи на классы и классы, которые очень похожи на структуры. На самом деле, самые ранние компиляторы С++ были просто предварительными компиляторами, которые переводили код С++ в C. Таким образом, эти абстракции являются преимуществом для логического мышления, не обязательно являющегося активом для самого компьютера.
Помимо того, что каждый из них представляет собой другой тип абстракции, классы обеспечивают решения головоломки с именованием кода C. Поскольку у вас не может быть более одной функции, открытой с тем же именем, разработчики использовали шаблон _(). например mathlibextreme_max(). Сгруппировав API в классы, подобные функции (здесь мы называем их "методами" ) могут быть сгруппированы вместе и защищены от именования методов в других классах. Это позволяет программисту лучше организовать свой код и увеличить повторное использование кода. Теоретически, по крайней мере.

        18.12. Функции работы с датой и временем.
Функции и типы данных, необходимые для работы с датой и временем объявлены в заголовочном файле time.h. В частности, этот файл содержит определения типа данных time_t:

typedef long time_t;

и структуры tm, которая объявлена следующим образом:

struct tm
{
int tm_sec; // секунды
int tm_min; // минуты
int tm_hour; // часы (0-23)
int tm_mday; // дата (1-31)
int tm mon; // месяц (0-11)
// год (текущий год минус 1900)
int tm_year;
// день недели (0-6; Воскр = 0)
int tm wday;
int tm_yday; // день в году (0-365)
int tm_isdst; // 0 если зимнее время
}

Ниже приводится таблица 9.1, обобщающая часть объявленных функций с кратким описанием их работы.

Таблица 9.1.
Функции работы с датой и временем

Наименование
Краткое описание
asctime
преобразует время и дату из формата структуры типа tm в символьную строку
clock
возвращает 'гасло "тиков" процессора, прошедших от начала запущенного процесса
ctime
преобразует время и дату из формата time t в символьную строку
difftime
вычисляет интервал между двумя заданными временными параметрами
gmtime
преобразует дату и время из формата time t в формат структуры tm по Гринвичу (GMT)
localtime
преобразует дату и время из формата time t в формат структуры tm
mktime
преобразует дату и время в календарный формат
strdate
преобразует текущую дату в символьную строку в формате mm/dd/yy
strftime
форматирует время для последующего вывода
strtime
возвращает текущее системное время в виде символьной строки
time
возвращает время в секундах, прошедшее с полуночи (0 часов 0 минут 0 секунд) 1 января 1970 г. по Гринвичу
tzset
устанавливает значения глобальных переменных daylight, _timezone, и tzname

В качестве обобщающего примера рассмотрим программу работы с датой и временем:

#include <time.h>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, "Rus");
	time_t tt;
	tm *pMyTime;
	tt = time(NULL);
	pMyTime = localtime(&tt);
	cout << "Текущее время: ";
	cout << asctime(pMyTime);

	getchar(); 	getchar();
	return 0;
}

В рассматриваемом примере используется функция time (), имеющая прототип

time_t time(time_t *timer);



возвращающая число секунд, прошедших с 00:00:00 1 января 1970 г. Параметр timer также принимает возвращаемое функцией значение. Для более удобной работы с датой и временем полученные данные преобразуются функцией local time() к формату структуры tm. Применение функции asctime () позволяет вывести полученную таким образом информацию в виде строки символов.

Что вы должны были узнать.
    • Что такое структурный шаблон, и как его определять
    • Что такое имя структуры и как оно используется
    • Как определить структурную переменную: struct car honda;
    • Как обратиться к элементу структуры: honda.mpg
    • Как обратиться к указателю на структуру: struct car*ptcar;
    • Как обратиться к элементу при помощи указателя: ptcar— >mpg
    • Как передать в функцию элемент структуры: eval (honda .mpg)
    • Как сообщить функции о структуре: rate (&honda)
    • Как создать вложенную структуру
    • Как обратиться к элементу вложенной структуры: honda .civic .cost
    • Как создавать и использовать массивы структур: struct car gm [5];
    • Как создать объединение: подобно структуре
    • Как использовать typedef: typedef struct car CRATE;

Вопросы и ответы.
Вопросы.
    1. Что неправильно в этом шаблоне?

structure {
		char itible;
		int num [20];
		char *togs;
};

    2. Вот фрагмент программы; что она напечатает?

struct house {
			float sqft;
			int rooms;
			int stories;
			char *address;
};
main ()
{
static struct house fruzt = {1560.0, 6, 1, "22 Spiffo Road"};
struct house *sign;
sign = &fruzt;
printf (" %d %d\n" , fruzt.rooms, sign— >stories);
printf (" %s\n", fruzt.address);
printf (" %c %c \n" sign->address [3], fruzt.address [4]);
}

    3. Придумайте структурный шаблон, который будет содержать название месяца, трехбуквенную аббревиатуру месяца, количество дней в месяце и номер месяца.
    4. Определите массив, состоящий из двенадцати структур того же типа, что и в вопросе 3, и инициализируйте его для невисокосного года.
    5. Напишите функцию, которая получает номер месяца, а возвращает общее число дней года вплоть до этого месяца. Считайте, что структурный шаблон и массив из вопросов 3 и 4 описаны как внешние.
    6. Взяв за основу нижеследующую функцию typedef, опишите 10-элементный массив указанной структуры. Затем, используя присваивание отдельного элемента, попытайтесь описать третьим элементом массива линзу Ремаркатара с фокусным расстоянием 500 мм и апертурой f/2.0.

typedef struct { /* описатель линзы */
			float foclen; /* фокусное расстояние, мм */
			float fstop; /* апертура */
			char *brand; /* фирменная марка */
} LENS;

Ответы.
    1. Должно быть ключевое слово struct, а не structure. Шаблон требует либо имени структуры перед открывающей скобкой или имени переменной после закрывающей скобки. Кроме того, точка с запятой должна стоять после *togs и в конце шаблона.
    2. 

6 1
22 Spiffo Road
S p

Элемент fruzt.address является символьной строкой, a fruzt.address [4] является пятым элементом этого массива.
    3. 
struct month {
			char name[10|; /* или char *name; */
			char abbrev[4]; /* или char*abbrev; */
			int days;
			int monumb;
};

    4. 
struct month months[12] = {
			{ " Январь" , "Янв", 31, 1},
			{ " Февраль", " Фев", 28, 2},
			…
			и т. д.
			…
			{ " Декабрь", "Дек", 31, 12}
			};

    5. 
days (month)
int month;
{
int index, total;
if (month < 1 || month > 12)
	return (—1); /* признак ошибки */
else
	for (index = 0, total = 0; index < month; index++)
		total + = months [index]. days; return (total);
}

Заметим, что index содержит номер месяца, уменьшенный на единицу, так как массивы начинаются с индекса 0; следовательно, мы используем выражение index < month вместо index <= month.
    6. ЛИНЗА tubby [10];

tubby [2]. foclen = 300.0;
tubby [2]. fstop = 2.0;
tubby [2]. brand = " Ремаркатар" ;

Упражнения.
    1. Переделайте вопрос 5, используя в качестве аргумента написанное буквами название месяца вместо номера месяца. [Не забывайте о функции strcmp().]
    2. Напишите программу, которая запрашивает у пользователя день, месяц и год. Месяц может обозначаться номером, названием месяца или его аббревиатурой. После работы программа выдает общее количество дней в году вплоть до данного дня.
    3. Переделайте нашу программу инвентаризации книг таким образом, чтобы она печатала информацию о книгах, упорядоченную в алфавитном порядке по названиям книг, и затем печатала общую стоимость книг.

1. Динамические структуры данных
1.1. Динамические структуры данных
1.2. Линейный список
1.2.1. Создание элемента списка (CreateNode)
1.2.2. Добавление узла
1.2.2.1. Добавление узла в начало списка (AddFirst)
1.2.2.2. Добавление узла после заданного (AddAfter)
1.2.2.3. Добавление узла перед заданным (AddBefore)
1.2.2.4. Добавление узла в конец списка (AddLast)
1.2.3. Проход по списку
1.2.4. Поиск узла в списке (Find, FindPlace)
1.2.5. Алфавитно-частотный словарь
1.2.6. Удаление узла (DeleteNode)
1.3. Барьеры
1.4. Двусвязный список
1.4.1. Операции с двусвязным списком
1.4.1.1. Добавление узла в начало списка
1.4.1.2. Добавление узла в конец списка
1.4.1.3. Добавление узла после заданного
1.4.1.4. Поиск узла в списке
1.4.1.5. Удаление узла
1.5. Циклические списки
1.6. Стек
1.6.1. Реализация стека с помощью массива
1.6.2. Реализация стека с помощью списка
1.6.2.1. Добавление элемента на вершину стека
1.6.2.2. Получение верхнего элемента с вершины стека
1.6.3. Системный стек в программах
1.7. Очередь
1.7.1. Реализация очереди с помощью массива
1.7.2. Реализация очереди с помощью списка
1.7.2.1. Добавление элемента в конец очереди
1.8. Дек
1.9. Деревья
1.9.1. Основные понятия
1.9.1.1. Термины и определения
1.9.1.2. Рекурсивное определение
1.9.1.3. Двоичные деревья
1.9.2. Реализация двоичных деревьев в языке Си
1.9.2.1. Описание вершины
1.9.2.2. Деревья минимальной высоты
1.9.2.2.1. Обход дерева
1.9.3. Поиск с помощью дерева
1.9.3.1. Как быстрее искать?
1.9.3.2. Построение дерева поиска
1.9.3.3. Поиск по дереву
1.9.3.3.1. Сортировка с помощью дерева поиска
1.9.3.3.2. Поиск одинаковых элементов
1.9.4. Разбор арифметического выражения
1.9.4.1. Дерево для арифметического выражения
1.9.4.2. Формы записи арифметического выражения
1.9.4.3. Алгоритм построения дерева
1.9.4.4. Вычисление выражения по дереву
1.9.4.5. Разбор выражения со скобками
1.9.4.6. Многозначные числа и переменные
1.9.4.7. Упрощение выражения с помощью дерева
1.9.5. Дерево игр
1.10. Графы
1.10.1. Основные понятия
1.10.1.1. Определения
1.10.1.2. Описание графов
1.10.2. Задача Прима-Краскала
1.10.2.1. Формулировка задачи
1.10.2.2. Жадные алгоритмы
1.10.2.3. Решение
1.10.3. Кратчайший путь
1.10.3.1. Формулировка задачи
1.10.3.2. Алгоритм Дейкстры
1.10.3.2.1. Инициализация
1.10.3.2.2. Основной цикл
1.10.3.3. Вывод результата
1.10.3.4. Пример
1.10.3.5. Алгоритм Флойда-Уоршелла
1.10.4. Оптимальное размещение
1.10.4.1. Задача на минимум суммы
1.10.4.2. Минимаксная задача размещения
1.10.5. Задача коммивояжера
1.10.5.1. Формулировка задачи
1.10.5.2. Метод грубой силы
1.10.5.3. Метод ветвей и границ
1.10.5.4. Алгоритм Литтла
1.10.5.5. Метод случайных перестановок
1.10.6. Задача о паросочетаниях
1.10.6.1. Формулировка задачи
1.10.6.2. Достижимость вершин в графе
1.10.6.2.1. Инициализация
1.10.6.2.2. Общий шаг
1.10.6.3. Метод чередующихся цепей
1.11. Примеры динамических структур данных
1.11.1. Односвязный список
1.11.1.1. Пример #01. Односвязный список
1.11.1.2. Пример #02. Односвязный список
1.11.2. Двухсвязный список
1.11.2.1. Пример #01. Двухсвязный список
1.11.3. Стек
1.11.3.1. Cтек #01
1.11.3.2. Cтек #02
1.11.3.3. Cтек #03
1.11.3.4. Cтек #04
1.11.4. Очередь
1.11.4.1. Очередь #01
1.11.4.2. Очередь #02 с использованием шаблона
1.11.4.3. Очередь #03 с использованием шаблона
1.11.4.4. Очередь #03 с приоритетом на основе std::vector
1.11.4.5. Очередь #04 на базе массива
1.11.4.6. Очередь #05 циклическая
1.11.5. Дек
1.11.5.1. Дек #01 простой пример
1.11.6. Дерево
1.11.6.1. Дерево #01 первое знакомство
1.11.6.2. Дерево #02 простой пример
1.11.6.3. Дерево #03 копия дерева. Количество листов
1.11.6.4. Дерево #04 бинарное дерево и рекурсия
1.11.7. Граф
1.11.7.1. Граф #01 простой пример

Динамические структуры данных
http://www.apmath.spbu.ru/ru/staff/smirnovmn/files/devcpp_4.pdf

    1. Динамические структуры данных

        1.1. Динамические структуры данных
Часто в серьезных программах надо использовать данные, размер и структура которых должны меняться в процессе работы. Динамические массивы здесь не выручают, поскольку заранее нельзя сказать, сколько памяти надо выделить – это выясняется только в процессе работы. Например, надо проанализировать текст и определить, какие слова и в каком количество в нем встречаются, причем эти слова нужно расставить по алфавиту.
В таких случаях применяют данные особой структуры, которые представляют собой отдельные элементы, связанные с помощью ссылок. Каждый элемент (узел) состоит из двух областей памяти: поля данных и ссылок. Ссылки – это адреса других узлов этого же типа, с которыми данный элемент логически связан. В языке Си для организации ссылок используются переменные-указатели. При добавлении нового узла в такую структуру выделяется новый блок памяти и (с помощью ссылок) устанавливаются связи этого элемента с уже существующими. Для обозначения конечного элемента в цепи используются нулевые ссылки (NULL).




        1.2. Линейный список
В простейшем случае каждый узел содержит всего одну ссылку. Для определенности будем считать, что решается задача частотного анализа текста – определения всех слов, встречающихся в тексте и их количества. В этом случае область данных элемента включает строку (длиной не более 40 символов) и целое число.



Каждый элемент содержит также ссылку на следующий за ним элемент. У последнего в списке элемента поле ссылки содержит NULL. Чтобы не потерять список, мы должны где-то (в переменной) хранить адрес его первого узла – он называется «головой» списка. В программе надо объявить два новых типа данных – узел списка Node и указатель на него PNode. Узел представляет собой структуру, которая содержит три поля - строку, целое число и указатель на такой же узел. Правилами языка Си допускается объявление

struct Node{
	char word[40];	//область данных
	int count;
	Node *next;		//ссылка на следующий узел
};
typedef Node *PNode; //тип данных: указатель на узел

В дальнейшем мы будем считать, что указатель Head указывает на начало списка, то есть, объявлен в виде

PNode Head = NULL;

Первая буква «P» в названии типа PNode происходит от слова pointer – указатель (англ.) В начале работы в списке нет ни одного элемента, поэтому в указатель Head записывается нулевой адрес NULL.

            1.1.1. Создание элемента списка (CreateNode)
Для того, чтобы добавить узел к списку, необходимо создать его, то есть выделить память под узел и запомнить адрес выделенного блока. Будем считать, что надо добавить к списку узел, соответствующий новому слову, которое записано в переменной NewWord. Составим функцию, которая создает новый узел в памяти и возвращает его адрес. Обратите внимание, что при записи данных в узел используется обращение к полям структуры через указатель.

PNode CreateNode(char NewWord[])
{
	PNode NewNode = new Node; //указатель на новый узел
	strcpy(NewNode->word, NewWord); //записать слово
	NewNode->count = 1; //счетчик слов = 1
	NewNode->next = NULL; //следующего узла нет
	return NewNode; //результат функции – адрес узла
}

После этого узел надо добавить к списку (в начало, в конец или в середину).

            1.1.2. Добавление узла
    2. Добавление узла в начало списка (AddFirst)
При добавлении нового узла NewNode в начало списка надо
    1. установить ссылку узла NewNode на голову существующего списка и
    2. установить голову списка на новый узел.

	1)	2)



По такой схеме работает процедура AddFirst. Предполагается, что адрес начала списка хранится в Head. Важно, что здесь и далее адрес начала списка передается по ссылке, так как при добавлении нового узла он изменяется внутри процедуры.

void AddFirst(PNode &Head, PNode NewNode)
{
	// установить ссылку узла NewNode на голову существующего списка
	NewNode->next = Head;
	//установить голову списка на новый узел
	Head = NewNode;
}

    3. Добавление узла после заданного (AddAfter)
Дан адрес NewNode нового узла и адрес p одного из существующих узлов в списке. Требуется вставить в список новый узел после узла с адресом p. Эта операция выполняется в два этапа:
    1. установить ссылку нового узла на узел, следующий за данным;
    2. установить ссылку данного узла p на NewNode.

	1)	2)



Последовательность операций менять нельзя, потому что если сначала поменять ссылку у узла p, будет потерян адрес следующего узла.

void AddAfter(PNode p, PNode NewNode)
{
	//установить ссылку нового узла на узел, следующий за данным
	NewNode->next = p->next;
	//установить ссылку данного узла p на NewNode
	p->next = NewNode;
}

    4. Добавление узла перед заданным (AddBefore)
Эта схема добавления самая сложная. Проблема заключается в том, что в простейшем линейном списке (он называется односвязным, потому что связи направлены только в одну сторону) для того, чтобы получить адрес предыдущего узла, нужно пройти весь список сначала. Задача сведется либо к вставке узла в начало списка (если заданный узел – первый), либо к вставке после заданного узла.

void AddBefore(PNode &Head, PNode p, PNode NewNode)
{
	PNode q = Head;
	if (Head == p){
		AddFirst(Head, NewNode); //вставка перед первым узлом
		return;
	}
	while(q && q->next != p) //ищем узел, за которым следует p
		q = q->next;
	if(q) //если нашли такой узел,
		AddAfter(q, NewNode); //добавить новый после него
}

Такая процедура обеспечивает «защиту от дурака»: если задан узел, не присутствующий в списке, то в конце цикла указатель q равен NULL и ничего не происходит.
Существует еще один интересный прием: если надо вставить новый узел NewNode до заданного узла p, вставляют узел после этого узла, а потом выполняется обмен данными между узлами NewNode и p. Таким образом, по адресу p в самом деле будет расположен узел с новыми данными, а по адресу NewNode – с теми данными, которые были в узле p, то есть мы решили задачу.
Замечание
Этот прием не сработает, если адрес нового узла NewNode запоминается где-то в программе и потом используется, поскольку по этому адресу будут находиться другие данные.

    5. Добавление узла в конец списка (AddLast)
Для решения задачи надо сначала найти последний узел, у которого ссылка равна NULL, а затем воспользоваться процедурой вставки после заданного узла. Отдельно надо обработать случай, когда список пуст.

void AddLast(PNode &Head, PNode NewNode)
{
	PNode q = Head;
	if(Head == NULL){ //если список пуст,
		AddFirst(Head, NewNode); //вставляем первый элемент
		return;
	}
	while(q->next)
		q = q->next; //ищем последний элемент
	AddAfter(q, NewNode);
}

            5.1.1. Проход по списку
Для того, чтобы пройти весь список и сделать что-либо с каждым его элементом, надо начать с головы и, используя указатель next, продвигаться к следующему узлу.

PNode p = Head; //начали с головы списка
while( p != NULL ){ //пока не дошли до конца
	//делаем что-нибудь с узлом p
	p = p->next; //переходим к следующему узлу
}

            5.1.2. Поиск узла в списке (Find, FindPlace)
Часто требуется найти в списке нужный элемент (его адрес или данные). Надо учесть, что требуемого элемента может и не быть, тогда просмотр заканчивается при достижении конца списка. Такой подход приводит к следующему алгоритму:
    1. начать с головы списка;
    2. пока текущий элемент существует (указатель – не NULL), проверить нужное условие и перейти к следующему элементу;
    3. закончить, когда найден требуемый элемент или все элементы списка просмотрены.

Например, следующая функция ищет в списке элемент, соответствующий заданному слову (для которого поле word совпадает с заданной строкой NewWord), и возвращает его адрес или NULL, если такого узла нет.

PNode Find(PNode Head, char NewWord[])
{
	// начать с головы списка
	PNode q = Head;
	// пока текущий элемент существует (указатель – не NULL),
	//проверить нужное условие и перейти к следующему элементу
	while (q && strcmp(q->word, NewWord))
		q = q->next;
	// закончить, когда найден требуемый элемент или
	//все элементы списка просмотрены
	return q;
}

Вернемся к задаче построения алфавитно-частотного словаря. Для того, чтобы добавить новое слово в нужное место (в алфавитном порядке), требуется найти адрес узла, перед которым надо вставить новое слово. Это будет первый от начала списка узел, для которого «его» слово окажется «больше», чем новое слово. Поэтому достаточно просто изменить условие в цикле while в функции Find., учитывая, что функция strcmp возвращает «разность» первого и второго слова.

PNode FindPlace (PNode Head, char NewWord[])
{
	PNode q = Head;
	while (q && (strcmp(q->word, NewWord) > 0))
		q = q->next;
	return q;
}

Эта функция вернет адрес узла, перед которым надо вставить новое слово (когда функция strcmp вернет положительное значение), или NULL, если слово надо добавить в конец списка.

            5.1.3. Алфавитно-частотный словарь
Теперь можно полностью написать программу, которая обрабатывает файл input.txt и составляет для него алфавитно-частотный словарь в файле output.txt.

void main()
{
	setlocale(LC_ALL, "Rus");
	PNode Head = NULL, p, where;
	FILE *in, *out;
	char word[80];
	int n;
	in = fopen("input.dat", "r");
	while (1){
		n = fscanf(in, "%s", word); //читаем слово из файла
		if(n <= 0) break;
		p = Find(Head, word); //ищем слово в списке
		if(p != NULL) // если нашли слово,
			p->count ++; // увеличить счетчик
		else{
			p = CreateNode(word); // создаем новый узел
			where = FindPlace(Head, word); // ищем место
			if(!where)
				AddLast(Head, p);
			else
				AddBefore(Head, where, p);
		}
	}
	fclose(in);
	out = fopen("output.dat", "w");
	p = Head;
	while(p) { // проход по списку и вывод результатов
		fprintf(out, "%-20s\t%d\n", p->word, p->count);
		p = p->next;
	}
	fclose(out);
	system("PAUSE");
}

Вся сборка программы, файл input.dat (это сама наша программа) и выходной файл output.dat представлены ниже:

#include <iostream>
#include <string.h>
using namespace std;

struct Node{
	char word[40];	//область данных
	int count;
	Node *next;		//ссылка на следующий узел
};
typedef Node *PNode; //тип данных: указатель на узел

PNode CreateNode(char NewWord[])
{
	PNode NewNode = new Node; //указатель на новый узел
	strcpy(NewNode->word, NewWord); //записать слово
	NewNode->count = 1; //счетчик слов = 1
	NewNode->next = NULL; //следующего узла нет
	return NewNode; //результат функции – адрес узла
}

void AddFirst(PNode &Head, PNode NewNode)
{
	NewNode->next = Head;
	Head = NewNode;
}

void AddAfter(PNode p, PNode NewNode)
{
	NewNode->next = p->next;
	p->next = NewNode;
}

void AddBefore(PNode &Head, PNode p, PNode NewNode)
{
	PNode q = Head;
	if (Head == p){
		AddFirst(Head, NewNode); //вставка перед первым узлом
		return;
	}
	while(q && q->next!=p) //ищем узел, за которым следует p
		q = q->next;
	if(q) //если нашли такой узел,
		AddAfter(q, NewNode); //добавить новый после него
}

void AddLast(PNode &Head, PNode NewNode)
{
	PNode q = Head;
	if(Head == NULL){ //если список пуст,
		AddFirst(Head, NewNode); //вставляем первый элемент
		return;
	}
	while(q->next)
		q = q->next; //ищем последний элемент
	AddAfter(q, NewNode);
}

PNode Find(PNode Head, char NewWord[])
{
	PNode q = Head;
	while (q && strcmp(q->word, NewWord))
		q = q->next;
	return q;
}

PNode FindPlace (PNode Head, char NewWord[])
{
	PNode q = Head;
	while (q && (strcmp(q->word, NewWord) > 0))
		q = q->next;
	return q;
}

void main()
{
	setlocale(LC_ALL, "Rus");
	PNode Head = NULL, p, where;
	FILE *in, *out;
	char word[80];
	int n;
	in = fopen("input.dat", "r");
	while (1){
		n = fscanf(in, "%s", word); //читаем слово из файла
		if(n <= 0) break;
		p = Find(Head, word); //ищем слово в списке
		if(p != NULL) // если нашли слово,
			p->count ++; // увеличить счетчик
		else{
			p = CreateNode(word); // создаем новый узел
			where = FindPlace(Head, word); // ищем место
			if(!where)
				AddLast(Head, p);
			else
				AddBefore(Head, where, p);
		}
	}
	fclose(in);
	out = fopen("output.dat", "w");
	p = Head;
	while(p) { // проход по списку и вывод результатов
		fprintf(out, "%-20s\t%d\n", p->word, p->count);
		p = p->next;
	}
	fclose(out);
	system("PAUSE");
}





В переменной n хранится значение, которое вернула функция fscanf (количество удачно прочитанных элементов). Если это число меньше единицы (чтение прошло неудачно или закончились данные в файле), происходит выход из цикла while.
Сначала пытаемся искать это слово в списке с помощью функции Find. Если нашли – просто увеличиваем счетчик найденного узла. Если слово встретилось впервые, в памяти создается новый узел и заполняется данными. Затем с помощью функции FindPlace определяем, перед каким узлом списка надо его добавить.
Когда список готов, открываем файл для вывода и, используя стандартный проход по списку, выводим найденные слова и значения счетчиков.

            5.1.4. Удаление узла (DeleteNode)
Эта процедура также связана с поиском заданного узла по всему списку, так как нам надо поменять ссылку у предыдущего узла, а перейти к нему непосредственно невозможно. Если мы нашли узел, за которым идет удаляемый узел, надо просто переставить ссылку.



Отдельно обрабатывается случай, когда удаляется первый элемент списка. При удалении узла освобождается память, которую он занимал.
Отдельно рассматриваем случай, когда удаляется первый элемент списка. В этом случае адрес удаляемого узла совпадает с адресом головы списка Head и надо просто записать в Head адрес следующего элемента.

void DeleteNode(PNode &Head, PNode OldNode)
{
	PNode q = Head;
	if (Head == OldNode)
		Head = OldNode->next; //удаляем первый элемент
	else {
		while (q && q->next != OldNode) //ищем элемент
			q = q->next;
		if ( q == NULL ) return; //если не нашли, выход
		q->next = OldNode->next;
	}
	delete OldNode; //освобождаем память
}

        1.3. Барьеры
Вы заметили, что для рассмотренного варианта списка требуется отдельно обрабатывать граничные случаи: добавление в начало, добавление в конец, удаление одного из крайних элементов. Можно значительно упростить приведенные выше процедуры, если установить два барьера – фиктивные первый и последний элементы. Таким образом, в списке всегда есть хотя бы два элемента-барьера, а все рабочие узлы находятся между ними.

        1.4. Двусвязный список
Многие проблемы при работе с односвязным списком вызваны тем, что в них невозможно перейти к предыдущему элементу. Возникает естественная идея – хранить в памяти ссылку не только на следующий, но и на предыдущий элемент списка. Для доступа к списку используется не одна переменная-указатель, а две – ссылка на «голову» списка (Head) и на «хвост» - последний элемент (Tail).




Каждый узел содержит (кроме полезных данных) также ссылку на следующий за ним узел (поле next) и предыдущий (поле prev). Поле next у последнего элемента и поле prev у первого содержат NULL. Узел объявляется так:

struct Node
{
	char word[40]; //область данных
	int count;
	Node *next, *prev; //ссылки на соседние узлы
};
typedef Node *PNode; //тип данных «указатель на узел»

В дальнейшем мы будем считать, что указатель Head указывает на начало списка, а указатель Tail – на конец списка:

PNode Head = NULL, Tail = NULL;

Для пустого списка оба указателя равны NULL.

            5.1.5. Операции с двусвязным списком
    6. Добавление узла в начало списка
При добавлении нового узла NewNode в начало списка надо
    1. установить ссылку next узла NewNode на голову существующего списка и его ссылку prev в NULL;
установить ссылку prev бывшего первого узла (если он существовал) на NewNode;
    2. установить голову списка на новый узел;
    3. если в списке не было ни одного элемента, хвост списка также устанавливается на новый узел.

	1)	2)	3)



По такой схеме работает следующая процедура:

void AddFirst(PNode &Head, PNode &Tail, PNode NewNode)
{
// установить ссылку next узла NewNode на голову существующего списка
	NewNode->next = Head;
// установить ссылку prev в NULL
	NewNode->prev = NULL;
// установить ссылку prev бывшего первого узла (если он существовал) на NewNode
	if(Head)
		Head->prev = NewNode;
// установить голову списка на новый узел
	Head = NewNode;
// если в списке не было ни одного элемента, хвост списка также устанавливается на новый узел
	if(! Tail)
		Tail = Head; //этот элемент – первый
}

    7. Добавление узла в конец списка
Благодаря симметрии добавление нового узла NewNode в конец списка проходит совершенно аналогично, в процедуре надо везде заменить Head на Tail и наоборот, а также поменять prev и next.

    8. Добавление узла после заданного
Дан адрес NewNode нового узла и адрес p одного из существующих узлов в списке. Требуется вставить в список новый узел после p. Если узел p является последним, то операция сводится к добавлению в конец списка (см. выше). Если узел p – не последний, то операция вставки выполняется в два этапа:
    1. установить ссылки нового узла на следующий за данным (next) и предшествующий ему (prev);
    2. установить ссылки соседних узлов так, чтобы включить NewNode в список.

	1)	2)



Такой метод реализует приведенная ниже процедура (она учитывает также возможность вставки элемента в конец списка, именно для этого в параметрах передаются ссылки на голову и хвост списка):

void AddAfter (PNode &Head, PNode &Tail,
				PNode p, PNode NewNode)
{
	if(! p->next)
		AddLast (Head, Tail, NewNode); //вставка в конец списка
	else {
// установить ссылки нового узла на следующий за данным (next) и предшествующий ему (prev)
		NewNode->next = p->next; //меняем ссылки нового узла
		NewNode->prev = p;
// установить ссылки соседних узлов так, чтобы включить NewNode в список
		p->next->prev = NewNode; //меняем ссылки соседних узлов
		p->next = NewNode;
	}
}

Добавление узла перед заданным выполняется аналогично.

    9. Поиск узла в списке
Проход по двусвязному списку может выполняться в двух направлениях – от головы к хвосту (как для односвязного) или от хвоста к голове.

    10. Удаление узла
Эта процедура также требует ссылки на голову и хвост списка, поскольку они могут измениться при удалении крайнего элемента списка. На первом этапе устанавливаются ссылки соседних узлов (если они есть) так, как если бы удаляемого узла не было бы. Затем узел удаляется и память, которую он занимает, освобождается. Эти этапы показаны на рисунке внизу. Отдельно проверяется, не является ли удаляемый узел первым или последним узлом списка.



void Delete(PNode &Head, PNode &Tail, PNode OldNode)
{
	if(Head == OldNode){
		Head = OldNode->next; //удаляем первый элемент
		if(Head)
			Head->prev = NULL;
		else
			Tail = NULL; //удалили единственный элемент
	}
	else {
		OldNode->prev->next = OldNode->next;
		if(OldNode->next)
			OldNode->next->prev = OldNode->prev;
		else
			Tail = NULL; //удалили последний элемент
	}
	delete OldNode;
}

        1.5. Циклические списки
Иногда список (односвязный или двусвязный) замыкают в кольцо, то есть указатель next последнего элемента указывает на первый элемент, и (для двусвязных списков) указатель prev первого элемента указывает на последний. В таких списках понятие «хвоста» списка не имеет смысла, для работы с ним надо использовать указатель на «голову», причем «головой» можно считать любой элемент.

        1.6. Стек
Стек – это упорядоченный набор элементов, в котором добавление новых и удаление существующих элементов допустимо только с одного конца, который называется вершиной стека.
Стек называют структурой типа LIFO (Last In – First Out) – последним пришел, первым ушел. Стек похож на стопку с подносами, уложенными один на другой – чтобы достать какой-то поднос надо снять все подносы, которые лежат на нем, а положить новый поднос можно только сверху всей стопки. На рисунке показан стек, содержащий 6 элементов.



В современных компьютерах стек используется для
    • размещения локальных переменных;
    • размещения параметров процедуры или функции;
    • сохранения адреса возврата (по какому адресу надо вернуться из процедуры);
    • временного хранения данных, особенно при программировании на Ассемблере.

На стек выделяется ограниченная область памяти. При каждом вызове процедуры в стек добавляются новые элементы (параметры, локальные переменные, адрес возврата). Поэтому если вложенных вызовов будет много, стек переполнится. Очень опасной в отношении переполнения стека является рекурсия, поскольку она как раз и предполагает вложенные вызовы одной и той же процедуры или функции. При ошибке в программе рекурсия может стать бесконечной, кроме того, стек может переполниться, если вложенных вызовов будет слишком много.

            10.1.1. Реализация стека с помощью массива
Если максимальный размер стека заранее известен, его можно реализовать в программе в виде массива. Удобно объединить в одной структуре сам массив и его размер. Объявим новый тип данных – стек на 100 элементов-символов.

const int MAXSIZE = 100;
struct Stack
{
	char data[MAXSIZE];
	int size;
};

Для работы со стеком надо определить, как выполняются две операции – добавление элемента на вершину стека (Push) и снятие элемента с вершины стека (Pop).

void Push(Stack &S, char x)
{
	if(S.size == MAXSIZE){
		printf("Стек переполнен");
		return;
	}
	S.data[S.size] = x;
	S.size ++;
}

Поскольку нумерация элементов массива data начинается с нуля, надо сначала записать новый элемент в S.data[S.size], а затем увеличить размер стека. В процедуре предусмотрена обработка ошибки «переполнение стека». В этом случае на экран будет выдано сообщение «Стек переполнен». Можно также сделать функцию Push, которая будет возвращать 1 в случае удачного добавления элемента и 0 в случае ошибки.
Обратите внимание, что стек S передается в процедуру по ссылке, то есть, фактически передается адрес этого стека в памяти. Поэтому все операции со стеком в процедуре выполняются непосредственно со стеком вызывающей программы.

char Pop(Stack &S)
{
	if(S.size == 0){
		printf("Стек пуст");
		return char(255);
	}
	S.size --;
	return S.data[S.size];
}



Функция Pop возвращает символ, «снятый» с вершины стека, при этом размер стека уменьшается на единицу. Если стек пуст, функция возвращает символ с кодом 255 (который никогда не может находиться в стеке по условию задачи и сигнализирует об ошибке).

Задача. Ввести символьную строку, которая может содержать три вида скобок: (), [] и {}. Определить, верно ли расставлены скобки (символы между скобками не учитывать). Например, в строках ()[{}] и [{}([])] скобки расставлены верно, а в строках ([)] и ]]]((( - неверно.

Для одного вида скобок решение очень простое – ввести счетчик «вложенности» скобок, просмотреть всю строку, увеличивая счетчик для каждой открывающей скобки и уменьшая его для каждой закрывающей. Выражение записано верно, если счетчик ни разу не стал отрицательным и после обработки всей строки оказался равен нулю.
Если используются несколько видов скобок, счетчики не помогают. Однако эта задача имеет красивое решение с помощью стека. Вначале стек пуст. Проходим всю строку от начала до символа с кодом 0, который обозначает конец строки. Если встретили открывающую скобку, заносим ее в стек. Если встретили закрывающую скобку, то на вершине стека должна быть соответствующая ей открывающая скобка. Если это так, снимаем ее со стека. Если стек пуст или на вершине стека находится скобка другого вида, выражение неверное. В конце прохода стек должен быть пуст.
В приведенной ниже программе используются написанные ранее объявление структуры Stack и операции Push и Pop.

void main()
{
	setlocale(LC_ALL, "Rus");
	char br1[3] = { '(', '[', '{' }; // открывающие скобки
	char br2[3] = { ')', ']', '}' }; // закрывающие скобки
	char s[80], upper;
	int i, k, OK;
	Stack S; //стек символов
	printf("Введите выражение со скобками> ");
	gets(s);
	S.size = 0; //сначала стек пуст
	OK = 1;
	for(i = 0; OK && (s[i] != '\0'); i ++)
		for(k = 0; k < 3; k ++ ){ //проверить 3 вида скобок
			if(s[i] == br1[k]){ // открывающая скобка
			Push(S, s[i]);
			break;
			}
			if(s[i] == br2[k]){ // закрывающая скобка
				upper = Pop(S);
				if(upper != br1[k])
					OK = 0;
				break;
			}
		}
	if(OK && (S.size == 0))
		printf("\nВыpажение пpавильное\n");
	else
		printf("\nВыpажение непpавильное \n");
	system("PAUSE");
}

Открывающие и закрывающие скобки записаны в массивах br1 и br2. В самом начале стек пуст и его размер равен нулю (S.size = 0). Переменная OK служит для того, чтобы выйти из внешнего цикла, когда обнаружена ошибка (и не рассматривать оставшуюся часть строки). Она устанавливается в нуль, если в стеке обнаружена скобка другого типа или стек оказался пуст.
Сборка программы и примеры ее работы представлены ниже:

#include <iostream>
#include <string.h>
using namespace std;

const int MAXSIZE = 100;
struct Stack
{
	char data[MAXSIZE];
	int size;
};

void Push(Stack &S, char x)
{
	if(S.size == MAXSIZE){
		printf("Стек переполнен");
		return;
	}
	S.data[S.size] = x;
	S.size ++;
}

char Pop(Stack &S)
{
	if(S.size == 0){
		printf("Стек пуст");
		return char(255);
	}
	S.size --;
	return S.data[S.size];
}

void main()
{
	setlocale(LC_ALL, "Rus");
	char br1[3] = { '(', '[', '{' }; // открывающие скобки
	char br2[3] = { ')', ']', '}' }; // закрывающие скобки
	char s[80], upper;
	int i, k, OK;
	Stack S; //стек символов
	printf("Введите выражение со скобками> ");
	gets(s);
	S.size = 0; //сначала стек пуст
	OK = 1;
	for(i = 0; OK && (s[i] != '\0'); i ++)
		for(k = 0; k < 3; k ++ ){ //проверить 3 вида скобок
			if(s[i] == br1[k]){ // открывающая скобка
			Push(S, s[i]);
			break;
			}
			if(s[i] == br2[k]){ // закрывающая скобка
				upper = Pop(S);
				if(upper != br1[k])
					OK = 0;
				break;
			}
		}
	if(OK && (S.size == 0))
		printf("\nВыpажение пpавильное\n");
	else
		printf("\nВыpажение непpавильное \n");
	system("PAUSE");
}





            10.1.2. Реализация стека с помощью списка
Рассмотрим пример стека, в котором хранятся символы (это простейший вариант, элементом стека могут быть любые типы данных или структур, так же, как и для списка). Реализуем стек на основе двусвязного списка. При этом количество элементов стека ограничивается только доступным объемом памяти.

struct Node
{
	char data;
	Node *next, *prev;
};
typedef Node *PNode;

Чтобы не работать с отдельными указателями на хвост и голову списка, объявим структуру, в которой будет храниться вся информация о стеке:

struct Stack
{
	PNode Head, Tail;
};

В самом начале надо записать в обе ссылки стека NULL.

    11. Добавление элемента на вершину стека
Фактически это добавление нового элемента в начало двусвязного списка. Эта процедура уже была написана ранее, теперь ее придется немного переделать, чтобы работать не с отдельными указателями, а со структурой типа Stack. В параметрах процедуры указывается не новый узел, а только данные для этого узла, то есть целое число. Память под новый узел выделяется в процедуре, то есть, скрыта от нас и снижает вероятность ошибки.

void Push(Stack &S, char x)
{
	PNode NewNode;
	NewNode = new Node; //создать новый узел...
	NewNode->data = x; //и заполнить его данными
	NewNode->next = S.Head;
	NewNode->prev = NULL;
	if (S.Head) //добавить в начало списка
		S.Head->prev = NewNode;
	S.Head = NewNode;
	if(! S.Tail)
		S.Tail = S.Head;
}

    12. Получение верхнего элемента с вершины стека
Функция Pop удаляет верхний элемент и возвращает его данные.

char Pop(Stack &S)
{
	PNode TopNode = S.Head;
	char x;
	if(! TopNode) //если стек пуст, то
		return char(255); //вернуть символ с кодом 255
	x = TopNode->data;
	S.Head = TopNode->next;
	if(S.Head)
		S.Head->prev = NULL; //переставить ссылки
	else
		S.Tail = NULL;
	delete TopNode; //освободить память
	return x;
}

С учетом предыдущего примера(комментарий) стек со списком для решения аналогичной задачи

#include <iostream>
#include <string.h>
using namespace std;

//const int MAXSIZE = 100;
//struct Stack
//{
//	char data[MAXSIZE];
//	int size;
//};
struct Node
{
	char data;
	Node *next, *prev;
};
typedef Node *PNode;

struct Stack
{
	PNode Head, Tail;
};

//void Push(Stack &S, char x)
//{
//	if(S.size == MAXSIZE){
//		printf("Стек переполнен");
//		return;
//	}
//	S.data[S.size] = x;
//	S.size ++;
//}
void Push(Stack &S, char x)
{
	PNode NewNode;
	NewNode = new Node; //создать новый узел...
	NewNode->data = x; //и заполнить его данными
	NewNode->next = S.Head;
	NewNode->prev = NULL;
	if (S.Head) //добавить в начало списка
		S.Head->prev = NewNode;
	S.Head = NewNode;
	if(! S.Tail)
		S.Tail = S.Head;
}

//char Pop(Stack &S)
//{
//	if(S.size == 0){
//		printf("Стек пуст");
//		return char(255);
//	}
//	S.size --;
//	return S.data[S.size];
//}
char Pop(Stack &S)
{
	PNode TopNode = S.Head;
	char x;
	if(! TopNode) //если стек пуст, то
		return char(255); //вернуть символ с кодом 255
	x = TopNode->data;
	S.Head = TopNode->next;
	if(S.Head)
		S.Head->prev = NULL; //переставить ссылки
	else
		S.Tail = NULL;
	delete TopNode; //освободить память
	return x;
}

void main()
{
	setlocale(LC_ALL, "Rus");
	char br1[3] = { '(', '[', '{' }; // открывающие скобки
	char br2[3] = { ')', ']', '}' }; // закрывающие скобки
	char s[80], upper;
	int i, k, OK;
	Stack S; //стек символов
	S.Head=NULL;
	S.Tail=NULL;
	printf("Введите выражение со скобками> ");
	gets(s);
	//S.size = 0; //сначала стек пуст
	OK = 1;
	for(i = 0; OK && (s[i] != '\0'); i ++)
		for(k = 0; k < 3; k ++ ){ //проверить 3 вида скобок
			if(s[i] == br1[k]){ // открывающая скобка
			Push(S, s[i]);
			break;
			}
			if(s[i] == br2[k]){ // закрывающая скобка
				upper = Pop(S);
				if(upper != br1[k])
					OK = 0;
				break;
			}
		}
	//if(OK && (S.size == 0))
	if(OK && (S.Head == NULL) && (S.Tail == NULL))
		printf("\nВыpажение пpавильное\n");
	else
		printf("\nВыpажение непpавильное \n");
	system("PAUSE");
}







            12.1.1. Системный стек в программах
При выполнении программ определенная область памяти отводится на стек программы. Более того, в процессоре есть специальная ячейка (регистр), в которой хранится адрес вершины стека. Программа использует стек для хранения
    • адресов возврата из процедур и функций (это адреса, на которые переходит программа после выполнения процедуры или функции);
    • параметров, передаваемых в процедуры и функции;
    • локальных переменных в процедурах и функциях;
    • временных данных (в основном в программах на ассемблере).

Больше всего места занимают в стеке локальные переменные. Поэтому память под большие массивы надо выделять динамически. Кроме того, желательно не передавать в процедуры большие структуры, вместо этого можно передать их адрес или использовать передачу по ссылке (при этом перед именем параметра должен стоять знак &).

        1.7. Очередь
Очередь – это упорядоченный набор элементов, в котором добавление новых элементов допустимо с одного конца (он называется концом очереди), а удаление существующих элементов – только с другого конца, который называется началом очереди.
Хорошо знакомой моделью является очередь в магазине. Очередь называют структурой типа FIFO (First In – First Out) – первым пришел, первым ушел. На рисунке изображена очередь из 3-х элементов.



Наиболее известные примеры применения очередей в программировании – очередь событий системы Windows и ей подобных. Очереди используются также для моделирования в задачах массового обслуживания (например, обслуживания клиентов в банке).

            12.1.2. Реализация очереди с помощью массива
Если максимальный размер очереди заранее известен, его можно реализовать в программе в виде массива. Удобно объединить в одной структуре сам массив и его размер. Объявим новый тип данных – очередь на 100 элементов (целых чисел).

const int MAXSIZE = 100;
struct Queue
{
	int data[MAXSIZE];
	int size, head, tail;
};

Если у стека один конец «закреплен» (не двигается), то у очереди «подвижны» оба конца. Чтобы не сдвигать все элементы в массиве при удалении или добавлении элемента, обычно использую две переменные head и tail – первая из них обозначает номер первого элемента в очереди, а вторая – номер последнего. Если они равны, то в очереди всего один элемент. Массив как бы замыкается в кольцо – если массив закончился, но в начале массива есть свободные места, то новый элемент добавляется в начало массива, как показано на рисунках.



Для работы с очередью надо определить, как выполняются две операции – добавление элемента в конец очереди (PushTail) и удаление элемента с начала очереди (Pop).

void PushTail(Queue &Q, int x)
{
	if(Q.size == MAXSIZE){
		printf ("Очередь переполнена\n");
		return;
	}
	Q.tail++;
	if(Q.tail >= MAXSIZE) //замыкание в кольцо
		Q.tail = 0;
	Q.data[Q.tail] = x;
	Q.size ++;
}

Поскольку очередь может начинаться не с начала массива (за счет того, что некоторые элементы уже «выбраны»), после увеличения Q.tail надо проверить, не вышли ли мы за границу массива. Если это случилось, новый элемент записывается в начало массива (хотя является хвостом очереди). В процедуре предусмотрена обработка ошибки «переполнение очереди». В этом случае на экран будет выдано сообщение «Очередь переполнена». Можно также сделать функцию PushTail, которая будет возвращать 1 в случае удачного добавления элемента и 0 в случае ошибки.
Обратите внимание, что очередь Q передается в процедуру по ссылке, то есть, фактически передается адрес этой структуры в памяти.

int Pop(Queue &Q)
{
	int temp;
	if(Q.size == 0){
		printf("Очередь пуста\n");
		return 32767; //сигнал об ошибке
	}
	temp = Q.data[Q.head];
	Q.head ++;
	if(Q.head >= MAXSIZE)
		Q.head = 0;
	Q.size --;
	return temp;
}

Функция Pop возвращает число, полученное с начала очереди, при этом размер очереди уменьшается на единицу. Если стек пуст, функция возвращает число 32767 (предполагается, что оно не может находиться в очереди по условию задачи и сигнализирует об ошибке).

            12.1.3. Реализация очереди с помощью списка
Если максимальный размер заранее неизвестен или требуется сделать его динамическим, для реализации используют список. Рассмотрим пример очереди, элементами которой являются целые числа. При этом количество ее элементов ограничивается только доступным объемом памяти. Новые типы данных (узел и указатель на него) объявляются так же, как для списка:

struct Node{

	int data;
	Node *next, *prev;
};
typedef Node *PNode;

Чтобы не работать с отдельными указателями на хвост и голову списка, объявим структуру, в которой будет храниться вся информация об очереди:

struct Queue
{
	PNode head, tail;
};

В самом начале надо записать в обе ссылки NULL. Заметим, что такая же структура использовалась и для стека. Более того, функция для получения первого элемента очереди (Pop) совпадает с функцией снятия элемента с вершины стека (напишите ее в качестве упражнения).

    13. Добавление элемента в конец очереди
Фактически это добавление нового элемента в конец двусвязного списка. В параметрах процедуры указывается не новый узел, а только данные для этого узла, то есть целое число. Память под новый узел выделяется в процедуре, то есть, скрыта от нас и снижает вероятность ошибки.

void PushTail(Queue &Q, int x)
{
	PNode NewNode;
	NewNode = new Node; //создать новый узел
	NewNode->data = x; //заполнить узел данными
	NewNode->prev = Q.Tail;
	NewNode->next = NULL;
	if (Q.tail) //добавить узел в конец списка
		Q.tail->next = NewNode;
	Q.tail = NewNode;
	if (! Q.head)
		Q.head = Q.tail;
}

        1.8. Дек
Дек (deque) -  это упорядоченный набор элементов, в котором добавление новых и удаление существующих элементов допустимо с любого конца.
Дек может быть реализован на основе массива или двусвязного списка. Для дека разрешены четыре операции:
    • добавление элемента в начало;
    • добавление элемента в конец;
    • удаление элемента с начала;
    • удаление элемента с конца.

Их можно реализовать, используя написанные выше процедуры для стека и очереди.

        1.9. Деревья
            13.1.1. Основные понятия
    14. Термины и определения
Дерево  –  это совокупность узлов (вершин) и соединяющих их направленных ребер (дуг), причем в каждый узел (за исключением одного - корня) ведет ровно одна дуга.
Корень  –  это начальный узел дерева, в который не ведет ни одной дуги.
Примером может служить генеалогическое дерево - в корне дерева находитесь вы сами, от вас идет две дуги к родителям, от каждого из родителей - две дуги к их родителям и т.д.



Например, на рисунке структуры а) и б) являются деревьями, а в) и г) - нет.

	а)	б)	в)	г)



Предком для узла x называется узел дерева, из которого существует путь в узел x.
Потомком узла x называется узел дерева, в который существует путь (по стрелкам) из узла x.
Родителем для узла x называется узел дерева, из которого существует непосредственная дуга в узел x.
Сыном узла x называется узел дерева, в который существует непосредственная дуга из узла x.
Уровнем узла x называется длина пути (количество дуг) от корня к данному узлу. Считается, что корень находится на уровне 0.
Листом дерева называется узел, не имеющий потомков.
Внутренней вершиной называется узел, имеющий потомков.
Высотой дерева называется максимальный уровень листа дерева.
Упорядоченным деревом называется дерево, все вершины которого упорядочены (то есть имеет значение последовательность перечисления потомков каждого узла).

Например, два упорядоченных дерева на рисунке ниже – разные.



    15. Рекурсивное определение
Дерево представляет собой типичную рекурсивную структуру (определяемую через саму себя). Как и любое рекурсивное определение, определение дерева состоит из двух частей – первая определяет условие окончания рекурсии, а второе – механизм ее использования.
    • пустая структура является деревом;
    • дерево – это корень и несколько связанных с ним деревьев (поддеревьев).

Таким образом, размер памяти, необходимый для хранения дерева, заранее неизвестен, потому что неизвестно, сколько узлов будет в него входить.

    16. Двоичные деревья
На практике используются главным образом деревья особого вида, называемые двоичными (бинарными).
Двоичным деревом называется дерево, каждый узел которого имеет не более двух сыновей.
Можно определить двоичное дерево и рекурсивно:
    • пустая структура является двоичным деревом;
    • дерево – это корень и два связанных с ним двоичных дерева, которые называют левым и правым поддеревом.

Двоичные деревья упорядочены, то есть различают левое и правое поддеревья. Типичным примером двоичного дерева является генеалогическое дерево (родословная). В других случаях двоичные деревья используются тогда, когда на каждом этапе некоторого процесса надо принять одно решение из двух возможных. В дальнейшем мы будем рассматривать только двоичные деревья.
Строго двоичным деревом называется дерево, у которого каждая внутренняя вершина имеет непустые левое и правое поддеревья.
Это означает, что в строго двоичном дереве нет вершин, у которых есть только одно поддерево. На рисунке даны деревья а) и б) являются строго двоичными, а в) и г) – нет.

	а)	б)	в)	г)



Полным двоичным деревом называется дерево, у которого все листья находятся на одном уровне и каждая внутренняя вершина имеет непустые левое и правое поддеревья.
На рисунке выше только дерево а) является полным двоичным деревом.

            16.1.1. Реализация двоичных деревьев в языке Си
    17. Описание вершины
Вершина дерева, как и узел любой динамической структуры, имеет две группы данных: полезную информацию и ссылки на узлы, связанные с ним. Для двоичного дерева таких ссылок будет две – ссылка на левого сына и ссылка на правого сына. В результате получаем структуру, описывающую вершину (предполагая, что полезными данными для каждой вершины является одно целое число):

struct Node
{
	int key; //полезные данные (ключ)
	Node  *left, *right; //указатели на сыновей
};
typedef Node *PNode; // указатель на вершину

    18. Деревья минимальной высоты
Для большинства практических задач наиболее интересны такие деревья, которые имеют минимально возможную высоту при заданном количестве вершин n. Очевидно, что минимальная высота достигается тогда, когда на каждом уровне (кроме, возможно, последнего) будет максимально возможное число вершин.
Предположим, что задано n чисел (их количество заранее известно). Требуется построить из них дерево минимальной высоты. Алгоритм решения этой задачи предельно прост.
    • Взять одну вершину в качестве корня и записать в нее первое нерассмотренное число.
    • Построить этим же способом левое поддерево из n1 = n/2 вершин (деление нацело!).
    • Построить этим же способом правое поддерево из n2 = n-n1-1 вершин.

Заметим, что по построению левое поддерево всегда будет содержать столько же вершин, сколько правое поддерево, или на 1 больше. Для массива данных

21, 8, 9, 11, 15, 19, 20, 21, 7



по этому алгоритму строится дерево, показанное на рисунке.
Как будет выглядеть эта программа на языке Си? Надо сначала разобраться, что означает «взять одну вершину в качестве корня и записать туда первое нерассмотренное число». Поскольку вершины должны создаваться динамически, надо выделить память под вершину и записать в поле данных нужное число. Затем из оставшихся чисел построить левое и правое поддеревья.
В основной программе нам надо объявить указатель на корень нового дерева, задать массив данных (в принципе можно читать данные из файла) и вызвать функцию, возвращающую указатель на построенное дерево.

int data[] = {21, 8, 9, 11, 15, 19, 20, 21, 7};
PNode Tree; //указатель на корень дерева
n = sizeof(data) / sizeof(int) - 1; //размер массива
Tree = MakeTree (data, 0, n); //использовать n элементов,
// начиная с номера 0

Сама функция MakeTree принимает три параметра: массив данных, номер первого неиспользованного элемента и количество элементов в новом дереве. Возвращает она указатель на новое дерево (типа PNode).

PNode MakeTree (int data[], int from, int n)
{
	PNode Tree;
	int n1, n2;
	if(n == 0)
		return NULL; //ограничение рекурсии
	Tree = new Node; //выделить память под вершину
	Tree->key = data[from]; //записать данные (ключ)
	n1 = n / 2; //размеры поддеревьев
	n2 = n - n1 - 1;
	Tree->left = MakeTree(data, from+1, n1);
	Tree->right = MakeTree(data, from+1+n1, n2);
	return Tree;
}

Выделенные строчки программы содержат рекурсивные вызовы. При этом левое поддерево содержит n1 элементов массива начиная с номера from+1, тогда как правое – n2 элементов начиная с номера from+1+n1.

                    18.1.1.1.1. Обход дерева
Одной из необходимых операций при работе с деревьями является обход дерева, во время которого надо посетить каждый узел по одному разу и (возможно) вывести информацию, содержащуюся в вершинах.
Пусть в результате обхода надо напечатать значения поля данных всех вершин в определенном порядке. Существуют три варианта обхода:
    • КЛП (корень – левое – правое): сначала посещается корень (выводится информация о нем), затем левое поддерево, а затем – правое;
    • ЛКП (левое – корень – правое): сначала посещается левое поддерево, затем корень, а затем – правое;
    • ЛПК (левое – правое – корень): сначала посещается левое поддерево, затем правое, а затем – корень.

Для примера ниже дана рекурсивная процедура просмотра дерева в порядке ЛКП. Обратите внимание, что поскольку дерево является рекурсивной структурой данных, при работе с ним естественно широко применять рекурсию.

void PrintLKP(PNode Tree)
{
	if(! Tree)
		return; // пустое дерево – окончание рекурсии
	PrintLKP(Tree->left); //обход левого поддерева
	printf("%d ", Tree->key); //вывод информации о корне
	PrintLKP(Tree->right); //обход правого поддерева
}

Остальные варианты обхода программируются аналогично.

            18.1.2. Поиск с помощью дерева
    19. Как быстрее искать?
Деревья очень удобны для поиска в них информации. Однако для быстрого поиска требуется предварительная подготовка – дерево надо построить специальным образом.
Предположим, что существует массив данных и с каждым элементом связан ключ - число, по которому выполняется поиск. Пусть ключи для элементов таковы:

59, 100, 75, 30, 16, 45, 250



Для этих данных нам надо много раз проверять, есть ли среди ключей заданный ключ x, и если есть, то вывести всю связанную с этим элементом информацию.
Если данные организованы в виде массива (без сортировки), то для поиска в худшем случае надо сделать n сравнений элементов (сравнивая последовательно с каждым элементом пока не найдется нужный или пока не закончится массив).
Теперь предположим, что данные организованы в виде дерева, показанного на рисунке. Такое дерево (оно называется дерево поиска) обладает следующим важным свойством:
Значения ключей всех вершин левого поддерева вершины x меньше ключа x, а значения ключей всех вершин правого поддерева x больше или равно ключу вершины x.

Для поиска нужного элемента в таком дереве требуется не более 3 сравнений вместо 7 при поиске в списке или массиве, то есть поиск проходит значительно быстрее. С ростом количества элементов эффективность поиска по дереву растет.

    20. Построение дерева поиска
Как же, имея массив данных, построить такое дерево?
    • Сравнить ключ очередного элемента массива с ключом корня.
    • Если ключ нового элемента меньше, включить его в левое поддерево, если больше или равен, то в правое.
    • Если текущее дерево пустое, создать новую вершину и включить в дерево.



Программа, приведенная ниже, реализует этот алгоритм:

void AddToTree(PNode &Tree, //указатель на корень (ссылка)
			   int data) //добавляемый ключ
{
	if(! Tree){
		Tree = new Node; //создать новый узел
		Tree->key = data;
		Tree->left = NULL;
		Tree->right = NULL;
		return;
	}
	if(data < Tree->key) //добавить в нужное поддерево
		AddToTree ( Tree->left, data );
	else
		AddToTree ( Tree->right, data );
}

Важно, что указатель на корень дерева надо передавать по ссылке, так как он может измениться при создании новой вершины.
Надо заметить, что в результате работы этого алгоритма не всегда получается дерево минимальной высоты – все зависит от порядка выбора элементов. Для оптимизации поиска используют так называемые сбалансированные или АВЛ-деревья (деревья называют так в честь изобретателей этого метода Г.М. Адельсона-Вельского и Е.М. Ландиса) деревья, у которых для любой вершины высоты левого и правого поддеревьев отличаются не более, чем на 1. Добавление в них нового элемента иногда сопровождается некоторой перестройкой дерева.

    21. Поиск по дереву
Теперь, когда дерево сортировки построено, очень легко искать элемент с заданным ключом. Сначала проверяем ключ корня, если он равен искомому, то нашли. Если он меньше искомого, ищем в левом поддереве корня, если больше – то в правом. Приведенная функция возвращает адрес нужной вершины, если поиск успешный, и NULL, если требуемый элемент не найден.

PNode Search(PNode Tree, int what)
{
	if(! Tree)//ключ не найден
		return NULL;
	if(what == Tree->key)//ключ найден!
		return Tree;
	if(what < Tree->key)//искать в поддеревьях
		return Search(Tree->left, what);
	else
		return Search(Tree->right, what);
}

                    21.1.1.1.1. Сортировка с помощью дерева поиска
Если дерево поиска построено, очень просто вывести отсортированные данные. действительно, обход типа ЛКП (левое поддерево – корень – правое поддерево) даст ключи в порядке возрастания, а обход типа ПКЛ (правое поддерево – корень – левое поддерево) – в порядке убывания.

                    21.1.1.1.2. Поиск одинаковых элементов
Приведенный алгоритм можно модифицировать так, чтобы быстро искать одинаковые элементы в массиве чисел. Конечно, можно перебрать все элементы массива и сравнить каждый со всеми остальными. Однако для этого требуется очень большое число сравнений. С помощью двоичного дерева можно значительно ускорить поиск. Для этого надо в структуру вершины включить еще одно поле – счетчик найденных дубликатов count.

struct Node
{
	int key;
	int count; //счетчик дубликатов
	Node *left, *right;
};

При создании узла в счетчик записывается единица (найден один элемент). Поиск дубликатов происходит по следующему алгоритму:
    • Сравнить ключ очередного элемента массива с ключом корня.
    • Если ключ нового элемента равен ключу корня, то увеличить счетчик корня и стоп.
    • Если ключ нового элемента меньше, чем у корня, включить его в левое поддерево, если больше или равен – в правое.
    • Если текущее дерево пустое, создать новую вершину (со значением счетчика 1) и включить в дерево.

            21.1.2. Разбор арифметического выражения
    22. Дерево для арифметического выражения
Вы задумывались над тем, как транслятор обрабатывает и выполняет арифметические и логические выражения, которые он встречает в программе? Один из вариантов – представить это выражение в виде двоичного дерева. Например, выражению

(a + b) / (c - d + 1)



соответствует дерево, показанное на рисунке. Листья содержат числа и имена переменных (операндов), а внутренние вершины и корень – арифметические действия и вызовы функций. Вычисляется такое выражение снизу, начиная с листьев. Как видим, скобки отсутствуют, и дерево полностью определяет порядок выполнения операций.

    23. Формы записи арифметического выражения
Теперь посмотрим, что получается при прохождении таких двоичных деревьев. Прохождение дерева в ширину (корень – левое – правое) дает

/ + a b + - c d 1

то есть знак операции (корень) предшествует своим операндам. Такая форма записи арифметических выражений называется префиксной. Проход в прямом порядке (левое – корень – правое) дает инфиксную форму, которая совпадает с обычной записью, но без скобок:

a + b / c - d + 1

Поскольку скобок нет, по инфиксной записи невозможно восстановить правильный порядок операций.
В трансляторах широко используется постфиксная запись выражений, которая получается в результате обхода в порядке ЛПК (левое – правое – корень). В ней знак операции стоит после обоих операндов:

a b + c d - 1 /

Порядок выполнения такого выражения однозначно определяется следующим алгоритмом, который использует стек:
Пока в постфиксной записи есть невыбранные элементы,
    • взять очередной элемент;
    • если это операнд (не знак операции), то записать его в стек;
    • если это знак операции, то
    • выбрать из стека второй операнд;
    • выбрать из стека первый операнд;
    • выполнить операцию с этими данными и результат записать в стек.

Проиллюстрируем на примере вычисление выражения в постфиксной форме

a b + c d - 1 /

Согласно алгоритму, сначала запишем в стек a, а затем b (рисунок 1).



Результат выполнения операции a+b запишем обратно в стек, а сверху – выбранные из входного потока значения переменных c и d (рисунок 2). Дальнейшее развитие событий показано на рисунках 3 и 4. Выполнение последней операции (деления) для стека на рисунке 4 дает искомый результат.

    24. Алгоритм построения дерева
Пусть задано арифметическое выражение. Надо построить для него дерево синтаксического разбора и различные формы записи.
Чтобы не слишком усложнять задачу, рассмотрим самый простой вариант, введя следующие упрощения.
    • В выражении могут присутствовать только однозначные целые числа знаки операций + - * /.
    • Запрещается использование вызовов функций, скобок, унарных знаков плюс и минус (например, запрещено выражение -a+5, вместо него надо писать 0-a+5).
    • Предполагается, что выражение записано верно, то есть не делается проверки на правильность.

Вспомним, что порядок выполнения операций в выражении определяется приоритетом операций – первыми выполняются операции с более высоким приоритетом. Например, умножение и деление выполняются раньше, чем сложение и вычитание.
Правильное арифметическое выражение записано в виде символьной строки Expr длиной N. Построим дерево для элементов массива с номерами от first до last (полное дерево дает применение этого алгоритма ко всему массиву, то есть при first=0 и last=N-1). В словесном виде алгоритм выглядит так:
    • Если first=last (остался один элемент – переменная или число), то создать новый узел и записать в него этот элемент. Иначе...
    • Среди элементов от first до last включительно найти последнюю операцию с наименьшим приоритетом (пусть найденный элемент имеет номер k).
    • Создать новый узел (корень) и записать в него знак операции Expr[k].
    • Рекурсивно применить этот алгоритм два раза:
    • построить левое поддерево, разобрав выражение из элементов массива с номерами от first до k-1
    • построить правое поддерево, разобрав выражение из элементов массива с номерами от k+1 до last

Объявим структуру, описывающую узел такого дерева. Так как мы используем только однозначные целые числа и знаки, область данных может содержать один символ.

struct Node
{
	char data;
	Node *left, *right;
};
typedef Node *PNode;

Далее надо определить функцию, возвращающую приоритет операции, которая ей передана.
Определим приоритет 1 для сложения и вычитания и приоритет 2 для умножения и деления.

int Priority(char c)
{
	switch(c){
		case '+': case '-': return 1;
		case '*': case '/': return 2;
	}
	return 100; //это не арифметическая операция
}

Приведенная ниже процедура строит требуемое дерево, используя эту функцию, и возвращает адрес построенного дерева в памяти. Обратите внимание, что при сравнении приоритета текущей операции с минимальным предыдущим используется условие <=. За счет этого мы ищем именно последнюю операцию с минимальным приоритетом, то есть, операцию, которая будет выполняться самой последней. Если бы мы использовали знак <, то нашли бы первую операцию с наименьшим приоритетом, и дерево было бы построено неверно (вычисления дают неверный результат, если встречаются два знака вычитания или деления).

PNode MakeTree(char Expr[], int first, int last)
{
	int MinPrt, i, k, prt;
	PNode Tree = new Node; //создать в памяти новую вершину
	if(first == last){ //конечная вершина: число или
		Tree->data = Expr[first]; //переменная
		Tree->left = NULL;
		Tree->right = NULL;
		return Tree;
	}
	MinPrt = 100;
	for(i = first; i <= last; i ++){
		prt = Priority ( Expr[i] );
		if(prt <= MinPrt){ //ищем последнюю операцию
			MinPrt = prt; //с наименьшим приоритетом
			k = i;
		}
	}
	Tree->data = Expr[k]; //внутренняя вершина (операция)
	Tree->left = MakeTree(Expr, first,k-1); //рекурсивно строим
	Tree->right = MakeTree(Expr, k+1,last); //поддеревья
	return Tree;
}

Теперь обход этого дерева разными способами дает различные формы представления соответствующего арифметического выражения.

    25. Вычисление выражения по дереву
Пусть для некоторого арифметического выражения построено дерево и известен его адрес Tree. Напишем функцию, которая возвращает целое число – результат вычисления этого выражения. Учтем, что деление выполняется нацело (остаток отбрасывается).

int CalcTree(PNode Tree)
{
	int num1, num2;
	if (! Tree->left) //если нет потомков,
		return Tree->data - '0'; //вернули число
	num1 = CalcTree(Tree->left); //вычисляем поддеревья
	num2 = CalcTree(Tree->right);
	switch(Tree->data) { //выполняем операцию
		case '+': return num1+num2;
		case '-': return num1-num2;
		case '*': return num1*num2;
		case '/': return num1/num2;
	}
	return 32767; //неизвестная операция, ошибка!
}

Если дерево не имеет потомков, значит это число. Чтобы получить результат как целое число, из кода этой цифры надо вычесть код цифры '0'. Если потомки есть, вычисляем левое и правое поддеревья (рекурсивно!) и выполняем операцию, записанную в корне дерева. Основная программа может выглядеть так, как показано ниже.

void main()
{
	char s[80];
	PNode Tree;
	printf("Введите выражение > ");
	gets(s);
	Tree = MakeTree(s, 0, strlen(s)-1);
	printf ( "= %d \n", CalcTree ( Tree ) );
	getch();
}

Полностью собранная программа и результат ее работы

#include <iostream>
#include <string.h>
#include <conio.h>
using namespace std;

struct Node
{
	char data;
	Node *left, *right;
};
typedef Node *PNode;

int Priority(char c)
{
	switch(c){
		case '+': case '-': return 1;
		case '*': case '/': return 2;
	}
	return 100; //это не арифметическая операция
}

PNode MakeTree(char Expr[], int first, int last)
{
	int MinPrt, i, k, prt;
	PNode Tree = new Node; //создать в памяти новую вершину
	if(first == last){ //конечная вершина: число или
		Tree->data = Expr[first]; //переменная
		Tree->left = NULL;
		Tree->right = NULL;
		return Tree;
	}
	MinPrt = 100;
	for(i = first; i <= last; i ++){
		prt = Priority ( Expr[i] );
		if(prt <= MinPrt){ //ищем последнюю операцию
			MinPrt = prt; //с наименьшим приоритетом
			k = i;
		}
	}
	Tree->data = Expr[k]; //внутренняя вершина (операция)
	Tree->left = MakeTree(Expr, first,k-1); //рекурсивно строим
	Tree->right = MakeTree(Expr, k+1,last); //поддеревья
	return Tree;
}

int CalcTree(PNode Tree)
{
	int num1, num2;
	if (! Tree->left) //если нет потомков,
		return Tree->data - '0'; //вернули число
	num1 = CalcTree(Tree->left); //вычисляем поддеревья
	num2 = CalcTree(Tree->right);
	switch(Tree->data) { //выполняем операцию
		case '+': return num1+num2;
		case '-': return num1-num2;
		case '*': return num1*num2;
		case '/': return num1/num2;
	}
	return 32767; //неизвестная операция, ошибка!
}

void main()
{
	setlocale(LC_ALL, "Rus");
	char s[80];
	PNode Tree;
	printf("Введите выражение > ");
	gets(s);
	Tree = MakeTree(s, 0, strlen(s)-1);
	printf ( "= %d \n", CalcTree ( Tree ) );
	getch();
	//system("PAUSE");
}



    26. Разбор выражения со скобками
Немного усложним задачу, разрешив использовать в выражении скобки одного вида (допустим, круглые). Тогда при поиске в заданном диапазоне операции с минимальным приоритетом не надо брать во внимание выражения в скобках (они выделены на рисунке).

1 + ((2 + 3) * 5 + 3) * 7

Самый простой способ добиться этого эффекта – ввести счетчик открытых скобок nest. В начале он равен нулю, с каждой найденной открывающей скобкой будем увеличивать его на 1, а с каждой закрывающей – уменьшать на 1. Рассматриваются только те операции, которые найдены при nest=0, то есть, расположены вне скобок.
Если же ни одной такой операции не найдено, то мы имеем выражение, ограниченной скобками, поэтому надо вызвать процедуру рекурсивно для диапазона from+1..last-1 (напомним, что мы предполагаем, что выражение корректно). Для сокращения записи показаны только те части процедуры, которые изменяются:

PNode MakeTree(char Expr[], int first, int last)
{
	int MinPrt, i, k, prt;
	int nest = 0; //счетчик открытых скобок
	PNode Tree = new Node;
	...
	MinPrt = 100;
	for(i = first; i <= last; i ++){
		if( Expr[i] == '(') //открывающая скобка
		{
			nest ++;
			continue;
		}
		if(Expr[i] == ')'){ //закрывающая скобка
			nest --;
			continue;
		}
		if(nest > 0)//пропускаем все, что в скобках
			continue;
		prt = Priority(Expr[i]);
		if(prt <= MinPrt){
			MinPrt = prt;
			k = i;
		}
	}
	if(MinPrt == 100 && // все выражение взято в скобки
		Expr[first]== '(' && Expr[last]==')' ){
			delete Tree;
			return MakeTree(Expr, first+1, last-1);
	}
	...
	return Tree;
}

Поскольку новый узел создается в самом начале функции, его надо удалить, если все выражение взято в скобки.

    27. Многозначные числа и переменные
Для хранения многозначных чисел и имен переменных надо использовать массив символов в области данных узла.

struct Node
{
	char data[40];
	Node *left, *right;
};
typedef Node *PNode;

Будем по-прежнему считать, что выражение не содержит ошибок. Тогда, если в строке нет ни одного знака арифметической операции (вне скобок) и нет скобок по краям, все выражение представляет собой единый элемент (он называется операндом) – число или имя переменной. Для записи этого элемента в область данных узла используется функция strncpy , которая копирует заданное количество символов. Она не ставит символ конца строки, поэтому приходится делать это вручную.

PNode MakeTree(char Expr[], int first, int last)
{
	int MinPrt, i, k, prt;
	PNode Tree = new Node;
	MinPrt = 100;
	for(i = first; i <= last; i ++ ){
		prt = Priority(Expr[i]);
		if(prt <= MinPrt){
			MinPrt = prt;
		k = i;
		}
	}
	if(MinPrt == 100)
		if(Expr[first] == '(' && Expr[last] == ')'){
			delete Tree;
			return
				MakeTree(Expr, first+1, last-1);
		}
		else{ // число или переменная
			k = last - first + 1;
			strncpy(Tree->data, Expr+first, k);
			Tree->data[k] = '\0';
			Tree->left = NULL;
			Tree->right = NULL;
			return Tree;
		}
	Tree->data[0] = Expr[k]; //знак операции
	Tree->data[1] = '\0';
	Tree->left = MakeTree(Expr,first,k-1);
	Tree->right = MakeTree(Expr,k+1,last);
	return Tree;
}

Если обнаружено число или переменная, сначала вычисляем ее длину и записываем в переменную k.
Для вычисления такого выражения по дереву надо несколько изменить функцию CalcTree с учетом того, что поле данных узла – символьная строка. Для преобразования числа из символьного вида в числовой используем стандартную функцию atoi (для этого надо подключить заголовочный файл stdlib.h).

int CalcTree(PNode Tree)
{
	int num1, num2;
	if(! Tree->left) // если нет потомков,
	return atoi(Tree->data); // раскодировали число
	// ... дальше все то же самое
}

Конечно, для того, чтобы выражение можно было вычислить, оно не должно содержать имен переменных.

    28. Упрощение выражения с помощью дерева
Некоторые выражения можно сразу значительно упростить, используя очевидные тождества, верные для любого x:

	0 + x = x	x + 0 = x	0 * x = 0
	0 - x = - x	x - 0 = x	1 * x = x



Пусть, например, мы нашли такую структуру, как показано на рисунке а. Значение всего первого выражения равно a, поэтому нам надо сделать следующее: указатель p поставить на вершину a, а две ненужные вершины удалить из памяти.
В случае б) аналогично надо указатель p переставить на вершину со значением 0. при этом надо учесть, что второй узел (со значением a) может иметь потомков, которых также надо корректно удалить. Это делается рекурсивно:

void DeleteNode(PNode Tree)
{
	if(Tree == NULL) return;
	DeleteNode(Tree->left);
	DeleteNode(Tree->right);
	delete Tree;
}

Кроме того, если оба сына какой-то вершины являются листьями и содержат числа, такое выражение можно сразу посчитать, также удалив два ненужных узла. Один из вариантов реализации этой операции приведен ниже. Здесь используется функция IsNumber, которая возвращает 1, если узел является листом и содержит число, и 0 в противном случае:

int IsNumber(PNode Tree)
{
	int i = 0;
	if(! Tree)// пустое дерево
		return 0;
	while(Tree->data[i]) // пока не дошли до конца строки
		if(! strchr("0123456789", Tree->data[i++]))
			return 0; // если не нашли цифру, выход
	return 1;
}

Сама процедура вычисления выражения выглядит так:

void Calculate(PNode Tree)
{
	int num1, num2, result = 0;
	if ( ! Tree || // если нельзя вычислить, выход
		! IsNumber(Tree->left) ||
		! IsNumber(Tree->right) )
		return;
	num1 = atoi(Tree->left->data); // получить данные от сыновей
	num2 = atoi(Tree->right->data);
	switch ( Tree->data[0] ) { // выполнить операцию
		case '+': result = num1 + num2; break;
		case '-': result = num1 - num2; break;
		case '*': result = num1 * num2; break;
		case '/': result = num1 / num2; break;
	}
	delete Tree->left; // удалить ненужные поддеревья
	delete Tree->right;
	sprintf(Tree->data, "%d", result);
	Tree->left = NULL;
	Tree->right = NULL;
}

            28.1.1. Дерево игр
Одно из применений деревьев - игры с компьютером. Рассмотрим самый простой пример – игру в крестики-нолики на поле 3 на 3.
Программа должны анализировать позицию и находить лучший ход. Для этого нужно определить оценочную функцию, которая получая позицию на доске и указание, чем играет игрок (крестики или нолики) возвращает число – оценку позиции. Чем она выше, тем более выгодна эта позиция для игрока. Примером такой функции может служить сумма строк, столбцов и диагоналей, которые может занять игрок минус такая же сумма для его противника.
Однако, в этой ситуации программа не ведет просчет вперед и не оценивает позиции, которые могут возникнуть из текущей. Это недостаточно для предсказания исхода игры. Хотя для крестиков-ноликов можно перебрать все варианты и найти выигрышную позицию, большинство игр слишком сложно, чтобы допускать полный перебор.
Выбор хода может быть существенно улучшен, если просматривать на несколько ходов вперед. Уровнем просмотра называется число будущих рассматриваемых ходов. Начиная с любой позиции можно построить дерево возможных позиций, получающихся после каждого хода игры. Для крестиков-ноликов ниже приведено дерево с уровнем просмотра 3 для того случая, когда крестики сделали первый ход в центр доски.




Обозначим игрока, который ходит в корневой позиции (в данном случае – нолики) знаком «плюс», а его соперника – знаком «минус». Попытаемся найти лучший ход для игрока «плюс» в этой позиции. Пусть все варианты следующих ходов были оценены для игрока «плюс». Он должен выбрать такой, в котором оценка максимальная для него.
С другой стороны, как только игрок «плюс» сделает свой ход, игрок «минус» из всех возможных ходов сделает такой, чтобы его оценка с позиции игрока «плюс» была минимальной. Поэтому значение минусового узла для игрока «плюс» равно минимальному из значений сыновей этого узла. Это означает, что на каждом шаге соперники делают наилучшие возможные ходы.
Для того, чтобы выбрать оптимальный ход в корне дерева, надо оценить позицию в его листьях. После этого каждому плюсовому узлу присваивается максимальное из значений его сыновей, а каждому минусовому – минимальное. Такой метод называется методом минимакса, так как по мере продвижения вверх используются попеременно функции максимума и минимума. Общая идея метода состоит в том, чтобы выбрать лучший ход на случай худших (для нас) действий противника. Таким образом, лучшим для ноликов в корневой позиции будет ход в угол.

        1.10. Графы
            28.1.2. Основные понятия
    29. Определения
Во многих жизненных ситуациях старая привычка толкает нас рисовать на бумаге точки, обозначающие людей, города, химические вещества, и показывать линиями (возможно со стрелками) связи между ними. Описанная картинка называется графом.

Граф  -  это совокупность узлов (вершин) и соединяющих их ребер (дуг).

Ниже показаны примеры графов



Если дуги имеют направление (вспомните улицы с односторонним движением), то такой граф называется направленным или ориентированным графом (орграфом).
Цепью называется последовательность ребер, соединяющих две (возможно не соседние) вершины u и v. В направленном графе такая последовательность ребер называется «путь».
Граф называется связным, если существует цепь между любой парой вершин. Если граф не связный, то его можно разбить на k связных компонент – он называется k-связным.
В практических задачах часто рассматриваются взвешенные графы, в которых каждому ребру приписывается вес (или длина). Такой граф называют сетью.
Циклом называется цепь из какой-нибудь вершины v в нее саму.
Деревом называется граф без циклов.
Полным называется граф, в котором проведены все возможные ребра (для графа, имеющего n вершин таких ребер будет n(n-1)/2.

    30. Описание графов
Для описания графов часто используют два типа матриц – матрицу смежности (для невзвешенных графов) и весовую матрицу (для взвешенных).
Матрица смежности графа с N вершинами – это матрица размером N на N, где каждый элемент с индексами (i,j) является логическим значением и показывает, есть ли дуга из вершины i в вершину j.
Часто вместо логических значений (истина/ложь) используют целые числа (1/0). Для неориентированных графов матрица смежности всегда симметрична относительно главной диагонали (рисунок а). Для ориентированных графов (рисунок б) это не всегда так, потому что может существовать путь из вершины i в вершину j и не существовать обратного пути.



Для взвешенных графов недостаточно просто указать, есть ли связь между вершинами. Требуется еще хранить в памяти «вес» каждого ребра, например, стоимость проезда или длину пути. Для этого используется весовая матрица.
Весовая матрица графа с N вершинами – это матрица размером N на N, где каждый элемент с индексами (i,j) равен «весу» ребра из вершины i в вершину j.



            30.1.1. Задача Прима-Краскала
    31. Формулировка задачи
Задача. Дана плоская страна и в ней n городов с известными координатами. Нужно соединить все города телефонной сетью так, чтобы длина телефонных линий была минимальная.

Город будем изображать узлом (точкой). Телефонные линии могут разветвляться только на телефонных станциях, а не в чистом поле. Поскольку требуется линия минимальной общей длины, в ней не будет циклов, потому что иначе можно было бы убрать одно звено цикла и станции по-прежнему были бы связаны. В терминах теории графов эта задача звучит так:

Дан граф с n вершинами; длины ребер заданы матрицей {d ij }, i,j=1..n. Найти набор ребер, соединяющий все вершины графа (он называется остовным деревом) и имеющий минимальную длину

Эта задача – одна из тех немногих, для которых известно точное и несложное решение, причем алгоритм предельно прост.

    32. Жадные алгоритмы
Представим себе зимовщика, которому предоставили некоторый запас продуктов на всю зиму. Конечно, он может сначала съесть все самое вкусное – шоколад, мясо и т.п., но за такой подход придется жестоко расплачиваться в конце зимовки, когда останется только соль и маргарин.
Подобным образом, если оптимальное решение строится по шагам, обычно нельзя выбирать на каждом этапе «самое вкусное» – за это придется расплачиваться на последних шагах. Такие алгоритмы называют жадными.

    33. Решение
Удивительно, но для непростой задачи Прима-Краскала жадный алгоритм дает точное оптимальное решение. Алгоритм формулируется так:

В цикле n-1 раз выбрать из оставшихся ребер самое короткое ребро, которое не образует цикла с уже выбранными.

Как же проследить, чтобы не было циклов? Оказывается очень просто: в самом начале покрасим все вершины в разные цвета и затем, выбрав очередное ребро между вершинами i и j, где i и j имеют разные цвета, перекрасим вершину j и все соединенные с ней (то есть имеющие ее цвет) в цвет i. Таким образом, при выборе ребер, соединяющих вершины разного цвета, цикл не возникнет никогда, а после n-1 шагов все вершины будут иметь один цвет.
Для записи информации о ребрах введем структуру

struct rebro { int i, j; }; // ребро соединяет вершины i и j

причем будем считать, что в паре номер первой вершины i меньше, чем номер второй j.
Приведенная ниже программа действует по следующему «жадному» алгоритму
    • Покрасить все вершины в разные цвета.
    • Сделать n-1 раз в цикле
    • выбрать ребро (i,j) минимальной длины, соединяющее вершины разного цвета;
    • запомнить его в массиве ребер;
    • перекрасить все вершины, имеющие цвет j, в цвет i.
    • Вывести результат.

const int N = 5;
void main()
{
	int D[N][N], Col[N], i, j, k, Dmin, jMin, iMin, col_j;
	rebro Reb[N-1];
	// здесь надо ввести матрицу D
	for ( i = 0; i < N; i ++ ) // покрасить все вершины
		Col[i] = i; // в разные цвета
	for ( k = 0; k < N-1; k ++ ) {
		Dmin = 30000;
		for ( i = 0; i < N-1; i ++ )
			for ( j = i+1; j < N; j ++ )
				if ( Col[i] != Col[j] && // ищем самое короткое ребро,
					D[i][j] < Dmin ) { // не образующее цикла
					Dmin = D[i][j];
					iMin = i;
					jMin = j;
				}
			Reb[k].i = iMin; // запомнить найденное ребро
			Reb[k].j = jMin;
			col_j = Col[jMin];
			for ( i = 0; i < N; i ++ ) // перекрасить все вершины, цвет
				if ( Col[i] == col_j ) // которых совпал с цветом
					Col[i] = Col[iMin]; // вершины jMin
	}
	// здесь надо вывести найденные ребра
}

Дополнительно можно рассчитывать общую длину выбранных ребер, но это не меняет принципиально алгоритм. Этот алгоритм требует памяти порядка n2 (обозначается O(n2 ), то есть при увеличении n в 2 раза объем требуемой памяти увеличивается в 4 раза). Его временная сложность – O(n3 ), то есть при увеличении n в 2 раза время вычислений увеличивается в 8 раз (надо просмотреть O(n3 ) чисел и сделать это n-1 раз).

            33.1.1. Кратчайший путь
    34. Формулировка задачи
Задача. Задана сеть дорог между населенными пунктами (часть из них могут иметь одностороннее движение). Требуется найти кратчайший путь между двумя заданными пунктами.

Обычно задачу несколько расширяют и находят сразу кратчайшие пути от заданной вершины ко всем остальным. В терминах теории графов задача выглядит так:

В сети, где часть дорог имеет одностороннее движение, найти кратчайшие пути от заданной вершины ко всем остальным.

    35. Алгоритм Дейкстры
Ниже описывается алгоритм, предложенный Дейкстрой в 1959 г. Дана матрица {dij } длин дуг между вершинами, если дуги между вершинами i и j нет, то dij =∞. Если сеть образуют n вершин, то для реализации алгоритма требуется три массива длиной n:

    • Массив {ai}, в котором ai =0, если вершина i еще не рассмотрена, и ai =1, если вершина i уже рассмотрена.
    • Массив {bi}, в котором bi  – текущее кратчайшее расстояние от выбранной стартовой вершины x до вершины i.
    • Массив {ci}, в котором ci  – номер предпоследней вершины в текущем кратчайшем пути из выбранной стартовой вершины x до вершины i.

Сам алгоритм состоит из трех этапов: инициализации, основного цикла и вывода результата.

                    35.1.1.1.1. Инициализация
Пусть x – номер выбранной стартовой вершины.
    • Заполним весь массив a значением 0 (пока ни одна вершина не рассмотрена).
    • В i-ый элемент массива b запишем расстояние от вершины x до вершины i (если пути нет, то оно равно ∞, в программе укажем очень большое число).
    • Заполним весь массив c значением x (пока рассматриваем только прямые пути от x к i).
    • Рассмотрим стартовую вершину: присвоим a[x]=1 и c[x]=0 (начало всех путей).

                    35.1.1.1.2. Основной цикл
Среди нерассмотренных вершин (для которых a[i]=0) найти такую вершину j, что расстояние bj – минимальное. Рассмотреть ее:
    • установить a[j]=1 (вершина рассмотрена);
    • сделать для всех вершин k:
    • если путь от вершины x к вершине k через j короче, чем уже найденный кратчайший путь (то есть bj +djk < bk ), то запомнить его: c[k]=j и bk =bj +djk .

    36. Вывод результата
Можно доказать, что в конце такой процедуры массив b, будет содержать кратчайшие расстояния от стартовой вершины x до вершины i (для всех i). Однако хотелось бы еще получить сам оптимальный путь.
Оказывается, массив c содержит всю необходимую информацию для решения этой задачи. Предположим, что надо вывести оптимальный путь из вершины x в вершину i. По построению предпоследняя вершина в этой цепи имеет номер z=c[i]. Теперь надо найти оптимальный путь в вершину z тем же способом. Таким образом, путь «раскручивается» с конца. Когда мы получили z=0, путь закончен, мы вернулись в стартовую вершину. В виде алгоритма это можно записать так:
    • установить z=i;
    • пока c[z] не равно нулю,
    • z=c[z];
    • вывести z.

Для выполнения алгоритма надо n раз просмотреть массив b из n элементов, поэтому он имеет квадратичную сложность O(n2 ).

    37. Пример
Пусть дана сеть дорог, показанная на рисунке справа. Найдем кратчайшие расстояния от вершины 3 до всех остальных вершин. Покажем ход выполнения алгоритма Дейкстры по шагам.



    • Инициализация. В результате этого шага получаем такие матрицы:



    • • Основной цикл. Последовательно массивы преобразуются к виду:














    • Вывод кратчайшего пути. Найдем, например, кратчайший путь из вершины 3 в вершину 8. «Раскручивая» массив c, получаем 8 ←2 ←3.

    38. Алгоритм Флойда-Уоршелла
Если надо только вычислить кратчайшие расстояния между всеми вершинами, но не требуется знать сами кратчайшие маршруты, можно использовать весьма элегантный и простой алгоритм Флойда-Уоршелла:

for (k = 0; k < n; k ++)
for (i = 0; i < n; i ++)
for (j = 0; j < n; j ++)
if ( d[i][j] > d[i][k]+d[k][j] ) {
d[i][j] = d[i][k]+d[k][j];
p[i][j] = p[k][j];
}

Сначала в матрице {dij} записаны расстояние между вершинами напрямую. Затем рассмотрим все пути, которые проходят через первую вершину. Если путь через нее короче, чем напрямую, то заменяем значение в матрице на новый кратчайший путь. В конце элемент матрицы {dij} содержит длину кратчайшего пути из i в j. Каждая строка матрицы {pij} сначала заполняется так, как массив c в алгоритме Дейкстры, а в конце элемент {pij} равен номеру предпоследней вершины для кратчайшего пути из вершины i в вершину j.

            38.1.1. Оптимальное размещение
    39. Задача на минимум суммы
Задача. Имеется n населенных пунктов, в каждом из которых живет pi школьников (i=1,...,n). Надо разместить школу в одном из них так, чтобы общее расстояние, проходимое всеми учениками по дороге в школу, было минимальным.

Эта задача просто решается на основе алгоритма Флойда-Уоршелла. Сначала получаем матрицу минимальных путей из каждой вершины в каждую {dij}. Пусть школа размещается в вершине с номером k. Тогда общее расстояние, которое должны пройти ученики из пункта j по дороге в школу, равно произведению расстояния между вершинами i и j на количество учеников в вершине j, то есть dij pj . Суммируя эти произведения для всех вершин, найдем общее расстояние, которое будут проходить ученики, если школа будет в пункте i. Естественно, надо выбрать такую вершину k, для которой это число будет наименьшим.
Рассмотрим сеть, показанную на рисунке а). Цифры у дуг показывают расстояние между населенными пунктами. Количество учеников в пунктах 1..7 задано числами (80, 100, 140, 90, 60, 50, 40).
На рисунке б) показана матрица длин кратчайших путей. В последнем столбце сосчитано общее расстояние, проходимое учениками, если школа будет в данной вершине. Поскольку надо выбрать наименьшее расстояние, то школу надо размещать в вершине 2.




    40. Минимаксная задача размещения
Имеется n населенных пунктов, в одном из которых надо разместить спецподразделение, которое должно выезжать на вызовы при срабатывании сигнализации на одном из охраняемых объектов. Надо расположить его так, чтобы самый дальний охраняемый объект достигался за минимальное время.
Прежде всего, находится матрица кратчайших путей. Затем в каждой строке i выбирается максимальное число – это будет расстояние до самого отдаленного охраняемого объекта, если пункт полиции разместить в вершине i. Затем выбирается такой пункт j, для которого это число наименьшее.
Более сложной является минимаксная задача, в которой допускается размещать объект на ребрах сети (между пунктами). Для решения этой задачи можно использовать следующие идеи.
Рассмотрим ребро между вершинами i и j. Если расположить пункт полиции на нем, то расстояние от него до другой вершины k не может быть меньше, чем



Вычислив эти величины для всех вершин k, определим максимальную из них. Это число δ0 называется нижней оценкой ребра (i,j), поскольку при любом выборе места для пункта полиции на этом ребре расстояние до самого дальнего объекта не будет меньше  δ0 . Мы уже знаем минимально возможное расстояние до самого дальнего пункта при размещении отряда в одном из городов. Очевидно, имеет смысл рассматривать только те ребра, для которых нижняя оценка не превышает это расстояние.
Для каждого ребра (i,j) с нижней оценкой, меньше уже полученной, сделать следующие операции:
    • найти самую дальнюю вершину k из всех тех вершин, в которые надо ехать через вершину i (то есть dik > djk ) ;
    • найти самую дальнюю вершину l из всех тех вершин, в которые надо ехать через вершину j (то есть dil < djl ) ;
    • вычислить середину расстояния между вершинами k и l; если она попадает на ребро (i,j) и расстояние до самых дальних вершин меньше уже найденного, запомнить это место

Ниже этот алгоритм записан на на языке Си:

minDist = 32767; // большое число
for (i = 0; i < N-1; i ++ )
	for (j = i+1; j < N; j ++ ) { // перебрать все ребра (i,j)
		maxDi = maxDj = 0;
		for (k = 0; k < N; k ++ ) { // перебрать все вершины
			if ( k == i || k == j )
				continue;
			if (D[j,k] < D[i,k])
				if (D[j,k] < maxDj)
					maxDj = D[j,k];
				else
					if (D[j,k] < maxDj)
						maxDj = D[j,k];
		}
		dist = (maxDi + D[i][j] + maxDj) / 2;
		if ( dist < minDist && dist > maxDi &&
			dist < maxDi+D[i][j] ) {
				minDist = dist; // запомнить новый вариант
				...
		}
}

            40.1.1. Задача коммивояжера
    41. Формулировка задачи
Эта знаменитая задача была сформулирована в 1934 г. В области дискретной оптимизации она стала испытательным полигоном, на котором проверяются новые методы. Проблема заключается в том, что эта задача относится к многочисленному классу задач, которые теоретически не решаются иначе, чем перебором.

Задача коммивояжера. Коммивояжер (бродячий торговец) должен выйти из первого города и, посетив по разу в неизвестном порядке города 2,3,...n, вернуться обратно в первый город. В каком порядке надо обходить города, чтобы замкнутый путь (тур) коммивояжера был кратчайшим?

    42. Метод грубой силы
Этот метод предусматривает просто перебор всех вариантов. Сначала нам надо получить некоторую допустимую последовательность обхода вершин. Поскольку первый город (1) зафиксирован, всего таких перестановок будет (n-1)!. Получив очередную перестановку надо найти длину пути и, если она окажется меньше уже найденного кратчайшего пути, ее надо запомнить и перейти к следующей перестановке.
Поскольку нами уже написана процедура получения всех перестановок из целых чисел от 1 до N (см.  Комбинации и перестановки в Рекурсии), имеет смысл ее использовать. Удобно ввести глобальные переменные

int Pmin[N], // лучшая перестановка
	P[N], // текущая перестановка
	Lmin, // минимальная длина
	L,  // текущая длина
	D[N][N];  // матрица расстояний

Основная программа будет инициализировать глобальные переменные, вызывать рекурсивную процедуру построения оптимального пути и распечатывать результат:

void main()
{
	Lmin = 32767; // большое число
	L = 0;
	P[0] = 1; // начальная вершина 1
	Commi(1); // построить тур
	for ( int i = 0; i < N; i ++ ) // вывести результат
		printf("%d ", Pmin[i]);
}

Ниже приведена рекурсивная процедура, решающая задачу коммивояжера, приводится ниже. Текущая длина пути вычисляется последовательно с добавление каждого нового звена.

void Commi( int q ) // q – число уже поставленных вершин
{
	int i, temp;
	if ( q == N ) { // перестановка получена
		if ( L < Lmin ) {
			Lmin = L;
			for ( i = 0; i < N; i ++ ) // запомнить новый минимальный тур
				Pmin[i] = P[i];
		}
		return;
	}
	for ( i = q; i < N; i ++ ) {
		temp = P[q];
		P[q] = P[i];
		P[i] = temp; // P[q] <-> P[i]
		L += D [P[q-1]] [P[q]]; // добавить ребро
		Commi ( q+1 ); // рекурсивный вызов
		L -= D [P[q-1]] [P[q]]; // убрать ребро
		temp = P[q]; P[q] = P[i]; P[i] = temp; // P[q] <-> P[i]
	}
}

Главная трудность такого переборного способа заключается в том, что для больших n (например, для n>20) число комбинаций настолько велико, что перебор нереален.
Однако, часто можно найти такую стратегию перебора, при которой сразу отбрасывается целая группа вариантов, которые заведомо не лучше уже найденного минимального решения. Одним из таких алгоритмов является метод ветвей и границ.

    43. Метод ветвей и границ
Идея этого подхода проста и естественна: если частичная длина пути стала больше длины самого лучшего из уже найденных туров, дальнейшую проверку делать бессмысленно. При этом второй цикл for в процедуре приобретает вид

for ( i = q; i < N; i ++ ) {
	temp = P[q];
	P[q] = P[i];
	P[i] = temp;
	L += D [P[q-1]] [P[q]];
	if ( L < Lmin )
		Commi ( q+1 );
	L -= D [P[q-1]] [P[q]];
	temp = P[q];
	P[q] = P[i];
	P[i] = temp;
}

Все варианты туров можно изобразить в виде дерева с корнем в вершине 1. На первом уровне находятся все вершины, в которые можно идти из вершины 1 и т.д. Если мы получили L>Lmin, то сразу отсекается целая ветка такого дерева.

    44. Алгоритм Литтла
Эффективность метода ветвей и границ очень сильно зависит от порядка рассмотрения вариантов. При удачном выборе стратегии перебора можно сразу же найти решение, близкое к оптимальному, которое позволит «отсекать» очень большие ветви, для которых нижняя оценка больше, чем стоимость уже найденного кратчайшего тура. Литтл с соавторами на основе метода ветвей и границ разработали удачный алгоритм, который позволяет во многих случаях быстро решить задачу коммивояжера.
Идея очень проста – разбить все варианты на классы и получить оценки снизу для каждого класса (оценкой снизу называется такое число, что стоимость любого варианта из данного класса заведомо не может быть ниже него).
Продемонстрируем на примере применение метода Литтла. Пусть есть 6 городов и матрица а) задает стоимость cij проезда из города i в город j. Прочерк означает, что из города i в город i ходить нельзя.



Предположим, что добрый мэр города j постановил выплачивать всем, кто въедет в его город 5 долларов. При этом из каждого элемента j-ого столбца матрицы надо вычесть 5. Так как в каждом туре надо въехать в город j ровно один раз, то все туры подешевеют одинаково, и оптимальный тур останется оптимальным. Так же если мэр города i будет выплачивать 5 долларов каждому выехавшему, из каждого элемента i-ой строки надо вычесть 5. Но все туры подешевеют одинаково, и это снова не повлияет на результат.

Если из всех элементов любой строки или столбца вычесть одинаковое число, то минимальный тур остается минимальным

Теперь вычтем минимальный элемент из каждой строки и каждого столбца матрицы а) (эта операция называется приведением по строкам) и получим матрицу б) (надо вычесть числа 4, 6, 3, 4, 3 и 7 из строк 1-6 соответственно). Затем из каждого столбца вычтем минимальный в нем элемент (числа 2, 1 и 4 из столбцов 2, 4 и 6, соответственно). После такого приведения по столбцам получим матрицу в). Если нам удастся найти минимальный тур в этой матрице, то он же будет минимальным и в исходной, только к его стоимости надо прибавить сумму всех чисел, которые мы вычитали из строк и столбцов, то есть 34. Поскольку в матрице в) нет отрицательных чисел, то стоимость минимального тура в ней больше или равна нулю, поэтому оценка снизу всех туров равна 34.
Теперь начинается основной шаг алгоритма. Выполним оценку нулей следующим образом. Рассмотрим нуль в клетке (1,2) матрицы в). Он означает, что цена перехода из 1 в 2 равна 0. А если мы не пойдем из 1 в 2, то все равно придется въехать в 2 (за цены, указанные в столбце 2 – дешевле всего за 1 из города 6). Также придется выехать из города 1 (за цену, указанную в первой строке – дешевле всего за 0) в город 3. Таким образом, если не ехать из 1 в 2 «по нулю», надо заплатить минимум 1. Это и есть «оценка нуля».
В матрице г) поставлены все оценки нулей, которые не равны нулю. Выберем максимальную из этих оценок (в примере - любой нуль с оценкой 1, например в клетке (1,2)).



Пусть выбрано ребро (1,2). Разобьем все туры на 2 класса – включающие ребро (1,2) и не включающие его. Про второй класс можно сказать, что туры этого класса «стоят» 35 и более – это нижняя граница класса. Чтобы исследовать дальше первый класс, вычеркнем из матрицы г) первую строку и второй столбец – получим матрицу д). Чтобы не было цикла, надо поставить запрет в клетке (2,1). Эту матрицу можно привести на 1 по первому столбцу, таким образом, оценка этого класса – 35. Оценим нули в этой матрице (см. матрицу е)).
Снова выбираем клетку (3,1) с наибольшей оценкой нуля, равной 3. Оценка для класса «без (3,1)» равна 35+3=38. Вычеркиваем строку 3 и столбец 1 и ставим запрет на преждевременное замыкание (2,3) (матрица ж)).



Эта матрица приводится по столбцу 4 на 1. Таким образом, получаем матрицу з) и оценку класса 35+1=36. Нуль с максимальной оценкой 3 находится в клетке (6,5). отрицательный вариант имеет оценку 36+3=39. Для оценки положительно варианта вычеркиваем столбец 5 и строку 6, а также ставим запрет в клетку (5,6). Получим матрицу и), которая неприводима и не увеличивает оценку класса. Далее получаем ветвление по выборы ребра (2,6), отрицательный вариант имеет оценку 36+3=39. Далее вычеркиваем строку 2 и столбец 6 и ставим запрет в клетку (5,3) - получается матрица к). Теперь, когда осталась матрица 2 на 2 с запретами по диагонали, достраиваем тур ребрами (4,3) и (5,4). Мы получили тур 1-2-6-4-3-1 стоимостью в 36. На рисунке показано дерево ветвлений и оценки вариантов.



Теперь можно начать отбрасывать варианты. Все классы, имеющие оценку 36 и выше, лучшего тура не содержат. Поэтому отбрасываем все вершины дерева перебора, имеющие оценку 36 и выше, а также вершины, у которых «убиты» оба потомка. Осталось проверить, не содержит ли лучшего тура класс «без (1,2)». Для этого в приведенной матрице в) поставим запрет в клетку (1,2), приведем столбец 2 на 1 и оценим нули. Полученная матрица л) приведена ниже.



Оценка нулей дает 3 для (1,3), поэтому стоимость отрицательного варианта 35+3=38 превосходит стоимость уже полученного тура и отрицательный вариант отсекается. Для оценки положительного варианта вычеркиваем первую строку и 3-й столбец, ставим запрет в (3,1) и получаем матрицу м). Она приводится по строке 4 на 1, поэтому оценка положительного варианта равна 35+1=36 и этот класс также отбрасывается. Таким образом мы получили минимальный тур.
Хотя теоретических оценок быстродействия этого и подобных алгоритмов не получено, на практике они часто позволяют решить задачи с n=100.

    45. Метод случайных перестановок
Для того, чтобы приближенно решать задачу коммивояжера для больших n, на практике часто используют метод случайных перестановок. В алгоритме повторяются следующие шаги:
    • Выбрать случайным образом номера вершин i и j в перестановке.
    • Если при перестановке вершин с номерами i и j длина пути уменьшилась, такая перестановка принимается.

Такой метод не гарантирует, что будет найдено точное решение, но очень часто позволяет найти приемлемое решение за короткое время в тех случаях, когда другие алгоритмы неприменимы.

            45.1.1. Задача о паросочетаниях
    46. Формулировка задачи
Задача. Есть m мужчин и n женщин. Каждый мужчина указывает несколько (от 0 до n) женщин, на которых он согласен жениться. Каждая женщина указывает несколько мужчин (от 0 до m), за которых она согласна выйти замуж. Требуется заключить наибольшее количество моногамных браков.

Для формулировки задачи в терминах теории графов надо ввести несколько определений.

Двудольным называется граф, все вершины которого разбиты на две доли (части), а ребра проходят только между вершинами разных частей.
Паросочетанием называется множество ребер, не имеющих общих вершин.

Таким образом, эта задача равносильна следующей:

Задача о наибольшем паросочетании. В заданном двудольном графе найти наибольшее паросочетание.

Для описания графа введем матрицу возможных браков A={aij}, где aij =1, если возможен брак между мужчиной i (i=1..m) и женщиной j (j=1..n) (оба согласны) и aij =0, если брак невозможен.

    47. Достижимость вершин в графе
Для начала решим вспомогательную задачу, которая понадобится в дальнейшем.

Задача о достижимости. Найти, какие вершины достижимы в заданном ориентированном графе из данной вершины s.

Эта задача решается с помощью алгоритма, очень похожего на алгоритм Дейкстры. Заведем три вспомогательных массива Q, R и P размером n, где n – число вершин:
    • в массив Q будем записывать номера вершин в порядке их просмотра (начиная с s);
    • в массиве R элемент Ri =1, если уже найден путь из s в i, и Ri =0, если ни один путь не найден;
    • в массиве P элемент Pi есть номер предпоследней вершины на пути от s к i, или Pi =-1,
    • если ни один путь не найден.

Две переменные a и z обозначают начало и конец «рабочей области» массива Q. Теперь можно привести алгоритм. Он состоит из двух частей.

                    47.1.1.1.1. Инициализация
Начать с вершины s, ни одна из вершин не рассмотрена:
    • Присвоить a=0; z=0; Q[0]=s;
    • Для всех i присвоить R[i]=0, P[i]=-1;

                    47.1.1.1.2. Общий шаг
В цикле рассмотреть все вершины орграфа, которые достижимы непосредственно из Q[a]. Если путь до вершины k еще не был найден (то есть Rk =0), сделать
    • z ++; Q[z] = k; P[k] = Q[a]; R[k] = 1;
    • a ++;
Повторять общий шаг пока a <= z.

Покажем работу алгоритма на примере. Найти вершины данного графа, достижимые из вершины 1.



Последовательно имеем

Рассмотрена вершина 2:
    • Q = {1, 2}
    • R = [0, 1, 0, 0, 0, 0, 0]
    • P = [-1, 1, -1, -1, -1, -1, -1]

Рассмотрены вершины 3 и 4:
    • Q = 1, 2, {3, 4}
    • R = [0, 1, 1, 1, 0, 0, 0]
    • P = [-1, 1, 2, 2, -1, -1, -1]

Рассмотрена вершины 5:
    • Q = 1, 2, 3, 4, {5}
    • R = [0, 1, 1, 1, 1, 0, 0]
    • P = [-1, 1, 2, 2, 4, -1, -1]

После этого новых достижимых вершин нет, рабочая зона массива Q (в фигурных скобках) закончилась.
Массив P можно «раскрутить» как в алгоритме Дейкстры. Например, вершина 5 достижима из 4, вершина 4 – из 4, а 2 – из 1, поэтому существует путь 1–2–4–5.

    48. Метод чередующихся цепей
Задача о наибольшем паросочетании решается методом чередующихся цепей. Пусть M – некоторое паросочетание в двудольном графе B. Ребра, которые входят в M, будем обозначать толстыми линиями, а все остальные – тонкими. Цепь, в которую входят поочередно жирные и тонкие ребра, будем называть чередующейся. Например, цепь (1, 6, 2, 8) – чередующаяся. По определению цепь из одного ребра тоже чередующаяся.



Вершины, которые связаны с жирными ребрами (участвующими в паросочетании), называются занятыми или насыщенными). Остальные вершины называются свободными или ненасыщенными.
Очевидно, что если в графе есть цепь, которая начинается и заканчивается на свободной вершине, то в ней тонких ребер на 1 больше, чем жирных. Поэтому такую цепь можно «перекрасить», то есть заменить все жирные ребра тонкими и наоборот. При этом пар станет на 1 больше, то есть решение улучшится. Такая цепь называется увеличивающейся.
Можно доказать, что паросочетание является наибольшим тогда и только тогда, когда в графе нет увеличивающихся цепей. На этой идее основан следующий алгоритм.
    • Построим начальное паросочетание «жадным» алгоритмом: будем брать по очереди незанятые вершины первой части и, если существует допустимое ребро, вводить его, не думая о последствиях.
    • Строим ориентированный граф так: все дуги, вошедшие в паросочетание («жирные») направляем вверх, а все остальные – вниз.
    • Просматриваем все свободные вершины первой части. Если среди достижимых вершин есть незанятая вершина из второй части, то есть увеличивающаяся цепь. Ее надо увеличить и перейти снова к пункту 2.
    • Если увеличивающихся цепей нет, получено наибольшее паросочетание.

Например, граф на рисунке а) (паросочетание получено «жадным» алгоритмом) после введения ориентации принимает вид б).



Из свободной вершины 5 достижимы вершины 7, 3, 4, 9 и 10, причем из них вершина 10 свободна, то есть существует увеличивающаяся цепь (5, 9, 4, 7, 3, 10). После ее увеличения получаем наибольшее паросочетание (рисунок в).

        1.11. Примеры динамических структур данных

            48.1.1. Односвязный список

    49. Пример #01. Односвязный список
http://blog.kislenko.net/show.php?id=1454

Напишем небольшую демо-программу, которая позволит нам прочитать данные списка и показать его на экране. Записи для списка будут браться из файла data.txt, расположенного в текущей папке и имеющего простой формат "одна строка – одна запись", например, такого:

Ivanov 5 4 4 5
Petrov 3 4 4 3
Ivanov 5 4 4 5

#define _CRT_SECURE_NO_WARNINGS
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <locale.h>

//using namespace std;

#define MAX 30 /* максимальная длина фамилии */

struct student {
 unsigned char f[MAX];
 int ekz[4];
 student *next;
};

int show (student *head) {
 int count=0;
 while (1) {
  //вывести данные очередного узла
  printf ("\n%s", head->f);
  for (int i=0; i<4; i++)  printf (" %d",head->ekz[i]);
  count++;
  //проверка на конец списка
  if (head->next == NULL) break;
  //переход к следующему узлу
  head = head->next;
 }
 printf ("\nAll=%d",count);
 return count;
}

student *search (student *head, char *st) {
 if (head==NULL) return NULL; //список пуст
 student *next = head;
 st=_strlwr((char *)st); //чтобы поиск не зависел от регистра символов
 do {
  char *find = strstr (strlwr((char *)next->f), st);
  if (find!=NULL) return next;
  if (next->next==NULL) break;
  next = next->next;
 } while (1);
 return NULL; //не найдено
}

student *exclude (student *head, char *f) {
 if (head==NULL) return NULL;
 student *current = head, //текущая запись
         *start = head, //начало списка
         *prev = NULL; //предыдущая запись
 while (current) {
  if (stricmp((char *)current->f,f)==0) {
   if (prev) prev->next = current->next;
   else start=current->next;
   free(current); //1
   break; //2
  }
  prev = current;
  current = current->next;
 }
 return start;
}

void copy0(student *to, student *from) {
 strcpy ((char *)to->f,(char *)from->f);
 for (int i=0; i<4; i++) to->ekz[i]=from->ekz[i];
}

student *add1 (student *head,student *st) {
 student *current = (student *) malloc (sizeof(student));
 copy0 (current,st);
 if (head==NULL) current->next=NULL;
 else {
  current->next = head;
  head = current;
 }
 return current;
}

student *add2 (student *head,student *st) {
 student *last=NULL;
 if (head) {
  last=head;
  while (last->next) last=last->next;
 }
 student *current = (student *) malloc (sizeof(student));
 copy0 (current,st);
 current->next=NULL;
 if (last) last->next = current;
 return current;
}

int check (student *head, char *s) {
 while (head) {
  if (stricmp((char *)head->f,s)==0) return 1;
  head = head->next;
 }
 return 0;
}

student *sort (student *ph) {
 student *q,*out=NULL,*p,*pr; //out - выход - сначала пуст
 while (ph !=NULL) { //пока не конец входного списка
  q = ph; ph = ph->next; //исключить очередной элемент
  for (p=out,pr=NULL;
       p!=NULL && stricmp((char *)q->f,(char *)p->f)>0;
       pr=p,p=p->next) ;
   //ищем, куда включить очередной элемент - тут stricmp
   //задает критерий сравнения элементов, в вашей задаче м.б. другой
  if (pr==NULL) { q->next=out; out=q; } //включение в начало
  else { q->next=p; pr->next=q; } //или после предыдущего
 }
 return out;
}

int main (void) {
 setlocale(LC_ALL, "Rus");
 FILE *f=fopen("data.txt","rt");
 if (f==NULL) {
  printf ("\nFile data.txt not found"); exit(1);
 }
 char buf[40]; //буфер
 student *current = NULL, //текущий элемент
  *prev = NULL, //есть ли предыдущий?
  *head; //начало списка
 do {
  fgets (buf, 40, f);
  if (strlen(buf)<10) continue; //Убираем слишком короткие строки
  if (current!=NULL) prev=current; //если был тек.эл-т, запомнили его
  current = (student *) malloc(sizeof(student));
  if (current==NULL) {
   printf ("\nNo memory"); exit(2);
  }
  current->next = NULL; //добавляемый эл-т пометили как последний
  if (prev!=NULL) prev->next = current;
    //Если добавляемый эл-т current не первый,
    //предыдущий эл-т заставили показывать на него
  else head = current;
    //Иначе запомнили, что он – начало списка
  sscanf (buf,"%s %d %d %d %d",current->f,
   &current->ekz[0], &current->ekz[1],
   &current->ekz[2], &current->ekz[3]);
 } while (!feof(f));
printf ("\nЧтение записей из файла и внесение их в список"); //
 show (head);

 printf ("\n\nДобавление записи вначало и конец списка"); //
 student test1 = {"Popova",4,4,4,4};
 head=add1 (head,&test1);
 student test2 = {"Vasilenko",5,5,5,4};
 add2 (head,&test2);
 show (head);

 printf ("\n\nПроверка записи в списке"); //
 printf ("\n%d- запись \"%s\" есть ",check(head,(char *)test1.f), test1.f); //1
 printf ("\n%d - записи \"NeponyatnoKto\" нет",check(head,"NeponyatnoKto")); //0

 printf ("\n\nСортированый список"); //
head = sort (head);
show (head);
 fclose (f);

 fflush (stdin);
 getchar ();
 return 0;
}



    50. Пример #02. Односвязный список

/* Процедурно-ориентированная реализация односвязного списка */

#define _CRT_SECURE_NO_WARNINGS
struct list {
 struct list * next;
 int   info;    
};

#include <locale.h>
#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <string.h>
#include <malloc.h>

/* INPUT_info() - ввод с клавиатуры информации */
int input_info(struct list * ptr) {
 fflush(stdin);
 scanf("%d", &(ptr -> info));
 return ptr->info;
}

/* PRINTON() - Вывод информации на экран. Возвращает
   указатель на следующий элемент списка. */
struct list * printOn(struct list * ptr) {
  printf("%d ", ptr -> info);
  return (ptr -> next);
}

/* DISPLAY() - Выводит информацию во всех элементах списка.
   Сканирует список от начала в конец. Возвращает указатель на
   последний элемент. */
struct list * display(struct list * head) {
 struct list * ret;
 if (head == NULL) { /* если список пуст */
  puts("Список пуст");
  return NULL;
 }
 do {
  printOn(head);
  ret = head;
  head = head -> next;
 } while(head  != NULL);
 return (ret);
}

/* DESTROY() - Освобождает память, выделенную под элемент списка. */
void destroy(struct list * element) {
 free(element);
}

/* HASMEMBER() - Проверяет, есть ли в списке, элемент с
   идентичными полями.  Список сканируется от начала в конец. */
int hasMember(struct list * head, struct list * work) {
 while(head != NULL) { /* цикл сканирования списка */
  if (head->info  == work -> info) return 1;
  head = head -> next;
 }
 return(0);
}

/* ADD() - Помещает элемент new_ptr в список head в порядке
   возрастания чисел (поля info). */
int add(struct list ** head, struct list * new_ptr) {
  struct list * first, * second;
  if ((*head) == NULL) { /* если список пуст */
   (* head) = new_ptr;
   new_ptr -> next = NULL;
   return 0;
  }
  if ((*head) -> next == NULL) { /* если в нем всего один элемент */
   if( (*head) -> info >  new_ptr -> info) {
    /* новый элемент становится первым в списке */
    second = (*head); /* сохраним указатель на второй */
    (*head) = new_ptr;
    new_ptr -> next = second;
    second -> next = NULL;
   }
   else { /* новый элемент становится в конец списка */
    (*head) -> next = new_ptr;
    new_ptr -> next = NULL;
   }
   return 1;
  }
  else {
   if ( (*head) -> info > new_ptr -> info) {
    /* новый эл-т ставится первым в списке */
    second = (*head); /* сохраним указатель на второй */
    (*head) = new_ptr;
    new_ptr -> next = second;
    return 4;
   }
   first  = (* head);
   second = first -> next;
   while (first -> next != NULL) { /* цикл поиска места в списке  */
    if ( first  -> info <= new_ptr -> info &&
	 second -> info >= new_ptr -> info) {
     /* вставляем элемент между first и second */
     first -> next   = new_ptr;
     new_ptr -> next = second;
     return 2;
    }
    first = second;
    second = first -> next;
   }
   /* если добрались сюда, элемент ставим в конец списка */
   first -> next    = new_ptr;
   new_ptr  -> next = NULL;
   return 3;
  }
}

/* DETACH() - Удаляет элемент element из списка head */
void detach(struct list ** head, struct list * element) {
 struct list * prev;
 if(* head == NULL) return; /* если список пуст */
 if((*head) == element) { /* если удаляемый эл-т - первый       */
  (* head) = element -> next;
  destroy(element);
  return;
 }
 /* Цикл поиска предыдущего для element элемента. */
 prev = (* head);
 while((prev -> next) != element)
  prev = prev -> next; /* на выходе из цикла - адрес предыдущ*/
 prev -> next = element -> next;
 destroy(element);
 return;
}

int main(void) {
 char ch;
 struct list * head;   /* указатель на начало списка          */
 struct list * new_ptr;/* указатель на новый элемент списка   */
 struct list * cur;    /* указатель на текущий элемент списка */
 struct list work;
 setlocale(LC_ALL, "Rus");
 head = NULL;          /* вначале список пуст                 */
 //setlocale(LC_ALL,"Rus"); SetConsoleCP(1251); SetConsoleOutputCP(1251);
 puts ("Вводите целые числа для списка, 0 - завершение ввода");
 while(input_info(&work) != 0) { /* цикл ввода описаний */
  if (hasMember(head, &work) != 1) {
   if((new_ptr = (struct list *)malloc(sizeof(struct list))) == NULL) {
    puts("Прием информации завершен: нет памяти");
    break;
   }
   new_ptr -> info = work.info;/* копируем введен. информацию */
   add(&head, new_ptr);   /* добавляем элемент в список  */
  }
 }
 if (head == NULL)              /* список остался пустым ?     */
  return 1;                  /* да, завершение программы    */
 puts("*** СВЯЗАННЫЙ СПИСОК ПОСЛЕ ЗАВЕРШЕНИЯ ВВОДА ***");
 display(head);                /* вывод всех элем-тов списка  */
 /* Цикл выборочного удаления элементов, начиная с первого. */
 cur = head;
 printf ("\n");
 puts("*** ВЫБОРОЧНОЕ УДАЛЕНИЕ ЭЛЕМЕНТОВ СПИСКА ***");
 do {
  new_ptr = printOn(cur);  /* вывод элемента списка       */
  printf("Удаляете элемент ? (Y/N) ");
  if ((ch = getch()) == 'Y' || ch == 'y') {
   puts("Yes");
   detach(&head, cur);   /* удаление элемента из спсика */
  }
  else puts("No");
  cur = new_ptr;
 }
 while(new_ptr != NULL);
  puts("*** СВЯЗАННЫЙ СПИСОК ПОСЛЕ ВЫБОРОЧНОГО УДАЛЕНИЯ ***");
 display(head);                /* вывод всех элем-тов списка  */
 fflush (stdin); getchar();
 return 0;
}



            50.1.1. Двухсвязный список

    51. Пример #01. Двухсвязный список

/* Процедурно-ориентированная реализация двусвязных списков
   Элемент списка - динамическая строковая переменная
*/
#define _CRT_SECURE_NO_WARNINGS
#include <locale.h>
#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <string.h>
#include <malloc.h>

typedef struct list {
 list *next, *prev;
 char *info;
};
char buffer[80];

char *input_info(list *ptr) {
 fflush(stdin);
 scanf("%s", &buffer[0]);
 if (buffer[0]=='0') return NULL;
 ptr->info=(char *)malloc((strlen(buffer)+1)*sizeof(char));
 if (ptr->info == NULL) {
  puts("Прием информации завершен: нет памяти");
  return NULL;
 }
 strcpy (ptr->info,buffer);
 return ptr->info;
}

list * printOn(list * ptr) {
  printf("\n%s", ptr -> info);
  return (ptr -> next);
}

list * display(list * head) {
 list * ret;
 printf ("\n");
 if (head == NULL) { /* если список пуст */
  puts("Список пуст");
  return NULL;
 }
 do {
  printOn(head);
  ret = head;
  head = head -> next;
 } while(head  != NULL);
 printf ("\n");
 return (ret);
}

void destroy (list *element) {
 free (element->info);
 free (element);
}

int hasMember (list * head, list * work) {
 while(head != NULL) {
  if (!strcmpi (head->info,work->info)) return 1;
  head = head -> next;
 }
 return 0;
}

int add(list ** head, list * new_ptr) {
  list * first, * second;
  if ((*head) == NULL) { /* если список пуст */
   (* head) = new_ptr;
   new_ptr->next = NULL;
   new_ptr->prev = NULL;
   return 0;
  }
  if ((*head) -> next == NULL) { /* если в нем всего один элемент */
   if (strcmpi((*head)->info,new_ptr->info)>0) {
    /* новый элемент становится первым в списке */
    second = (*head); /* сохраним указатель на второй */
    (*head) = new_ptr;
    new_ptr -> next = second;
    new_ptr -> prev = NULL;
    second -> next = NULL;
    second -> prev = new_ptr;
   }
   else { /* новый элемент становится в конец списка */
    (*head) -> next = new_ptr;
    (*head) -> prev = NULL;
    new_ptr -> next = NULL;
    new_ptr -> prev = new_ptr;
   }
   return 1;
  }
  else {
   if ( strcmpi((*head)->info,new_ptr->info)>0) { /* новый эл-т ставится первым в списке */
    second = (*head);
    (*head) = new_ptr;
    new_ptr -> next = second;
    new_ptr -> prev = NULL;
    second -> prev = new_ptr;
    return 4;
   }
   first  = (* head);
   second = first -> next;
   while (first -> next != NULL) { /* цикл поиска места в списке  */
    if ( (strcmpi(first->info,new_ptr->info)<0) &&
       	 (strcmpi(second->info,new_ptr->info)>0) ) {
     /* вставляем элемент между first и second */
     first->next   = new_ptr;
     second->prev= new_ptr;
     new_ptr->next = second;
     new_ptr->prev = first;
     return 2;
    }
    first = second;
    second = first->next;
   }
   /* если добрались сюда, элемент ставим в конец списка */
    first->next=new_ptr;
   first->prev=second;
    new_ptr->next = NULL;
   new_ptr->prev=first;
   return 3;
  }
}

/* DETACH() - Удаляет элемент element из списка head */
void detach(list ** head, list * element) {
 list * prev;
 if(* head == NULL) return; /* если список пуст */
 if((*head) == element) { /* если удаляемый эл-т - первый       */
  (* head) = element -> next;
  destroy(element);
  return;
 }
 /* Цикл поиска предыдущего для element элемента. */
 prev = (* head);
 while((prev -> next) != element)
  prev = prev -> next; /* на выходе из цикла - адрес предыдущ*/
 prev -> next = element -> next;
 destroy(element);
 return;
}

int main(void) {
 char ch;
 list * head;   /* указатель на начало списка          */
 list * new_ptr;/* указатель на новый элемент списка   */
 list * cur;    /* указатель на текущий элемент списка */
 list work;
 head = NULL;          /* вначале список пуст                 */

 setlocale(LC_ALL,"Rus");// SetConsoleCP(1251); SetConsoleOutputCP(1251);
 puts ("Вводите строки для списка, 0 - завершение ввода");

 while(input_info(&work) != NULL) { /* цикл ввода описаний */
  if (hasMember(head, &work) != 1) {
   new_ptr = (list *)malloc(sizeof(list));
   if (new_ptr == NULL) {
    puts("Прием информации завершен: нет памяти");
    break;
   }
   new_ptr->info = work.info;/* копируем введен. информацию */
   add(&head, new_ptr);   /* добавляем элемент в список  */
   //display (head);
  }
  else {
   puts("Элемент уже есть в списке");
  }
 }
 if (head == NULL)              /* список остался пустым ?     */
  return 1;                  /* да, завершение программы    */
 //puts("*** СВЯЗАННЫЙ СПИСОК ПОСЛЕ ЗАВЕРШЕНИЯ ВВОДА ***");
 printf("\n*** СВЯЗАННЫЙ СПИСОК ПОСЛЕ ЗАВЕРШЕНИЯ ВВОДА ***");
 display(head);                /* вывод всех элем-тов списка  */
 /* Цикл выборочного удаления элементов, начиная с первого. */
 cur = head;
 //puts("\n*** ВЫБОРОЧНОЕ УДАЛЕНИЕ ЭЛЕМЕНТОВ СПИСКА ***");
 printf("\n*** ВЫБОРОЧНОЕ УДАЛЕНИЕ ЭЛЕМЕНТОВ СПИСКА ***");
 do {
  new_ptr = printOn(cur);  /* вывод элемента списка       */
  printf(" Удаляете элемент ? (Y/N) ");
  if ((ch = getch()) == 'Y' || ch == 'y') {
   //puts("Yes");
	printf("Yes");
   detach(&head, cur);   /* удаление элемента из спсика */
  }
  else
	printf("No");
	  //puts("No");
  cur = new_ptr;
 }
 while(new_ptr != NULL);
  //puts("*** СВЯЗАННЫЙ СПИСОК ПОСЛЕ ВЫБОРОЧНОГО УДАЛЕНИЯ ***");
  printf("\n*** СВЯЗАННЫЙ СПИСОК ПОСЛЕ ВЫБОРОЧНОГО УДАЛЕНИЯ ***");
 display(head);                /* вывод всех элем-тов списка  */
 fflush (stdin); getchar();
 return 0;
}







            51.1.1. Стек

    52. Cтек #01
Стек (или динамический список LIFO) использует 4 функции (main, Добавить в список, Показать список, Удалить список из памяти)

#include <iostream>
using namespace std;

/*НАША СТРУКТУРА*/
struct List
{
    int x; //информационный элемент
    List *Next,*Head; //Голова стека и указатель на следующий элемент
};

/*ФУНКЦИЯ ДОБАВЛЕНИЯ ЭЛЕМЕНТА В СТЕК (в список LIFO)*/
void Add(int x, List *&MyList)  //Принимаем элемент стека и указатель на стек,
								//при этом говорим, что принимаемый указатель будет сам по себе указателем
{
    List *temp=new List; //Выделяем память для нового элемента
    temp->x=x; //Записываем в поле x принимаемый в функцию элемент x
    temp->Next=MyList->Head; //Указываем, что следующий элемент это предыдущий
    MyList->Head=temp; //Сдвигаем голову на позицию вперед
}

/*ФУНКЦИЯ ОТОБРАЖЕНИЯ СТЕКА*/
void Show(List *MyList) //Нужен только сам стек
{
    List *temp=MyList->Head; //Объявляем указатель и Указываем ему, что его позиция в голове стека
    //с помощью цикла проходим по всему стеку
    while (temp!=NULL){ //выходим при встрече с пустым полем
		cout<<temp->x<<" "; //Выводим на экран элемент стека
		temp=temp->Next; //Переходим к следующему элементу
    }
}

/*ФУНКЦИЯ УДАЛЕНИЯ СТЕКА ИЗ ПАМЯТИ*/
void ClearList(List *MyList)
{
    while (MyList->Head!=NULL){ //Пока по адресу не пусто
		List *temp=MyList->Head->Next; //Временная переменная для хранения адреса следующего элемента
		delete MyList->Head; //Освобождаем адрес обозначающий начало
		MyList->Head=temp; //Меняем адрес на следующий
	}
}

int main()
{
	setlocale(LC_ALL, "Rus");
    List *MyList=new List; //Выделяем память для стека
    MyList->Head=NULL; //Во избежание ошибок инициализируем первый элемент
    for (int i=0;i<10;i++)
		Add(i,MyList); //Заносим данные в стек
	cout<<"В стеке записано:\n"; //Выводим на экран элемент стека
	Show(MyList); //Выводим стек на экран
    ClearList(MyList); //Очищаем память.
	cout<<"\n";
	system("PAUSE");
	delete MyList->Head;
    delete MyList;
}



    53. Cтек #02

#include <iostream>
using namespace std;

struct stek
{
    int value;
    struct stek *next; // указатель на следующий элемент списка (стека)
};

void push(stek* &NEXT, const int VALUE)
{
    stek *MyStack = new stek; // объявляем новую динамическую переменную типа stek
    MyStack->value = VALUE; // записываем значение, которое помещается в стек
    MyStack->next = NEXT; // связываем новый элемент стека с предыдущим
    NEXT = MyStack; // новый элемент стека становится его вершиной
}

int pop(stek* &NEXT)
{
    int temp = NEXT->value; // извлекаем в переменную temp значение в вершине стека
    stek *MyStack = NEXT; // запоминаем указатель на вершину стека, чтобы затем
    // освободить выделенную под него память
    NEXT = NEXT->next; // вершиной становится предшествующий top элемент
    delete MyStack; // освобождаем память, тем самым удалили вершину
    std::cout<<temp; //Вывод текущего элемента на экран
    return temp; // возвращаем значение, которое было в вершине
}

int main()
{
	setlocale(LC_ALL, "Rus");
	stek *p=0;
    push(p,100); //Положили в стек 100
	cout << "Положили в стек 100\n"; //
	push(p,200); //Положили в стек 200
	cout << "Положили в стек 200\n"; //
	cout << "Достали из стека: "; //
    pop(p); //вывели на экран текущий элемент стека = 200
	cout << "\n";
	cout << "Достали из стека: "; //
    pop(p); //вывели на экран текущий элемент стека = 100
	cout << "\n";
	system("PAUSE");
    return 0;
}



    54. Cтек #03
http://younglinux.info/c/stack

#include <stdio.h>
#include <stdlib.h>
#include <iostream>
using namespace std;

struct stack {
       int data;
       struct stack *next;
};

struct stack *create(struct stack *, int); // присоединение элемента к голове, возврат адреса головы
void list(struct stack *); // просмотр стека

void main() {
       int i, n;
       struct stack *head; // адрес, указывающий на голову стека
		setlocale(LC_ALL, "Rus");
		head = NULL;
		cout << "Элементы стека через 5: "; //

       scanf("%d", &n);
	   cout << "В стек: \n"; //
       for (i=0; i <= n; i+=5) {
           head = create(head,i);
           printf("%d<--", head->data);
       }
       printf("\n");
	   cout << "\nИз стека: \n"; //
       list(head);
       free(head);
	   system("PAUSE");
}

struct stack *create(struct stack *head, int x) {
       struct stack *element; // указатель на новую структуру
       element = (struct stack *)malloc(sizeof(struct stack)); // выделяем память
       element->next = head;
       element->data = x;
       return element;
}

void list(struct stack *p){
     while (p != NULL) { // пока не конец стека  
           printf("%d-->", p->data);
           p = p->next; // продвижение по списку
     }
     printf("\n");
}



    55. Cтек #04
http://blog.kislenko.net/show.php?id=1454

/*
   Процедурно-ориентированная реализация стека
*/
#define _CRT_SECURE_NO_WARNINGS
#include <locale.h>
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <malloc.h>

typedef struct STACK {
 STACK * next;
 int info;
};

/* Из реализации списка в list1.cpp */
int input_info(STACK * ptr) {
 fflush(stdin);
 scanf("%d", &(ptr -> info));
 return ptr->info;
}

STACK * printOn(STACK * ptr) {
  printf("%d ", ptr -> info);
  return (ptr -> next);
}

STACK * display (STACK * head) {
 STACK * ret;
 if (head == NULL) { /* если список пуст */
  puts("Список пуст");
  return NULL;
 }
 do {
  printOn(head);
  ret = head;
  head = head -> next;
 } while(head  != NULL);
 return (ret);
}

/* Извлечь элемент с вершины стека */
STACK * pop(STACK ** head) {
 STACK * current;
 if ((*head) == NULL) /* если список пуст                      */
  return NULL;
 current = (* head);
 if (current -> next == NULL) /* если всего один элемент      */
  (* head) = NULL;
 else
  (*head)  = current -> next;
 return current;
}

/* Взять элемент с вершины, не извлекая его */
STACK * peek(STACK ** head) {
 if ((*head) == NULL) /* если список пуст                      */
  return NULL;
 else return (* head);
}

/* Добавить элемент на вершину стека */
void push (STACK ** head, STACK * newitem) {
 STACK * old_head;
 if ((* head) == NULL) { /* список пуст                          */
  (* head) = newitem ;
  newitem -> next = NULL;
 }
 else {
  old_head = (* head);
  (* head) = newitem;
  newitem -> next = old_head;
 }
}

int main(void) {
 STACK * head;  /* указатель на вершину стека                 */
 STACK * newitem;   /* элемент стека                              */
 STACK work;
 head = NULL;   /* вначале стек пуст                          */
 setlocale(LC_ALL,"Rus"); //SetConsoleCP(1251); SetConsoleOutputCP(1251);
 puts ("Вводите целые числа в стек, 0 - завершение ввода");

 while (input_info (&work) != 0) { /* цикл ввода описаний */
  if ((newitem = (STACK *)malloc(sizeof(STACK))) == NULL) {
   puts("Прием информации завершен: нет памяти");
   break;
  }
  newitem -> info = work.info;      /* копируем введен. информацию */
  push(&head, newitem);        /* добавляем элемент */
 }
 if (head == NULL)             /* список остался пустым ?     */
  return 1;                 /* да, завершение программы    */
 puts("\n*** СТЕК ПОСЛЕ ЗАВЕРШЕНИЯ ВВОДА ***");
 display(head);                /* вывод всех элем-тов списка  */
 /* Цикл чтения/удаления элементов очереди, начиная с вершины */
 puts("\n*** ПОЭЛЕМЕНТНОЕ ЧТЕНИЕ ЭЛЕМЕНТОВ СТЕКА PEEK+POP ***");
 while((newitem = peek(&head)) != NULL) {
  printOn(newitem);              /* вывод элемента очереди      */
  pop(&head);
  free(newitem);
 }
 puts("\n*** СТЕК ПОСЛЕ ЧТЕНИЯ ЭЛЕМЕНТОВ ***");
 display(head);                /* вывод всех элем-тов списка  */

 STACK n,n2;
 n.info=111; n2.info=222; push(&head, &n); push(&head, &n2);
 puts("\n*** СТЕК ПОСЛЕ НОВОГО ДОБАВЛЕНИЯ 2 ЭЛЕМЕНТОВ ПРОГРАММНО ***");
 display(head);

 fflush (stdin); getchar();
 return 0;
}




            55.1.1. Очередь

    56. Очередь #01
http://blog.kislenko.net/show.php?id=1454

/*
   Процедурно-ориентированная реализация очереди
*/
#define _CRT_SECURE_NO_WARNINGS
#include <locale.h>
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <malloc.h>

typedef struct QUEUE {
 QUEUE * next;
 int info;
};

int input_info(QUEUE * ptr) {
 fflush(stdin);
 scanf("%d", &(ptr -> info));
 return ptr->info;
}

QUEUE * printOn(QUEUE * ptr) {
  printf("%d ", ptr -> info);
  return (ptr -> next);
}

QUEUE * display (QUEUE * head) {
 QUEUE * ret;
 if (head == NULL) { /* если список пуст */
  puts("Список пуст");
  return NULL;
 }
 do {
  printOn(head);
  ret = head;
  head = head -> next;
 } while(head  != NULL);
 return (ret);
}

/* получить элемент из очереди */
QUEUE * get(QUEUE ** head) {
 QUEUE * current, * previous;
 if((*head) == NULL) 	/* если список пуст */
  return NULL;
 if ((* head) -> next == NULL) {	/* если всего один элемент  */
  current = (* head);
  (* head) = NULL;
  return current;
 }
 previous  = (* head);
 current = previous -> next;
 while (current -> next != NULL) { /* цикл поиска конца    */
  previous = current;
  current = previous -> next;
 }
 previous -> next  = NULL;
 return current;
}

/* поместить элемент в очередь */
void put(QUEUE ** head, QUEUE * newitem) {
 QUEUE * old_head;
 if ((* head) == NULL) { /* список пуст */
  (* head) = newitem;
  newitem -> next = NULL;
 }
 else {
  old_head = (* head);
  (* head) = newitem;
  newitem -> next = old_head;
 }
}

int main(void) {
 QUEUE * head; 		/* указатель на начало списка       */
 QUEUE * newitem;	/* элемент очереди                  */
 QUEUE work;
 head = NULL;       /* вначале список пуст              */

 setlocale(LC_ALL,"Rus"); //SetConsoleCP(1251); SetConsoleOutputCP(1251);
 puts ("Вводите целые числа в очередь, 0 - завершение ввода");

 while(input_info(&work) != 0)	{ /* цикл ввода описаний              */
  if ((newitem = (struct QUEUE *)malloc(sizeof(struct QUEUE))) == NULL) {
   puts("Прием информации завершен: нет памяти");
   break;
  }
  newitem -> info = work.info;	     /* копируем введен. информацию */
  put(&head, newitem); 	     /* добавляем элемент в очередь */
 }
 if(head == NULL)	/* список остался пустым ?  */
  return 1;  		/* да, завершение программы */
 puts("\n*** ОЧЕРЕДЬ ПОСЛЕ ЗАВЕРШЕНИЯ ВВОДА ***");
 display(head);	/* вывод всех элементов списка  */
 /* Цикл чтения/удаления элементов очереди, начиная с первого
    пришедшего в очередь.
 */
 puts("\n*** ПОЭЛЕМЕНТНОЕ ЧТЕНИЕ ЭЛЕМЕНТОВ ОЧЕРЕДИ ***");
 while((newitem = get(&head)) != NULL) {
  printOn(newitem);		/* вывод элемента очереди   */
  free(newitem);
 }
 puts("\n*** ОЧЕРЕДЬ ПОСЛЕ ЧТЕНИЯ ЭЛЕМЕНТОВ ***");
 display(head);			/* вывод всех элем-тов списка  */

 QUEUE n,n2;
 n.info=111; n2.info=222; put(&head, &n); put(&head, &n2);
 puts("\n*** ОЧЕРЕДЬ ПОСЛЕ НОВОГО ДОБАВЛЕНИЯ 2 ЭЛЕМЕНТОВ ПРОГРАММНО ***");
 display(head);

 fflush (stdin); getchar();
 return 0;
}




    57. Очередь #02 с использованием шаблона
Если вы хотите использовать шаблон очереди в C++, то вам сначала нужно подключить библиотеку — <queue>.
Дальше для объявления очереди нужно воспользоваться конструкцией ниже.

queue <тип данных> <имя>;

Вот пример правильного объявления:

  queue <int> q;  // создали очередь q

Методы очереди
Метод — это та же самая функция, но она работает только с контейнерами STL. Например, очередь и стек.
Для работы с очередью вам понадобится знать функции: push(), pop(), front(), back(), empty(). Кстати, если хотите узнать, как в C++ работают функции и как их правильно использовать в проекте, то можете узнать все это здесь.
    • Для добавления в очередь нового элемента нужно воспользоваться функцией — push(). В круглых скобках должно находится значение, которое мы хотим добавить.
    • Если нам понадобилось удалить первый элемент нужно оперировать функцией pop(). В круглых скобках уже не чего не нужно указывать, но по правилам они в обязательном порядке должны присутствовать! Эти функции тоже не нуждаются в указании аргумента: empty(), back() и front().
    • Если вам понадобилось обратиться к первому элементу очереди, то вам понадобится функция front().
    • Чтобы обратиться к последнему элементу в очереди вам поможет функция back().
    • Чтобы узнать пуста ли очередь нужно воспользоваться функцией empty().
Если ваша очередь пуста — возвратит true.
Если же в ней что-то есть — возвратит false.

Ниже мы использовали все выше перечисленные методы:

#include <iostream>
#include <queue>  // подключили библиотеку queue

using namespace std;

int main()
{
  setlocale(LC_ALL,"rus");
  queue <int> q;  // создали очередь q

  cout << "Пользователь, пожалуйста введите 7 чисел: " << endl;

  for (int h = 0; h < 7; h++) {
    int a;
    cin >> a;
    q.push(a);  // добавляем в очередь элементы
  }

  cout << endl;
  cout << "Самый первый элемент в очереди: " << q.front() << endl;  // выводим первый
                                                                   // элемент очереди
  q.pop();  // удаляем элемент из очереди
  
  cout << "Новый первый элемент (после удаления): " << q.front() << endl;
  
  if (!q.empty()) cout << "Очередь не пуста!";  // проверяем пуста ли очередь (нет)

  cout << endl;
  system("pause");
  return 0;
}




    58. Очередь #03 с использованием шаблона

#include <iostream>
#include <conio.h>
#include <queue>        // подключаем заголовочный файл очереди
#include <string>       // заголовочный файл для работы со строками типа string
using namespace std;

int main()
{
    queue<string> myQueue;     // создаем пустую очередь типа string

	setlocale(LC_ALL, "Rus");
    // добавили в очередь несколько элементов типа string
    myQueue.push("No pain ");
    myQueue.push("- no gain");

    cout << "Количество элементов в очереди: " << myQueue.size() << endl;
    cout << "\nВот они: " << myQueue.front() << myQueue.back();

    myQueue.pop(); // удаляем один элемент в очереди
    cout << "\nТеперь в очереди остался один элемент: " << myQueue.front();
	getch();
    return 0;
}





    59. Очередь #03 с приоритетом на основе std::vector

#include <iostream>
#include <vector>
#include <algorithm>
#include <string>

template<typename T, typename Container = std::vector<T>>
class PriorityQueue
{
public:
    void push(T const& lhs)
    {
        con.push_back(lhs);
        std::push_heap(con.begin(), con.end());
    }
    void pop()
    {
        std::pop_heap(con.begin(), con.end());
        con.pop_back();
    }
    T const& top()const
    {
        return con.front();
    }
    typedef typename Container::size_type size_type;
    size_type size() const
    {
        return con.size();
    }
    bool empty() const
    {
        return con.empty();
    }
private:
    Container con;
};

int main()
{
    PriorityQueue<std::string> pq;
    pq.push("sd sd");
    pq.push("zz xx x");
    pq.push("ad,a");
    pq.push("wt wrr wf");
    while(!pq.empty())
    {
        std::cout << pq.top() << std::endl;
        pq.pop();
    }
    system("pause");
    return 0;
}



    60. Очередь #04 на базе массива

#include <iostream>

using namespace std;

#define SIZE 100
#define PRINT(A) cout << endl << #A << endl;

class queue {
    int q[SIZE];
    int sloc, rloc;
public:
    void init ();
    void qput (int val);
    int qget ();
};

void queue::init()
{
    rloc = sloc = 0;
}

void queue::qput(int val)
{
    if ( sloc == SIZE ) {
        PRINT ( QUEUE filled with );
        return ;
    }
    q[++sloc] = val;
}

int queue::qget()
{
    if ( rloc == sloc ) {
        PRINT ( QUEUE 0 );
        return 0;
    }
    return q[++rloc] ;
}


int main(int argc, char* argv[])
{
    queue q1;
    int value;
    int i;
    const int COUNT = 3;

    q1.init ();

    for ( i = 0 ; i < COUNT ; ++i)
    {
        cout << " Enter val = ";
        cin >> value ;
        q1.qput(value);
    }

    cout << " QUEUE : " ;

    for ( i = 0 ; i < COUNT ; ++i )
        cout << q1.qget() << "   ";

    cout << endl;


    system ("pause");
    return 0;
}



    61. Очередь #05 циклическая

#include<iostream>
#include<conio.h>
using namespace std;
const int maxlength = 100;
struct QUEUE{
  char elements[maxlength];
  int front;
  int rear;
  };

void MAKENULL(QUEUE *);
bool EMPTY(QUEUE *);
char FRONT(QUEUE *);
void ENQUEUE(char, QUEUE *);
void DEQUEUE(QUEUE *);
int addone(int);

int main()
{
  QUEUE Q;
  char c;
  cout<<"Enter TEXT"<<endl;
  MAKENULL(&Q);
  c = getchar();
  while (c != '=')
  {
    ENQUEUE(c, &Q);
    c = getchar();
  }
  DEQUEUE(&Q);
  DEQUEUE(&Q);
  ENQUEUE('<', &Q);
  while (!EMPTY(&Q))
  {
    cout<<FRONT(&Q);
    DEQUEUE(&Q);
  }
  cout<<endl;
  getch();
  return 0;
}

void MAKENULL(QUEUE *Q)
{
  Q->front = 1;
  Q->rear = maxlength;
}

bool EMPTY(QUEUE *Q)
{
  if (addone(Q->rear) == Q->front)
    return true;
  else
    return false;
}

char FRONT(QUEUE *Q)
{
  if (EMPTY(Q))
    cout<<"Queue is empty";
  else return Q->elements[Q->front];
}

void ENQUEUE(char elem, QUEUE *Q)
{
  if (addone(addone(Q->rear)) == Q->front)
    cout<<"Queue is full";
  else
  {
    Q->rear = addone(Q->rear);
    Q->elements[Q->rear] = elem;
  }
}

void DEQUEUE(QUEUE *Q)
{
  if (EMPTY(Q))
    cout<<"Queue is empty";
  else
    Q->front = addone(Q->front);
}

int addone(int i)
{
  return (i % maxlength) + 1;
}





            61.1.1. Дек

    62. Дек #01 простой пример

    • Дек — двусторонняя очередь.
    • Дек — это не обязательно работа с динамическим распределением памяти.
Это простой пример неполноценного дека. Реализация дека построена на статическом массиве. В примере для дека будут определены только операции добавления в начало и в конец очереди.
При добавлении в начало сам массив отталкивается и в начало массива встает указанный элемент.
При добавлении в конец, элемент занимает самую правую часть массива.
Длина очереди контролируется нами вручную.

#include <iostream>

const int N_global=10; //Количество элементов статического одномерного массива на котором строится дек

void showarr(int *Arr,const int N) //Функция показывает одномерный массив на экране
{
    for (int i=0;i<N;i++) std::cout<<Arr[i]<<"\t";
    std::cout<<"\n";
}

void addright(int Arr[N_global],int &N, const int el) //Функция добавляет элемент в конец очереди
{
    if (N==N_global)  //Если размер очереди стал равен размеру массива
        {
            std::cout<<"Дек полон\n"; //Сообщаем, что дек полон
            std::cout<<el<<" не попал в дек\n";
            return; // и сразу выходим из функции
        }

     //Если размер очереди меньше размера массива
    Arr[N]=el; //Записываем элемент в конец массива
    N++; //Увеличиваем счетчик размерности очереди
}

void addleft(int Arr[N_global],int &N,const int el) //Функция добавляет элемент в начало очереди
{

    if (N==N_global) //Если размер дека равен размеру массива
        {
            std::cout<<"Дек полон\n"; //Выводим сообщение, что дек полон
            std::cout<<el<<" не попал в дек\n";
            return; //и сразу выходим из функции
        }

    int temp=Arr[0]; //Запоминаем первый элемент во временную переменную
    Arr[0]=el; //Записываем в первый элемент значение
    N++; //Увеличиваем счетчик размерности очереди

    for (int i=1;i<N;i++)    std::swap(Arr[i],temp); //как бы отталкиваем весь массив вправо, не трогаем самый левый элемент
}

int main()
{
    int mas[N_global];
    int len=0; //Сначала дек пустой, размер = 0

    //Добавление элементов в начало очереди
    addleft(mas,len,1);
    addleft(mas,len,7);
    addleft(mas,len,4);
    addleft(mas,len,14);
    addleft(mas,len,54);
    addleft(mas,len,24);
    addright(mas,len,1000); //В конец 1000
    addleft(mas,len,2000); //В начало 2000

    showarr(mas,len); //Показываем созданную очередь
    len=0;//Создали иллюзию обнуления очереди.
    addleft(mas,len,777); //Создаем другую очередь
    addleft(mas,len,1);
        showarr(mas,len); //Показываем вторую очередь

    std::cin.get();
}





            62.1.1. Дерево

    63. Дерево #01 первое знакомство
http://ci-plus-plus-snachala.ru/?p=89

Динамические структуры данных используются много и часто, но у начинающих много вопросов и для начинающих много непонятных моментов в программировании этих динамических структур.
Считаю, что для первого знакомства, бинарное дерево достаточно ввести с клавиатуры и вывести его на экран. Остальные функции лучше оставить на после изучения такого фундамента.
Первое на что я обращаю внимание, это сама структура Node, которая представляет одно звено нашего будущего дерева. В структуре объявлен информационный элемент и указатели на самую правую и на самую левую часть будущего дерева.
Объявляем указатель на нашу структуру (на звено дерева) и Во избежание непредвиденных ошибок сразу инициализируем этот указатель в ноль
После описания структуры-звена бинарного дерева и объявления на неё указателя, в главной функции пишем стандартные строчки (сколько элементов ввести) и выполняем цикл по вводу элементов указанное число раз. При этом нам нужно каждый новый элемент сразу записывать в дерево,с этой целью пишем отдельную функцию.
В приведенном мною коде функция принимает 2 параметра. Первый — записываемое число, второй указатель на указатель звена дерева.
При начале занесения информации, двоичное дерево или содержит информацию, или еще не заполнялось, поэтому первый шаг — проверка на наличие данных в дереве.
    • Если дерево пустое, то надо создать первый элемент. Этот элемент будет корнем дерева. После создания первого элемента надо выделить память для возможных ветвей.
    • Если дерево что-то содержит, то проверяется условие, согласно которому мы размещаем в дереве элементы.

Бинарное дерево — это упорядоченное дерево, каждая вершина которого имеет не более двух поддеревьев, причем для каждого узла выполняется правило: в левом поддереве содержатся только ключи, имеющие значения, меньшие, чем значение данного узла, а в правом поддереве содержатся только ключи, имеющие значения, большие, чем значение данного узла.

При всем этом, если элемент, который мы хотим поместить в дерево больше чем корневой, то с помощью рекурсивного вызова функции происходит последовательное перемещение элемента в правую часть. Наш элемент прыгает через один как через скакалку, пока не найдет своё место. А его место это то место, где справа элемент или больше чем он сам или если прыгать больше не через кого. Одним словом «Чехарда»
Если записываемый элемент меньше чем корневой, то выполняется такая же «Чехарда», только в левую сторону.
Для того чтоб отобразить наше Бинарное дерево на экране сначала проверяем вообще есть ли оно. Если мы не заполним дерево и не заложим семечко (не создадим корень), то дерева в принципе существовать не может и поэтому отображать будет нечего, но если создали, то используя рекурсивный вызов функции последовательно отображаем все элементы. Кроме того, эта первая проверка будет и сигналом для завершения рекурсивного вызова функции. Ведь если встретится Нулевое звено, то происходит return, а мы после создания каждого звена очищали память для следующего роста
Может кому-то непонятно зачем использован параметр u. При выводе на экран вы будете видеть палочки, которые выводятся с помощью цикла. Найти в коде это место нетрудно. Эти палочки символически обозначают количество узлов
Я не писал, но узел дерева, не имеющий потомков называется лист. В нашем случае у дерева два листа. 0 и 9.
Если кому мало что понятно, то вот мое личное художество. Предположительно пользователь вводит числа и из них строится дерево. То что вводит пользователь появляется поочередно и ищет свое место. Когда число находит свою позицию, то бронирует её. Правую часть я не брал, но там все заполняется точно также. После заполнения дерева, пройтись по нему не составит труда. Каждый шаг прохода обозначен в конце красной цифрой. Если встречаются равные элементы, то они создают что-то похожее на ветку и эта ветка с каждым элементом увеличивается (в конце обозначено стрелками). При считывании информации с дерева сначала все собирается с одной ветки, потом со следующей и так пока «ветки» не закончатся. Присмотритесь к рисунку, может получиться понять еще какие-то моменты.




#include <iostream>
#include <conio.h>
using namespace std;

//Наша структура
struct node
{
    int info; //Информационное поле
    node *l, *r;//Левая и Правая часть дерева
};

node * tree=NULL; //Объявляем переменную, тип которой структура Дерево

/*ФУНКЦИЯ ЗАПИСИ ЭЛЕМЕНТА В БИНАРНОЕ ДЕРЕВО*/
void push(int a,node **t)
{
    if ((*t)==NULL) //Если дерева не существует
    {
        (*t)=new node; //Выделяем память
        (*t)->info=a; //Кладем в выделенное место аргумент a
        (*t)->l=(*t)->r=NULL; //Очищаем память для следующего роста
        return; //Заложили семечко, выходим
    }
       //Дерево есть
        if (a>(*t)->info) push(a,&(*t)->r); //Если аргумент а больше чем текущий элемент, кладем его вправо
        else push(a,&(*t)->l); //Иначе кладем его влево
}

/*ФУНКЦИЯ ОТОБРАЖЕНИЯ ДЕРЕВА НА ЭКРАНЕ*/
void print (node *t,int u)
{
    if (t==NULL) return; //Если дерево пустое, то отображать нечего, выходим
    else //Иначе
    {
    print(t->l,++u);//С помощью рекурсивного посещаем левое поддерево
    for (int i=0;i<u;++i) cout<<"|";
    cout<<t->info<<endl; //И показываем элемент
    u--;
    }
    print(t->r,++u); //С помощью рекурсии посещаем правое поддерево
}

void main ()
{ 
    int n; //Количество элементов
    int s; //Число, передаваемое в дерево
	setlocale(LC_ALL, "Rus");
    cout<<"введите количество элементов  ";
    cin>>n; //Вводим количество элементов

    for (int i=0;i<n;++i)
    {
    cout<<"ведите число  ";
    cin>>s; //Считываем элемент за элементом
 
    push(s,&tree); //И каждый кладем в дерево
    }
    cout<<"ваше дерево\n";
    print(tree,0);
    getch();
}





    64. Дерево #02 простой пример
http://ci-plus-plus-snachala.ru/?p=1249

Чтобы понимать тему бинарное дерево, нужно понимать основы рекурсии, хорошо знать матчасть об указателях и знать про передачу параметров в функции.

Этап первый.
Первое, что нужно для создания бинарного дерева — это структура с некоторыми определенными полями. Я буду использовать 1 элемент и два адресных поля. Элемент — это то, что я хочу записать в узел дерева, а два адресных поля — это потому, что у бинарного дерева каждое звено по мере необходимости порождает два новых звена, обычно их называют левое и правое.

struct Node //Звено дерева
{
	int x; //То, что записываем в дерево
	Node *l,*r; //Это указатели на новые звенья
};

По ходу выполнения программы Звенья будут создаваться и дописываться к существующим по указанным нами правилам. Сама эта структура — это фундамент очень простого бинарного дерева.
Заполнение простого бинарного дерева разделено на три основные части,а именно — Если дерева нет, то нужно заложить семечко для роста, если же оно уже есть, то нужно записывать данные либо влево, либо вправо. Вот внутри функции добавления элемента как раз будут использованы все три основные части.

#include <iostream>
using namespace std;

struct Node //Звено дерева
{
	int x; //То, что записываем в дерево
	Node *l,*r; //Это указатели на новые звенья
};

int main()
{
	Node *Tree=NULL;  //Создаю указатель, тип которого = звено дерева и инициализирую его пустотой
	return 0;
}

Прошу обратить внимание, что я не стал выделять память сейчас. Сейчас просто объявлен один указатель и во избежание ошибок этот указатель я сразу инициализировал пустотой.

Этап второй.
Опишем функцию обхода. Посмотрим как работает вывод дерева на экран. Используем рекурсию для обхода, потому что это намного проще, чем использовать обычные циклы.

#include <iostream>
using namespace std;

struct Node //Звено дерева
{
	int x; //То, что записываем в дерево
	Node *l,*r; //Это указатели на новые звенья
};

void show(Node *&Tree) //Функция обхода
{
	if (Tree!=NULL){ //Пока не встретится пустое звено
		show(Tree->l); //Рекурсивная функция для вывода левого поддерева
		cout<<Tree->x; //Отображаем корень дерева
		show(Tree->r); //Рекурсивная функци для вывода правого поддерева
	}
}

int main()
{
	Node *Tree=NULL;  //Создаю указатель, тип которого = звено дерева и инициализирую его пустотой
	show(Tree); //Вызов функции обхода дерева; 
	cin.get(); //Обычная задержка перед выходом;
	return 0;
}

Код постепенно растет. Но результата не будет. Мы ничего для дерева и не описывали и не создавали звеньев. Собственно, выводить совсем нечего. Добавим звенья в Бинарное дерево.

Этап третий. Добавляем звенья в бинарное дерево
#include <iostream>
using namespace std;

struct Node //Звено дерева
{
	int x; //То, что записываем в дерево
	Node *l,*r; //Это указатели на новые звенья
};

void show(Node *&Tree) //Функция обхода
{
	if (Tree!=NULL){ //Пока не встретится пустое звено
		show(Tree->l); //Рекурсивная функция для вывода левого поддерева
		cout<<Tree->x; //Отображаем корень дерева
		show(Tree->r); //Рекурсивная функции для вывода правого поддерева
	}
}

void add_node(int x,Node *&MyTree) //Функция добавления звена в дерево
{
	if (NULL==MyTree){  //Если дерева нет, то сеем семечко
		MyTree=new Node; //Выделяем память под звено дерева
		MyTree->x=x; //Записываем данные в звено
		MyTree->l=MyTree->r=NULL; //Подзвенья инициализируем пустотой во избежание ошибок
	}
}

int main()
{
	Node *Tree=NULL;  //Создаю указатель, тип которого = звено дерева и инициализирую его пустотой
	for (int i=5;i>0;i--) add_node(i,Tree); //Я решил так заполнять
		show(Tree); //Обход дерева
	cin.get();
	return 0;
}

Для функции add_node должен возникнуть вопрос каким образом правильно заполнять левые звенья и правые. В моем примере будет использована рекурсия. Заполнение левого и правого поддерева аналогичны друг другу.
Принцип заполнения не очень сложен. Сейчас создается дерево и данные записываются в левое поддерево, но осталось дописать и для правого. Для записи данных в правое поддерево нужно использовать такую же схему как и для записи в левое, только поменять условие и нужно обращаться уже к правым подзвеньям. Обратите внимание, на момент в рекурсии, какой там параметр указан. Функция add_node принимает вид

void add_node(int x,Node *&MyTree) //Функция добавления звена в дерево
{
	if (NULL==MyTree){  //Если дерева нет, то сеем семечко
		MyTree=new Node; //Выделяем память под звено дерева
		MyTree->x=x; //Записываем данные в звено
		MyTree->l=MyTree->r=NULL; //Подзвенья инициализируем пустотой во избежание ошибок
	}

	if (x<MyTree->x){	//Если нововведенный элемент x меньше чем элемент x из семечка дерева,
						//уходим влево
		if (MyTree->l!=NULL) add_node(x,MyTree->l); //При помощи рекурсии заталкиваем элемент на свободный участок
		else { //Если элемент получил свой участок, то
			MyTree->l=new Node;  //Выделяем память левому подзвену. Именно подзвену, а не просто звену
			MyTree->l->l=MyTree->l->r=NULL; //У левого подзвена будут свои левое и правое подзвенья, инициализируем их пустотой
			MyTree->l->x=x; //Записываем в левое подзвено записываемый элемент
		}
	}

	if (x>MyTree->x){ //Если нововведенный элемент x больше чем элемент x из семечка дерева, уходим вправо
		if (MyTree->r!=NULL) add_node(x,MyTree->r); //При помощи рекурсии заталкиваем элемент на свободный участок
		else { //Если элемент получил свой участок, то
			MyTree->r=new Node;  //Выделяем память правому подзвену. Именно подзвену, а не просто звену
			MyTree->r->l=MyTree->r->r=NULL; //У правого подзвена будут свои левое и правое подзвенья, инициализируем их пустотой
			MyTree->r->x=x; //Записываем в правое подзвено записываемый элемент
		}
	}
}

Добавляем очистку памяти

/*Добавили очистку памяти*/
void del(Node *&Tree)
{
	if (Tree!=NULL){ //Пока не встретится пустое звено
		del(Tree->l); //Рекурсивная функция прохода по левому поддереву
		del(Tree->r); //Рекурсивная функци для прохода по правому поддереву
		delete Tree; //Убиваем конечный элемент дерева
		Tree = NULL; //Может и не обязательно, но плохого не будет
	}
}

И окончательный вид программы

#include <iostream>
using namespace std;

struct Node //Звено дерева
{
	int x; //То, что записываем в дерево
	Node *l,*r; //Это указатели на новые звенья
};

void show(Node *&Tree) //Функция обхода
{
	if (Tree!=NULL){ //Пока не встретится пустое звено
		show(Tree->l); //Рекурсивная функция для вывода левого поддерева
		cout<<Tree->x; //Отображаем корень дерева
		show(Tree->r); //Рекурсивная функции для вывода правого поддерева
	}
}

void add_node(int x,Node *&MyTree) //Функция добавления звена в дерево
{
	if (NULL==MyTree){  //Если дерева нет, то сеем семечко
		MyTree=new Node; //Выделяем память под звено дерева
		MyTree->x=x; //Записываем данные в звено
		MyTree->l=MyTree->r=NULL; //Подзвенья инициализируем пустотой во избежание ошибок
	}

	if (x<MyTree->x){	//Если нововведенный элемент x меньше чем элемент x из семечка дерева,
						//уходим влево
		if (MyTree->l!=NULL) add_node(x,MyTree->l); //При помощи рекурсии заталкиваем элемент на свободный участок
		else { //Если элемент получил свой участок, то
			MyTree->l=new Node;  //Выделяем память левому подзвену. Именно подзвену, а не просто звену
			MyTree->l->l=MyTree->l->r=NULL; //У левого подзвена будут свои левое и правое подзвенья, инициализируем их пустотой
			MyTree->l->x=x; //Записываем в левое подзвено записываемый элемент
		}
	}

	if (x>MyTree->x){ //Если нововведенный элемент x больше чем элемент x из семечка дерева, уходим вправо
		if (MyTree->r!=NULL) add_node(x,MyTree->r); //При помощи рекурсии заталкиваем элемент на свободный участок
		else { //Если элемент получил свой участок, то
			MyTree->r=new Node;  //Выделяем память правому подзвену. Именно подзвену, а не просто звену
			MyTree->r->l=MyTree->r->r=NULL; //У правого подзвена будут свои левое и правое подзвенья, инициализируем их пустотой
			MyTree->r->x=x; //Записываем в правое подзвено записываемый элемент
		}
	}
}

/*Добавили очистку памяти*/
void del(Node *&Tree)
{
	if (Tree!=NULL){ //Пока не встретится пустое звено
		del(Tree->l); //Рекурсивная функция прохода по левому поддереву
		del(Tree->r); //Рекурсивная функци для прохода по правому поддереву
		delete Tree; //Убиваем конечный элемент дерева
		Tree = NULL; //Может и не обязательно, но плохого не будет
	}
}

int main()
{
	Node *Tree=NULL;  //Создаю указатель, тип которого = звено дерева и инициализирую его пустотой
	for (int i=5; i>0; i--)
		add_node(i,Tree); //Это я забивал 5-4-3-2-1, а вывод сами увидите
	show(Tree); //Вывод на экран дерева. или просто обход дерева
	cout << '\n';
	del(Tree);
	cin.get();
	return 0;

	//Node *Tree=NULL;  //Создаю указатель, тип которого = звено дерева и инициализирую его пустотой
	//srand((int)time(NULL));
	//for (int i=5; i>0; i--){
	//	int a=rand()%11;
	//	add_node(a,Tree);
	//}
	//show(Tree); //Вывод на экран дерева. или просто обход дерева
	//cout << '\n';
	//del(Tree);
	//cin.get();
}



Возможно улучшение программы за счет модернизации

void add_node(int node, Node *&Tree)
{
	if(Tree == NULL){
		Tree = new Node;
		Tree->node = node;
		Tree->left = NULL;
		Tree->right = NULL;
	}
	if(node node){
		add_node(node, Tree->left);
	}
	if(node > Tree->node){
		add_node(node, Tree->right);
	}
}

    65. Дерево #03 копия дерева. Количество листов
Создать копию дерева. Сделать так, что бы количество листьев можно было посчитать и вывести это все на экран.



#include <iostream>
using namespace std;

struct Node //Звено дерева
{
	int x; //То, что записываем в дерево
	Node *l, *r; //Это указатели на новые звенья
};

void show(Node *&Tree) //Функция обхода
{
	if (Tree != NULL){ //Пока не встретится пустое звено
		show(Tree->l); //Рекурсивная функция для вывода левого поддерева
		cout << '-';
		cout  << Tree->x; //Отображаем корень дерева
		show(Tree->r); //Рекурсивная функци для вывода правого поддерева
	    cout << '-';
	}
	else {
	
		cout << '\n';
	}
}

/*Добавили очистку памяти*/
void del(Node *&Tree) {
	if (Tree != NULL){ //Пока не встретится пустое звено
		del(Tree->l); //Рекурсивная функция прохода по левому поддереву
		del(Tree->r); //Рекурсивная функци для прохода по правому поддереву
		delete Tree; //Убиваем конечный элемент дерева
		Tree = NULL; //Может и не обязательно, но плохого не будет
	}

}

void get_leaf_count(Node *&Tree, int &count) {
	if (Tree != NULL){ //Пока не встретится пустое звено
		get_leaf_count(Tree->l, count); //Рекурсивная функция для вывода левого поддерева
		if (Tree->r == NULL) {
			cout << Tree->x << '-';
			count++;
		}
		get_leaf_count(Tree->r, count); //Рекурсивная функци для вывода правого поддерева
	}
}

void add_node(int x, Node *&MyTree) //Фукция добавления звена в дерево
{
	if (NULL == MyTree){  //То, о чем я в самом начале писал. Если дерева нет, то ложим семечко
		MyTree = new Node; //Выделяем память под звено дерева
		MyTree->x = x; //Записываем данные в звено
		MyTree->l = MyTree->r = NULL; //Подзвенья инициализируем пустотой во избежание ошибок
	}

	if (x<MyTree->x){   //Если нововведенный элемент x меньше чем элемент x из семечка дерева, уходим влево
		if (MyTree->l != NULL) add_node(x, MyTree->l); //При помощи рекурсии заталкиваем элемент на свободный участок
		else {//Если элемент получил свой участок, то
			MyTree->l = new Node;  //Выделяем память левому подзвену. Именно подзвену, а не просто звену
			MyTree->l->l = MyTree->l->r = NULL; //У левого подзвена будут свои левое и правое подзвенья, инициализируем их пустотой
			MyTree->l->x = x; //Записываем в левое подзвено записываемый элемент
		}
	}

	if (x>MyTree->x){   //Если нововведенный элемент x больше чем элемент x из семечка дерева, уходим вправо
		if (MyTree->r != NULL) add_node(x, MyTree->r); //При помощи рекурсии заталкиваем элемент на свободный участок
		else {//Если элемент получил свой участок, то
			MyTree->r = new Node;  //Выделяем память правому подзвену. Именно подзвену, а не просто звену
			MyTree->r->l = MyTree->r->r = NULL; //У правого подзвена будут свои левое и правое подзвенья, инициализируем их пустотой
			MyTree->r->x = x; //Записываем в правое подзвено записываемый элемент
		}
	}
}

Node* cloning(Node *&Tree, Node *&semko) //Функция копирования
{
        if (Tree != NULL){ //Пока не встретится пустое звено
            int x = Tree->x;
			add_node(x,semko);
			cloning(Tree->l,semko); //Рекурсивная функция для вывода левого поддерева
			cloning(Tree->r,semko); //Рекурсивная функци для вывода правого поддерева
        }
        return semko;
}

int main()
{
	Node *Tree = NULL;  //Создаю указатель, тип которого = звено дерева и инициализирую его пустотой

	add_node(81, Tree);
	add_node(49, Tree);
	add_node(34, Tree);
	add_node(51, Tree);
	add_node(52, Tree);
	add_node(53, Tree);
	add_node(94, Tree);
	add_node(93, Tree);
	add_node(100, Tree);

	int count_leaf = 0;  //Число листьев
	show(Tree); //Вывод на экран дерева. или просто обход дерева
	cout << "\n=============================\n";
	get_leaf_count(Tree, count_leaf);

	//Создаем копию
	Node *Clon = NULL;
	Clon = cloning(Tree,Clon);

	del(Tree);
	cout << "\n=============================\n count leaf == " << count_leaf << '\n';
	show(Clon);   //Показываем копию
	del(Clon);    //Чистим память от копии

	cin.get();
}




    66. Дерево #04 бинарное дерево и рекурсия
http://blog.kislenko.net/show.php?id=1454

/*
   Пример работы с бинарным деревом и рекурсией
*/
#define _CRT_SECURE_NO_WARNINGS
#include <locale.h>
#include <windows.h>
#include <stdio.h>
#include <iostream>
#include <string.h>
using namespace std;

typedef struct btree {
 int val;
 btree *left,*right;
};

//----- Рекурсивный поиск в двоичном дереве---------------
// Возвращается указатель на найденную вершину
btree *Search(btree *p, int v) {
 if (p==NULL) return(NULL);                    // Ветка пустая
 if (p->val == v) return(p);                   // Вершина найдена
 if (p->val > v)                            // Сравнение с текущим
  return(Search(p->left,v));                   // Левое поддерево
 else
  return(Search(p->right,v));                  // Правое поддерево
}

//----- Включение значения в двоичное дерево--------------
// функция возвращает указатель на созданную вершину,
// либо на существующее поддерево
btree *Insert(btree *pp, btree *v) {
 if (pp == NULL) {           // Найдена свободная ветка
                             // Создать вершину дерева
  btree *q = new btree;      // и вернуть указатель
  q->val = v->val;
  q->left = q->right = NULL;
  return q;
 }
 if (pp->val == v->val) return pp;
 if (pp->val > v->val)                     // Перейти в левое или
  pp->left=Insert(pp->left,v);            // правое поддерево
 else
  pp->right=Insert(pp->right,v);
 return pp;
}

// Рекурсивный обход двоичного дерева с выводом
// значений вершин в порядке возрастания
void Scan(btree *p) {
 if (p==NULL) return;
 Scan(p->left);
 cout << p->val << endl;
 Scan(p->right);
}

// Рекурсивный обход двоичного дерева с нумерацией вершин
// снизу-вверх слева-направо, n - текущий номер вершины
int Scan2 (btree * p, int n) {
 if (p==NULL) return n;
 Scan2 (p->left,n);
 n++;
 cout << n << ") " << p->val << endl;
 n=Scan2(p->right,n) ;
 return n;
}

// Рекурсивный обход двоичного дерева с последовательной
// нумерацией вершин в возвратом указателя на вершину с заданным номером
// Глобальный счетчик вершин передается через указатель
btree *ScanNum(btree *p, int *n) {
 btree *q;
 if (p==NULL) return NULL;
 q=ScanNum(p->left,n);
 if (q!=NULL) return q;
 if ((*n)-- ==0) return p;
 return ScanNum(p->right,n);
}

int main (void) {
 int v=1;
 btree *root=NULL;
 int depth=1;
 setlocale(LC_ALL,"Rus"); //SetConsoleCP(1251); SetConsoleOutputCP(1251);
 // ввод узлов
 while (1) {
  printf ("\n Введите целое число (узел дерева) или 0 для выхода:");
  fflush (stdin);
  scanf ("%d",&v);
  if (!v) break;
  btree node;
  node.val=v;
  root=Insert (root,&node);
 }
 // поиск значения
 printf ("\n введите узел для поиска:");
 fflush (stdin);
 scanf ("%d",&v);
 btree *found=Search (root,v);
 if (found) printf ("\n found %d\n",found->val);
 else printf ("\n not found %d\n",v);
 // нумерация вершин
 printf ("\nScan:\n");
 Scan (root);
 printf ("\n введите начальный номер вершины:");
 fflush (stdin);
 scanf ("%d",&v);
 // поиск по номеру вершины
 printf ("\nScan2:\n");
 Scan2 (root,v);
 printf ("\nScan&Num:\n");
 found=ScanNum (root,&v);
 if (found) printf ("\n found %d\n",found->val);
 else printf ("\n not found %d\n",v);
 fflush (stdin); getchar ();
 return 0;
}



            66.1.1. Граф

    67. Граф #01 простой пример
http://ci-plus-plus-snachala.ru/?p=918

В программировании можно встречать много задач, которые на теорию графов опираются. Я не буду переписывать о графах из других источников, а опишу немного по-своему. Здесь будет описан именно Гамильтонов цикл. Это первое мое знакомство с материалами из теории графов, поэтому здесь простой и не глубокий материал.
Чтобы объяснить, что такое Гамильтонов цикл, я приведу 2 визуальных примера. Очень простой и чуть-чуть посложнее.
Советую перерисовать дом с номерами на лист бумаги, удобнее будет смотреть позже.



Это самый простой пример. Если представить, что линии — это дороги, а точки — пункты назначения, то существует множество маршрутов между этими точками. Предлагаю сыграть в простую игру.

Задача. Вы командир снайперов. У вас есть 5 снайперов, которых надо расставить по 5 пунктам. Ваши начальники жестоко над вами пошутили и дали вам 5 снайперов дальтоников. Задача каждого снайпера стрелять в любого, кто остановится или свернет в его точке. Т.е. вы двигаетесь по маршруту, оставляете в каждой точке снайпера. Если вы останавливаетесь или сворачиваете в точке, где снайпер есть, то вся ваша оставшаяся команда умирает под обстрелом. Вы должны вернутся на базу один и целым. База — это точка выхода. Откуда вышли, надо туда прийти.

Вот пример. Поможет понять правило игры.
Старт точка 4:

4—>3—>1—>2—>4

Снайпер с точки 4 вас убил за то, что у вас снайпер остался. Ведь вы вернулись на базу не выполнив приказ.
Если делать проход по 3-4, то дальше в одной из точек будете убиты.
Но можно пройти 4—>5—>3—>1—>2—>4, снайперы на месте, вы на базе. Совсем не обязательно по всем дорогам шататься, главное посещение нужных точек и не попадаться на глаза оставленным снайперам.
Если бы между 2 и 4 был пункт 6, то можно было двигаться 2—>4—6, дальше снайпер. Если бы в 6 стоял снайпер, а вы шли 2—>4, то снайпер 6 вас не трогает, вы не остановились и прошли прямо.
Надеюсь освоились с правилом и поняли, что от вас требуется.
Такой маршрут можно рассчитать с помощью теории графов и запрограммировать это в программу..
А сейчас поясню как оно программируется. Для начала я буду использовать матрицу смежности.

А сейчас поясню как оно программируется. Для начала я буду использовать матрицу смежности.
Матрица смежности — Это квадратная матрица, элементы которой показывают, смежны ли вершины друг с другом. Если элемент матрицы x[i,j]=0, то вершины i и j не смежны, если x[i,j]=1 — то смежны (смежными называются вершины, которые соединяются ребром (дугой) графа)
Чтобы было понятнее, попытаюсь объяснить. Давайте смотреть на нумерованный рисунок и отталкиваться от нумерованных узлов по порядку. (удобнее если вы все-таки срисовали)
1) 1 соединен с 2 и 3 (значит 1 смежно с 2 и 3)
2) 2 соединен с 4 и 1
3) 3 соединен с 1, 4 и 5
4) 4 соединен с 2, 3 и 5
5) 5 соединен с 3 и 4

Из этой информации нужно создавать матрицу. Сначала просто пронумеруем поле для матрицы



Отсчет у нас от единицы. Можно делать от нуля, но мне оказалось проще так. Теперь постепенно заполняем матрицу нулями и единицами. Смотрим на информацию выше (там где про соединения) и расставляем по матрице значения.
1) 1 соединен с 2 и 3 (значит 1 смежно с 2 и 3)



Видите связь? Внимательно присмотритесь. Слева у нас номер узла, сверху номер другого узла. Если узлы соединены, то ставим 1, если нет, то 0. Дальше заполняем матрицу аналогично. Итоговая матрица по рисунку получается



Исходник Гамильтонова цикла

#include <iostream>
#include <stdlib.h>

using namespace std;

const int n=5;

int c[n] ;   // номер хода, на котором посещается вершина
int path[n]; // номера посещаемых вершин
int v0=2;    // начальная вершина

//Матрица смежности
int a[n][n]=
{
    0,1,1,0,0,
	1,0,0,1,0,
	1,0,0,1,0,
	0,1,1,0,1,
    0,0,1,1,0
};

void prnt(void)
{
int p;
        for ( p = 0 ; p<n ; p++)
	 cout<<path[p]+1<<"\t";
	 cout<<path[0]+1 ;
         cout<<"\n" ;
}

//подпрограмма нахождения гамильтонова цикла
int gamilton ( int k)
{
int v,q1=0;
    for(v=0; v<n && !q1; v++)
    {
      if(a[v][path[k-1]]||a[path[k-1]][v])
      {
    if (k==n &&  v==v0 ) q1=1;
    else if (c[v]==-1)
            {
          c[v] = k ; path[k]=v;
          q1=gamilton (k+1) ;
          if (!q1) c[v]=-1;
        } else continue;
    }
    }   return q1;
}

int main()
{
int j;
system("CLS");
setlocale(LC_ALL, "Rus");
    cout<<"Гамильтонов цикл:\n";
        for(j=0;j<n;j++) c[j]=-1;
        path[0]=v0 ;
          c[v0]=v0;
    if(gamilton (1)) prnt(); else cout<<"Нет решений\n";
    cin.get();
	return 0;
}



Программа есть. Смотрим результат.

3—>1—>4—>2—>5—>3

Программа показала нам нужный маршрут нашей простецкой игры.





1. Динамические структуры данных C++. Однонаправленный список, очередь, стек, дек, двунаправленный список, двунаправленный кольцевой список, дек на двунаправленном списке,
1.1. Линейные однонаправленные списки
1.1.1. Общие сведения
1.1.2. Однонаправленные списки без заглавного звена
1.1.3. Построение списка с заглавным звеном
1.1.4. Удаление списка из памяти
1.2. Операции над списками с заглавным звеном.
1.2.1. Поиск звена
1.2.2. Включение звена после звена (1-й случай)
1.2.3. Включение звена с заданным информационным полем перед звеном (2-й случай)
1.2.4. Удаление звена после звена (1-й случай)
1.2.5. Удаление звена на которое указывает ссылка (2-й случай)
1.3. Ортогональные списки
1.3.1. Реализация операций над ортогональными списками
1.4. Кольцевые списки
1.4.1. Построение и вывод кольца
1.4.2. Основные операции
1.5. Списки магазинного типа
1.6. Списки магазинного типа. Очереди
1.6.1. Формирование очереди
1.6.2. Добавление звена к очереди
1.6.3. Удаление звена из очереди
1.7. Стек
1.7.1. Формирование стека
1.7.2. Включение звена в стек
1.7.3. Удаление звена из стека
1.8. Дек
1.9. Линейные двунаправленные списки
1.9.1. Формирование линейного двунаправленного списка
1.9.2. Проход по линейному двунаправленному списку, начиная с его начала
1.9.3. Проход по линейному двунаправленному списку, начиная с его конца
1.9.4. Поиск звена в двунаправленном списке, начиная с начала списка
1.9.5. Поиск звена в двунаправленном списке, начиная с конца списка
1.9.6. Вставка звена в двунаправленный список (1-й случай)
1.9.7. Вставка звена в двунаправленный список (2-й случай)
1.9.8. Удаление звена из двунаправленного списка. Указатель на удаляемое звено (1-й случай)
1.9.9. Удаление звена из двунаправленного списка. После звена (2-й случай)
1.10. Двунаправленные кольцевые списки
1.11. Деки на базе двунаправленных списков
1.11.1. Формирование дека и его просмотр
1.11.2. Добавление звена в начало дека
1.11.3. Добавление звена в конец дека
1.11.4. Удаление звена из дека слева
1.11.5. Удаление звена из дека справа

    1. Динамические структуры данных C++. Однонаправленный список, очередь, стек, дек, двунаправленный список, двунаправленный кольцевой список, дек на двунаправленном списке,

http://khpi-iip.mipk.kharkiv.edu/library/datastr/book_sod/kgsu/oglav.html

        1.1. Линейные однонаправленные списки
            1.1.1. Общие сведения
На этом шаге мы приведем общие сведения о списках.
Список - это совокупность объектов, называемых элементами списка, в которой каждый объект содержит информацию о местоположении связанного с ним объекта [1, с. 214].
Если список располагается в оперативной памяти, то, как правило, информация для поиска следующего объекта - это адрес (указатель) в памяти. Если список хранится в файле на диске, то информация о следующем элементе может включать смещение элемента от начала файла, положение указателя записи/считывания файла, ключ записи и любую другую информацию, позволяющую однозначно отыскать следующий элемент списка.
Каждый элемент списка представим структурой языка C++ с двумя полями:
    • информационное поле, которое в общем случае может содержать произвольное количество полей разных типов. Ясно, что если значением переменной p является ссылка на элемент списка, то присоединяя к обозначению (*p) с помощью точки имя соответствующего поля, можно манипулировать со значением любого поля информационной части;
    • ссылка на следующий элемент списка.

Каждую пару будем называть звеном, а ссылки, содержащиеся в каждом из звеньев, будем использовать для соединения звеньев в список. Такой способ представления упорядоченной последовательности звеньев называется сцеплением.
С учетом сказанного, мы можем описать звено списка так:

    struct node
    {
      int elem; //Информационный элемент звена списка
      node *sled; // Указатель на следующее звено списка
    };

Чтобы иметь возможность оперировать со списком как с единым объектом, введем в употребление статическую ссылочную переменную phead, которая указывает на первое звено списка и описывается следующим образом:

    struct node *phead;

            1.1.2. Однонаправленные списки без заглавного звена
На этом шаге мы рассмотрим построение списка без заглавного звена.
Приведем алгоритм построения однонаправленного списка без заглавного звена с помощью схем "до и после" [1]. В ниже приведенной схеме переменная phead - указатель на первый элемент списка, а t - указатель, содержащий адрес последнего (текущего) элемента списка.
    1. Отведем место для указателей в статической памяти:

    struct node *phead;
    struct node *t;


Рис.1. Размещение указателей

    2. В куче резервируем место для динамического объекта:

    phead = new (node);



Рис.2. Размещение объекта в куче

    3. Присвоим значение переменной t, и поместим в информационное поле значение элемента:

    t = phead;
    (*t).value = Элем;



Рис.3. Определение t

    4. Поместим в поле звена адрес нового динамического объекта, зарезервированного в куче:

    (*t).next = new (node);


Рис.4. Добавление нового элемента

    5. Переменная t должна содержать адрес последнего добавленного элемента:

    t = (*t).next;


Рис.5. t содержит адрес последнего элемента

    6. Если требуется завершить построение списка, то в поле указателя последнего элемента нужно поместить NULL:

    (*t).next = NULL;
    (*t).value = Элем1;


Рис.6. Результат выполнения операций

В результате построен линейный однонаправленный список без заглавного звена, содержащий два узла:


Рис.7. Конечный результат

Оформим алгоритм в виде программы на языке C++.

#include<iostream>
using namespace std;

struct node
{
   int value;
   node *next;
};

void main ()
{
   int i;
   node *phead, *t;

   setlocale(LC_ALL,"Rus");
   phead = new (node);
   t = phead;

   (*t).value = 1;
   (*t).next = new (node);
   t = (*t).next;

   (*t).value = 2;
   (*t).next = new (node);
   t = (*t).next;

   (*t).value = 6;
   (*t).next = new (node);
   t = (*t).next;

   (*t).value = 17;
   (*t).next = new (node);
   (*t).next = NULL;
   // Вывод содержимого информационных полей списка
   for (t = phead; t != NULL; t = (*t).next)
                cout << (*t).value << " ";

   cout << "\n";
   system("PAUSE");
}




            1.1.3. Построение списка с заглавным звеном
На этом шаге мы рассмотрим алгоритм построения списка с заглавным звеном.
Чтобы сделать действия, выполняемые при включении элемента в список (исключении элемента из списка), единообразными, обычно применяется следующий прием. В начало каждого списка добавляется заглавное звено (заголовок списка). Оно никогда не исключается из списка и перед ним в список никогда не включаются новые элементы.
Информационная часть заглавного звена или не используется вовсе, или используется для специальных целей. Например, в случае списка целых чисел она может содержать число, равное количеству звеньев в списке. Добавление заглавного звена в список приводит к тому, что теперь у всех элементов, в том числе и у первого, имеется предшественник, и действия по включению новых элементов в список (или исключение элементов из списка) проводятся единым способом.
Приведем алгоритм построения однонаправленного списка с заглавным звеном с сохранением порядка поступления звеньев. Шаги построения алгоритма будем иллюстрировать с помощью схем "до и после" Д.Кнута.

1) Вначале отведем место для указателей в статической памяти:

    struct node *phead;
    struct node *t;



Рис.1. Резервирование места в памяти

2) В куче зарезервируем место для динамического объекта, на который указывает phead:

    phead = new(node);



Рис.2. Выделили место для элемента списка

Построено заглавное звено будущего однонаправленного списка.
Выполним еще ряд подготовительных действий:

    t = phead;



Рис.3. Присвоим значение t

    (*t).sled = NULL;


Рис.4. Присвоим указателю заглавного звена NULL

Теперь можно приступить к циклическому процессу построения списка. Идентификатор Число обозначает объект языка C++, вводимый с клавиатуры.

    cin >> Число;
    while  (Число != Числу, определяющему окончание ввода)
      {
          (*t).sled = new (node); //Резервируем место для нового объекта.


Рис.5. Создаем новый объект

          t = (*t).sled; //Указатель t содержит адрес
                         //расположения созданного объекта.


Рис.6. Определяем t

          (*t).elem = Число; //Заполняем поля объекта.
          (*t).sled = NULL;


Рис.7. Результат заполнения полей

          cin >> Число; //Запрос на ввод следующего значения.
      }

Алгоритм построения оформим в виде функции на языке C++:

void POSTROENIE (node **phead)
// Построение списка с заглавным звеном.
// *phead - указатель на заглавное звено.
{
    node *t;
    int el;
    // Вначале создадим заглавное звено
    *phead = new (node);
    t = *phead; (*t).sled = NULL;
    cout << "Вводите элементы звеньев списка: ";
    cin >> el;
    while (el!=0)
    {
      (*t).sled = new (node); t = (*t).sled;
      (*t).elem = el; (*t).sled = NULL;
      cin >> el;
    }
}

Ясно, что пустой однонаправленный список с заглавным звеном можно схематически представить так:



Рис.8. Пустой однонаправленный список с заглавным звеном

На следующем шаге мы рассмотрим удаление списка из памяти.

            1.1.4. Удаление списка из памяти
На этом шаге мы рассмотрим алгоритм удаления списка из памяти.
Остановимся теперь на удалении однонаправленного линейного списка из динамической памяти.
Алгоритм удаления можно сформулировать следующим образом:
    • заводим два указателя q и q1, один из которых будет "опережать" другой (пусть q1 опережает q);
    • начальное значение q - это адрес расположения в памяти заглавного звена, а q1 - адрес расположения первого элемента списка;
    • организуем цикл, пока q1 != NULL, то есть пока q1 "не доберется" до указателя последнего элемента списка;
    • в теле цикла переместим указатели на следующую пару элементов списка (то есть для первого случая q будет содержать адрес первого звена списка, а q1 - второго), и удалим элемент, который адресуется значением q;
    • после выполнения цикла у нас останется только заглавное звено, адресуемое указателем phead. Его также нужно удалить.

Приведем текст функции, реализующей указанный алгоритм.

void OCHISTKA (node **phead)
//Удаление однонаправленного списка из памяти.
// *phead - указатель на заглавное звено списка.
{
  struct node *q, *q1; // Рабочие указатели.
  q = *phead;
  q1 = (*q).sled; // Указатель q1 "опережает" указатель q.
  while (q1!=NULL)
  { q = q1; q1 = (*q1).sled; delete q;}
  delete *phead; //Удаление заглавного звена.
}

Отметим, что одной из распространенных ошибок при составлении программ является неаккуратное обращение с динамически распределяемой памятью, в частности, "забывание" освободить ее после использования, что в конце концов может привести к аварийному завершению программы из-за нехватки оперативной памяти. Поиск же мест "засорения" оперативной памяти в отлаживаемых программах, занимающих значительный объем, может занять много места, поскольку к моменту комплексной отладки, когда эти ошибки попадаются на глаза, естественным образом забываются многие детали создания программных компонентов. Поэтому целесообразно с самого начала отладки программ отслеживать процесс возврата динамической памяти в "кучу".
Соберем рассмотренные функции в объектно-ориентированную программу.

Пример. Построение однонаправленного списка с заглавным звеном и его просмотр.

#include<iostream>
using namespace std;

class Spisok
{
  private:
    struct node
      {
        int elem;
        node *sled;
      } *phead; //Указатель на начало списка.
  public:
    Spisok() {phead = new (node); (*phead).sled=NULL;} //Конструктор.
    ~Spisok() { delete phead; } //Деструктор.
    void POSTROENIE ();
    void VYVOD ();
    void OCHISTKA ();
};

void main ()
{
  setlocale(LC_ALL,"Rus");
  Spisok A;

  A.POSTROENIE ();
  A.VYVOD ();
  A.OCHISTKA ();

  cout << "\n";
  system("PAUSE");
}

void Spisok::POSTROENIE ()
//Построение однонаправленного списка с заглавным звеном.
// phead - указатель на заглавное звено списка.
{
  node *t;
  int el;
  t = phead;
  cout << "Вводите элементы списка: ";
  cin >> el;
  while (el!=0)
  {
    (*t).sled = new (node);
    t = (*t).sled; (*t).elem = el; (*t).sled = NULL;
    cin >> el;
  }
}

void Spisok::VYVOD ()
//Вывод содержимого однонаправленного линейного списка
//с заглавным звеном.
// phead - указатель на заглавное звено списка.
{
  node *t;
  t = (*phead).sled;
  cout << "Список: ";
  while (t != NULL)
  {
    cout << (*t).elem << " ";
    t = (*t).sled;
  }
  cout << endl;
}

void Spisok::OCHISTKA ()
//Удаление однонаправленного списка из памяти.
// phead - указатель на заглавное звено списка.
{
  node *q, *q1;// Рабочие указатели.

  q = phead;
  q1 = (*q).sled; // Указатель q1 "опережает" указатель q.
  while (q1 != NULL)
  { q = q1; q1 = (*q1).sled; delete q;}
}



Со следующего шага мы начнем рассматривать основные операции над списками с заглавным звеном.

        1.2. Операции над списками с заглавным звеном.
            1.1.5. Поиск звена
На этом шаге мы приведем алгоритм поиска звена.
Приведем алгоритм последовательного поиска звена с заданным значением информационного поля в однонаправленном списке, записанный в виде функции языка C++:

void POISK (node **phead, int el, node **Res)
// Поиск звена с элементом el в списке, заданном указателем *phead.
// В случае успешного поиска в *Res находится адрес
// звена списка, содержащего элемент el, в случае неуспеха в *Res помещается NULL.
{
   node *t;

  *Res = NULL;
  t = *phead; t = (*t).sled;
  while (t != NULL && *Res == NULL)
      if ((*t).elem == el) *Res = t; else t = (*t).sled;
}

Со следующего шага мы начнем рассматривать алгоритмы включения звена в список.

            1.1.6. Включение звена после звена (1-й случай)
На этом шаге мы рассмотрим первый случай включения звена в список.
На этом шаге мы рассмотрим алгоритм включения звена в список после звена, на которое указывает заданная ссылка.
Предположим, что имеется однонаправленный список с заглавным звеном, и необходимо вставить звено с заданным информационным полем после звена, на которое указывает ссылка Res. Вставка звена осуществляется по следующему алгоритму.
    1) В куче резервируется место для динамического объекта:

    q = new (node);



Рис.1. Зарезервировали место под элемент списка

В информационное поле этого объекта помещается значение элемента, который необходимо вставить:

    (*q).elem = el;



Рис.2. Заполнение информационного поля

    2) В поле указателя помещается адрес элемента, следующего за звеном, на которое указывает Res:

    (*q).sled = (*Res).sled;


Рис.3. Заполнение поля указателя вставляемого элемента

И, наконец, после выполнения оператора

    (*Res).sled = q;

получаем результат, изображенный на следующей схеме:


Рис.4. Изменение указателя у предыдущего элемента

Алгоритм оформим в виде функции.

void VSTAV (node **Res, int el)
// Включение звена  с  информационным полем  el
//после звена, на которое указывает ссылка *Res.
{
  node *q;
  q = new (node);
  (*q).elem = el; (*q).sled = (**Res).sled;
  (**Res).sled = q;
}

На следующем шаге мы рассмотрим второй случай алгоритма включения в список звена.

            1.1.7. Включение звена с заданным информационным полем перед звеном (2-й случай)
На этом шаге мы рассмотрим второй случай включения звена и приведем пример программы, реализующей рассмотренные действия.
На этом шаге мы рассмотрим алгоритм включения в однонаправленный список звена с заданным информационным полем перед звеном, на которое указывает заданная ссылка Res.


Рис.1. Начальное положение

    1) Опишем алгоритм при помощи схем Д.Кнута "до и после":

    q = new (node);


Рис.2. Выделение места в памяти для нового звена

    2) 
    (*q).elem = (*Res).elem;
    (*q).sled = (*Res).sled;


Рис.3. Заполнение полей нового элемента

    3) 
    (*Res).elem = el;
    (*Res).sled = q;


Рис.4. Включение элемента в список

Приведем функцию, реализующую описанное включение:

void VSTAV1 (node **Res, int el)
//Включение звена с информационным полем el
//перед звеном, на  которое  указывает *Res.
{
  node *q;
  q = new (node);
  (*q).elem = (**Res).elem; (*q).sled = (**Res).sled;
  (**Res).elem = el; (**Res).sled = q;
}

Пример. Включение звена с заданным элементом в однонаправленный список с заглавным звеном.

#include<iostream>
using namespace std;

struct node
{
	int  elem;
	node *sled;
};

class Spisok
{
  private:
    node *phead; //Указатель на заглавное звено списка.
    node *Res; //Указатель на найденное звено списка.
  public:
    Spisok() {phead=new(node); (*phead).sled=NULL; Res=NULL;}
    ~Spisok() { delete phead; }
    void POSTROENIE();
    void VYVOD();
    node *POISK(int);
    void VSTAV(int);
    void VSTAV1(int);
    void OCHISTKA();
};

void main ()
{
  setlocale(LC_ALL,"Rus");
  Spisok A;
  int  el,el1;

  A.POSTROENIE ();
  A.VYVOD ();
  cout<<"\nВведите элемент звена, после которого ";
  cout<<"осуществляется вставка:\n";
  cin>>el;
  cout<<"Введите элемент вставляемого звена:\n";
  cin>>el1;
  if  (A.POISK(el)!=NULL)
  {
    A.VSTAV (el1); A.VYVOD ();
  }
  else  cout<<"Звена с заданным элементом в списке нет!";
  cout<<"\nВведите элемент звена, перед которым  ";
  cout<<"осуществляется вставка:\n";
  cin>>el;
  cout<<" Введите элемент вставляемого звена:\n";
  cin>>el1;
  if  (A.POISK (el)!=NULL)
  {
    A.VSTAV1 (el1); A.VYVOD ();
  }
  else  cout<<" Звена с заданным элементом в списке нет!";
  A.OCHISTKA();

  cout << "\n";
  system("PAUSE");
}

void Spisok::POSTROENIE ()
// Построение однонаправленного списка с заглавным звеном.
// phead - указатель на заглавное звено списка         
{
  node *t;
  int   el;
  t = phead;
  cout<<"Вводите элементы звеньев списка: ";
  cin>>el;
  while  (el!=0)
  {
    (*t).sled = new (node);
    t = (*t).sled; (*t).elem = el; (*t).sled = NULL;
    cin>>el;
  }
}

void Spisok::VYVOD ()
// Вывод содержимого однонаправленного списка с
// заглавным звеном.  phead - указатель на заглавное звено списка.
{
  node *t;

  t =(*phead).sled;
  cout<<"Список: ";
  while  (t!=NULL)
  {
    cout<<(*t).elem<<" "; t = (*t).sled;
  }
  cout<<endl;
}

node *Spisok::POISK (int el)
//Поиск звена с элементом el в списке, заданном указателем
//phead. В случае успешного поиска в Res находится адрес
//звена списка, содержащего элемент el, в случае  неуспеха
//в Res помещается NULL.
{
  node *t;

  Res = NULL; t = (*phead).sled;
  while  (t!=NULL && Res==NULL)
    if  ((*t).elem==el)
      Res = t;
    else  t = (*t).sled;

  return Res;
}

void Spisok::VSTAV (int el)
// Включение звена  с  информационным полем  el
// после звена, на которое указывает ссылка Res.
{
  node *q;

  q = new(node);
  (*q).elem = el;
  (*q).sled = (*Res).sled; (*Res).sled = q;
}

void Spisok::VSTAV1 (int el)
// Включение звена с информационным полем el
// перед звеном, на  которое  указывает  Res.
{
  node *q;

  q = new (node);
  (*q).elem = (*Res).elem; (*q).sled = (*Res).sled;
  (*Res).elem = el; (*Res).sled = q;
}

void Spisok::OCHISTKA ()
//Удаление однонаправленного списка из памяти.
// phead - указатель на заглавное звено списка.
{
  node *q,*q1;// Рабочие указатели.

  q = phead;
  q1 = (*q).sled; // Указатель q1 "опережает" указатель q.
  while (q1!=NULL)
    { q = q1; q1 = (*q1).sled; delete q;}
}



Со следующего шага мы начнем рассматривать удаление звена из списка.

            1.1.8. Удаление звена после звена (1-й случай)
На этом шаге мы рассмотрим один из алгоритмов удаления звена.
На этом шаге мы рассмотрим алгоритм удаления звена, расположенного после звена, на которое указывает ссылка Res.
Воспользуемся схемами "до и после":

    1) 

    q = (*Res).sled;



Рис.1. Определение местоположения удаляемого звена.

    2) Проверяем, не является ли звено, после которого нужно удалять, последним. В этом случае удалять нечего.

    if  (q!=NULL) //Если звено, после которого нужно удалять,
                             // не является последним, то...
    {
       (*Res).sled = (*(*Res).sled).sled;


Рис.2. Исключение удаляемого элемента из списка

    3) Последняя тонкость: присоединение "кусочка" heap-области к списку свободной памяти:

      delete q;


Рис.3. Возврат памяти в кучу

    }

Приведем текст функции удаления:

void YDALE (node **Res)
// Удаление  звена, расположенного  после
// звена, на которое указывает ссылка *Res.
{
  node *q;

  q = (**Res).sled;
  if (q!=NULL)
      // Если звено, после которого нужно удалять,
      // не является последним, то...
    { (**Res).sled = (*(**Res).sled).sled; delete q; }
  else
    cout<<"Звено с заданным элементом - последнее!\n";
}

На следующем шаге мы продолжим рассматривать алгоритмы удаления звена.

            1.1.9. Удаление звена на которое указывает ссылка (2-й случай)
На этом шаге мы рассмотрим другой случай удаления звена.
На этом шаге мы рассмотрим алгоритм удаления звена, на которое указывает ссылка Res.
Воспользуемся схемами "до и после":

    1) Определяем местоположение следующего за удаляемым элемента.

    q = (*Res).sled;


Рис.1. Сохранение адреса следующего элемента

    2) Определяем, не является ли удаляемое звено последним. В зависимости от этого реализация алгоритма будет различной.

    if (q!=NULL)
    {//Если удаляемое звено не является последним, то ...
      (*Res).elem = (*q).elem;
      (*Res).sled = (*q).sled;


Рис.2. "Переписываем" следующий элемент в удаляемый

    3) Последняя тонкость: присоединение "кусочка" heap-области к списку свободной памяти:

      delete q;


Рис.3. Возврат памяти в кучу

    }

    4) Теперь рассмотрим ситуацию, когда удаляемое звено является последним звеном списка:


Рис.4. Удаляемый элемент – последний

Найдем указатель на предпоследнее звено линейного списка с помощью двух вспомогательных указателей q1 и q2, перемещающихся по списку "параллельно друг другу", причем указатель q2 "опережает" указатель q1 на один шаг.

    q1 = phead; q2 = (*q1).sled; //Инициализация указателей.
    while (q2!=Res)
    { q1 = q2; q2 = (*q2).sled;}

После выполнения цикла while, мы получим следующую ситуацию:


Рис.5. Положение указателей

    5) Приступим к удалению:

    (*q1).sled = NULL; q2 = NULL; delete  (Res);


Рис.6. После удаления

Приведем текст функции удаления:

void YDALE1 (node **phead, node **Res)
//Удаление звена, на которое указывает ссылка *Res
//из однонаправленного списка с заглавным звеном.
//*phead - указатель на заглавное звено списка.
{
  node *q,*q1,*q2;
  q = (**Res).sled;
  if (q!=NULL)
  { (**Res).elem = (*q).elem; (**Res).sled = (*q).sled;delete q; }
  else
  { q1 = *phead; q2 = (*q1).sled; //Инициализация указателей.
     while (q2!=*Res)
        { q1 = q2; q2 = (*q2).sled; }
    (*q1).sled = NULL; q2 = NULL; delete *Res;
  }
}

Приведем пример программы, осуществляющей удаление звена из однонаправленного списка с заглавным звеном.

#include<iostream>
using namespace std;

struct node
{
  int  elem;
  node *sled;
};
 class Spisok {
   private:
     node *phead, *Res;
   public:
     Spisok() {phead=new(node);Res=NULL;}
     ~Spisok() {delete phead;}
     void POSTROENIE ();
     void VYVOD ();
     node *POISK (int);
     void YDALE ();
     void YDALE1();
     void OCHISTKA();
 };

void main ()
{
  setlocale(LC_ALL,"Rus");
  Spisok A;
  int   el;
  node *Res_Zn;

  A.POSTROENIE ();
  A.VYVOD ();
  cout<<"\nВведите элемент звена, после которого ";
  cout<<"осуществляется удаление:\n";
  cin>>el;
  Res_Zn=A.POISK (el);
  if  (Res_Zn!=NULL && (*Res_Zn).sled!=NULL)
    {A.YDALE (); A.VYVOD ();}
  else  cout<<"Звена с заданным элементом в списке нет!";
  cout<<"\nВведите удаляемый элемент звена:\n";
  cin>>el;
  Res_Zn=A.POISK (el);
  if  (A.POISK (el)!=NULL)
  {
    A.YDALE1 (); A.VYVOD (); cout<<endl;
  }
  else  cout<<"Звена с заданным элементом в списке нет!";
  A. OCHISTKA();

  cout << "\n";
  system("PAUSE");
}

void Spisok::POSTROENIE ()
//Построение однонаправленного списка с заглавным звеном.
//phead -указатель на заглавное звено
{
  node *t;
  int  el;

  t = phead; (*t).sled = NULL;
  cout<<"Вводите элементы звеньев списка: ";
  cin>>el;
  while  (el!=0)
  {
    (*t).sled = new (node);
    t = (*t).sled; (*t).elem = el; (*t).sled = NULL;
    cin>>el;
  }
}

void Spisok::VYVOD ()
//Вывод содержимого однонаправленного списка.
//phead - указатель на заглавное звено.
{
  node *t;

  t = phead; t = (*t).sled;
  cout<<"Список: ";
  while  (t!=NULL)
  {
	 cout<<(*t).elem <<" ";
    t = (*t).sled;
  }
}

 node *Spisok::POISK (int el)
//Поиск звена с элементом el в списке, заданном указателем phead.
//В случае успешного поиска в Res находится адрес искомого звена
//списка. В противном случае Res содержит NULL.
{
  node *t;

  Res = NULL; t = phead; t = (*t).sled;
  while  (t!=NULL && Res==NULL)
    if  ((*t).elem==el)  Res = t;
    else  t = (*t).sled;
  return Res;
}

void Spisok::YDALE ()
//Удаление звена, расположенного после звена,
//на которое указывает ссылка Res.
{
  node *q;
  q = (*Res).sled;
  if  (q!=NULL)
  {
    //Если звено, после которого нужно удалять,
    //не является последним, то:
    (*Res).sled = (*(*Res).sled).sled; delete q;
  }
  else
    cout<<"Звено с заданным элементом - последнее!\n";
}

void Spisok::YDALE1 ()
//Удаление звена, на которое указывает ссылка Res.
{
  node *q,*q1,*q2;

  q = (*Res).sled;
  if  (q!=NULL)
  {
    (*Res).elem = (*q).elem; (*Res).sled = (*q).sled;
    delete q;
  }
  else
  {
     q1 = phead; q2 = (*q1).sled;
    while  (q2!=Res)
    {
        q1 = q2; q2 = (*q2).sled;
    }
    (*q1).sled = NULL; q2 = NULL; delete Res;
  }
}

void Spisok::OCHISTKA ()
//Удаление однонаправленного списка из памяти.
// phead - указатель на заглавное звено списка.
{
  node *q,*q1;// Рабочие указатели.

  q = phead;
  q1 = (*q).sled; // Указатель q1 "опережает" указатель q.
  while (q1!=NULL)
  { q = q1; q1 = (*q1).sled; delete q;}
}



Со следующего шага мы начнем рассматривать ортогональные списки.

        1.3. Ортогональные списки
На этом шаге мы рассмотрим структуру ортогональных списков.
До сих пор мы рассматривали линейные структуры динамических переменных. Добавление к динамической переменной двух и более полей указателей создает возможность построения нелинейных структур. Дело в том, что при решении практических задач обычно не удается обойтись только линейными динамическими структурами данных (список, очередь, стек, дек и т.д.): приходится создавать структуры данных, максимально отражающие существо выполняемой исполнителем задачи.
Мы рассмотрим только простейшие нелинейные динамические структуры, которые называются ортогональными списочными структурами (ортогональными списками, многосвязными списками).
Более точно, ортогональными списками называется списочная структура данных, в которой узлы могут принадлежать более чем одному списку и содержать более одного указателя.
На рисунке изображено графическое представление ортогональных списков:


Рис.1. "Гирлянды" и "висюльки"

Горизонтальный линейный однонаправленный список с заглавным звеном мы будем называть гирляндой. Каждое звено этого списка содержит три поля, причем, если указатель P указывает на звено гирлянды, то:
    • поле (*P).Key является информационным полем узла гирлянды;
    • поле (*P).Next содержит указатель на следующее звено гирлянды;
    • поле (*P).Trail содержит указатель на линейный однонаправленный список с заглавным звеном, который называется висюлькой (английское слово Trail переводится как "тащиться, свисать, волочиться").

Звено каждой висюльки содержит два поля: Id и Next, причем, если указатель Q указывает на элемент висюльки, то:
поле (*Q).Id является информационным полем звена висюльки;
поле (*Q).Next указывает на следующее звено данной висюльки.

На следующем шаге мы приведем реализацию простейших операций над ортогональными списками.

            1.1.10. Реализация операций над ортогональными списками
На этом шаге мы приведем пример программы, реализующей основные операции над ортогональными списками.
Приведем реализацию на языке C++ простейших операций над ортогональными списками ("гирляндо-висюлечной" структурой).
Сначала опишем типы данных:

// Описание типа звена гирлянды.
struct nodeGir
{
int elem; // Информационное поле звена гирлянды.
nodeVis *vniz; // Указатель на звено висюльки.
nodeGir *sled; // Указатель на звено гирлянды.
};
// Описание типа звена висюльки.
struct nodeVis
{
int elem; // Информационное поле звена висюльки.
nodeVis *vniz; // Указатель на звено висюльки.
};

Приведем программу, демонстрирующую работу с "гирляндо-висюлечной" структурой.

#include<iostream>
using namespace std;

struct nodeVis
{
  int elem; //Информационное поле звена висюльки.
  nodeVis *vniz;//Указатель на звено висюльки.
};
struct nodeGir
{
  int elem;//Информационное поле звена гирлянды.
  nodeVis *vniz;//Указатель на звено висюльки.
  nodeGir *sled;//Указатель на звено гирлянды.
};

class GirVis {
  private:
    nodeGir *phead;//Голова гирлянды.
    nodeVis *pheadVis;//Голова висюльки.
    void VisVyvod ();
  public:
	 GirVis() {phead = new (nodeGir); }
	 ~GirVis() {delete phead;}
	 nodeVis *VisPostr ();
	 nodeVis* VisPoisk (int);
	 void SetpheadVis (nodeVis *r) {pheadVis=r;} //Определение головы висюльки.
	 void VisVstav (nodeVis *,int);
	 void Vis1Vstav (nodeVis *,int);
	 void  VisUdale (nodeVis *);
	 void Vis1Udale (nodeVis *);
	 void GirPostr ();
	 void GirVyvod ();
	 nodeGir *GirPoisk (int);
	 void OCHISTKA();
	 void OCHISTKA1();
};

void main ()
{
  setlocale(LC_ALL,"Rus");
  GirVis A;
  int el,elGir,elVis;
  nodeGir *Res; //Рабочий указатель.
  nodeVis *ResVis; //Указатель на звено висюльки.

  A.GirPostr ();
  A.GirVyvod ();
  cout<<"\nВведите элемент звена гирлянды, ";
  cout<<"чьи висюльки будем изменять:\n";
  cin>>elGir;
  cout<<"\nВведите элемент звена висюльки, после которого ";
  cout<<"осуществляется вставка:\n";
  cin>>elVis;
  cout<<"\nВведите вставляемый элемент:\n";
  cin>>el;
  //Поиск элемента elGir в гирлянде.
  Res=A.GirPoisk (elGir);
  if  (Res!=NULL)
  {
    //Поиск элемента elVis в висюльке.
	 A.SetpheadVis((*Res).vniz);
	 ResVis=A.VisPoisk (elVis);
    if  (ResVis!=NULL)
      A.VisVstav (ResVis,el);
	 else  cout<<"Элемента в висюльке нет!\n";
  }
  else  cout<<"Элемента в гирлянде нет\n";
  A.GirVyvod ();

  cout<<"\nВведите элемент гирлянды, чью висюльку будем изменять:\n";
  cin>>elGir;
  cout<<"Введите элемент висюльки, перед которым ";
  cout<<"осуществляется вставка:\n";
  cin>>elVis;
  cout<<"Введите вставляемый элемент:\n";
  cin>>el;
  //Поиск элемента elGir в гирлянде.
  Res=A.GirPoisk (elGir);
  if  (Res!=NULL)
  {
    //Поиск элемента elVis в висюльке.
    A.SetpheadVis((*Res).vniz);
    ResVis=A.VisPoisk (elVis);
    if  (ResVis!=NULL)
      A.Vis1Vstav (ResVis,el);
    else  cout<<"Элемента в висюльке нет!\n";
  }
  else  cout<<"Элемента в гирлянде нет!\n";
  A.GirVyvod ();

  cout<<"\nВведите элемент гирлянды, чью висюльку будем изменять:\n";
  cin>>elGir;
  cout<<"Введите элемент висюльки, после которого нужно удалить:\n";
  cin>>elVis;
  //Поиск элемента elGir в гирлянде.
  Res=A.GirPoisk (elGir);
  if  (Res!=NULL)
  {
    //Поиск элемента elVis в висюльке.
    A.SetpheadVis((*Res).vniz);
    ResVis=A.VisPoisk (elVis);
    if  ((ResVis!=NULL) && ((*ResVis).vniz!=NULL))
      A.VisUdale (ResVis);
    else  cout<<"Элемента в висюльке нет!\n";
  }
  else  cout<<"Элемента в гирлянде нет!\n";
  A.GirVyvod ();

  cout<<"\nВведите элемент гирлянды, чью висюльку будем изменять:\n";
  cin>>elGir;
  cout<<"Введите элемент висюльки, который удаляется:\n";
  cin>>elVis;
  //Поиск элемента elGir в гирлянде.
  Res=A.GirPoisk (elGir);
  if  (Res!=NULL)
  {
    //Поиск элемента elVis в висюльке.
    A.SetpheadVis((*Res).vniz);
    ResVis=A.VisPoisk (elVis);
    if  ((ResVis!=NULL) && ((*ResVis).vniz!=NULL))
      A.Vis1Udale (ResVis);
    else  cout<<"Элемента в висюльке нет или он последний!\n";
  }
  else  cout<<"Элемента в гирлянде нет!\n";
  A.GirVyvod ();
  A.OCHISTKA();

  cout << "\n";
  system("PAUSE");
}

void GirVis::OCHISTKA()
{
  nodeGir *q,*q1;//Рабочие указатели.
  q = phead;
  q1 = (*q).sled; //Указатель q1 "опережает" указатель q.

  while (q1!=NULL)
  { q = q1; q1 = (*q1).sled;
    pheadVis=(*q).vniz;
    OCHISTKA1(); //Очистка висюльки.
    delete q;}
}

void GirVis::OCHISTKA1()
{
  nodeVis *q,*q1;
  q=pheadVis;
  q1 = (*q).vniz;
  while (q1!=NULL)
    { q = q1; q1 = (*q1).vniz;
      delete q;}
}

void GirVis::GirPostr ()
//Построение однонаправленного списка с заглавным звеном,
//заданного указателем phead (построение гирлянды).
{
  nodeGir *t;
  int el;
  t = phead; (*t).sled = NULL;
  cout<<"Вводите элемент гирлянды: \n";
  cin>>el;
  while  (el!=0)
  {
    (*t).sled = new (nodeGir);
     t = (*t).sled; (*t).elem = el; (*t).sled = NULL;
     (*t).vniz=VisPostr();
    cout<<" Вводите элемент гирлянды: \n";
    cin>>el;
  }
}

nodeVis *GirVis::VisPostr ()
//Построение однонаправленного списка с заглавным звеном
//(построение висюльки). pheadVis - указатель на висюльку.
{
  nodeVis *t;
  int el;
  //Создадим заглавное звено списка.
  pheadVis = new (nodeVis);
  t = pheadVis; (*t).vniz = NULL;
  cout<<"Вводите элементы звеньев висюльки: \n";
  cin>>el;
  while  (el!=0)
  {
    (*t).vniz = new (nodeVis);
    t = (*t).vniz; (*t).elem = el; (*t).vniz = NULL;
    cin>>el;
  }
  return pheadVis;
}


void GirVis::GirVyvod ()
//Вывод содержимого однонаправленного списка, заданного
//указателем phead (вывод содержимого гирлянды).
{
  nodeGir *t;

  t = phead; t = (*t).sled;
  cout<<"Гирлянда: ";
  while  (t!=NULL)
  {
    cout<<(*t).elem<<" ";
    pheadVis=(*t).vniz;
    VisVyvod ();
    t = (*t).sled;
  }
}

nodeGir *GirVis::GirPoisk (int el)
//Поиск элемента el в списке, заданном указателем phead.
//В случае успешного поиска возвращается адрес звена списка,
//содержащего элемент el. В противном случае - NULL.
{
  nodeGir *t,*r;

  r = NULL; t = phead; t = (*t).sled;
  while  (t!=NULL && r==NULL)
  if  ((*t).elem==el) r = t;
  else  t = (*t).sled;
  return r;
}

void GirVis::VisVyvod ()
//Вывод содержимого однонаправленного списка с заглавным звеном,
//заданного указателем pheadVis (вывод содержимого висюльки).
{
  nodeVis *t;

  t = pheadVis; t = (*t).vniz;
  cout<<"(";
  while  (t!=NULL)
  {
    cout<<(*t).elem<<" "; t = (*t).vniz;
  }
  cout<<")";
}

nodeVis *GirVis::VisPoisk (int el)
//Поиск элемента el в списке, заданном указателем pheadVis.
//В случае успешного поиска возвращается адрес звена списка,
//содержащего элемент el. В противном случае - NULL.
{
  nodeVis *t,*r;

  r = NULL; t = pheadVis; t = (*t).vniz;
  while  (t!=NULL && r==NULL)
  if  ((*t).elem==el) r = t;
  else  t = (*t).vniz;

  return r;
}

void GirVis::VisVstav (nodeVis *r,int el)
//Включение звена с информационным полем el
//после звена, на которое указывает r
//(включение звена в висюльку).
{
  nodeVis *q;

  q = new (nodeVis);
  (*q).elem = el; (*q).vniz = (*r).vniz; (*r).vniz = q;
}

void GirVis::Vis1Vstav (nodeVis *r,int el)
//Включение звена с информационным полем el
//перед звеном, на которое указывает r
//(включение звена в висюльку).
{
  nodeVis *q;

  q = new (nodeVis);
  (*q).elem = (*r).elem; (*q).vniz = (*r).vniz;
  (*r).elem = el; (*r).vniz = q;
}

void GirVis::VisUdale (nodeVis *r)
//Удаление звена, расположенного после звена,
//на которое указывает ссылка r
//(удаление звена висюльки).
{
  nodeVis *q;
  q = (*r).vniz;
  if  ((*r).vniz!=NULL)
  {
    (*r).vniz = (*(*r).vniz).vniz; delete q;
  }
  else  cout<<"Звено с заданным элементом - последнее!\n";
}

void GirVis::Vis1Udale (nodeVis *r)
//Удаление звена, на которое указывает ссылка r
//(удаление звена висюльки).
{
  nodeVis *g;

  if  ((*r).vniz!=NULL)
  {
    g = (*r).vniz;
    (*r).elem = (*(*r).vniz).elem;
    (*r).vniz = (*(*r).vniz).vniz;
    delete g;
  }
  else  cout<<"Не умею удалять последнее звено!\n";
}



Со следующего шага мы начнем знакомиться с кольцами.

        1.4. Кольцевые списки
            1.1.11. Построение и вывод кольца
На этом шаге мы рассмотрим построение и вывод кольца.
Хотя структура в виде линейного списка является весьма полезной, у нее имеется ряд недостатков. Сейчас мы рассмотрим другие методы организации списков и использование их с целью устранения этих недостатков.
Один из недостатков линейных списков заключается в том, что, зная указатель p на звено списка, мы не имеем доступа к предшествующим ему звеньям. Если производится просмотр списка, то для повторного обращения к нему исходный указатель на начало списка должен быть сохранен.
Предположим теперь, что в структуре линейного списка было сделано изменение, при котором поле sled последнего элемента содержит указатель "назад" или на заглавное звено, или на элемент, следующий за заглавным звеном.
Под кольцевым (циклическим) списком понимается список, в котором указатель из некоторой ячейки направлен на такое место в списке, откуда данная ячейка может быть достигнута снова [1]. Очевидно, что теперь мы можем из любого звена списка, "перемещаясь" по указателям достичь любого другого звена.
Кольцевым списком (кольцом) на базе линейного однонаправленного списка называется линейный список, в котором указатель из некоторого звена направлен на такое звено в списке, из которого данное звено может быть достигнуто вновь.
Опишем два способа представления однонаправленного кольцевого списка с заглавным звеном:


Рис.1. Кольцо с удаленным заглавным звеном

Такой кольцевой список будем называть кольцевым списком с удаленным заглавным звеном.
Пустой кольцевой список с удаленным заглавным звеном представим так:


Рис.2. Пустое кольцо с удаленным заглавным звеном


Рис.3. Кольцо с включенным заглавным звеном

А этот кольцевой список назовем кольцевым списком с включенным заглавным звеном.
Пустой кольцевой список с включенным заглавным звеном представим так:


Рис.4. Пустое кольцо с включенным заглавным звеном

Рассмотрим способ построения кольцевого списка. Построение выполняется так же, как и в случае линейного однонаправленного списка с заглавным звеном, только после окончания ввода элементов кольцевого списка, в поле указателя последнего звена списка помещается адрес звена, следующего за заглавным.
Сказанное легко формализуется:

void POSTROENIE (node **phead)
//Построение кольцевого списка с заглавным звеном.
//*phead - указатель на заглавное звено.
{
  int el;
  struct node *t;
  // Вначале сформируем заглавное звено.
  *phead = new (node);
  t = *phead; (*t).sled = NULL;
  cout<<"Вводите элементы кольца: "; cin>>el;
  while (el!=0)
  { (*t).sled = new (node); t = (*t).sled; (*t).elem = el;
    cin>>el;
  }
  (*t).sled = (*(*phead)).sled;
}

Вывод на экран дисплея содержимого информационных полей кольцевого списка производится до тех пор, пока рабочий указатель, перемещающийся по кольцу, не совпадет с указателем на звено, расположенное после заглавного:

void VYVOD (node **phead)
//Вывод содержимого кольцевого списка с удаленным
// заглавным звеном.
//*phead - указатель на заглавное звено.
{
  struct node *t;
  t = (**phead).sled; cout<< "Кольцо: ";
  if (t!=NULL)
  { cout<<(*t).elem; t = (*t).sled;
     while (t!=(**phead).sled)
      {
        cout<<(*t).elem;
        t = (*t).sled; }
      }
  else cout<<"пусто!\n";
}

На следующем шаге мы перечислим основные операции над кольцами.

            1.1.12. Основные операции
На этом шаге мы приведем пример, иллюстрирующий использование основных операций над кольцевыми списками (построение кольцевого списка, вывод списка, поиск элемента(по данным), вставка звена после заданного, вставка звена перед заданным, удаление заданного звена, удаление звена после заданного, очистка кольцевого списка).
На этом шаге мы приведем лишь обобщающий пример. Приведем текст программы, осуществляющий включение звена в кольцо с удаленным заглавным звеном, а также удаление звена с заданным значением информационного поля из кольца с удаленным заглавным звеном.

#include<iostream>
using namespace std;

struct node
{
  int elem;
  node *sled;
};
class Spisok {
  private:
    node *phead,*Res;
  public:
    Spisok () {phead=new(node);Res=NULL;}
    ~Spisok() {delete phead;}
    void POSTROENIE ();
    void VYVOD ();
    node *POISK (int);
    void InsAfter (int);
    void InsBefore (int);
    void Delete ();
    void DelAfter ();
    void OCHISTKA();
};

void main ()
{
  setlocale(LC_ALL,"Rus");
  Spisok A;
  int el,el1;
  node *Res_Zn;

  A.POSTROENIE();
  A.VYVOD();
  cout<<"\nВведите элемент звена, после которого ";
  cout<<"осуществляется вставка: ";
  cin>>el;
  cout<<"\nВведите элемент вставляемого звена: ";
  cin>>el1;
  if  (A.POISK(el)!=NULL)
  { A.InsAfter (el1); A.VYVOD ();}
  else  cout<<"Звена с заданным элементом в кольце нет!";
  cout<<"\nВведите элемент звена, перед которым ";
  cout<<"осуществляется вставка: ";
  cin>>el;
  cout<<"Введите элемент вставляемого звена: ";
  cin>>el1;
  if  (A.POISK(el)!=NULL)
  {
    A.InsBefore(el1); A.VYVOD ();
  }
  else  cout<<"Звена с заданным элементом в кольце нет!";
  cout<<"\nВведите элемент удаляемого звена: ";
  cin>>el;
  if  (A.POISK(el)!=NULL)
  {
    A.Delete (); A.VYVOD ();
  }
  else  cout<<"Звена с заданным элементом в кольце нет!";
  cout<<"\nВведите элемент звена, ";
  cout<<"после которого нужно удалять: ";
  cin>>el;
  if  (A.POISK(el)!=NULL)
  {
    A.DelAfter (); A.VYVOD ();
  }
  else  cout<<" Звена с заданным элементом в кольце нет!";
  A.OCHISTKA();

  cout << "\n";
  system("PAUSE");
}

void Spisok::POSTROENIE ()
//Построение кольцевого списка с удаленным заглавным звеном.
//phead - указатель на заглавное звено.
{
  node *t;
  int  el;

  t = phead; (*t).sled = NULL;
  cout<<"Вводите элементы кольца: ";
  cin>>el;
  while  (el!=0)
  {
    (*t).sled = new (node);
    t = (*t).sled; (*t).elem = el;
    cin>>el;}
  (*t).sled = (*phead).sled;
}

void Spisok::VYVOD ()
//Вывод содержимого кольцевого списка с удаленным заглавным звеном.
//phead - указатель на заглавное звено.
{
  node *t;
  t = (*phead).sled;
  cout<<"Кольцо: ";
  if  (t!=NULL)
  {
    cout<<(*t).elem<<" "; t = (*t).sled;
    while  (t!=(*phead).sled)
    { cout<<(*t).elem << " "; t = (*t).sled; }
  }
  else  cout<<"пусто!\n";
}

node *Spisok:: POISK (int el)
//Поиск элемента el в кольцевом списке phead.
//Если элемент найден, то Res содержит указатель на звено,
//содержащее элемент el. В противном случае - NULL.
{
  node *t;
  Res = NULL; t =(*phead).sled;
  while ((*t).sled!=(*phead).sled && Res==NULL)
  if  ((*t).elem==el) Res = t;
  else  t = (*t).sled;

  if  (Res==NULL && (*t).elem==el)
    Res = t;

  return Res;
}

void Spisok::InsAfter (int el)
//Включение звена с информационным полем el в кольцо
//после звена, на которое указывает ссылка Res.
{
  node *q;

  q = new (node);
  (*q).elem = el; (*q).sled = (*Res).sled;
  (*Res).sled = q;
}

void Spisok::InsBefore (int el)
//Включение звена с информационным полем el в кольцо
//перед звеном, на которое указывает ссылка Res.
{
  node *q;
  q = new (node);
  (*q).elem = (*Res).elem; (*q).sled = (*Res).sled;
  (*Res).elem = el; (*Res).sled = q;
}

void Spisok::Delete ()
//Удаление звена, на которое указывает ссылка Res,
//из кольцевого списка с удаленным заглавным звеном,
//заданного указателем phead.
{
  node *z,*q;

  if  ((*Res).sled!=(*phead).sled)
  {
    q = (*Res).sled;
    (*Res).elem = (*((*Res).sled)).elem;
    (*Res).sled = (*((*Res).sled)).sled;
    delete q;
  }
  else  if  ((*Res).sled==Res)
        {
           //В кольце единственное звено.
           q = (*phead).sled; (*phead).sled = NULL;
          delete q; cout<<"Кольцо пусто!";
        }
       else
       {
         //Удаляется "последнее" звено кольца.
         z = phead; q = (*phead).sled;
         while  (q!=Res)
           { z = q; q = (*q).sled; }
         (*z).sled = (*((*z).sled)).sled;
         delete q;
        }
}

void Spisok::DelAfter ()
//Удаление звена, расположенного после звена,
//на которое указывает ссылка Res,
//из кольцевого списка с удаленным заглавным звеном,
//заданного указателем phead.
{
  node *q;

  if  ((*Res).sled!=(*phead).sled)
  {
    //Ссылка Res не указывает на последнее звено.
    q = (*Res).sled;
    (*Res).sled = (*((*Res).sled)).sled;
    delete q;
  }
  else  if  ((*Res).sled==Res)
          {
            //Удаляемое звено - единственное в кольце.
            q = (*phead).sled; (*phead).sled = NULL;
            delete q; cout<<"Кольцо пусто!";
           }
          else
          {
            //Удаляемое звено - первое в кольце и не единственное.
            q = (*phead).sled;
           (*Res).sled = (*((*Res).sled)).sled;
           (*phead).sled  = (*Res).sled; delete q;
           }
}

void Spisok::OCHISTKA()
{
  node *q,*q1;// Рабочие указатели.
  q = phead;
  q1 = (*q).sled; // Указатель q1 "опережает" указатель q.
  do {
        q = q1;
        q1 = (*q1).sled;
        delete q;
       }
  while (q1!=(*phead).sled);
}



Со следующего шага мы начнем рассматривать списки магазинного типа.

        1.5. Списки магазинного типа
На этом шаге мы дадим общую характеристику списков магазинного типа.
В практике информационного моделирования часто используются линейные списки, в которых включение, исключение или доступ к звеньям почти всегда производится в первом или последнем звеньях.
Назовем списком магазинного типа линейный список, все звенья которого вставляются и удаляются только с одного или обоих концов списка. Списки магазинного типа подразделяются на очереди, стеки и деки.
Очередь - список магазинного типа, в котором все включения производятся на одном конце списка, а все исключения делаются на другом его конце.
Очередь иногда называют циклической памятью или списком типа FIFO ("First In - First Out" - "первым включается - первым исключается").
Мы часто будем использовать термины начало и конец очереди: информация помещается в конец очереди и удаляется в момент, когда, наконец, достигает ее начала. Изобразим это схематически:


Рис.1. Очередь

Стек - список магазинного типа, в котором все включения и исключения звеньев делаются в одном конце списка.
Из стека мы всегда исключаем "младший" элемент из имеющихся в списке (тот элемент, который был включен позже других). Для очереди справедливо в точности противоположное правило: исключается всегда самый "старший" элемент; элементы "покидают" список в том порядке, в котором они в него вошли.
Существуют и другие названия стека: магазин, список типа LIFO ("Last In - First Out" - "последним включается - первым исключается"); "пуш-даун" список ("push-down"), реверсивная память, гнездовая память.


Рис.2. Стек

Дек ("Double-Ended Queue" - "двухсторонняя очередь") - список магазинного типа, в котором все включения и исключения звеньев делаются на обоих концах списка.
Очевидно, что дек обладает большей общностью, чем стек или очередь; он имеет некоторые общие свойства с колодой игральных карт.

Замечание. Понятие стек было введено А.М.Тьюрингом в 1947 г. и названо им реверсивной памятью (оно использовалось для связи подпрограмм). Термин "дек" был введен Швеппе (E.J.Schweppe).

Со следующего шага мы начнем знакомиться с очередью.

        1.6. Списки магазинного типа. Очереди
На этом шаге мы дадим общую характеристику очереди.
Отметим, что очередь - динамическая структура данных, так как с течением времени длина очереди (количество входящих в нее звеньев) изменяется. Например, все мы знакомы с очередью людей у кассы в магазине самообслуживания или очередью автомобилей у бензозаправочной станции. Вновь прибывшие становятся в один конец очереди и покидают ее после оплаты покупок или заправки с другого.
Другой, возможно более уместный, пример очереди может быть обнаружен в вычислительной системе с разделением времени, с которой одновременно работает несколько пользователей. Поскольку такая система обычно имеет единственный центральный процессор и одну основную память, то эти ресурсы должны разделяться среди пользователей путем выделения короткого интервала времени на выполнение программы одного пользователя, за которым следует выполнение программы другого пользователя и так далее до тех пор, пока не будет вновь выполняться программа первого пользователя. Программы пользователей, ожидающие своего выполнения, образуют очередь ожидания. Управление такой очередью необязательно должно основываться на принципе "первым пришел" - "первым вышел", а можно использовать некоторую сложную приоритетную схему, учитывающую такие факторы, как используемый компилятор, требуемое время выполнения, желаемое число строк, выводимых на печать и так далее.
На следующем шаге мы рассмотрим формирование очереди.

            1.1.13. Формирование очереди
На этом шаге мы рассмотрим алгоритм формирования очереди.
Очередь на базе линейного однонаправленного списка - линейный список, в котором включения элементов производятся на одном конце списка, а все исключения делаются на другом его конце. Обычно удаление звеньев из очереди происходит из начала линейного списка, а помещение звеньев осуществляется в конец линейного списка.
Запишем алгоритм формирования очереди:

    1) 
    r = new (node);
    (*r).elem = Элем;
    (*r).sled = NULL;


Рис.1. Первый элемент в очереди

    2) 
    no = r; ko = r;
// *no - указатель на начало очереди,
// *ko - указатель на конец очереди.


Рис.2. Настройка указателей начала и конца очереди

Итак, мы образовали очередь, состоящую из одного звена.

    3) Продолжим заполнение очереди:
    r = new (node);
    (*r).elem = Элем1;
    (*r).sled = NULL;


Рис.3. Создали новый элемент очереди

    4) Настроим указатель на конец очереди:
    (*ko).sled = r;
    ko = r;


Рис.4. Настроили указатель на конец очереди

Таким образом, очередь уже содержит два звена и, нам думается, что процесс построения понятен.
Представим описанный алгоритм в виде функции на языке C++:

void POSTROENIE (node **no, node **ko)
// Построение очереди на базе однонаправленного
// линейного списка без заглавного звена:
// *no - указатель на начало очереди,
// *ko - указатель на конец очереди.
{
  node *r;
  int el;

  cin>>el;
  if (el!=0)
  {
    r = new (node);
    (*r).elem = el;
    (*r).sled = NULL;
    *no = r;
    *ko = r;
    cin>> el;
    while (el!=0)
      { r = new (node);
       (*r).elem = el; (*r).sled = NULL;
       (**ko).sled = r; *ko = r; cin>>el;}
      }
  else
  { r = NULL; *no = r; *ko = r;}
}

Тут же приведем функцию для просмотра содержимого очереди:

void VYVOD (node **no, node **ko)
// Вывод содержимого очереди.
// *no - указатель на начало очереди,
// *ko - указатель на конец очереди.
{
  node *r;
  cout<< "Очередь: "; r = *no;
  while (r!=NULL)
    { cout<<(*r).elem<<" "; r = (*r).sled; }
  cout<<endl;
}

Замечание. Очереди целесообразно хранить в памяти ЭВМ в виде кольцевого списка с двумя указателями (один - на начало, другой - на конец очереди):


Рис.5. Представление очереди

При исключении из очереди первого звена в первый указатель записывается ссылка на следующее звено списка, которая содержалась в поле указателя исключаемого звена, а при включении в очередь нового звена во второй указатель записывается ссылка на новое звено.
Со следующего шага мы начнем рассматривать операции с очередями.

            1.1.14. Добавление звена к очереди
На этом шаге мы рассмотрим алгоритм добавления звена к очереди.
Приступим к описанию алгоритма добавления звена к очереди. Напомним, что звено добавляется в конец очереди.

    1) Вначале построим добавляемое звено:
    r = new (node);
    (*r).elem = Элем;
    (*r).sled = NULL;


Рис.1. Исходная очередь и заполнение добавляемого звена

    2) Присоединяем звено к очереди:
    (*ko).sled = r;


Рис.2. Результат присоединения звена

    3) "Настраиваем" указатель ko на конец очереди:
    ko = r;

Изобразим результат добавления звена:


Рис.3. "Настройка" указателя

В результате добавляемое звено стало последним звеном очереди.
Оформим алгоритм в виде функции на языке C++:

void DOBAVLENIE (node **no, node **ko,int el)
// Добавление звена  с информационным  полем  el
//* к очереди, определенной указателями *no и *ko.
{
  node *r;

  r = new (node);
  (*r).elem = el; (*r).sled = NULL;
  if (*no!=NULL)
  { (**ko).sled = r; *ko = r;}
  else
  { *no = r; *ko = r;}
}

На следующем шаге мы рассмотрим алгоритм удаления звена из очереди.

            1.1.15. Удаление звена из очереди
На этом шаге мы рассмотрим алгоритм удаления звена из очереди.
Пусть очередь не пуста (no != NULL). Изобразим ее схематически:


Рис.1. Очередь

Приступим к удалению звена. Напомним, что звено удаляется из очереди из ее начала.

    1) Сохраним удаляемый элемент:
    klad = (*no).elem;


Рис.2. Сохранение удаляемого элемента

    2) Сохраним указатель на удаляемый элемент и "перенастроим" указатель на начало очереди:
    q = no;
    no = (*no).sled;


Рис.3. "Перенастройка" указателя на начало очереди

    3) Теперь необходимо включить в список свободной памяти удаленное из очереди звено с помощью вызова функции:
    delete q;


Рис.4. Возврат памяти в кучу

Запишем приведенную схему в виде функции на языке C++:

void YDALENIE (node **no, node **ko, int klad)
// Удаление звена из очереди, определенной указателями *no
// и *ko. Значение информационного  поля  удаленного звена
// сохраняется в параметре klad.
{
  node *q;

  if (*no == NULL)
    cout<< "Удалить нельзя, так как очередь пуста!\n";
  else
    { *klad = (**no).elem; q = *no; *no = (**no).sled; delete q;}
}

Пример. Построение и просмотр очереди, добавление и удаление звеньев из очереди.

#include<iostream>
using namespace std;

struct node
{
  int elem;
  node *sled;
};
class Spisok {
  private:
    node *no,*ko;
    int klad;
  public:
    Spisok () {no=ko=NULL;}
    void POSTROENIE ();
    void VYVOD ();
    void DOBAVLENIE (int);
    int  Set_Udal () { return klad; }
    void YDALENIE ();
    void OCHISTKA();
};

void main ()
{
  setlocale(LC_ALL,"Rus");
  Spisok A;
  int el;

  A.POSTROENIE ();
  A.VYVOD ();
  cout<<"Введите добавляемый элемент: ";
  cin>>el;
  A.DOBAVLENIE (el); A.VYVOD ();
  cout<<"Удалим элемент из очереди.\n";
  A.YDALENIE (); A.VYVOD ();
  el=A.Set_Udal();
  cout<<"Информационное поле удаленного звена: "<<el<<endl;
  A.OCHISTKA();

  cout << "\n";
  system("PAUSE");
}

void Spisok::POSTROENIE ()
//Построение очереди на базе однонаправленного списка
//без заглавного звена.
//no - указатель на начало очереди.
//ko - указатель на конец очереди.
{
  node *r;
  int el;

  cout<<"Вводите элементы очереди:\n";
  cin>>el;
  if  (el!=0)
  {
    r = new (node);
    (*r).elem = el; (*r).sled = NULL;
    no = r; ko = r; cin>>el;
    while  (el!=0)
    {
      r = new (node);
      (*r).elem = el; (*r).sled = NULL;
      (*ko).sled = r; ko = r; cin>>el;
    }
  }
  else
  {r = NULL; no = r; ko = r;}
}

void Spisok::VYVOD ()
//Вывод содержимого очереди.
//no - указатель на начало очереди.
//ko - указатель на конец очереди.
{
  node *r;
  cout<<"Очередь: "; r = no;
  while  (r!=NULL)
  {
    cout<<(*r).elem<<" "; r = (*r).sled;
  }
  cout<<endl;
}

void Spisok::DOBAVLENIE (int el)
//Добавление звена с информационным полем el к очереди,
//определенной указателями  no и ko.
{
  node *r;

  r = new (node);
  (*r).elem = el; (*r).sled = NULL;
  if  (no!=NULL)
  {
     (*ko).sled = r; ko = r;
  }
  else
  {no = r; ko = r;}
}

void Spisok::YDALENIE ()
//Удаление звена из очереди, определенной указателями
//no и ko, с помещением его информационного поля в
//параметр klad.
{
  node *q;

  if  (no==NULL)
  cout<<"Удалить нельзя, так как очередь пуста!\n";
  else
  {
    klad = (*no).elem; q = no;
    no = (*no).sled; delete q;
  }
}

void Spisok::OCHISTKA()
//Возврат выделенной памяти в "кучу".
{
  node *q;

  q=no;
  if (no!=NULL)
  {
    while (no!=ko)
    {
      no=(*q).sled;
      delete q;  q=no; }
    delete no;
    no=ko=NULL;
  }
}



Со следующего шага мы начнем рассматривать стек.

        1.7. Стек
            1.1.16. Формирование стека
На этом шаге мы рассмотрим алгоритм формирования стека.
Напомним, что стек - это специально организованная память, выборка и занесение данных в которую подчиняется дисциплине LIFO ("последним вошел - первым обслужен").
Стек на базе линейного однонаправленного списка - линейный однонаправленный список, в котором все включения и исключения звеньев делаются в одном (выбранном нами) конце списка.
Опишем алгоритм помещения в стек информации.

    1) Вначале стек пуст:
   stk = NULL;


Рис.1. Стек пуст

    2) Содержимое стека будем вводить с клавиатуры, ввод заканчивается нулем:
    cin>>Элем;
    t = new (node);
    (*t).elem = Элем; (*t).sled = stk;


Рис.2. Новый элемент

    3) "Настраиваем" указатель стека на созданный элемент:
    stk = t;


Рис.3. "Настройка" указателя стека

    4) В результате в стек будет помещено первое звено:


Рис.4. Первый элемент в стеке

    5) Продолжим заполнение стека:
    cin>>Элем1;
    t = new (node);
    (*t).elem = Элем1;
    (*t).sled = stk;

Рис.5. Размещение в стеке второго элемента

    6) "Настраиваем" указатель стека на созданный элемент:
    stk = t;


Рис.6. "Настройка" указателя стека

    7) Теперь стек содержит уже два звена:


Рис.7. В стеке два элемента

Продолжение процесса построения стека достаточно очевидно.
Оформим алгоритм в виде функции языка C++:

void POSTROENIE (node **stk)
//Построение стека, заданного указателем *stk с клавиатуры.
{
  node *t;
  int el;
  *stk = NULL;
  cin>>el;
  while (el!=0)
  {
    t = new (node);
    (*t).elem = el; (*t).sled = *stk; *stk = t;
    cin>>el;
  }
}

На следующего шаге мы рассмотрим алгоритм включения звена в стек.

            1.1.17. Включение звена в стек
На этом шаге мы рассмотрим алгоритм включения элемента в стек.
Опишем алгоритм включения звена с информационным полем Элем в стек.

    1) Исходное состояние стека:


Рис.1. Исходное состояние стека

    2) Создаем новый элемент:
    q = new (node);
    (*q).elem = Элем;


Рис.2. Новый элемент

    3) Включаем элемент в начало стека:
   (*q).sled = stk;


Рис.3. Включение элемента в стек

    4) "Настроим" указатель вершины стека:
     stk = q;


Рис.4. "Настройка" указателя вершины стека

Функция имеет вид:

void W_S (node **stk, int el)
//Включение звена с элементом el в стек,
// заданный указателем *stk.
{
  node *q;

  q = new (node);
  (*q).elem = el; (*q).sled = *stk; *stk = q;
}

Заметим, что функцию POSTROENIE() можно переписать следующим образом, если воспользоваться функцией W_S():

void POSTROENIE (node **stk)
// Построение стека, заданного указателем *stk с клавиатуры.
{
  int el;

  *stk = NULL; cin>>el;
  while (el!=0)
    { W_S (stk,el); cin>>el;}
}

На следующем шаге мы рассмотрим алгоритм удаления элемента из стека.

            1.1.18. Удаление звена из стека
На этом шаге мы рассмотрим алгоритм удаления звена из стека.
Перед удалением звена из стека проверяем, пуст ли стек.
Пусть стек не пуст.


Рис.1. Исходный стек

Тогда спокойно приступаем к удалению.

    1) Сохраняем удаляемый элемент:
    klad = (*stk).elem;


Рис.2. Сохранение удаляемого элемента

    2) "Перенастраиваем" указатель стека и сохраняем адрес удаляемого элемента:
    q = stk; stk = (*stk).sled;


Рис.3. "Перенастройка" указателя стека

    3) Возвращаем память в кучу:
    delete q;


Рис.4. Возврат памяти в кучу

Запишем полученный алгоритм в виде функции:

void YDALENIE (node **stk, int klad)
// Удаление звена  из  стека, заданного указателем  *stk, и
// помещение значения информационного поля удаленного звена
// в параметр klad.
{
  node *q;

  if (*stk==NULL) cout<<"Стек пуст!\n";
  else
    { *klad = (**stk).elem; q = *stk;
      *stk = (**stk).sled; delete q;}
}

Приведем пример программы, реализующей действия со стеком. Формирование и вывод содержимого стека на экран дисплея. Удаление и вставка звена в стек.

#include<iostream>
using namespace std;

struct node
{
  int elem;
  node *sled;
};
class Spisok
{
  private:
    node *stk;
    int klad;
  public:
    Spisok () { stk=NULL; }
    int Set_Stack () {return klad;}
    void POSTROENIE();
    void VYVOD();
    void W_S(int);
    void YDALENIE ();
    void OCHISTKA();
};

void main ()
{
  setlocale(LC_ALL,"Rus");
  Spisok A;
  int  el;
  int t; //Содержимое информационного поля верхушки стека.

  A.POSTROENIE (); A.VYVOD ();
  cout<<"Введите вставляемый элемент: ";
  cin>>el;
  A.W_S (el); A.VYVOD ();

  cout<<"Удалим элемент из стека.\n";
  A.YDALENIE ();
  t=A.Set_Stack();
  cout<<"Из стека было извлечено число... "<<t<<endl;
  A.VYVOD ();
  A.OCHISTKA();

  cout << "\n";
  system("PAUSE");
}

void Spisok::POSTROENIE ()
//Построение стека, заданного указателем stk.
{
  node *t;
  int el;

  cout<<"Вводите элементы стека: ";
  cin>>el;
  while  (el!=0)
  {
     t = new (node);
    (*t).elem = el; (*t).sled = stk;
    stk = t; cin>>el;
  }
}

void Spisok::VYVOD ()
//Вывод содержимого стека, заданного указателем stk.
{
  node *t;

  cout<<"Содержимое стека: "; t = stk;
  while  (t!=NULL)
    {cout<<(*t).elem<<" "; t = (*t).sled;}
  cout<<endl;
}

void Spisok::W_S (int el)
//Помещение элемента el в стек stk.
{
  node *q;

  q = new (node);
  (*q).elem = el; (*q).sled = stk; stk = q;
}

void Spisok::YDALENIE ()
//Удаление элемента из стека, заданного указателем stk.
//Значение информационного поля удаляемого элемента
//помещается в параметр klad.
{
  node *q;

  if  (stk==NULL)
    cout<<"Стек пуст!\n";
  else
  {
    klad = (*stk).elem; q = stk;
    stk = (*stk).sled; delete q;
  }
}

void Spisok::OCHISTKA()
//Возврат выделенной памяти в "кучу".
{
  node *t,*q;

  t = stk;
  if (t!=NULL)
  {
    q=(*t).sled;
    while  (q!=NULL)
    {
      delete t; t = q; q =(*q).sled;
    }
    delete t;
  }
}



Со следующего шага мы познакомимся с деком.

        1.8. Дек
На этом шаге мы рассмотрим создание и основные операции над деками.
Дек ("двухсторонняя очередь") на базе однонаправленного линейного списка - список магазинного типа на базе однонаправленного линейного списка, в котором все включения и исключения звеньев делаются на обеих концах очереди.
Мы приведем лишь демонстрационный пример.

Пример. Формирование дека, просмотр его содержимого, добавление элемента к деку и удаление элемента из дека.

#include<iostream>
using namespace std;

struct node
{
  int elem;
  node *sled;
};
class Spisok
{
  private:
    node *ld,*rd;
    int el_left,el_right;
  public:
    void POSTROENIE ();
    void VYVOD ();
    void VSTAV1 (int);
    void VSTAV2 (int);
    int SetElLeft() {return el_left;}
    int SetElRight() {return el_right;}
    void YDALE1 ();
    void YDALE2 ();
    void OCHISTKA();
};

void main ()
{
  setlocale(LC_ALL,"Rus");
  Spisok A;
  int el;

  A.POSTROENIE (); A.VYVOD ();
  cout<<"Добавим звено справа.\n";
  cout<<"Введите элемент добавляемого звена: ";
  cin>>el;
  A.VSTAV1 (el); A.VYVOD ();
  cout<<"Добавим звено слева.\n";
  cout<<"Введите элемент добавляемого звена: ";
  cin>>el;
  A.VSTAV2 (el); A.VYVOD ();
  cout<<"Удалим звено справа.\n";
  A.YDALE1 (); A.VYVOD (); cout<<A.SetElRight()<<endl;
  cout<<"Удалим зввено слева.\n";
  A.YDALE2 (); A.VYVOD (); cout<<A.SetElLeft()<<endl;
  A.OCHISTKA();

  cout << "\n";
  system("PAUSE");
}

void Spisok::POSTROENIE ()
//Построение дека :
// ld - указатель на левый конец дека,
// rd - Указатель на правый конец дека.
{
  node *k;
  int el;

  cout<<"Вводите содержимое звеньев дека: \n";
  cin>>el;
  if  (el!=0)
  {
    k = new (node);
    (*k).elem = el; (*k).sled = NULL;
    ld = k; rd = k; cin>>el;
    while  (el!=0)
      {VSTAV1 (el); cin>>el;}
  }
  else
    {rd = NULL; ld = NULL;}
}

void Spisok::VYVOD ()
//Вывод содержимого дека:
// ld - указатель на левый конец дека.
{
  node *k;

  k = ld; cout<<"Дек: ";
  while  (k!=NULL)
    {cout<<(*k).elem<<" "; k = (*k).sled;}
  cout<<endl;
}

void Spisok::VSTAV1 (int el)
// Помещение звена, содержащего элемент el, в дек справа.
// ld - указатель на левый конец дека,
// rd - указатель на правый конец дека.
{
  node *k;

  k = new (node);
  (*k).elem = el; (*k).sled = NULL;
  if  (rd!=NULL)
    {(*rd).sled = k; rd = k;}
  else
    {rd = k; ld = k;}
}

void Spisok::VSTAV2 (int el)
//Помещение звена, содержащего элемент el, в дек слева.
// ld - указатель на левый конец дека,
// rd - указатель на правый конец дека.
{
  node *k;

  k = new (node);
  (*k).elem = el; (*k).sled = ld;
  if  (ld!=NULL) ld = k;
  else  {ld = k; rd = k;}
}

void Spisok::YDALE1 ()
//Удаление звена из дека справа
//с сохранением удаляемого звена в переменной el_right.
// ld - указатель на левый конец дека,
// rd - указатель на правый конец дека.
{
  node *z;
  node *k;

  if  (rd==ld)
  {
    el_right = (*rd).elem; delete rd;
    ld = rd = NULL; cout<<"Дек пуст!\n";
  }
  else
  {
    z = ld; k = (*ld).sled;
    while  (k!=rd)
      {z = k; k = (*k).sled;}
    el_right = (*rd).elem; (*z).sled = NULL; delete rd;
    rd = z;
  }
}

void Spisok::YDALE2 ()
// Удаление звена из дека слева
// с сохранением удаляемого звена в переменной el_left.
// ld - указатель на левый конец дека,
// rd - указатель на правый конец дека.
{
  node *q;

  if  (ld!=NULL)
  {
    el_left = (*ld).elem; q = ld;
    ld = (*ld).sled; delete q;
  }
  else  cout<<"Дек пуст!\n";
}

void Spisok::OCHISTKA()
{
  node *k,*q;

  k = ld;
  if (k!=NULL)
  {
    q = (*k).sled;
    while  (q!=NULL)
      {delete k; k = q; q=(*k).sled;}
  delete k;
  }
}


Со следующего шага мы начнем рассматривать линейные двунаправленные списки.

        1.9. Линейные двунаправленные списки
На этом шаге мы приведем общую информацию о линейных двунаправленных списках.
Мы будем рассматривать лишь двунаправленные списки с заглавным звеном, которые имеют следующую структуру:


Рис.1. Общий вид двунаправленного списка с заглавным звеном

Здесь nsp - указатель на заглавное звено двунаправленного списка, ksp - указатель на последнее звено двунаправленного списка.
Тип каждого звена списка можно описать так:

struct node
{
  int elem;//Информационное поле.
  node *sled; // Указатель на следующее звено.
  node *pred; // Указатель на предыдущее звено.
};


Рис.2. Структура звена списка

На следующем шаге мы разберем формирование списка.

            1.1.19. Формирование линейного двунаправленного списка
На этом шаге мы рассмотрим алгоритм формирования списка.
Приступим к построению алгоритма формирования двунаправленного списка с заглавным звеном. Опишем необходимые переменные:

    node *nsp; // Указатель на заглавное звено списка.
    node *ksp; // Указатель на последнее звено списка.
    node *rsp; // Рабочий указатель для перемещения по списку.

    1) Построим заглавное звено:
    nsp = new(node);
    rsp = nsp;
    (*nsp).pred = NULL;
    (*nsp).sled = NULL;


Рис.1. Заглавное звено

    2) Создаем элемент списка:
    cin>>el;
    (*rsp).sled = new(node);


Рис.2. Элемент списка

    3) Заполняем поля элемента:
    (*((*rsp).sled)).pred = rsp;
    rsp = (*rsp).sled;
    (*rsp).sled = NULL;
    (*rsp).elem = el;


Рис.3. Заполнили поля элемента списка

    4) "Настраиваем" указатель на последний элемент списка:
    ksp = rsp;


Рис.4. "Настроили" указатель

Построен двунаправленный список с заглавным звеном, содержащий одно звено. Мы предоставляем возможность читателю проделать самостоятельно несколько последующих шагов алгоритма.
Запишем функцию построения двунаправленного списка с заглавным звеном:

void Postroenie (node **nsp, node **ksp)
// Построение двунаправленного списка с заглавным звеном:
// *nsp - указатель на начало списка,
// *ksp - указатель на конец списка.
{
  node *rsp;
  int el;
  *nsp = new(node);
  rsp = *nsp;
  (**nsp).pred = (**nsp).sled = NULL;
  cout<<"Вводите последовательность:\n"; cin>>el;
  while (el!=0)
  { (*rsp).sled = new(node); (*((*rsp).sled)).pred = rsp;
    rsp = (*rsp).sled; (*rsp).sled = NULL; (*rsp).elem = el;
    cin>>el; }
    *ksp = rsp;
}

Со следующего шага мы начнем рассматривать алгоритмы обхода двунаправленного списка.

            1.1.20. Проход по линейному двунаправленному списку, начиная с его начала
На этом шаге мы рассмотрим один из способов перемещения по списку.
Алгоритм перемещения может быть следующим.
    • Установим указатель rsp на звено, следующее за заглавным.
    • Далее, в цикле указатель будем перемещать по списку "с помощью" оператора rsp = (*rsp).sled;.
    • "Движение" указателя продолжается, пока rsp<>NULL.


Рис.1. "Начальная позиция"

Алгоритм оформим в виде функции:

void VyvodForward (node **nsp, node **ksp)
// Вывод содержимого двунаправленного списка от его начала.
// *nsp - указатель на начало списка,
// *ksp - указатель на конец списка.
{
  node *rsp;
  rsp = (**nsp).sled;
  cout<<"Двунаправленный список содержит: ";
  while (rsp!=NULL)
    { cout<<(*rsp).elem; rsp = (*rsp).sled;}
  cout<<endl;
}

На следующем шаге мы рассмотрим другой способ перемещения по списку.

            1.1.21. Проход по линейному двунаправленному списку, начиная с его конца
На этом шаге мы рассмотрим проход по списку, начиная с его конца.
Алгоритм перемещения может быть следующим.
    • Установим указатель rsp на последнее звено двунаправленного списка.
    • Далее, в цикле указатель перемещается по списку "с помощью" оператора rsp = (*rsp).pred;.
    • Ясно, что "движение" указателя продолжается, пока (*rsp).pred<>NULL.


Рис.1. "Начальная позиция"

Алгоритм оформим в виде функции:

void VyvodBack (node **nsp, node **ksp)
// Вывод содержимого двунаправленного списка от его конца.
// *nsp - указатель на начало списка,
// *ksp - указатель на конец списка.
{
  node *rsp;

  rsp = *ksp;
  cout<<"Двунаправленный список в обратном порядке: ";
  while ((*rsp).pred!=NULL)
    { cout<< (*rsp).elem; rsp = (*rsp).pred;}
cout<<endl;
}

Со следующего шага мы начнем рассматривать основные операции над списками.

            1.1.22. Поиск звена в двунаправленном списке, начиная с начала списка
На этом шаге мы рассмотрим первый способ поиска звена.
Поиск звена в двунаправленном списке можно производить в двух направлениях: с начала и с конца списка. Рассмотрим алгоритм поиска с начала списка.
Обозначим через Элем информационное поле звена, которое необходимо найти в списке. Вначале опишем алгоритм:

  Res = NULL; //Указатель на искомое звено содержит NULL.
  q = (*nsp).sled; //Рабочий указатель установим на звено,
                   //следующее за заглавным.
  while (q!=NULL && Res=NULL)
  {
    if ((*q).elem==Элем)
    // Если звено, содержащее элемент Элем, найдено, то
    //запоминаем указатель на найденное звено.
    Res = q;
  else
    // ... иначе: перемещаем рабочий указатель по списку.
    q = (*q).sled;
  }

Оформим приведенный выше алгоритм в виде функции:

node *PoiskForward (int el,node**nsp,node**ksp)
// Функция возвращает указатель на найденное звено,
// содержащее элемент el двунаправленного списка,
// заданного указателями *nsp и *ksp, или NULL, если
// звено в списке не найдено.
{
  node *q; // Текущий указатель.
  node *Res;

  *Res = NULL; q = (**nsp).sled;
  while (q!=NULL && *Res==NULL)
    { if ((*q).elem==el) *Res = q; else q = (*q).sled;}
  return Res;
}

На следующем шаге мы рассмотрим поиск звена, начиная с конца списка.

            1.1.23. Поиск звена в двунаправленном списке, начиная с конца списка
На этом шаге мы рассмотрим другой способ поиска звена в списке.
Рассмотрим алгоритм поиска элемента, начиная с конца списка.
    • Рабочий указатель устанавливается на последнее звено двунаправленного списка.
    • Анализ содержимого информационных полей происходит таким же образом, как и в функции PoiskForward(), только рабочий указатель q теперь перемещается в "обратном" направлении с помощью оператора q = (*q).pred;.
Оформим алгоритм в виде функции:

node *PoiskBack (int el,node **nsp,node **ksp)
// Функция возвращает указатель на найденное звено,
// содержащее элемент el двунаправленного списка,
// заданного указателями *nsp и *ksp, или NULL, если
// звено в списке не найдено.
{
  node *q;
  node *Res;

  Res = NULL; q = *ksp;
  while (q!=NULL && Res==NULL)
    { if ((*q).elem==el) Res = q; else q = (*q).pred;}
  return Res;
}

Со следующего шага мы начнем знакомиться со способами вставки звена в линейный двунаправленный список.

            1.1.24. Вставка звена в двунаправленный список (1-й случай)
На этом шаге мы рассмотрим алгоритм вставки нового звена после звена, на которое указывает ссылка.
Вначале рассмотрим алгоритм вставки звена после звена, на которое указывает ссылка Res. Пусть ссылка Res указывает на звено, после которого будет производиться вставка нового звена. Изобразим это схематически:


Рис.1. "Начальная позиция"

Проверим, является ли звено, на которое указывает ссылка Res, последним в списке. Это осуществляется путем анализа значения операции отношения (*Res).sled != NULL.
Пусть звено, на которое указывает Res, не является последним.

    1) В heap-области резервируем место для нового динамического объекта, а в информационное поле этого объекта помещаем значение информационного поля звена, которое желательно вставить в двунаправленный список:
    q = new(node);
    (*q).elem = Элем;


Рис.2. Вставляемый элемент

    2) "Настраиваем" указатели вставляемого элемента:
    (*q).sled = (*Res).sled;
    (*q).pred = (**Res.sled).pred;


Рис.3. "Настройка" указателей вставляемого элемента

    3) "Настраиваем" указатели списка на вставляемый элемент:
    (**Res.sled).pred = q;
    (*Res).sled = q;


Рис.4. "Настройка" указателей элементов списка на вставляемый элемент

    4) В итоге получим:


Рис.5. Результат вставки элемента

Если элемент, после которого размещается новый элемент, окажется последним в двунаправленном списке, тогда алгоритм изменится следующим образом:

    1) Создадим новый элемент и заполним его поля:
    q = new(node);
    (*q).elem = Элем;
    (*q).sled = NULL;


Рис.6. Вставляемый элемент

    2) Осуществим "настройку" указателей:
    (*q).pred = Res; *ksp = q;
    (*Res).sled = q;


Рис.7. "Настройка" указателей

Оформим алгоритм вставки звена в список в виде функции:

void InsAfter (int el, node **nsp, node **ksp, node *Res)
// Вставление  звена с информационным полем el в
// двунаправленный список, заданный  указателями
// *nsp и *ksp, после звена, на которое указывает Res.
{
  node *q;

  q = new(node);
  (*q).elem = el;
  if ((*Res).sled!=NULL)
  {
     (*q).sled = (*Res).sled;
     (*q).pred = (*(*Res).sled).pred; (*(*Res).sled).pred = q; (*Res).sled = q;
  }
  else
    { (*q).sled = NULL; (*q).pred = Res; *ksp = q; (*Res).sled = q;}
}

На следующем шаге мы продолжим рассматривать алгоритмы вставки звена в список.

            1.1.25. Вставка звена в двунаправленный список (2-й случай)
На этом шаге мы рассмотрим другой способ вставки звена в двунаправленный список.
Рассмотрим алгоритм вставки звена перед звеном, на которое указывает ссылка Res. Опишем его с помощью схем "до и после" Д.Кнута:

    1) Создаем элемент:
    q = new(node);
    (*q).elem = Элем;


Рис.1. Создание элемента

    2) "Настраиваем" его указатели:
    (*q).sled = (*(*Res).pred).sled;
    (*q).pred = (*Res).pred;


Рис.2. "Настройка" указателей созданного элемента

    3) "Настраиваем" указатели элементов списка на вставляемый элемент:
    (*(*Res).pred).sled = q;
    (*Res).pred = q;


Рис.3. "Настройка" указателей элементов списка на созданный элемент

    4) В итоге получим:


Рис.4. Итоговый результат

Оформим алгоритм помещения звена в список в виде функции:

void InsBefore (int el, node **nsp, node **ksp, node *Res)
// Вставление звена с информационным полем el в двуна-
// правленный список, заданный указателями *nsp и *ksp,
// перед звеном, на которое указывает Res.
{
  node *q;

  q = new (node);
  (*q).elem = el;
  (*q).sled = (*(*Res).pred).sled;
  (*q).pred = (*Res).pred;
  (*(*Res).pred).sled = q; (*Res).pred = q;
}

Со следующего шага мы начнем знакомиться с алгоритмами удаления звена из двунаправленного списка.

            1.1.26. Удаление звена из двунаправленного списка. Указатель на удаляемое звено (1-й случай)
На этом шаге мы рассмотрим первый случай удаления звена.
Пусть нам известен указатель Res на удаляемое звено. Возможны два случая:
    • удаляемый элемент является последним в двунаправленном списке,
    • удаляемый элемент не является последним в двунаправленном списке.

Вначале рассмотрим ситуацию, когда он не последний, то есть (*Res).sled != NULL. Изобразим схему "до", соответствующую этому случаю:


Рис.1. "Начальная" позиция

    1) Исключим звено из списка, "перенастроив" указатели предыдущего и последующего звеньев:
    (*(*Res).sled).pred = (*Res).pred;
    (*(*Res).pred).sled = (*Res).sled;


Рис.2. "Перенастройка" указателей

    2) Осталось только удалить звено, на которое указывает Res, из heap-области:
    delete Res;


Рис.3. Освобождение памяти

Пусть теперь удаляемый элемент оказался последним.
Взгляните на схему "до":


Рис.4. "Начальная" позиция

    1) "Настроим" указатели предпоследнего элемента и конца списка:
    (*(*Res).pred).sled = NULL;
    ksp = (*ksp).pred;


Рис.5. "Настройка" указателей

    2) Теперь удалим из кучи звено, на которое указывает Res:
    delete Res;


Рис.6. Возврат памяти в кучу

Запишем функцию для удаления звена, на которое указывает ссылка:

void Delete (node **nsp, node **ksp, node *Res)
// Удаление звена из двунаправленного списка.
// *nsp - указатель на начало списка,
// *ksp - указатель на конец списка,
// Res  - указатель на удаляемое звено.
{
  if ((*Res).sled!=NULL)
    { (*(*Res).sled).pred = (*Res).pred;
      (*(*Res).pred).sled = (*Res).sled; delete Res;}
  else
    { (*(*Res).pred).sled = NULL; *ksp = (**ksp).pred; delete Res;}
}

На следующем шаге мы продолжим знакомиться с алгоритмами удаления звена.

            1.1.27. Удаление звена из двунаправленного списка. После звена (2-й случай)
На этом шаге мы рассмотрим другой алгоритм удаления звена из двунаправленного списка.
Построим теперь алгоритм для удаления звена, стоящего после звена, на которое указывает ссылка Res. Пусть удаляемое звено не является последним, то есть (*(*Res).sled).sled!=NULL. Изобразим этот факт на схеме "до":


Рис.1. "Начальная" позиция

    1) Исключим звено из списка, "перенастроив" указатели предыдущего и последующего звеньев, а также сохраним адрес удаляемого звена:
    q = (*Res).sled;
    (*(*(*Res).sled).sled).pred = Res;
    (*Res).sled = (*(*Res).sled).sled;


Рис.2. "Перенастройка" указателей
    2) Осталось только удалить звено, на которое указывает q, из heap-области:

    delete q;

Если же удаляемый элемент является последним в двунаправленном списке,


Рис.3. "Начальная" позиция

то алгоритм становится тривиальным:
    1) "Настроим" указатели предпоследнего элемента и конца списка:
    q = (*Res).sled; (*Res).sled = NULL; ksp = (*ksp).pred;


Рис.4. "Настройка" указателей

    2) Теперь удалим из кучи звено, на которое указывает q:
    delete q;



Рис.5. Возврат памяти в кучу

Функция для удаления звена, стоящего после звена, на которое указывает ссылка Res, имеет вид:

void DelAfter (node **nsp, node **ksp, node *Res)
// Удаление звена из двунаправленного списка.
// *nsp - указатель на начало списка,
// *ksp - указатель на конец списка,
// Res - указатель на звено, предыдущее удаляемому.
{
  node *q;

  if ((*Res).sled==NULL)
    cout<<"Вы хотите удалить звено за последним звеном!\n";
  else
    if ((*(*Res).sled).sled!=NULL)
      {
        q = (*Res).sled;
        (*(*(*Res).sled).sled).pred = Res;
        (*Res).sled = (*(*Res).sled).sled;
        delete q;
      }
    else
      {   q = (*Res).sled; (*Res).sled = NULL;
          *ksp = (**ksp).pred; delete q; }
}

Приведем пример программы, иллюстрирующей применение рассмотренных функций.

Пример: построение двунаправленного списка. Помещение звена в двунаправленный список. Удаление звена из двунаправленного списка. Очистка двунаправленного списка.

#include <iostream>
using namespace std;

struct node
{
  int elem;
  node *sled;
  node *pred;
};
class Spisok
{
  private:
    node *nsp,*ksp;
  public:
    Spisok() {nsp=ksp=NULL;}
    void Postroenie ();
    void VyvodForward ();
    void VyvodBack ();
    void Ochistka ();
    void InsAfter (int,node*);
    void InsBefore (int,node*);
    void Delete (node*);
    void DelAfter (node*);
    node *PoiskForward (int);
    node *PoiskBack (int);
};
void main ()
{
  setlocale(LC_ALL,"Rus");
  Spisok A;
  node *Res;
  int el,el1;
    
  A.Postroenie ();
  A.VyvodForward (); A.VyvodBack ();
    
  cout<<"Введите элемент звена, после которого ";
  cout<<"осуществляется вставка: ";
  cin>>el;
  cout<<"Введите элемент вставляемого звена: ";
  cin>>el1;
  Res=A.PoiskForward (el);
  if  (Res!=NULL)
    {
      A.InsAfter (el1,Res);
      A.VyvodForward (); A.VyvodBack ();
    }
  else  cout<<"Звена с заданным элементом в списке нет!\n";

  cout<<"Введите элемент звена, перед которым ";
  cout<<"осуществляется вставка: ";
  cin>>el;
  cout<<"Введите элемент вставляемого звена: ";
  cin>>el1;
  Res = A.PoiskBack (el);
  if  (Res!=NULL)
  {
    A.InsBefore (el1,Res);
    A.VyvodForward (); A.VyvodBack ();
  }
  else  cout<<"Звена с заданным элементом в списке нет!\n";

  cout<<"Введите элемент звена, после которого ";
  cout<<"осуществляется удаление: ";
  cin>>el;
  Res = A.PoiskForward (el);
  if  (Res!=NULL)
  {
    A.DelAfter (Res);
    A.VyvodForward (); A.VyvodBack (); }
  else  cout<<"Звена с заданным элементом в списке нет!\n";

  cout<<"Введите элемент звена, которое ";
  cout<<"надо удалить: ";
  cin>>el;
  Res = A.PoiskForward (el);
  if  (Res!=NULL)
  {
    A.Delete (Res);
    A.VyvodForward (); A.VyvodBack ();
  }
  else  cout<<"Звена с заданным элементом в списке нет!\n";

  A.Ochistka ();

  cout << "\n";
  system("PAUSE");
}

void Spisok::Postroenie ()
//Построение двунаправленного списка с заглавным звеном:
// nsp - указатель на начало списка,
// ksp - указатель на конец списка.
{
  node *rsp;
  int el;

  nsp = new(node);
  rsp = nsp;
  (*nsp).pred = NULL; (*nsp).sled = NULL;
  cout<<"Вводите последовательность:\n";
  cin>>el;
  while  (el!=0)
  {
    (*rsp).sled = new(node);
    (*((*rsp).sled)).pred = rsp; rsp = (*rsp).sled;
    (*rsp).sled = NULL; (*rsp).elem = el;
    cin>>el;
  }
  ksp = rsp;
}

void Spisok::VyvodForward ()
//Вывод содержимого двунаправленного списка от его начала.
// nsp - указатель на начало списка, ksp - указатель на конец списка.
{
  node *rsp;
  rsp = (*nsp).sled;
  cout<<"Двунаправленный список содержит: ";
  while  (rsp!=NULL)
  {
    cout<<(*rsp).elem<<" "; rsp = (*rsp).sled;
  }
  cout<<endl;
}

void Spisok::VyvodBack ()
//Вывод содержимого двунаправленного списка от его конца.
// nsp - указатель на начало списка, ksp - указатель на конец списка.
{
  node *rsp;

  rsp = ksp;
  cout<<"Двунаправленный список в обратном порядке: ";
  while  ((*rsp).pred!=NULL)
  {
    cout<<(*rsp).elem<<" "; rsp = (*rsp).pred;
  }
  cout<<endl;
}

node *Spisok::PoiskForward (int el)
//Функция возвращает указатель на найденный элемент el
//двунаправленного списка, заданного указателями  nsp
// и ksp, или NULL, если элемент в списке не найден.
{
  node   *q;
  node *Res;

  Res = NULL; q = (*nsp).sled;
  while  (q!=NULL && Res==NULL)
    if  ((*q).elem==el) Res = q;
    else  q = (*q).sled;
  return Res;
}

node *Spisok::PoiskBack (int el)
//Функция возвращает указатель на найденный элемент el
//двунаправленного списка, заданного указателями  nsp
// и ksp, или NULL, если элемент в списке не найден.
{
  node   *q;
  node *Res;

  Res = NULL; q = ksp;
  while  (q!=NULL && Res==NULL)
    if  ((*q).elem==el) Res = q;
    else  q = (*q).pred;
  return Res;
}

void Spisok::InsAfter (int el,node *Res)
//Вставка звена с информационным полем el в
//в двунаправленный список, заданный указателями
// nsp и ksp, после звена, на которое указывает Res.
{
  node *q;

  q = new(node);
  (*q).elem = el;
  if  ((*Res).sled!=NULL)
  {
    (*q).sled = (*Res).sled;
    (*q).pred = (*(*Res).sled).pred;
    (*(*Res).sled).pred = q; (*Res).sled = q;
  }
  else
  {
    (*q).sled = NULL;
    (*q).pred = Res; ksp = q; (*Res).sled = q;
  }
}

void Spisok::InsBefore (int el,node *Res)
//Вставка звена с информационным полем el в
//в двунаправленный список, заданный указателями
// nsp и ksp, перед звеном, на которое указывает Res.
{
  node *q;
  q = new(node);
  (*q).elem = el;
  (*q).sled = (*(*Res).pred).sled;
  (*q).pred = (*Res).pred;
  (*(*Res).pred).sled = q; (*Res).pred = q;
}

void Spisok::Delete (node *Res)
//Удаление звена из двунаправленного списка.
// nsp - указатель на начало списка,
// ksp - указатель на конец списка,
// Res - указатель на удаляемое звено.
{
  if  ((*Res).sled!=NULL)
  {
     (*(*Res).sled).pred = (*Res).pred;
     (*(*Res).pred).sled = (*Res).sled;
     delete Res;
  }
  else
  {
    (*(*Res).pred).sled = NULL; ksp = (*ksp).pred;
    delete Res;
  }
}

void Spisok::DelAfter (node *Res)
//Удаление звена из двунаправленного списка.
// nsp - указатель на начало списка,
// ksp - указатель на конец списка,
// Res - указатель на звено, предыдущее удаляемому.
{
  node *q;

  if  ((*Res).sled==NULL) cout<<"Указано последнее звено!\n";
  else
    if  ((*(*Res).sled).sled!=NULL)
    {
      q = (*Res).sled;
      (*(*(*Res).sled).sled).pred = Res;
      (*Res).sled = (*(*Res).sled).sled;
      delete q;
    }
    else
    {
      q = (*Res).sled; (*Res).sled = NULL;
      ksp = (*ksp).pred; delete q; }
}

void Spisok::Ochistka ()
//Удаление двунаправленного списка из памяти.
// nsp - указатель на заглавное звено списка,
// ksp - указатель на последнее звено списка.
{
  node *q,*q1;

  q  = nsp; q1 = (*q).sled;
  while  (q1!=NULL)
  {
    q = q1; q1 = (*q1).sled; delete q;
  }
  delete nsp; nsp = ksp = NULL;
}



На следующем шаге мы рассмотрим двунаправленные кольцевые списки.

        1.10. Двунаправленные кольцевые списки
На этом шаге мы познакомимся с двунаправленными кольцевыми списками.
В программировании двунаправленные списки часто преобразовывают следующим образом: "обычный" линейный двунаправленный список замыкают в своеобразное "кольцо": при движении по списку в прямом направлении можно от последнего звена переходить к звену, следующему прямо за заглавным звеном, а при движении в обратную сторону - от заглавного звена переходить сразу к последнему звену. В связи с этим мы будем называть двунаправленные списки подобного типа кольцевыми двунаправленными списками (двунаправленными кольцами или просто кольцами).
Подобная организация списка упрощает процедуру поиска или перебора звеньев с любого места списка с автоматическим переходом от конца к началу или наоборот.
Мы приведем два варианта структуры кольцевых двунаправленных списков.
Рассмотрим первый вариант структуры кольцевого списка, которую мы будем называть кольцевым двунаправленным списком с удаленным заглавным звеном. Уже само название структуры говорит о том, что заглавное звено двунаправленного списка в кольцо не включается.
Взгляните на приведенную ниже схему:


Рис.1. Кольцевой двунаправленный список с удаленным заглавным звеном

Пустое кольцо можно представить следующим образом:


Рис.2. Пустой кольцевой двунаправленный список

Проще всего построить кольцевой двунаправленный список с удаленным заглавным звеном с использованием алгоритма построения двунаправленного списка с заглавным звеном и последующего "замыкания" кольца. Это реализовано в приведенной ниже функции:

void BuiltRing (node **nsp)
// Построение двунаправленного кольцевого списка nsp
//  с удаленным заглавным звеном.
// *nsp - указатель на заглавное звено списка.
{
  node *r;
  int el;
  // Построим заглавное звено будущего кольцевого списка.
  *nsp = new(node);
  r = *nsp; (**nsp).pred = NULL; (**nsp).sled = NULL;
  cout<<"Вводите элементы звеньев списка: \n";
  cin>>el;
  while (el!=0)
    { (*r).sled = new(node); (*((*r).sled)).pred = r;
       r = (*r).sled; (*r).sled = NULL; (*r).elem = el;
      cin>>el; }
  // Образуем кольцевой список с удаленным заглавным звеном.
  if ((**nsp).sled!=NULL)
    {(*((**nsp).sled)).pred = r; (*r).sled = (**nsp).sled;}
  else  cout<<"Кольцевой список пуст!\n";
}

Обход кольцевого списка реализовать несложно. Приведем, например, функцию, позволяющую обойти кольцо "по часовой стрелке":

void VyvodLeftRight (node **nsp)
// Вывод содержимого двунаправленного кольцевого списка
// с удаленным заглавным звеном "по часовой стрелке".
// *nsp - указатель на заглавное звено списка.
{
  node *r;

  cout<<"Кольцевой список: ";
  if ((**nsp).sled!=NULL)
    { cout<<(*((**nsp).sled)).elem)<<" ";
       r = (*((**nsp).sled)).sled;
      while (r!=(**nsp).sled)
        { cout<<(*r).elem)<<" "; r = (*r).sled; }
      cout<<endl;}
  else cout<<"пуст!";
}

Пример. Построение двунаправленного кольца с удаленным заглавным звеном, вывод содержимого кольцевого списка, вставка звена, удаление звена.

#include <iostream>
using namespace std;

struct node
{
  int elem;
  node *sled;
  node *pred;
};

class Spisok
{
  private:
    node *nsp;
  public:
    Spisok() {nsp=NULL;}
    void BuiltRing ();
    void VyvodLeftRight ();
    void VyvodRightLeft ();
    void InsAfter (node*,int);
    void InsBefore (node*,int);
    void Delete (node*);
    void DelAfter (node*);
    node *SearchRing (int);
    void Ochistka();
};

void main ()
{
  setlocale(LC_ALL,"Rus");
  Spisok A;
  node *Res;
  int el,el1;

  A.BuiltRing ();
  cout<<"Содержимое кольца 'по часовой стрелке': \n";
  A.VyvodLeftRight ();
  cout<<"Содержимое кольца'против часовой стрелки': \n";
  A.VyvodRightLeft ();
  cout<<"Введите элемент звена, после которого ";
  cout<<"осуществляется вставка: ";
  cin>>el;
  cout<<"Введите элемент вставляемого звена: ";
  cin>>el1;
  Res = A.SearchRing (el);
  if  (Res!=NULL)
    {A.InsAfter (Res,el1); A.VyvodLeftRight ();}
  else  cout<<"Звена с таким элементом в списке нет!\n";
  cout<<"Введите элемент звена, перед которым ";
  cout<<"осуществляется вставка: ";
  cin>>el;
  cout<<"Введите элемент вставляемого звена: ";
  cin>>el1;
  Res = A.SearchRing (el);
  if  (Res!=NULL)
    { A.InsBefore (Res,el1); A.VyvodLeftRight (); }
  else  cout<<"Звена с таким элементом в списке нет!\n";

  cout<<"Введите элемент звена, который ";
  cout<<"надо удалить: ";
  cin>>el;
  Res = A.SearchRing (el);
  if  (Res!=NULL)
    { A.Delete (Res); A.VyvodLeftRight (); }
  else  cout<<"Звена с таким элементом в списке нет!\n";

  cout<<"Введите элемент звена, после которого ";
  cout<<"осуществляется удаление: ";
  cin>>el;
  Res = A.SearchRing (el);
  if  (Res!=NULL)
    { A.DelAfter (Res); A.VyvodLeftRight (); }
  else  cout<<"Звена с таким элементом в списке нет!\n";
  A.Ochistka();

  cout << "\n";
  system("PAUSE");
}

void Spisok::BuiltRing ()
// Построение двунаправленного кольцевого списка nsp
//          с удаленным заглавным звеном.
// nsp - указатель на заглавное звено списка.
{
  node *r;
  int el;
  //Построим заглавное звено кольцевого списка.
  nsp = new(node);
  r = nsp; (*nsp).pred = NULL; (*nsp).sled = NULL;
  cout<<"Вводите элементы списка: \n";
  cin>>el;
  while  (el!=0)
  {
    (*r).sled = new (node);
    (*((*r).sled)).pred = r; r = (*r).sled;
    (*r).sled = NULL; (*r).elem = el;
    cin>>el;
  }
  //А теперь - образуем кольцевой список!
  if  ((*nsp).sled!=NULL)
    { (*((*nsp).sled)).pred = r; (*r).sled = (*nsp).sled; }
  else
    cout<<"Кольцевой список пуст!\n";
}

void Spisok::VyvodLeftRight ()
// Вывод содержимого двунаправленного кольцевого списка
// с удаленным заглавным звеном "по часовой стрелке".
// nsp - указатель на заглавное звено списка.
{
  node *r;

  cout<<"Кольцевой список: ";
  if  ((*nsp).sled!=NULL)
  {
    cout<<(*((*nsp).sled)).elem<<" ";
    r = (*((*nsp).sled)).sled;
    while  (r!=(*nsp).sled)
      { cout<<(*r).elem<<" "; r = (*r).sled; }
    cout<<endl;
  }
  else cout<<"пуст!";
}

void Spisok::VyvodRightLeft ()
// Вывод содержимого двунаправленного кольцевого списка
// с удаленным заглавным звеном "против часовой стрелки".
// nsp - указатель на заглавное звено списка.
{
  node *r;

  cout<<"Кольцевой список: ";
  if  ((*nsp).sled!=NULL)
  {
    cout<<(*((*((*nsp).sled)).pred)).elem<<" ";
    r = (*((*((*nsp).sled)).pred)).pred;
    while  (r!=(*((*nsp).sled)).pred)
      { cout<<(*r).elem<<" "; r = (*r).pred; }
    cout<<endl;
  }
  else cout<<"пуст!";
}

node *Spisok::SearchRing (int el)
// Поиск элемента el в кольцевом двунаправленном списке
//             с удаленным заглавным звеном.
// nsp - указатель на заглавное звено списка.
{
  node   *q;
  node   *p;
  node *Res;

  Res = NULL; p = nsp;
  if  ((*((*p).sled)).elem==el) Res = (*p).sled;
  else
  {
    q = (*((*p).sled)).sled;
    while  (q!=(*p).sled && Res==NULL)
      if  ((*q).elem==el) Res = q;
      else  q = (*q).sled;
  }
  return Res;
}

void Spisok::InsAfter (node *Res,int el)
// Вставление в кольцевой двунаправленный список звена
// с информационным полем el после  звена, на  которое
// указывает ссылка Res.
{
  node *q;

  q = new(node);
  (*q).elem = el; (*q).sled = (*Res).sled;
  (*q).pred = (*(*Res).sled).pred;
  (*(*Res).sled).pred = q; (*Res).sled = q;
}

void Spisok::InsBefore (node *Res,int el)
// Вставка в кольцевой двунаправленный список звена
// с информационным полем el перед звеном, на  которое
// указывает ссылка Res.
// nsp - указатель на заглавное звено списка.
{
  node *q;

  q = new(node);
  (*q).elem = el;
  (*q).sled = (*(*Res).pred).sled; (*q).pred = (*Res).pred;
  (*(*Res).pred).sled = q; (*Res).pred = q;
  if  (Res==(*nsp).sled) (*nsp).sled = q;
}

void Spisok::Delete (node *Res)
// Удаление из кольцевого двунаправленного списка
// звена, на которое указывает ссылка Res.
// nsp - указатель на заглавное звено списка.
{
  if  ((*Res).sled==Res)
    { (*nsp).sled = NULL; delete Res; }
  else
  {
    (*(*Res).sled).pred = (*Res).pred;
    (*(*Res).pred).sled = (*Res).sled;
    if  ((*nsp).sled==Res)
      // Удаляем "первое" звено кольца.
      (*nsp).sled = (*Res).sled;
    delete Res;
  }
}

void Spisok::DelAfter (node *Res)
// Удаление из кольцевого двунаправленного списка звена,
// расположенного  после  звена, на  которое  указывает
// ссылка Res.
// nsp - указатель на заглавное звено списка.
{
  node *q;

  if  ((*Res).sled==Res)
    { (*nsp).sled = NULL; delete Res;}
  else
  {
    q = (*Res).sled;
    (*(*(*Res).sled).sled).pred = (*(*Res).sled).pred;
    (*Res).sled = (*(*Res).sled).sled;
    if  ((*(*nsp).sled).pred==Res)
      // Удаляем "последнее" звено кольца.
      (*nsp).sled = (*Res).sled;
    delete q;
  }
}

void Spisok::Ochistka()
{
  node *q,*q1;

  q = (*((*nsp).sled)).sled;
  q1 = (*q).sled;
  while (q1!=(*((*nsp).sled)).sled)
    { delete q; q=q1; q1=(*q1).sled; }
  delete q;
  delete nsp;
}



Следует заметить, что предложенный выше способ образования двунаправленного кольцевого списка не является единственно возможным. Имеется еще один вариант представления кольцевых двунаправленных списков, который схематически можно представить так:


Рис.3. Кольцевой двунаправленный список с включенным заглавным звеном

Мы будем называть подобную структуру кольцевым двунаправленным списком с включенным заглавным звеном.
Опишем структуру пустого кольцевого списка с включенным заглавным звеном:


Рис.4. Пустой кольцевой двунаправленный список с включенным заглавным звеном

Каждый из способов образования кольцевого списка имеет как положительные, так и отрицательные стороны. Например, во втором варианте образования списка очень просто реализуется вставка нового звена как в начало списка (после заглавного звена), так и в его конец, ибо вставка нового звена в конец списка эквивалентна его вставке перед заглавным звеном. Однако здесь при циклической обработке элементов списка придется каждый раз проверять, не является ли очередное звено заглавным звеном списка.
Этого недостатка лишен первый способ организации списка, но в этом случае труднее реализуется добавление звена в конец списка.
На следующем шаге мы рассмотрим деки на базе двунаправленных списков.

        1.11. Деки на базе двунаправленных списков
            1.1.28. Формирование дека и его просмотр
На этом шаге мы рассмотрим алгоритмы создания и просмотра дека.
Мы будем моделировать дек с помощью двунаправленного списка без заглавного звена.
Вначале опишем алгоритм формирования двунаправленного списка без заглавного звена из двунаправленного списка с заглавным звеном, изображенного ниже:

    1) "Начальная" позиция:


Рис.1. "Начальная" позиция

    2) Исключим заглавное звено из списка:
    q = nd;
    nd = (*nd).sled;
    (*nd).pred = NULL;


Рис.2. Исключение заглавного звена

    3) Возврат памяти в кучу и "настройка" указателя на конец дека:
    delete q;
    kd = z;


Рис.3. "Настройка" указателя и возврат памяти в кучу

Очевидно, что суть алгоритма состоит в "отбрасывании" заглавного звена двунаправленного списка.
Оформим данный алгоритм в виде функции:

void BuiltDeck (node **nd, node **kd)
// Построение дека на базе двунаправленного
// списка с заглавным звеном.
// *nd - указатель на начало дека.
// *kd - указатель на конец дека.
{
  node *q, *z;
  int el;

  // Построение заглавного звена.
  *nd = new(node);
  z = *nd;
  (**nd).pred =  (**nd).sled = NULL;
  cout<<"Введите последовательность: \n";
  cin>>el;
  while (el!=0)
    { (*z).sled = new(node);
      (*((*z).sled)).pred = z; z = (*z).sled;
      (*z).sled = NULL; (*z).elem = el; cin>>el; }
  if ((**nd).sled!=NULL)
    { q = *nd; *nd = (**nd).sled; (**nd).pred = NULL; *kd = z; delete q; }
  else
    { delete *nd; *nd = *kd = NULL;}
}

Со следующего шага мы начнем рассматривать основные операции над деками.

            1.1.29. Добавление звена в начало дека
На этом шаге мы рассмотрим алгоритм добавления звена в начало дека.
Алгоритм добавления звена в начало дека заключается в создании из кучи нового элемента и настройки указателя начала дека на новый элемент:

    q = new(node);
    (*q).elem = Элем;
    (*q).sled = nd;      (*q).pred = NULL;
    (*nd).pred = q;      nd = q;


Рис.1. Вставка звена в начало дека

Приведем текст функции:

void InsLeft (node **nd, node **kd,int el)
// Вставка звена, содержащего элемент el, в дек слева.
// *nd - указатель на начало дека.
// *kd - указатель на конец дека.
{
  node *q;

  q = new(node);
  (*q).elem = el;
  if (*nd==NULL)
    { // Если дек пуст, то...
      *nd = q; (*q).sled = (*q).pred = NULL; *kd = q;}
  else
    { (*q).sled = *nd; (*q).pred = NULL; (**nd).pred = q; *nd = q;}
}

На следующем шаге мы рассмотрим алгоритм добавления звена в дек справа.

            1.1.30. Добавление звена в конец дека
На этом шаге мы рассмотрим алгоритм добавления звена в конец дека.
Алгоритм добавления звена в конец дека заключается в выделении памяти под новый элемент и включение его в конец дека:

    q = new(node);
    (*q).elem = Элем;
    (*q).sled = NULL;
    (*q).pred = *kd;
    (*kd).sled = q;
    *kd = q;


Рис.1. Вставка звена в конец дека

Приведем текст функции:

void InsRight (node **nd, node **kd,int el)
// Добавление звена, содержащего элемент el, в дек справа.
// *nd - указатель на начало дека.
// *kd - указатель на конец дека.
{
  node *q;

  q = new(node);
  (*q).elem = el;
  if (*kd==NULL)
    {// Если дек пуст, то...
      *nd = q; (*q).sled = (*q).pred = NULL; *kd = q;}
  else
    { (*q).sled = NULL; (*q).pred = *kd; (**kd).sled = q; *kd = q;}
}

Со следующего шага мы начнем рассматривать алгоритмы удаления звена из дека.

            1.1.31. Удаление звена из дека слева
На этом шаге мы рассмотрим первый алгоритм удаления звена дека.
Рассмотрим алгоритм удаления звена слева.

    1) Пусть уже построен дек на базе двунаправленного списка без заглавного звена:


Рис.1. "Начальная" позиция

    2) Сохраним адрес удаляемого элемента и "настроим" указатель начала дека:
    q = nd;
    nd = (*nd).sled;


Рис.2. "Настройка" указателей

    3) Возвратим память в кучу:
    delete q;


Рис.3. Возврат памяти в кучу

Запишем по описанному алгоритму функцию на языке C++:

void DelLeft (node **nd, node **kd,int *el)
// Удаление звена из дека слева с помещением элемента
//  удаляемого звена в переменную el.
// *nd - указатель на начало дека.
// *kd - указатель на конец дека.
{
  node *q;
  if ((**nd).sled!=NULL)
    { q = *nd; *el =(*q).elem; *nd = (**nd).sled; (**nd).pred = NULL; delete q;}
  else
  { //В деке находится один элемент.
     q = *nd; *el =(*q).elem; *nd = *kd = NULL;
    delete q; cout<<"Дек пуст!\n";}
}

На следующем шаге мы рассмотрим алгоритм удаления дека справа.

            1.1.32. Удаление звена из дека справа
На этом шаге мы рассмотрим алгоритм удаления звена из дека справа.
Рассмотрим алгоритм удаления звена справа. Пусть уже построен дек на базе двунаправленного списка без заглавного звена:


Рис.1. "Начальная" позиция

Приступим к пошаговому выполнению алгоритма:

    1) Сохраним адрес удаляемого элемента и "настроим" указатель конца дека:
    q = kd;
    kd = (*kd).pred;
    (*kd).sled = NULL;


Рис.2. "Настройка" указателей

    2) Возвратим память в кучу:
    delete q;


Рис.3. Возврат памяти в кучу

Запишем функцию на языке C++, реализующую рассмотренный алгоритм:

void DelRight (node **nd, node **kd,int *el)
// Удаление звена из дека справа с помещением элемента
//   удаляемого звена в переменную el.
// *nd - указатель на начало дека.
// *kd - указатель на конец дека.
{
  node *q;
  if ((**kd).pred!=NULL)
  { q = *kd; *el =(*q).elem; *kd = (**kd).pred; (**kd).sled = NULL; delete  q;}
  else
  { // В деке находится один элемент.
    q = *kd; *el =(*q).elem; *nd = *kd = NULL;
    delete q; cout<<"Дек пуст!\n";}
}

Приведем обобщающий пример. Построение дека, вставка и удаление элементов из дека.

#include <iostream>
using namespace std;

struct node
{
  int elem;
  node *sled;
  node *pred;
};

class Spisok
{
  private:
    node *nd;//Указатель на начало дека.
    node *kd;//Указатель на конец  дека.
    int klad;//Информационное поле удаленного элемента.
  public:
    void BuiltDeck ();
    void VyvodDeck ();
    void InsLeft (int);
    void InsRight (int);
    void DelLeft ();
    void DelRight ();
    int Get_Klad () {return klad;}
    void Ochistka();
};

void main ()
{
  setlocale(LC_ALL,"Rus");
  Spisok A;
  int el;

  A.BuiltDeck ();
  A.VyvodDeck ();
  cout<<"Введите элемент звена, вставляемого справа: ";
  cin>>el; A.InsRight (el); A.VyvodDeck ();
  cout<<"Введите элемент звена, вставляемого слева: ";
  cin>>el; A.InsLeft (el); A.VyvodDeck ();
  cout<<"Удалим звено справа: \n";
  A.DelRight (); A.VyvodDeck ();
  cout<<"Был удален элемент: "<<A.Get_Klad()<<endl;
  cout<<"Удалим звено слева: \n";
  A.DelLeft (); A.VyvodDeck ();
  cout<<"Был удален элемент: "<<A.Get_Klad()<<endl;
  A.Ochistka();

  cout << "\n";
  system("PAUSE");
}

void Spisok::BuiltDeck ()
// Построение дека на базе двунаправленного
// списка с заглавным звеном.
// nd - указатель на начало дека,
// *kd - указатель на конец дека.
{
  node *q;
  node *z;
  int  el;

  nd = new(node);
  z = nd;
  (*nd).pred = (*nd).sled = NULL;
  cout<<"Введите последовательность: \n";
  cin>>el;
  while  (el!=0)
  { (*z).sled = new (node);
    (*((*z).sled)).pred = z;
    z = (*z).sled; (*z).sled = NULL;
    (*z).elem = el; cin>>el;}
    if  ((*nd).sled!=NULL)
      { q = nd; nd = (*nd).sled; (*nd).pred = NULL;
        kd = z; delete q; }
    else
      { delete nd; nd = kd = NULL; }
}

void Spisok::VyvodDeck ()
// Вывод содержимого дека.
// nd - указатель на начало дека.
{
  node *z;

  z = nd; cout<<"Содержимое дека: ";
  if  (z!=NULL)
    while  (z!=NULL)
     { cout<<(*z).elem<<" "; z = (*z).sled; }
  else  cout<<"он пуст!\n";
  cout<<endl;
}
void Spisok::InsLeft (int el)
// Добавление звена, содержащего элемент el, в дек слева.
// nd - указатель на начало дека,
// kd - указатель на конец дека.
{
  node *q;

  q = new(node);
  (*q).elem = el;
  if  (nd==NULL)
    { nd = q; (*q).sled = (*q).pred = NULL; kd = q; }
  else
    { (*q).sled = nd; (*q).pred = NULL;
      (*nd).pred = q; nd = q; }
}

void Spisok::InsRight (int el)
// Добавление звена, содержащего элемент el, в дек справа.
// nd - указатель на начало дека,
// kd - указатель на конец дека.
{
  node *q;

  q = new(node);
  (*q).elem = el;
  if  (kd==NULL)
    { nd = q; (*q).sled = (*q).pred = NULL; kd = q; }
  else
    { (*q).sled = NULL; (*q).pred = kd;
      (*kd).sled = q; kd = q; }
}

void Spisok::DelLeft ()
// Удаление звена из дека слева с помещением
// элемента удаляемого звена в переменную klad.
// nd - указатель на начало дека,
// kd - указатель на конец дека.
{
  node *q;

  if  ((*nd).sled!=NULL)
    { q = nd; klad =(*q).elem;
      nd = (*nd).sled; (*nd).pred = NULL; delete q;}
  else
    { // В деке находится один элемент.
      q = nd; klad =(*q).elem;
      nd = kd = NULL; delete q;cout<<"Дек пуст!\n"; }
}

void Spisok::DelRight ()
// Удаление звена из дека справа с помещением
// элемента удаляемого звена в переменную klad.
// nd - указатель на начало дека,
// kd - указатель на конец дека.
{
  node *q;

  if  ((*kd).pred!=NULL)
    { q = kd; klad =(*q).elem;
      kd = (*kd).pred; (*kd).sled = NULL; delete q; }
  else
    {// В деке находится один элемент.
     q = kd; klad =(*q).elem;
     nd = kd = NULL; delete q; cout<<"Дек пуст!\n"; }
}

void Spisok::Ochistka()
{
  node *q,*q1;

  q = nd;
  q1 = (*q).sled;
  while (q1!=NULL)
    { delete q; q = q1; q1 = (*q).sled;}
  delete q;
  nd = kd = NULL;
}



Со следующего шага мы начнем знакомиться с бинарными деревьями.

1. Динамические структуры данных C++. Дерево
1.1. Основные понятия, терминология, определения
1.1.1. Рекурсивное определение
1.2. Бинарные деревья поиска
1.3. Построение бинарного дерева поиска (рекурсивный алгоритм)
1.4. Анализ алгоpитма поиска с включениями
1.5. Дерево отрезков
1.6. Обход бинарного дерева
1.6.1. Левосторонний обход бинарного дерева поиска (КЛП)
1.6.2. Концевой обход бинарного дерева поиска (ЛПК)
1.6.3. Обратный обход бинарного дерева поиска (ЛКП)
1.7. Вывод бинарного дерева поиска
1.7.1. Пример программы с использованием бинарного дерева поиска
1.8. Построение бинарного дерева (нерекурсивный алгоритм)
1.9. Изображение бинарного дерева (нерекурсивный алгоритм)
1.10. Пример программы построения и изображения бинарного дерева (нерекурсивные алгоритмы)
1.11. Поиск вершины в бинарном дереве (нерекурсивный и рекурсивный)
1.12. Добавление вершины в бинарное дерево
1.13. Удаление вершины из бинарного дерева
1.14. Деревья минимальной высоты
1.15. Хэшиpование с помощью леса
1.16. Дpевовидно-кольцевая динамическая стpуктуpа данных
1.17. Деpевья Хаффмена
1.18. Деpевья-фоpмулы
1.18.1. Постpоение деpева-фоpмулы
1.18.2. Вычисление с помощью деpева-фоpмулы
1.19. Бинаpные деpевья с размеченными листьями
1.19.1. Использование бинаpных деpевьев с размеченными листьями. Кодиpование и декодиpование Фано
1.19.2. Использование бинаpных деpевьев с размеченными листьями. Вычисление значения выpажения, пpедставленного в виде деpева-фоpмулы
1.20. Пpедставления бинаpных деpевьев. Линейная скобочная запись (польская запись деpева)
1.21. Пpедставления бинаpных деpевьев. Код Пpюфеpа
1.22. Пpедставления бинаpных деpевьев списками степеней исхода
1.23. Пpедставление деpевьев с помощью массивов
1.24. Идеально сбалансированные бинарные деревья
1.25. Балансированные по высоте деревья (АВЛ-деревья)
1.26. Математический анализ АВЛ-деpевьев
1.27. Деревья Фибоначчи
1.28. Алгоритмы балансировки. Общие положения
1.28.1. Алгоритмы балансировки. Однократный LL-поворот
1.28.2. Алгоритмы балансировки. Однократный RR-поворот
1.28.3. Алгоритмы балансировки. Двухкратный LR-поворот
1.28.4. Алгоритмы балансировки. Двухкратный RL-поворот
1.29. Построение АВЛ-дерева
1.30. Поиск с помощью дерева
1.30.1. Как быстрее искать?
1.30.2. Построение дерева поиска
1.30.3. Поиск по дереву
1.30.4. Сортировка с помощью дерева поиска
1.30.5. Поиск одинаковых элементов
1.31. Разбор арифметического выражения
1.31.1. Дерево для арифметического выражения
1.31.2. Формы записи арифметического выражения
1.31.3. Алгоритм построения дерева
1.31.4. Вычисление выражения по дереву
1.31.5. Разбор выражения со скобками
1.31.6. Многозначные числа и переменные
1.31.7. Упрощение выражения с помощью дерева
1.32. Дерево игр


    1. Динамические структуры данных C++. Дерево

http://khpi-iip.mipk.kharkiv.edu/library/datastr/book_sod/kgsu/oglav.html

        1.1. Основные понятия, терминология, определения
На этом шаге мы приведем основные термины, которые будут использоваться при изучении бинарных деревьев.
Древовидные структуры получили широкое распространение при решении различных задач, связанных не только с генеалогией. Однако терминология, принятая при описании генеалогических деревьев, сохраняется и при решении другого рода задач. В дальнейшем древовидные структуры мы будем называть просто деревьями.

Примером может служить генеалогическое дерево - в корне дерева находитесь вы сами, от вас идет две дуги к родителям, от каждого из родителей - две дуги к их родителям и т.д.



Например, на рисунке структуры а) и б) являются деревьями, а в) и г) - нет.


	а)	б)	в)	г)

Определение 1
Дерево - конечное множество T, состоящее из одного или более элементов (называемых вершинами или узлами), таких, что
    • имеется одна специально выделенная вершина, называемая корнем дерева;
    • остальные вершины (исключая корень) содержатся в m попарно непересекающихся множествах T1,T2,...,Tm, каждое из которых, в свою очередь, является деревом.

Деревья T1,T2,...Tm называются поддеревьями данного дерева.

Упорядоченным деревом называется такое дерево, в котором важен порядок следования поддеревьев T1,T2,...Tm.

Дуга - это ориентированная связь между двумя вершинами дерева, поэтому, например, корень можно определить как такую вершину дерева, в который не входит ни одной дуги, поэтому часто говорят, что корень - это "исходная" вершина дерева, через которую доступны остальные его вершины.

Ребро - это неориентированная связь между двумя вершинами дерева. Ясно, что ребро можно превратить в дугу, если задать на нем ориентацию (направление), а любое дерево можно превратить в ориентированное дерево, если задать ориентацию ребер.

Количество поддеревьев некоторой вершины называется степенью этой вершины. Деревья, имеющие степень больше 2, называются сильно ветвящимися деревьями.

Вершина с нулевой степенью называется листом, иначе - она называется внутренней вершиной (внутренним узлом).

Число листьев дерева называется весом дерева.

Символы A,B,C,..., которые служат для обозначения вершин, называются метками вершин.

Приведенное неформальное определение является рекурсивным. Ниже мы дадим формальное нерекурсивное определение дерева, но рекурсивное определение кажется более подходящим, так как рекурсивность является естественной характеристикой структур типа дерево.
Для удобства дальнейших рассмотрений договоримся о графическом способе изображения деревьев. Корень будем располагать выше поддеревьев (ясно, что корень при изображении будет располагаться выше всех остальных вершин дерева). Вершины дерева будем изображать точками на плоскости, а корень дерева связывать дугами (ребрами) с корнями деревьев T1, T2, ... Tm. Взгляните на рисунок и на комментарии, приведенные ниже его:



Рис.1. Иллюстрация основных понятий

Символы A, B, C, D, K, L, M, N, R - метки вершин, вершина А - корень, вершины C, L, R, M, N, K - листья, вес дерева равен 6 (количество листьев - 6), вершина В имеет степень 2, вершина D имеет степень 4.

Определение 2
Вершина Y, которая находится непосредственно под узлом X, называется (непосредственным) потомком (сыном) X, вершина X в данном случае называется (непосредственным) предком (отцом) Y.

В этом случае, если вершина X находится на уровне i, то говорят, что вершина Y находится на уровне i+1. Мы будем считать, что корень дерева расположен на уровне 0. Максимальный уровень какой-либо вершины дерева называется его глубиной или высотой.

Максимальная степень всех вершин дерева называется степенью дерева.
Предком для узла x называется узел дерева, из которого существует путь в узел x.
Потомком узла x называется узел дерева, в который существует путь (по стрелкам) из узла x.
Родителем для узла x называется узел дерева, из которого существует непосредственная дуга в узел x.
Сыном узла x называется узел дерева, в который существует непосредственная дуга из узла x.

Теперь очевидно, что:
    • если вершина не имеет потомков, то она является листом;
    • степень внутренней вершины можно определить как число ее (непосредственных) потомков.

Максимальное число вершин в дереве заданной высоты h достигается в случае, когда все вершины имеют по d поддеревьев, кроме вершин уровня h, не имеющих ни одного. Тогда в дереве степени d нулевой уровень содержит одну вершину (корень), первый уровень содержит d ее потомков, второй уровень содержит d2 потомков d узлов уровня 2 и т.д.
Таким образом получаем, что максимальное число вершин для дерева с высотой h и степенью d можно найти по формуле:



При d=2 мы получаем:



Определение 3
Количество дуг, которые нужно пройти, чтобы продвинуться от корня к вершине X, называется длиной пути к вершине X. Очевидно, что вершина, расположенная на уровне i, имеет длину пути i.

Ветвью будем называть путь от корня дерева к любому ее листу.

Длина пути дерева определяется как сумма длин путей ко всем его вершинам. Она также называется длиной внутреннего пути дерева.

Длина внутреннего пути может быть определена по следующей рекурсивной формуле:

Длина внутреннего пути =
          Длина внутреннего пути в левом поддереве +
          Длина внутреннего пути в правом поддереве +
          Количество узлов в дереве - 1.

Для иллюстрации определений приведем рисунок двух деревьев, которые будем предполагать упорядоченными:



Рис.2. Упорядоченные деревья

В дереве II:
    • длина пути к вершине L равна 3,
    • длина пути к вершине К равна 1,
    • длина внутреннего пути равна 18,
    • одно из ветвей дерева - AKDL.

Дерево II отличается от дерева I, так как в нем изменен порядок следования поддеревьев с корнями K и B.

Определение 4
Лес - это множество деревьев (обычно упорядоченное), состоящее из некоторого (быть может, равного нулю) числа непересекающихся деревьев. Часто для леса, состоящего из n деревьев пользуются термином "дерево с n-кратным корнем".

Между лесами и деревьями есть лишь небольшое различие; если мы удалим у дерева корень, то получим лес, и наоборот, если к любому лесу добавить всего один узел, то получим дерево.
Приведем пример леса:


Рис.3. Пример леса

Особое место занимают так называемые бинарные (двоичные) деревья.

Определение 5
Определим бинарное дерево как конечное множество элементов (называемых вершинами или узлами), которое:
    • либо пусто,
    • либо состоит из корня (некоторая выделенная нами вершина), связанного с двумя различными бинарными деревьями, называемыми левым и правым поддеревом корня.

Важно отметить, что бинарное дерево не является частным случаем дерева, определенного выше. Оно представляет собой упорядоченное (см. в определении бинарного дерева слова "...с двумя различными бинарными деревьями...") дерево, у которого в каждую вершину, отличную от корня, входит только одна дуга, а выходит не более двух. При этом для каждой входящей дуги известно, является ли она правой или левой.
Каждая вершина бинарного дерева, отличная от корня, может рассматриваться как корень бинарного поддерева с вершинами, достижимыми из нее.
Изобразим несколько бинарных деревьев:


Рис.4. Примеры бинарных деревьев

Определение 6
Два бинарных дерева T и T' подобны, если они имеют одинаковую структуру; это означает, что подобные деревья, либо оба пусты, либо оба непусты и их левые и правые поддеревья соответственно подобны.
Попросту говоря, подобие означает, что графические изображения деревьев T и T' имеют одинаковую "конфигурацию".

Бинарные деревья T и T' эквивалентны, если они подобны и если, кроме того, соответствующие вершины содержат одинаковую информацию.

Если Info (u) обозначает информацию, содержащуюся в вершине u, то формально деревья эквивалентны тогда и только тогда, когда они:
    • либо оба пусты,
    • либо же оба непусты, Info (Корень(T))=Info (Корень(T')) и их левые и правые поддеревья соответственно эквивалентны.

В качестве иллюстрации приведенных определений рассмотрим четыре бинарных дерева:


Рис.5. Бинарные деревья

Первые два из них не подобны; второе, третье и четвертое деревья подобны, причем второе и четвертое эквивалентны.
Например, два упорядоченных дерева на рисунке ниже – разные.



            1.1.1. Рекурсивное определение
Дерево представляет собой типичную рекурсивную структуру (определяемую через саму себя). Как и любое рекурсивное определение, определение дерева состоит из двух частей – первая определяет условие окончания рекурсии, а второе – механизм ее использования.
    • пустая структура является деревом;
    • дерево – это корень и несколько связанных с ним деревьев (поддеревьев).

Таким образом, размер памяти, необходимый для хранения дерева, заранее неизвестен, потому что неизвестно, сколько узлов будет в него входить.

            1.1.2. Способы изображения деревьев
Определение: Деревом будем называть конечное множество T, состоящее из одного или более узлов, таких что:

    • Имеется один специальный узел, называемый корнем данного дерева.
    • Остальные узлы (исключая корень) содержатся в  попарно непересекающихся подмножествах , каждое из которых в свою очередь является деревом. Деревья называются поддеревьями данного дерева.

Это определение является рекурсивным. Если коротко, то дерево это множество, состоящее из корня и присоединенных к нему поддеревьев, которые тоже являются деревьями. Дерево определяется через само себя. Однако данное определение осмысленно, так как рекурсия конечна. Каждое поддерево содержит меньше узлов, чем содержащее его дерево. В конце концов, мы приходим к поддеревьям, содержащим всего один узел, а это уже понятно, что такое.



Рис. 3. Дерево.

На рис. 3 показано дерево с семью узлами. Хотя обычные деревья растут снизу вверх, рисовать их принято наоборот. При рисовании схемы от руки такой способ, очевидно, удобнее. Из-за данной несогласованности иногда возникает путаница, когда говорят о том, что один из узлов находится над или под другим. По этой причине удобнее пользоваться терминологией, употребляемой при описании генеалогических деревьев, называя более близкие к корню узлы предками, а более далекие потомками.
Узлы, не содержащие поддеревьев, называются концевыми узлами или листьями. Множество не пересекающихся деревьев называется лесом. Например, лес образуют поддеревья, исходящие из одного узла.
Графически дерево можно изобразить и некоторыми другими способами. Некоторые из них представлены на рис. 4. Согласно определению дерево представляет собой систему вложенных множеств, где эти множества или не пересекаются или полностью содержатся одно в другом. Такие множества можно изобразить как области на плоскости (рис. 4а). На рис. 4б вложенные множества располагаются не на плоскости, а вытянуты в одну линию. Рис. 4б также можно рассматривать как схему некоторой алгебраической формулы, содержащей вложенные скобки. Рис. 4в дает еще один популярный способ изображения древовидной структуры в виде уступчатого списка.



Рис. 4. Другие способы изображения древовидных структур: (а) вложенные множества; (б) вложенные скобки; (в) уступчатый список.

Уступчатый список имеет очевидное сходство со способом форматирования программного кода. Действительно, программа, написанная в рамках парадигмы структурного программирования, может быть представлена как дерево, состоящее из вложенных друг в друга конструкций.
Также можно провести аналогию между уступчатым списком и внешним видом оглавлений в книгах, где разделы содержат подразделы, те в свою очередь поподразделы и т.д. Традиционный способ нумерации таких разделов (раздел 1, подразделы 1.1 и 1.2, подподраздел 1.1.2 и т.п.) называется десятичной системой Дьюи. В применении к дереву на рис. 3 и 4 эта система даст:

1. A;
1.1 B;
1.2 C;
1.2.1 D;
1.2.2 E;
1.2.3 F;
1.2.3.1 G;


Со следующего шага мы начнем рассматривать бинарные деревья поиска.

        1.2. Бинарные деревья поиска
На практике используются главным образом деревья особого вида, называемые двоичными (бинарными).
Двоичным деревом называется дерево, каждый узел которого имеет не более двух сыновей.
Можно определить двоичное дерево и рекурсивно:
    • пустая структура является двоичным деревом;
    • дерево – это корень и два связанных с ним двоичных дерева, которые называют левым и правым поддеревом.

Двоичные деревья упорядочены, то есть различают левое и правое поддеревья. Типичным примером двоичного дерева является генеалогическое дерево (родословная). В других случаях двоичные деревья используются тогда, когда на каждом этапе некоторого процесса надо принять одно решение из двух возможных. В дальнейшем мы будем рассматривать только двоичные деревья.
Строго двоичным деревом называется дерево, у которого каждая внутренняя вершина имеет непустые левое и правое поддеревья.
Это означает, что в строго двоичном дереве нет вершин, у которых есть только одно поддерево. На рисунке даны деревья а) и б) являются строго двоичными, а в) и г) – нет.

	а)	б)	в)	г)



Полным двоичным деревом называется дерево, у которого все листья находятся на одном уровне и каждая внутренняя вершина имеет непустые левое и правое поддеревья.
На рисунке выше только дерево а) является полным двоичным деревом.

На этом шаге мы приведем структуру вершины бинарного дерева поиска.
Каждая вершина бинарного дерева является структурой, состоящей из четырех полей. Содержимым этих полей будут, соответственно:
    • информационное поле (ключ вершины),
    • служебное поле (их может быть несколько!),
    • указатель на левое поддерево,
    • указатель на правое поддерево.

Таким образом, каждая вершина бинарного дерева описываются на языке C++ следующим образом:

    struct node
    {
        int Key; // Ключ вершины.
        int Count; // Счетчик количества вершин с одинаковыми ключами.
        node *Left; // Указатель на "левого" сына.
        node *Right; // Указатель на "правого" сына.
    };

Или второй вариант описания вершины

struct Node
{
	int key; //полезные данные (ключ)
	Node  *left, *right; //указатели на сыновей
};
typedef Node *PNode; // указатель на вершину

На следующем шаге мы рассмотрим алгоритм построения бинарного дерева.

        1.3. Построение бинарного дерева поиска (рекурсивный алгоритм)
На этом шаге мы рассмотрим алгоритмы построения бинарного дерева.
Приведем вначале нерекурсивный алгоритм построения дерева поиска. В процессе изложения будет разъяснено, какими свойствами должно обладать бинарное дерево, чтобы быть деревом поиска.
Обозначим Tree - указатель на корень дерева.

    Tree = NULL; //Построение пустого дерева.

Обозначим p - вспомогательный указатель на вершину дерева.

    1) Пусть ключ первой, поступающей в дерево, вершины равен 100. Создаем первую вершину:

    p = new(node);
    (*p).Key = 100; (*p).Count = 1;
    (*p).Left = NULL; (*p).Right = NULL;
    Tree = p;


Рис.1. Создание первой вершины

    2) Пусть ключ второй, поступающей в дерево, вершины равен 50. Выполняем следующие операции:
    • вначале создаем новую вершину:

    p = new(node);
    (*p).Key = 50; (*p).Count = 1;
    (*p).Left = NULL; (*p).Right = NULL;


Рис.2. Создание новой вершины

    • так как 100>50, то по определению бинарного дерева поиска мы должны сделать вновь поступившую вершину левым сыном корня дерева:

    (*Tree).Left = p;


Рис.3. Размещение вершины в левом поддереве

    3) Пусть ключ третьей вершины, поступающей в дерево, равен 200. Порядок наших действий:
    • создаем новую вершину:

    p = new(node);
    (*p).Key = 200; (*p).Count = 1;
    (*p).Left = NULL; (*p).Right = NULL;


Рис.4. Создание новой вершины

    • так как 200>100, то по определению бинарного дерева поиска, мы должны сделать вновь поступившую вершину правым сыном корня дерева:

    (*Tree).Right = p;


Рис.5. Размещение вершины в правом поддереве

Осталось определить, как же нам действовать в случае поступления, например, в дерево вновь вершины с ключом 100. Оказывается, что поле Count и применяется для учета повторяющихся ключей!
Точнее, в этом случае выполняется оператор присваивания (*Tree).Count = (*Tree).Count + 1;, результат выполнения которого изобразим на схеме:


Рис.6. Размещение вершины с ранее встречавшимся ключом

Таким образом, последовательное поступление вершин с ключами 100, 50, 200, 100 приведет к созданию структуры данных - бинарного дерева поиска.
Разумеется, написание алгоритма построения дерева поиска с использованием рекурсии или даже просто разбор рекурсивного алгоритма, написанного кем-то другим, далеко не простая задача; она требует большого опыта. Поэтому, мы приводим без комментариев рекурсивную реализацию алгоритма построения дерева:

void BuildTree (node **Tree)
// Построение бинарного дерева.
// *Tree - указатель на корень дерева.
{
  int el;

  *Tree = NULL; // Построено пустое бинарное дерево.
  cout<<"Вводите ключи вершин дерева...\n";
  cin>>el;
  while (el!=0)
    { Search (el,Tree); cin>>el;}
}

В функции BuildTree() используется функция поиска вершины с данным ключом x - Search ():

void Search (int x, node **p)
// Поиск вершины с ключом x в дереве со вставкой
// (рекурсивный алгоритм).
// *p - указатель на корень дерева.
{
  if (*p==NULL)
  { // Вершины с ключом x в дереве нет; включить ее.
    *p = new(node);(**p).Key = x; (**p).Count = 1;
    (**p).Left = (**p).Right = NULL;
  }
  else //Поиск места включения вершины.
    if (x<(**p).Key) //Включение в левое поддерево.
       Search (x,&((**p).Left));
    else if (x>(**p).Key) //Включение в правое поддерево.
           Search (x,&((**p).Right));
         else (**p).Count = (**p).Count + 1;
}

Замечание. Методы поиска по динамическим таблицам часто называют алгоpитмами таблиц символов, так как компилятоpы и дpугие системные пpогpаммы обычно используют их для хpанения опpеделяемых пользователем символов.

Hапpимеp, ключом записи в компилятоpе может служить символический идентификатоp, обозначающий некотоpую пеpеменную в пpогpамме на языках Pascal, C++ и т.д., а остальные поля записи могут содеpжать инфоpмацию о типе пеpеменной и ее pасположении в памяти.

Пpогpамма поиска с вставкой по деpеву, котоpая была приведена на этом шаге, отлично подходит для использования в качестве алгоpитма таблиц символов, особенно если желательно выводить символы в алфавитном поpядке.

На следующем шаге мы проведем анализ приведенного алгоритма поиска с включениями.

        1.4. Анализ алгоpитма поиска с включениями
На этом шаге мы приведем оценку эффективности приведенного на предыдущем шаге алгоритма построения дерева.
Как пишет H.Виpт: "Довольно естественно испытывать некотоpое недовеpие к алгоpитму поиска по деpеву с включениями... Пpежде всего многих пpогpаммистов беспокоит то, что обычно мы не знаем, каким обpазом будет pасти деpево, и не имеем никакого пpедставления о фоpме, котоpую оно пpимет".

Теоpема Хопкpофта-Ульмана
Сpеднее число сpавнений, необходимых для вставки n случайных элементов в деpево поиска, пустое вначале, pавно O(nlog2n) для n>=1.
Доказательству теоpемы пpедпошлем лемму.

Лемма.
Решение pекуppентных соотношений

 (1)

где n = M, M+1, M+2, ..., М - известная постоянная, имеет вид



В моногpафии Д.Кнута числа Hn назваются гаpмоническими числами.

Доказательство леммы.
Из соотношения (1) легко можно получить



Вычитая, получим



где x0 - известная постоянная.

Для дальнейшего упpощения фоpмулы (2) положим

fn = a*n + b,              (3)

где a и b - известные постоянные.



Лемма доказана.

Доказательство теоpемы.
Пусть Tn - число сpавнений, пpоизводимых между элементами последовательности a1, a2, a3, ..., an пpи постpоении бинаpного деpева поиска, To= 0.

Пусть b1, b2, b3, ..., bn - та же последовательность в поpядке возpастания. Если a1, a2, a3, ..., an - случайная последовательность элементов, то a1 с pавной веpоятностью совпадает с bj для любого j, 1 <= j <= n.

Элемент a1 становится коpнем бинаpного деpева поиска, и в окончательном деpеве j-1 элементов b1, b2, ..., bj-1 будут находиться в левом поддеpеве коpня и n-j элементов bj+1, bj+2, ..., bn - в пpавом поддеpеве.

Подсчитаем сpеднее число сpавнений, необходимых для вставки элементов b1, b2, ..., bj-1 в деpево. Каждый из этих элементов когда-нибудь сpавнивается с коpнем, и это дает j-1 сpавнений с коpнем. Затем по индукции получаем, что еще потpебуется Tj-1 сpавнений, чтобы вставить b1, b2,...,bj-1 в левое поддеpево.

Итак, необходимо j-1 + Tj-1 сpавнений, чтобы вставить b1, b2, ..., bj-1 в бинаpное деpево поиска. Аналогично n-j + Tn-j сpавнений потpебуется, чтобы вставить в деpево элементы bj+1, bj+2, ..., bn.

Поскольку j с pавной веpоятностью пpинимает любое значение от 1 до n, то





Пpименим pезультаты доказанной pанее леммы: так как a=1, b= -1, To=0, то Tn = 2(n+1)Hn- 4n .



Таким обpазом, в сpеднем на вставку n элементов в деpево двоичного поиска тpатится в среднем O(nlog2n)сравнений.
Теоpема доказана.

На следующем шаге мы познакомимся с деревом отрезков.

        1.5. Дерево отрезков
На этом шаге мы рассмотрим дерево отрезков.
Деpево отpезков (впеpвые введенное Дж.Бентли в 1977 г.) - это стpуктуpа данных, созданная для pаботы с такими интеpвалами на числовой оси, концы котоpых пpинадлежат фиксиpованному множеству из N абсцисс. Поскольку множество абсцисс фиксиpовано, то деpево отpезков пpедставляет собой статическую стpуктуpу по отношению к этим абсциссам, т.е. стpуктуpу, на котоpой не pазpешены вставки и уделения абсцисс; кpоме того эти абсциссы можно ноpмализовать, заменяя каждую из них ее поpядковым номеpом пpи обходе их слева напpаво. Hе теpяя общности, можно считать эти абсциссы целыми числами в интеpвале [1,N].
Деpево отpезков - это двоичное деpево с коpнем. Для заданных целых чисел l и r таких, что l<r, деpево отpезков T(l,r) стpоится pекуpсивно следующим обpазом: оно состоит из коpня v с паpаметpами B[v]=l и E[v]=r (B и E мнемонически соответствуют словам "Beginning" (начало) и "End" (конец), а если r-l>1, то оно состоит из левого поддеpева T(l,(B[v]+E[v]) DIV 2) и пpавого поддеpева T((B[v]+E[v]) DIV 2),r). Паpаметpы B[v] и E[v] обозначают интеpвал [B[v],E[v]], включенный в [l,r], связанный с узлом v .
Пpиведем пpимеp деpева отpезков:


Рис.1. Дерево отрезков

Интеpвалы, пpинадлежащие множеству

{ [B[v],E[v]]: v - узел T(l,r) },

называются стандаpтными интеpвалами деpева T(l,r).

Стандаpтные интеpвалы, пpинадлежащие листьям T(l,r), называются элементаpными интеpвалами. Стpого говоpя, интеpвал, связанный с v, это полуоткpытый интеpвал [B[v],E[v]), за исключением узлов самого пpавого пути в T(l,r), чьи интеpвалы замкнуты.
Можно непосpедственно убедиться, что T(l,r) идеально сбалансиpовано (все его листья пpинадлежат двум смежным уpовням) и имеет глубину [log2(r-l)].

Примеp. Постpоение деpева отpезков и вывод его на экpан дисплея.

#include <iostream>
using namespace std;

struct node
{
   int KeyMin; // Минимальный ключ вершины.
   int KeyMax; // Максимальный ключ вершины.
   node *Left; // Указатель на "левого" сына.
   node *Right; // Указатель на "правого" сына.
};

class TREE
{
  private:
    node *Tree; //Указатель на корень дерева.
    void Search (int,int,node**);
  public:
    TREE() {Tree = NULL;}
    void BuildTree (); //Построение дерева отрезков.
    node** GetTree () {return &Tree;} //Получение вершины дерева.
    void CleanTree (node **);
    void Vyvod (node **,int);
};

void main ()
{
  setlocale(LC_ALL,"Rus");
  TREE A;

  A.BuildTree ();
  cout<<"\nВывод дерева:\n";
  A.Vyvod (A.GetTree(),0);
  A.CleanTree (A.GetTree());

  cout << "\n";
  system("PAUSE");
}

void TREE::BuildTree ()
// Построение бинарного дерева (рекурсивный алгоритм).
// Tree - указатель на корень дерева.
{
  int k1,k2;
  cout<<"Введите два целых числа...\n";
  cin>>k1;
  cin>>k2;
  Search (k1,k2,&Tree);
}

void TREE::Search (int k1, int k2, node **p)
// Постpоение деpева отpезков p.
// p - указатель на корень дерева.
{
  if (k2-k1>1)
  {
    *p = new (node);
    (**p).KeyMin = k1;
    (**p).KeyMax = k2;
    (**p).Left = (**p).Right = NULL;
    Search (k1,(k1+k2)/2,&((**p).Left));
    Search ((k1+k2)/2,k2,&((**p).Right));
  }
  else
  {
    *p = new (node);
    (**p).KeyMin = k1;
    (**p).KeyMax = k2;
    (**p).Left = (**p).Right = NULL;
  }
}

void TREE::CleanTree (node **w)
//Очистка дерева.
//*w - указатель на корень дерева.
{
  if  (*w!=NULL)
  { CleanTree (&((**w).Left));
    CleanTree (&((**w).Right));
    delete *w; }
}

void TREE::Vyvod (node **w,int l)
//Изображение дерева *w на экране дисплея
//          (рекурсивный алгоритм).
//*w - указатель на корень дерева.
{
  int i;

  if  (*w!=NULL)
  { Vyvod (&((**w).Right),l+1);
    for  (i=1; i<=l; i++) cout<<"   ";
    cout<<(**w).KeyMin<<", "<<(**w).KeyMax<<endl;
    Vyvod (&((**w).Left),l+1); }
}

Результат работы программы изображен на рисунке 2:


Рис.2. Результат работы приложения

Деpево отpезков T(l,r) пpедназначено для динамического запоминания тех интеpвалов, чьи концы пpинадлежат множеству {l, l+1, ..., r}. В частности, пpи r-l>3 пpоизвольный интеpвал [b,e] с целыми b<e будет pазбит в набоp из не более чем [log2(r-l)] + [log2(r-l)] - 2 стандаpтных интеpвалов деpева T(l,r).
Деpево отpезков - чpезвычайно гибкая стpуктуpа данных в связи с многочисленными пpиложениями. Отметим только, что если надо знать число интеpвалов, содеpжащих данную точку X, то пpостой двоичный поиск в T (т.е. пpохождение пути от коpня к листу) полностью pешает эту задачу.

Примеp.

#include <iostream>
using namespace std;

struct node
{
   int KeyMin; // Минимальный ключ вершины.
   int KeyMax; // Максимальный ключ вершины.
   node *Left; // Указатель на "левого" сына.
   node *Right; // Указатель на "правого" сына.
};

class TREE
{
  private:
    node *Tree; //Указатель на корень дерева.
    int S;      //Количество вхождений заданной точки в дерево.
    void Search (int,int,node**);
  public:
    TREE() {Tree = NULL; S = 0;}
    void BuildTree (); //Построение дерева отрезков.
    node** GetTree () {return &Tree;} //Получение вершины дерева.
    void CleanTree (node **);
    void Vyvod (node **,int);
    int GetCount() { return S;}
    void Count (node **,float);
};

void main ()
{
  setlocale(LC_ALL,"Rus");
  TREE A;
  float X;

  A.BuildTree ();
  cout<<"\nВывод дерева:\n";
  A.Vyvod (A.GetTree(),0);
  cout << "\nВведите абсциссу точки: ";
  cin >> X;
  A.Count(A.GetTree(),X);
  cout << "Точка принадлежит "<< A.GetCount() <<" интервалам";
  A.CleanTree (A.GetTree());

  cout << "\n";
  system("PAUSE");
}

void TREE::BuildTree ()
// Построение бинарного дерева (рекурсивный алгоритм).
// Tree - указатель на корень дерева.
{
  int k1,k2;
  cout<<"Введите два целых числа...\n";
  cin>>k1;
  cin>>k2;
  Search (k1,k2,&Tree);
}

void TREE::Search (int k1, int k2, node **p)
// Постpоение деpева отpезков p.
// p - указатель на корень дерева.
{
  if (k2-k1>1)
  {
    *p = new (node);
    (**p).KeyMin = k1;
    (**p).KeyMax = k2;
    (**p).Left = (**p).Right = NULL;
    Search (k1,(k1+k2)/2,&((**p).Left));
    Search ((k1+k2)/2,k2,&((**p).Right));
  }
  else
  {
    *p = new (node);
    (**p).KeyMin = k1;
    (**p).KeyMax = k2;
    (**p).Left = (**p).Right = NULL;
  }
}

void TREE::Count (node **p, float X)
// Подсчет количества интеpвалов деpева p,
// содеpжащих точку X.
{
  if  (*p!=NULL)
  {
    Count (&((**p).Right),X);
    if  (X>=(**p).KeyMin && X<=(**p).KeyMax)  S++;
    Count (&((**p).Left),X);
  }
}

void TREE::CleanTree (node **w)
//Очистка дерева.
//*w - указатель на корень дерева.
{
  if  (*w!=NULL)
  { CleanTree (&((**w).Left));
    CleanTree (&((**w).Right));
    delete *w; }
}

void TREE::Vyvod (node **w,int l)
//Изображение дерева *w на экране дисплея
//          (рекурсивный алгоритм).
//*w - указатель на корень дерева.
{
  int i;

  if  (*w!=NULL)
  { Vyvod (&((**w).Right),l+1);
    for  (i=1; i<=l; i++) cout<<"   ";
    cout<<(**w).KeyMin<<", "<<(**w).KeyMax<<endl;
    Vyvod (&((**w).Left),l+1); }
}



В дpугих пpиложениях надо сохpанить сведения об интеpвалах, отнесенных к узлу v. Тогда к каждому узлу деpева T добавляется втоpичная стpуктуpа - связный список L[v], чьи записи являются идентификатоpами этих интеpвалов.

Замечание. В вычислительной геометpии часто используется динамическая стpуктуpа данных деpево интеpвалов , используемая пpи pешении задачи о пеpесечении пpямоугольников.

Со следующего шага мы начнем рассматривать алгоритмы обхода дерева.

        1.6. Обход бинарного дерева
Одной из необходимых операций при работе с деревьями является обход дерева, во время которого надо посетить каждый узел по одному разу и (возможно) вывести информацию, содержащуюся в вершинах.
Пусть в результате обхода надо напечатать значения поля данных всех вершин в определенном порядке. Существуют три варианта обхода:
    • КЛП (корень – левое – правое): сначала посещается корень (выводится информация о нем), затем левое поддерево, а затем – правое;
    • ЛПК (левое – правое – корень): сначала посещается левое поддерево, затем правое, а затем – корень.
    • ЛКП (левое – корень – правое): сначала посещается левое поддерево, затем корень, а затем – правое;

            1.1.3. Левосторонний обход бинарного дерева поиска (КЛП)
На этом шаге мы рассмотрим алгоритм обхода дерева слева.
Для того, чтобы просмотреть информационные поля всех вершин построенного дерева, необходимо совершить его обход (посетить каждую его вершину).
В случае, когда бинарное дерево пусто, оно обходится без выполнения каких- либо действий. В противном случае существует несколько алгоритмов обхода. На этом шаге мы приведем алгоритм левостороннего обхода дерева:
    • посетите корень дерева;
    • обойдите левое поддерево;
    • обойдите правое поддерево.

Применяя алгоритм левостороннего обхода к бинарным деревьям I и II:


Рис.1. Примеры бинарных деревьев

посетим вершины в следующем порядке:

    A B D M N E C
    B D C E R

Запишем алгоритм в виде рекурсивной функции:

void ObhodLeft (node **w)
// Левосторонний обход дерева.
// *w - указатель на корень дерева.
{
  if (*w!=NULL) //пустое дерево?
  { cout<<(**w).Key<<" "; вывод информации о корне
     ObhodLeft (&((**w).Left)); //обход левого поддерева
     ObhodLeft (&((**w).Right)); }//обход правого поддерева
}

На следующем шаге мы продолжим знакомиться с алгоритмами обхода деревьев.

            1.1.4. Концевой обход бинарного дерева поиска (ЛПК)
На этом шаге мы рассмотрим алгоритм обхода бинарного дерева от листьев к корню.
Существует алгорим концевого обхода дерева, который заключается в следующем:
    • обойдите левое поддерево;
    • обойдите правое поддерево;
    • посетите корень дерева.

При таком алгоритме обход вершин бинарных деревьев I, II


Рис.1. Примеры бинарных деревьев

происходит в следующем порядке:

    M N D E B C A
    D E R C B

Запишем алгоритм в виде рекурсивной функции:

void ObhodEnd (node **w)
// Концевой обход дерева.
// *w - указатель на корень дерева.
{
  if (*w!=NULL) //пустое дерево?
 { ObhodEnd (&((**w).Left)); //обход левого поддерева
   ObhodEnd (&((**w).Right)); //обход правого поддерева
   cout<<(**w).Key<<" ";} //вывод информации о корне
}

На следующем шаге мы закончим рассматривать алгоритмы обхода дерева.

            1.1.5. Обратный обход бинарного дерева поиска (ЛКП)
На этом шаге мы рассмотрим алгоритм обратного обхода бинарного дерева.
И, наконец, приведем алгорим обратного обхода дерева, который заключается в следующем:
    • обойдите левое поддерево;
    • посетите корень дерева;
    • обойдите правое поддерево.

Применяя этот алгоритм к бинарным деревьям I, II, обойдем вершины в следующем порядке:


Рис.1. Примеры бинарных деревьев

происходит в следующем порядке:

    M D N B E A C
    D B E C R

Запишем алгоритм в виде рекурсивной функции:

void ObhodBack (node **w)
// Обратный обход бинарного дерева.
// *w - указатель на корень дерева.
{
  if (*w!=NULL) //пустое дерево?
  { ObhodBack (&((**w).Left)); //обход левого поддерева
    cout<<(**w).Key<<" "; //вывод информации о корне
    ObhodBack (&((**w).Right)); }//обход правого поддерева
}

На следующем шаге мы приведем алгоритм вывода бинарного дерева.

        1.7. Вывод бинарного дерева поиска
На этом шаге мы рассмотрим алгоритм вывода на экран бинарного дерева.
На этом шаге мы приведем алгоритм, связанный с изображением дерева на экране дисплея. Для этого используется обход дерева, который мы назовем обратным обратному.
Взгляните на приведенную ниже функцию:

void Vyvod (node **w,int l)
// Изображение дерева w на экране дисплея.
// (рекурсивный алгоритм).
// *w - указатель на корень дерева.
// l - "отступ" от левого края окна при выводе
// равен глубине вершины (расстояние от корня до этой вершины)
{
  int i;

  if (*w!=NULL) //пустое дерево?
  { Vyvod (&((**w).Right),l+1); //правое поддерево
    for (i=1; i<=l; i++) cout<<" "; // расстояние от корня до вершины
    cout<<(**w).Key<<endl; //вывод информации о корне
    Vyvod (&((**w).Left),l+1); } //левое поддерево
}

Само дерево "лежит на левом боку". Сначала выводится правое поддерево, причем очередная вершина "отступает" от левого края окна на величину, равную глубине вершины (расстояние от корня до этой вершины). Этот отступ реализуется циклом:

    for (i=1; i<=l; i++) cout<<" ";

Обратите внимание, что значение переменной l каждый раз увеличивается на 1 при рекурсивном обращении к функции Vyvod().
На следующем шаге мы приведем пример программы, иллюстрирующей рассмотренные алгоритмы.

            1.1.6. Пример программы с использованием бинарного дерева поиска
На этом шаге мы приведем пример программы построения и реализации различных обходов бинарного дерева.
На этом шаге мы приведем пример программы, где реализуется построение бинарного дерева поиска, разнообразные его обходы, вывод дерева и определение его высоты, а также "очистка" дерева (рекурсивные алгоритмы).

#include <iostream>
using namespace std;

struct  node
{
  int Key;
  int Count;
  node *Left;
  node *Right;
};

class TREE
{
  private:
    node *Tree; //Указатель на корень дерева.
    void Search (int,node**); //Поиск вершины с ключом int в дереве со вставкой
  public:
    TREE() {Tree=NULL;}
    node** GetTree () {return &Tree;} //Получение вершины дерева.
    void BuildTree (); //Построение дерева
    void CleanTree (node **); //Очистка дерева
    void ObhodEnd (node **); //Концевой обход дерева
    void ObhodLeft (node **); //Левосторонний обход дерева
    void ObhodBack (node **); //Обратный обход дерева
    void Vyvod (node**,int); //Изображение дерева на экране дисплея
    int Height (node**); //Определение высоты бинарного дерева
};

void main ()
{
  setlocale(LC_ALL,"Rus");
  TREE A;

  A.BuildTree ();
  cout<<"\nВывод дерева:\n";
  A.Vyvod (A.GetTree(),0);
  cout<<"\nВысота дерева:"<<A.Height(A.GetTree())<<endl;
  cout<<"\nЛевосторонний обход дерева: ";
  A.ObhodLeft (A.GetTree());
  cout<<"\nКонцевой обход дерева: "; A.ObhodEnd (A.GetTree());
  cout<<"\nОбратный обход дерева: "; A.ObhodBack (A.GetTree());
  A.CleanTree (A.GetTree());

  cout << "\n";
  system("PAUSE");
}

void TREE::BuildTree ()
// Построение бинарного дерева (рекурсивный алгоритм).
// Tree - указатель на корень дерева.
{
  int el;

  cout<<"Вводите ключи вершин дерева ...\n";
  cin>>el;
  while  (el!=0)
  { Search (el,&Tree); cin>>el; }
}

void TREE::Search (int x,node **p)
//  Поиск вершины с ключом x в дереве со вставкой
//             (рекурсивный алгоритм).
// *p - указатель на корень дерева.
{
  if  (*p==NULL)
  {// Вершины в дереве нет; включить ее.
    *p = new(node);
    (**p).Key = x;     (**p).Count = 1;
    (**p).Left = NULL; (**p).Right = NULL; }
  else
    if  (x<(**p).Key) Search (x,&((**p).Left));
    else
      if  (x>(**p).Key) Search (x,&((**p).Right));
      else  (**p).Count = (**p).Count + 1;
}

void TREE::ObhodLeft (node **w)
//Левосторонний обход дерева.
//*w - указатель на корень дерева.
{
  if  (*w!=NULL)
  {
    cout<<(**w).Key<<" ";
    ObhodLeft (&((**w).Left));
    ObhodLeft (&((**w).Right));
  }
}

void TREE::ObhodEnd (node **w)
//Концевой обход дерева.
//*w - указатель на корень дерева.
{
  if  (*w!=NULL)
  { ObhodEnd (&((**w).Left));
    ObhodEnd (&((**w).Right));
    cout<<(**w).Key<<" "; }
}

void TREE::ObhodBack (node **w)
//Обратный обход дерева.
//*w - указатель на корень дерева.
{
  if  (*w!=NULL)
  { ObhodBack (&((**w).Left));
    cout<<(**w).Key<<" ";
    ObhodBack (&((**w).Right)); }
}

void TREE::CleanTree (node **w)
//Очистка дерева.
//*w - указатель на корень дерева.
{
  if  (*w!=NULL)
  { CleanTree (&((**w).Left));
    CleanTree (&((**w).Right));
    delete *w; }
}

void TREE::Vyvod (node **w,int l)
//Изображение дерева *w на экране дисплея
//          (рекурсивный алгоритм).
//*w - указатель на корень дерева.
{
  int i;

  if  (*w!=NULL)
  { Vyvod (&((**w).Right),l+1);
    for  (i=1; i<=l; i++) cout<<"   ";
    cout<<(**w).Key<<endl;
    Vyvod (&((**w).Left),l+1); }
}

int TREE::Height (node **w)
//Определение высоты бинарного дерева.
//*w - указатель на корень дерева.
{
  int h1,h2;
  if  (*w==NULL) return (-1);
  else
  {
    h1 = Height (&((**w).Left));
    h2 = Height (&((**w).Right));
    if  (h1>h2) return (1 + h1);
    else  return (1 + h2);
  }
}

Результат работы программы изображен на рисунке 1:


Рис.1. Результат работы приложения

На следующем шага мы рассмотрим нерекурсивные алгоритмы построения бинарного дерева.

        1.8. Построение бинарного дерева (нерекурсивный алгоритм)
На этом шаге мы рассмотрим нерекурсивный алгоритм построения бинарного дерева.
Рассмотрим нерекурсивный алгоритм построения бинарного дерева поиска, который заключается в циклическом обращении к функции TreeSearch (&Tree, el); где el - значение информационного поля включаемой в дерево Tree вершины. Эта функция осуществляет поиск вершины дерева с информационным полем el и в случае неудачного поиска осуществляет включение вершины с информационным полем el в дерево.
Опишем лишь начало этого процесса. Н.Вирт пишет: "Чтобы правильно привязать включаемую компоненту, мы должны иметь ссылку на ее предка и знать, включается она в качестве правого или левого поддерева. Для этого вводятся две переменные p2 и d (для направления). Используются две ссылки p1 и p2, такие, что в процессе поиска p2 всегда указывает на узел дерева, содержащий p1. Чтобы удовлетворить этому условию в начале поиска, вводится вспомогательный фиктивный элемент, на который указывает Tree. Начало действительного дерева поиска обозначается ссылкой (*Tree).Right."
Формализуем сказанное на языке C++:
    1) Создаем "заглавное звено" бинарного дерева:

    Tree = new(node);
    (*Tree).Right = NULL;
    p2 = Tree;
    p1 = (*p2).Right;


Рис.1. Создание "заглавного звена"

    2) При поступлении информационного элемента Элем1 первой вершины дерева выполняем следующие команды:

     p1 = new(node);
    (*p1).Key = Элем1; (*p1).Left = (*p1).Right = NULL;
    (*p1).Count = 1;

и получаем:


Рис.2. Размещение первой вершины дерева

    3) Далее, в зависимости от поступающего значения информационного поля следующей вершины дерева, структура, содержащая этот элемент, будет "помещаться" либо в правое поддерево (если значение информационного поля больше значения информационного поля корня), либо в левое поддерево (если наоборот), либо будет изменено только содержимое поля Count.

Запишем алгоритм построения в виде функции на языке C++:

void TreeSearch (node **Tree,int el)
// Поиск вершины с информационным полем el в дереве
// с последующим включением.
// *Tree - указатель на корень дерева.
{
  node *p1;
  node *p2; // Указатель p2 "опережает" указатель p1.
  int d; // Флаг для распознавания поддеревьев.

  p2 = *Tree; p1 = (*p2).Right;
  d = 1; // Флаг правого поддерева.
  while (p1!=NULL && d!=0)
  { p2 = p1;
    if (el<(*p1).Key) { p1 = (*p1).Left; d = -1; } //Флаг левого поддерева
    else
      if (el>(*p1).Key) { p1 = (*p1).Right; d = 1; }
      else d = 0; }
    if (d==0) (*p1).Count = (*p1).Count + 1;
    else
      { p1 = new(node);
        (*p1).Key = el; (*p1).Left = (*p1).Right = NULL; (*p1).Count = 1;
        if (d<0) (*p2).Left = p1; else (*p2).Right = p1;}
}

На следующем шаге мы рассмотрим нерекурсивный алгоритм вывода дерева на экран дисплея.

        1.9. Изображение бинарного дерева (нерекурсивный алгоритм)
На этом шаге мы рассмотрим нерекурсивные алгоритм изображения бинарного дерева.
Пусть бинарное дерево построено с помощью описанного на предыдущем шаге нерекурсивного алгоритма и определено указателем t.
Нам понадобятся два стека, которые мы реализуем на базе однонаправленных списков. Тип звеньев стека опишем так:

    struct no // Звено стека
    {
      no *sled; // Указатель на вершину.
      node *elem; // Информационное поле.
      int ch; // Уровень вершины.
    }

Изобразим схематично звено стека:


Рис.1. Звено стека

Опишем используемые переменные:

    no *stk;  // Стек "левых" ссылок.
    no *stk1; // Стек "правых" ссылок.
    node *u;  // Указатель на структуру.

Теперь приведем и сам алгоритм:

    stk = stk1 = NULL; // Первоначально оба стека пусты.
    n = 0;
    while (t!=NULL)
    {
      PushStack (&stk1,&t,&n);
      // Пока не достигнут лист дерева, в стек stk помещаются
      // левые ссылки тех структур, по которым перемещается
      // указатель t.
      if ((*t).Right!=NULL)
        { if ((*t).Left!=NULL) PushStack (&stk,&(*t).Left,&n); t = (*t).Right;}
      else {
        // Как только будет достигнут самый правый лист, проверяем левую
        //ссылку. Если она существует, то из стека правых ссылок удаляем
        //последний  адрес, и на печать выводим поле ключа этой вершины.
        if ((*t).Left!=NULL)
        { if (stk1!=NULL)
          { PopStack (&stk1,&u,&n);
            for (i=0; i<=n; i++) cout<<" ";
              cout<<(*u).Key<<endl; }
            t = (*t).Left; }
        if (stk==NULL) t = NULL;
        else {
          // Если у вершины дерева указатели на правое и
          // левое поддеревья равны NULL, а стек левых
          // указателей не пуст, то...
          while ((*stk).elem!=(*((*stk1).elem)).Left)
            { // Удаляется адрес из стека правых ссылок
              //и на печать выводится значение поля ключа
              //вершины с данным адресом
               PopStack (&stk1,&u,&n);
               for (i=0; i<=n; i++) cout<<" ";
                 cout<<(*u).Key<<endl; }
               // Как только выполнится условие
               //((*stk).elem==(*((*stk1).elem)).Left), удаля-
               //ются адреса из обоих стеков, а поле ключа
               //также выводится на экран дисплея.
               PopStack (&stk1,&u,&n);
               for (i=0; i<=n; i++) cout<<" ";
                 cout<<(*u).Key<<endl;
               PopStack (&stk,&t,&n); }
            }
           n = n + 1;
        }
    VyvodStack (&stk1);

Оформим алгоритм в виде функции на языке C++:

void VyvodTree (node *t)
// Изображение дерева, заданного указателем t,
// на экране дисплея (нерекурсивный алгоритм).
{
  no *stk, *stk1;
  node *u;
  int i,n;
  stk = stk1 = NULL; n = 0;
  while (t!=NULL)
  { PushStack (&stk1,&t,&n);
    if ((*t).Right!=NULL)
    {    if ((*t).Left!=NULL)
        PushStack (&stk,&((*t).Left),&n);
        t = (*t).Right; }
    else {
      if ((*t).Left!=NULL)
        { if (stk1!=NULL)
          { PopStack (&stk1,&u,&n);
             for (i=0; i<=n; i++) cout<<" ";
                 cout<<(*u).Key<<endl; }
             t = (*t).Left; }
          else
            if (stk==NULL) t = NULL;
            else
              { while ((*stk).elem!=(*((*stk1).elem)).Left)
                  { PopStack (&stk1,&u,&n);
                     for (i=0; i<=n; i++) cout<<" ";
                       cout<<(*u).Key<<endl;
                  }
                 PopStack (&stk1,&u,&n);
                 for (i=0; i<=n; i++) cout<<" ";
                    cout<< (*u).Key<endl;
                 PopStack (&stk,&t,&n);
              }
        }
      n = n + 1;
    }
  VyvodStack (&stk1);
}

На следующем шаге мы приведем пример построения и изображения бинарного дерева с помощью нерекурсивных алгоритмов.

        1.10. Пример программы построения и изображения бинарного дерева (нерекурсивные алгоритмы)
На этом шаге мы приведем пример программы построения и изображения бинарного дерева с использованием нерекурсивных алгоритмов.

Пример. Нерекурсивное построение бинарного дерева и его изображение на экране дисплея.

#include <iostream>
using namespace std;

struct node
{
  int Key;
  int Count;
  node  *Left;
  node *Right;
};

struct no // Звено стека
{
  node *elem; // Информационное поле.
  int ch; // Уровень вершины.
  no *sled; // Указатель на вершину.
};

class TREE
{
  private:
    node *Tree;
    void PushStack (no **,node **,int *);// Помещение звена с элементами *el и n в
                                         // стек. *stk - указатель на стек.
    void PopStack (no**,node **,int *); // Извлечение из стека звена
                                        // с элементами *t и n.
                                        // *stk - указатель на стек
    void VyvodStack (no**); // Вывод содержимого стека на экран дисплея.
                            // *stk - указатель на стек.

  public:
    TREE () { Tree = new(node); (*Tree).Right = NULL; }
    node* GetTreeRight () {return (*Tree).Right;}
    void  TreeSearch (int); // Поиск вершины с информационным полем  el в дереве с
                            // последующим (в случае неудачного поиска!) включением
                            // в дерево. Tree - указатель на корень дерева.

    void  VyvodTree (node *); //Построение дерева, заданного указателем t,
                              //на экране дисплея (нерекурсивный алгоритм).

};

void main ()
{
  setlocale(LC_ALL,"Rus");

  TREE A;
  int el;

  cout<<"Вводите значения информационных полей вершин: "<<endl;
  cin>>el;
  while  (el!=0)
   { A.TreeSearch (el); cin>>el; }
  A.VyvodTree (A.GetTreeRight());

  cout << "\n";
  system("PAUSE");
}

void TREE::TreeSearch (int el)
// Поиск вершины с информационным полем  el в дереве с
// последующим (в случае неудачного поиска!) включением
// в дерево. Tree - указатель на корень дерева.
{
  node *p1,*p2;
  int  d;

  p2 = Tree; p1 = (*p2).Right; d = 1;
  while  (p1!=NULL && d!=0)
  {
    p2 = p1;
    if  (el<(*p1).Key) {p1 = (*p1).Left; d = -1;}
    else
      if  (el>(*p1).Key) {p1 = (*p1).Right; d = 1;}
      else  d = 0;
  }
  if  (d==0)  (*p1).Count = (*p1).Count + 1;
  else
  {
    p1 = new(node);
    (*p1).Key = el;  (*p1).Left = NULL;
    (*p1).Right = NULL;  (*p1).Count = 1;
    if  (d<0) (*p2).Left = p1;
    else  (*p2).Right = p1;
  }
}


void TREE::VyvodTree (node *t)
 //Построение дерева, заданного указателем t,
 //на экране дисплея (нерекурсивный алгоритм).
{
  no *stk,*stk1;
  node *u;
  int i,n;
  stk = stk1 = NULL; n = 0;
  while  (t!=NULL)
  {
    PushStack (&stk1,&t,&n);
    if  ((*t).Right!=NULL)
    {
      if  ((*t).Left!=NULL) PushStack (&stk,&((*t).Left),&n);
      t = (*t).Right;
    }
    else
    {
      if  ((*t).Left!=NULL)
      {
        if  (stk1!=NULL)
        {
          PopStack (&stk1,&u,&n);
          for  (i=0; i<=n; i++) cout<<" ";
          cout<<(*u).Key<<endl;
        }
        t = (*t).Left;
      }
      else
       if  (stk==NULL) t = NULL;
       else
       {
         while  ((*stk).elem!=(*((*stk1).elem)).Left)
         {
           PopStack (&stk1,&u,&n);
           for  (i=0; i<=n; i++) cout<<" ";
           cout<<(*u).Key<<endl;
         }
         PopStack (&stk1,&u,&n);
         for  (i=0; i<=n; i++) cout<<" ";
         cout<<(*u).Key<<endl;
         PopStack (&stk,&t,&n);
       }
    }
    n = n + 1;
  }
  VyvodStack (&stk1);
}


void TREE::PushStack (no **stk,node **el,int *n)
 // Помещение звена с элементами *el и n в стек.
 // *stk - указатель на стек.
{
  no *q;

  q = new(no);
  (*q).elem = *el;  (*q).ch = *n;
  (*q).sled = *stk; *stk = q;
}

void TREE::PopStack (no**stk,node **t,int *n)
// Извлечение из стека звена с элементами *t и n.
// *stk - указатель на стек.
{
  no *q;

  if  (*stk!=NULL)
  {
    *t = (**stk).elem;
    *n = (**stk).ch;
    q  = *stk;
    *stk = (**stk).sled;
    delete q;
  }
}

void TREE::VyvodStack (no** stk)
// Вывод содержимого стека на экран дисплея.
// *stk - указатель на стек.
{
  node *k;
  int i,n;

  while  (*stk!=NULL)
  {
    k = (**stk).elem; n = (**stk).ch;
    for  (i=0; i<=n; i++) cout<<" ";
      cout<<(*k).Key<<endl;
    *stk = (**stk).sled;
  }
}



Со следующего шага мы начнем рассматривать основные операции над бинарными деревьями.

        1.11. Поиск вершины в бинарном дереве (нерекурсивный и рекурсивный)
На этом шаге мы приведем тексты функций, осуществляющих поиск заданной вершины в дереве.

Нерекурсивный поиск проводится следующим образом:

#define TRUE 1
#define FALSE 0
void Poisk (int k, node **Tree, node **Res)
// Поиск вершины с ключом k в дереве (нерекурсивный алгоритм).
// *Tree - указатель на вершину дерева.
// *Res - указатель на найденную вершину
// или на лист, если вершины в дереве нет.
// B - глобальная булевская переменная:
// TRUE, если вершина с ключом k в дереве найдена,
// FALSE, в противном случае.
{
  node *p, *q;

  B = FALSE; p = q = *Tree;
  if (*Tree!=NULL)
  do {
    q = p;
    if ((*p).Key==k) B = TRUE;
    else
    { q = p;
      if (k<(*p).Key) p = (*p).Left;
      else p = (*p).Right; }
  } while (!B && p!=NULL);
  *Res = q;
}

а рекурсивный - так:

node Poisk_1 (int k, node** Tree)
// Поиск вершины с ключом k в дереве  (рекурсивный алгоритм).
// *Tree - указатель на вершину дерева.
// Функция возвращает указатель на вершину,
// содержащую ключ k.
{
  if (*Tree==NULL) return (NULL);
  else
    if ((**Tree).Key==k) return (*Tree);
    else {
      if (k<(**Tree).Key) return Poisk_1 (k,&((**Tree).Left));
      else return Poisk_1 (k,&((**Tree).Right));
    }
}

На следующем шаге мы приведем алгоритм добавления вершины в дерево.

        1.12. Добавление вершины в бинарное дерево
На этом шаге мы рассмотрим алгоритм добавления вершины в дерево.
Перед добавлением вершины в дерево обращаемся к функции Poisk (k, Tree, &r);. Если значение глобальной переменной B, которое вернула функция Poisk, равен FALSE (в дереве нет ключа, равного вновь поступающему), то вершина, после которой будет осуществляться добавление, является листом. Указатель на этот лист хранится в переменной r.
В heap-области резервируем место для динамического объекта:

    s = new(node); (*s).Key = Элем; (*s).Count = 1;
    (*s).Left = (*s).Right = NULL;

и "подвешиваем" вершину:

    *Tree = s;

Иначе, если вершина, после которой будем прикреплять новую, не является листом дерева, то перед "подвешиванием" определяем, в какое поддерево относительно этой вершины будет включена новая:

    if (k<(*r).Key) (*r).Left = s;
    else (*r).Right = s;

Приведем текст функции добавления:

void Addition (node **Tree, int k)
// Добавление вершины k в бинарное дерево.
// *Tree - указатель на вершину дерева.
// B - глобальная булевская переменная:
// TRUE, если вершина с ключом k в дереве найдена,
// FALSE, в противном случае.
{
  node *r, *s;

  Poisk (k,Tree,&r);
  if (!B)
  {
    s = new(node);
    (*s).Key = k; (*s).Count = 1;
    (*s).Left = (*s).Right = NULL;
    if (*Tree==NULL) *Tree = s;
    else
      if (k<(*r).Key) (*r).Left = s;
      else (*r).Right = s;
  }
  else (*r).Count += 1;
}

На следующем шаге мы рассмотрим удаление вершины из дерева.

        1.13. Удаление вершины из бинарного дерева
На этом шаге мы рассмотрим алгоритм удаления вершины из дерева.
Алгоритм удаления из бинарного дерева вершины с заданным ключом различает три случая:
    • вершины с заданным ключом в дереве нет;
    • вершина с заданным ключом имеет не более одной исходящей дуги;
    • вершина с заданным ключом имеет две исходящие дуги.

Н.Вирт отмечает: "Трудность заключается в удалении элементов с двумя потомками, поскольку мы не можем указать одной ссылкой на два направления. В этом случае удаляемый элемент нужно заменить либо на самый правый элемент его левого поддерева, либо на самый левый элемент его правого поддерева. Ясно, что такие элементы не могут иметь более одного потомка. Подробно это показано в рекурсивной процедуре, называемой Delete()..."

void Delete (node **Tree, int k)
// Удаление вершины k из бинарного дерева.
// *Tree - указатель на вершину дерева.
{
  node *q;

  if (*Tree==NULL) cout << "Вершина с заданным ключом не найдена!\n";
  else
    if (k<(**Tree).Key) Delete (&((**Tree).Left),k);
    else
      if (k>(**Tree).Key) Delete (&((**Tree).Right),k);
      else  {
          q = *Tree;
          if ((*q).Right==NULL) { *Tree = (*q).Left; delete q; }
          else
            if ((*q).Left==NULL) { *Tree = (*q).Right; delete q;}
            else Delete_1 (&((*q).Left),&q); // вершина с заданным ключом имеет две исходящие дуги
      }
}

"Вспомогательная рекурсивная процедура Delete_1() вызывается только в 3-м случае. Она "спускается" вдоль самой правой ветви левого поддерева удаляемого узла q и затем заменяет существенную информацию (ключ и счетчик) в q соответствующими значениями самой правой компоненты r этого левого поддерева, после чего от r можно освободиться..." (Н.Вирт). Освобождение памяти, занятой динамической переменной, происходит при помощи конструкции delete.

void Delete_1 (node **r, node **q)
{
//*q указатель на удаляемый узел
//*r указатель правой компоненты левого поддерева
//вызывается только в случае если вершина с заданным ключом имеет две исходящие дуги
//спускается вдоль самой правой ветви левого поддерева удаляемого узла q
//затем заменяет существенную информацию (ключ и счетчик) в q
//соответствующими значениями самой правой компоненты r этого левого поддерева
//после чего от r можно освободиться
  node *s;

  if ((**r).Right==NULL)
    { (**q).Key = (**r).Key; (**q).Count = (**r).Count;*q = *r;
      s = *r; *r = (**r).Left; delete s; }
  else Delete_1 (&((**r).Right),q);
}

Приведем пример программы, иллюстрирующей поиск заданной вершины в дереве, добавление вершины в дерево, удаление вершины из дерева.

#include <iostream>
using namespace std;

#define TRUE 1
#define FALSE 0
struct  node
{
  int Key;
  int Count;
  node *Left;
  node *Right;
};

class TREE
{
  private:
    node *Tree;//Указатель на корень дерева.
    node  *Res;//Указатель на найденную вершину.
    int B; //Признак нахождения вершины в дереве.
    //Поиск вершины в дереве (рекурсивный алгоритм).
    void Search (int, node**); //Поиск звена x в бинарном дереве
    //вершина с заданным ключом имеет две исходящие дуги
    void Delete_1 (node**, node**);
  public:
    TREE() { Tree = NULL;}
    node** GetTree() {return &Tree;}
    void  BuildTree ();//Построение бинарного дерева.
    //Вывод дерева на экран (рекурсивный алгоритм).
    void Vyvod (node**,int);
    //Поиск вершины в дереве (нерекурсивный алгоритм).
    int Poisk (int);
    //Поиск вершины в дереве (рекурсивный алгоритм).
    node *Poisk_1 (int,node **);
    //Добавление вершины в дерево (нерекурсивный алгоритм).
    void Addition (int);
    // Удаление вершины из дерева.
    void Delete (node**, int);
};

void main ()
{
  setlocale(LC_ALL,"Rus");
  TREE A;
  int el;

  A.BuildTree ();  A.Vyvod (A.GetTree(),0);

  cout<<"Введите ключ вершины, которую нужно найти в дереве: ";
  cin>>el;
  if  (A.Poisk (el)) cout<<"В дереве есть такая вершина!\n";
  else  cout<<"В дереве нет такой вершины!\n";
  cout<<"Введите ключ вершины, которую нужно найти в дереве: ";
  cin>>el;
  if  (A.Poisk_1 (el,A.GetTree())!=NULL)
    cout<<"В дереве есть такая вершина!\n";
  else  cout<<"В дереве нет такой вершины!\n";

  cout<<"Введите ключ добавляемой вершины: ";
  cin>>el;
  A.Addition (el);  A.Vyvod (A.GetTree(),0);

  cout<<"Введите ключ удаляемой вершины: "; cin>>el;
  A.Delete (A.GetTree(),el);  A.Vyvod (A.GetTree(),0);

  cout << "\n";
  system("PAUSE");
}

void TREE::BuildTree ()
//Построение бинарного дерева.
//Tree - указатель на вершину дерева.
{
  int el;

  cout<<"Вводите ключи вершин дерева: \n";
  cin>>el;
  while  (el!=0)
    { Search (el,&Tree);cin>>el; }
}

void TREE::Vyvod (node **w,int l)
//Изображение дерева w на экране дисплея
//         (рекурсивный алгоритм).
//*w - указатель на корень дерева.
{
  int i;

  if  (*w!=NULL)
  {
    Vyvod (&((**w).Right),l+1);
    for  (i=1; i<=l; i++) cout<<"   ";
    cout<<(**w).Key<<endl;
    Vyvod (&((**w).Left),l+1);
  }
}


void TREE::Search (int x,node **p)
//Поиск звена x в бинарном дереве со вставкой
//            (рекурсивный алгоритм).
//*p - указатель на вершину дерева.
{
  if  (*p==NULL)
  { // Вершины в дереве нет; включить ее.
    *p = new(node);
    (**p).Key = x;     (**p).Count = 1;
    (**p).Left = (**p).Right = NULL;
  }
  else
  if  (x<(**p).Key) Search (x,&((**p).Left));
  else
    if  (x>(**p).Key) Search (x,&((**p).Right));
    else  (**p).Count += 1;
}

void TREE::Addition (int k)
// Поиск звена k в бинарном дереве со вставкой
//         (нерекурсивный алгоритм).
// Tree - указатель на вершину дерева.
{
  node *s;

  Poisk (k);
  if  (!B)
  {
    s = new(node);
    (*s).Key  = k;    (*s).Count = 1;
    (*s).Left = (*s).Right = NULL;
    if  (Tree==NULL) Tree = s;
    else
      if  (k<(*Res).Key) (*Res).Left = s;
      else  (*Res).Right = s;
  }
  else  (*Res).Count += 1;
}

int TREE::Poisk (int k)
// Поиск вершины с ключом k в дереве
//      (нерекурсивный алгоритм).
// Tree - указатель на бинарное дерево.
// Res  - указатель на найденную вершину
// или на лист, к которому можно присоединить новую вершину.
{
  node *p,*q;

  B = FALSE; p = Tree;
  if  (Tree!=NULL)
  do
  {
    q = p;
    if  ((*p).Key==k) B = TRUE;
    else
      {
       q = p;
       if  (k<(*p).Key) p = (*p).Left;
       else  p = (*p).Right;
      }
  } while  (!B && p!=NULL);
  Res = q;
  return B;
}

node *TREE::Poisk_1 (int k,node **p)
// Поиск вершины с ключом k в дереве
//        (рекурсивный алгоритм).
// *p - указатель на корень дерева.
{
  if  (*p==NULL) return (NULL);
  else
	 if  ((**p).Key==k) return (*p);
	 else
           if  (k<(**p).Key) return Poisk_1 (k,&((**p).Left));
           else return Poisk_1 (k,&((**p).Right));
}

void TREE::Delete (node **p,int k)
// Удаление вершины k из бинарного дерева.
// *p - указатель на корень дерева.
{
  node *q;

  if  (*p==NULL) cout<<"Вершина с заданным ключом не найдена!\n";
  else
	 if  (k<(**p).Key) Delete (&((**p).Left),k);
	 else
		if  (k>(**p).Key) Delete (&((**p).Right),k);
		else
		{
                    q = *p;
                    if  ((*q).Right==NULL) {*p = (*q).Left; delete q;}
                    else
                     if  ((*q).Left==NULL) { *p = (*q).Right; delete q; }
                     else  Delete_1 (&((*q).Left),&q);
		}
}

void TREE::Delete_1 (node **r,node **q)
{
  node *s;

  if  ((**r).Right==NULL)
  {
    (**q).Key = (**r).Key; (**q).Count = (**r).Count;
    *q = *r;
    s = *r; *r = (**r).Left; delete s;
  }
  else  Delete_1 (&((**r).Right), q);
}



На следующем шаге мы организуем хэшиpование с помощью леса.

        1.14. Деревья минимальной высоты
Для большинства практических задач наиболее интересны такие деревья, которые имеют минимально возможную высоту при заданном количестве вершин n. Очевидно, что минимальная высота достигается тогда, когда на каждом уровне (кроме, возможно, последнего) будет максимально возможное число вершин.
Предположим, что задано n чисел (их количество заранее известно). Требуется построить из них дерево минимальной высоты. Алгоритм решения этой задачи предельно прост.
    • Взять одну вершину в качестве корня и записать в нее первое нерассмотренное число.
    • Построить этим же способом левое поддерево из n1 = n/2 вершин (деление нацело!).
    • Построить этим же способом правое поддерево из n2 = n-n1-1 вершин.

Заметим, что по построению левое поддерево всегда будет содержать столько же вершин, сколько правое поддерево, или на 1 больше. Для массива данных

21, 8, 9, 11, 15, 19, 20, 21, 7



по этому алгоритму строится дерево, показанное на рисунке.
Вершина дерева, как и узел любой динамической структуры, имеет две группы данных: полезную информацию и ссылки на узлы, связанные с ним. Для двоичного дерева таких ссылок будет две – ссылка на левого сына и ссылка на правого сына. В результате получаем структуру, описывающую вершину (предполагая, что полезными данными для каждой вершины является одно целое число):

struct Node
{
	int key; //полезные данные (ключ)
	Node  *left, *right; //указатели на сыновей
};
typedef Node *PNode; // указатель на вершину

Как будет выглядеть эта программа на языке Си? Надо сначала разобраться, что означает «взять одну вершину в качестве корня и записать туда первое нерассмотренное число». Поскольку вершины должны создаваться динамически, надо выделить память под вершину и записать в поле данных нужное число. Затем из оставшихся чисел построить левое и правое поддеревья.
В основной программе нам надо объявить указатель на корень нового дерева, задать массив данных (в принципе можно читать данные из файла) и вызвать функцию, возвращающую указатель на построенное дерево.

int data[] = {21, 8, 9, 11, 15, 19, 20, 21, 7};
PNode Tree; //указатель на корень дерева
n = sizeof(data) / sizeof(int) - 1; //размер массива
Tree = MakeTree (data, 0, n); //использовать n элементов,
// начиная с номера 0

Сама функция MakeTree принимает три параметра: массив данных, номер первого неиспользованного элемента и количество элементов в новом дереве. Возвращает она указатель на новое дерево (типа PNode).

PNode MakeTree (int data[], int from, int n)
{
	PNode Tree;
	int n1, n2;
	if(n == 0)
		return NULL; //ограничение рекурсии
	Tree = new Node; //выделить память под вершину
	Tree->key = data[from]; //записать данные (ключ)
	n1 = n / 2; //размеры поддеревьев
	n2 = n - n1 - 1;
	Tree->left = MakeTree(data, from+1, n1);
	Tree->right = MakeTree(data, from+1+n1, n2);
	return Tree;
}

Выделенные строчки программы содержат рекурсивные вызовы. При этом левое поддерево содержит n1 элементов массива начиная с номера from+1, тогда как правое – n2 элементов начиная с номера from+1+n1.

        1.15. Хэшиpование с помощью леса
На этом шаге мы рассмотрим создание хеш-массивов с помощью деревьев.

Понятие хэширования и что оно дает.
Хэширование представляет интерес только для программистов (и, возможно, математиков).
Хэширование - это процесс, в котором вы подаёте на вход некоторого хэширующего алгоритма некоторые достаточно большие по объёму данные (допустим миллион байт) и получаете на выходе относительно короткую (допустим 32 байта), но при этом достаточно уникальную строку, которая позволяет отличить эти ваши данные (что были на входе) от каких-то других данных. Эта строка называется "хэш".
Хэш используется для того, чтобы быстрее отличать одни данные от других без необходимости сравнивать каждый-каждый бит этих данных. Достаточно обработать эти данные один раз (вычислить их хэши) и можно сравнивать только их, а это гораздо быстрее. Идея такая. Если хэши различаются, значит, это совершенно точно разные данные. Если хэши одинаковы, значит, с вероятностью в 99,99999... (и ещё 70 девяток, если предположить идеальное распределение 256-битных хэшей), это одинаковые данные. Хотя всегда существует маленький шанс, что данные всё-таки разные, несмотря на одинаковые хэши.
Хэширующий алгоритм (хэш-функция) должен стремиться как можно лучше выполнять следующие требования:
1. Одни и те же данные должны давать всегда один и тот же хэш. Это обязательное условие.
2. Разные данные должны давать разный хэш. Это условие не может быть выполнено полностью (понятно, что миллион байт нельзя магическим образом уменьшить до 30, на то он и миллион), но нужно стремиться к тому, чтобы выполнить его как можно лучше.

Хорошая хэш-функция ведёт себя следующим образом:
1. Весь доступный диапазон хэшей используется по максимуму. То есть, если на хэш отведено 32 байта, то разные данные дают максимально разнообразный хэш, который может являться совершенно любой комбинацией битов. То есть, диапазон хэшей не "простаивает".
2. Даже небольшое изменение входных данных (даже изменение 1 бита входных данных) должно давать другой хэш. Не должно быть такого, что небольшие изменения дают тот же самый хэш. Тот же самый хэш должен возникать в результате какого-то совершенно другого набора данных, чтобы вероятность случайного присутствия двух таких данных (дающих одинаковый хэш) была минимальной.

Для чего нужен хэш. Допустим, у вас есть массив из миллиона разных (неодинаковых) строк. В каждой строке миллион символов (то есть, всего у вас 1 терабайт = 1000 гигабайт данных). Вам приходит такое указание: добавьте строку, которая содержит "тото-сёто-пятое-десятое-и-ещё-миллион-символов", в ваш массив, но только в том случае, если такой строки там ещё нет. Без быстрого поиска здесь не обойтись.
В итоге, ваша задача превращается в посимвольное сравнение миллиона символов в миллионах строк. Очень хорошо, если начала строк у вас разные и вы сможете быстро отсеивать неподходящие строки. Но если все строки содержат примерно одинаковый текст, то вам нужно провернуть гигантское количество работы.
Но если перед записью вы имеете (вычислили их ранее) хэши эти строк, то ваша задача превращается в сравнение 32 символов вместо миллиона символов (32 мегабайта данных на весь массив). Если вы обнаружили, что у вас в списке есть точно такой же хэш, то для полной надёжности, вы можете сравнить посимвольно только эту строку. Гораздо меньше затрат, чем проверять терабайт целиком, не так ли? (На самом деле, даже 32 мегабайта хэшей проверять не потребуется, поскольку по теории вероятностей, лишь 1-2 первых символа хэшей будут совпадать, да и то очень редко, а 3 одинаковых символа подряд, возможно, не найдутся во всём миллионе хэшей. И это при том, что изначальные данные могли быть очень похожими.)
Хэш также может использоваться для проверки целостности данных при передаче. Вы передали гигабайт данных. А затем передали 32-байтный хэш. Получатель на своей стороне захешировал этот гигабайт тем же способом (той же хэш-функцией) и получил тот же самый хэш. Теперь он уверен, что он имеет точно те же данные, что и отправитель (вероятность случайной ошибки примерно около 1e-70, поэтому ей можно пренебречь; на самом деле, вероятность, скорее всего, ещё меньше, потому что хорошая хэш-функция не даст такой же хэш на похожих данных).
На практике некоторые хэш-функции также используются для шифрования. Хотя шифрование не является хэшированием, некоторые хэш-функции для этого хорошо подходят. Благодаря практически полностью хаотичному соответствию хэшей исходным данным, практически невозможно подобрать ключ, изучая закономерности в последовательностях данных.

В моногpафии [Вирт H. Алгоритмы + структуры данных = программы. - М.: Мир, 1985. - 406 с.,с.317] есть упpажнение, котоpое звучит так:
"Рассмотpите пpедложения о pешении пpоблемы скопления с помощью деpевьев пеpеполнения вместо списков пеpеполнения, т.е. оpганизации тех ключей, котоpые вступают в конфликт, в виде деpева. Следовательно, каждый вход в pассеянную таблицу можно pассматpивать как коpень (возможно, пустого) деpева (дpевовидная pасстановка)".
Вначале схематически изобpазим стpуктуpу данных:


Рис.1. Структура данных

где Деpево1, Деpево2, ..., ДеpевоN - бинаpные деpевья поиска, а затем постpоим пpогpамму для pазpешения поставленной пpоблемы.

#include <time.h>
#include <iostream>
using namespace std;

#define N 10 //Количество элементов массива.
struct node
{
	int Key;
	int Count;
	node *Left;
	node *Right;
};

class Spisok {
  private:
	 node *UkStr[N];
	 void Search (int, node**);
	 void PrintTree (node *, int);
	 void U_d (node **,node **);
  public:
	 Spisok ();
	 void BuildTree();
	 void Sodergimoe();
	 node** GetTree (unsigned i) {return &(UkStr[i]);}
	 void Udaldr (node** d, int k);
};

Spisok::Spisok()
{
  //Инициализация хэш-списка.
  for (int i=0;i<N;i++) UkStr[i] = NULL;
}

void Spisok::BuildTree()
{
  int klutch;
  unsigned hash;

  srand( time( 0 ) );
  // автоматическая рандомизация
  cout << "\nВведите значение ключа...";
  //cin >> klutch;
  //Закомментируйте следующие три строки,
  //если нужно задавать значения ключей с клавиатуры.
  //randomize();
  //klutch = random(31);
  klutch = rand() % 31 + 0; // диапазон равен от 0 до 31 включительно
  cout << klutch;
  while (klutch!=0)
  {
	 hash = klutch % 10;  //Вычисление значения хэш-функции.
	 Search (klutch,&UkStr[hash]);
	 cout << "\nВведите значение ключа...";
	 //cin >> klutch;
	 //klutch = random(31);
     klutch = rand() % 31 + 0; // диапазон равен от 0 до 31 включительно
	 cout << klutch;
  }
}

void Spisok::Search(int X, node **p)
{
  if  (*p==NULL)
   { //Узла нет в деpеве; включить его.
     *p = new (node);
     (**p).Key = X;
     (**p).Count = 1;
     (**p).Left = (**p).Right = NULL;
   }
  else
	if  (X<(**p).Key) Search (X, &((**p).Left));
	else  if  (X > (**p).Key)  Search (X, &((**p).Right));
              else  (**p).Count += 1;
}

void Spisok::Sodergimoe()
{
  for(int i=0;i<N;i++)
  {
	 cout << "  "<< i <<"...  ";
	 if  (UkStr[i]==NULL)  cout << "Деpево пусто...\n";
	 else
	 {
            cout << endl;
            PrintTree (UkStr[i],0);
	 }
	 cout << "------------------------------------------" << endl;
  }
}

void Spisok::PrintTree (node *w, int l)
{
  if  (w!=NULL)
  {
	 PrintTree ((*w).Right,l+1);
	 cout << "          ";
	 for (int i=1;i<=l;i++) cout <<"   ";
	 cout << (*w).Key << endl;
	 PrintTree ((*w).Left,l+1);
  }
}

void Spisok::Udaldr (node** d, int k)
{ //Удаление узла с ключом k из деpева d.
  node** q;

  if (*d==NULL) cout << "Узел с заданным ключом в деpеве не найден...\n";
  else
	if  (k < (**d).Key) Udaldr (&((**d).Left),k);
	else
     if  (k > (**d).Key)  Udaldr (&((**d).Right),k);
     else 
      {
        q = d;
        if ((**q).Right == NULL) *d = (**q).Left;
        else
          if  ((**q).Left == NULL )  *d = (**q).Right;
          else  U_d (&((**q).Left),&(*q));
      }
}

void Spisok::U_d(node **r, node **q)
{
  if  ((**r).Right == NULL)
  {
    (**q).Key = (**r).Key;
    (**q).Count = (**r).Count;
    q = r; *r = (**r).Left; delete (*q);
  }
  else  U_d (&((**r).Right),&(*q));
}

void main()
{
  setlocale(LC_ALL,"Rus");
  Spisok A;
  int klutch;
  unsigned hash;

  A.BuildTree();
  cout << "\n          Содеpжимое хэш-списка...";
  cout << "\n    -----------------------------------\n";
  A.Sodergimoe();
  //Удаление элемента из хэш-списка.
  for (int i=0;i<4;i++) //Будем удалять всего 4 pаза!
  {
    cout << "\nВведите значение удаляемого ключа...";
    cin >> klutch;
    hash = klutch % 10;
    A.Udaldr (A.GetTree(hash),klutch);
    cout << "          Содеpжимое хэш-списка...\n";
    cout << "   ----------------------------------\n";
    A.Sodergimoe();
  }

  cout << "\n";
  system("PAUSE");
}



Замечание. Дополнительную информацию о хэш-массивах можно получить в разделах по языкам программирования Perl (шаг 10) и LISP (шаг 68).

На следующем шаге мы рассмотрим использование древовидно-кольцевой динамической структуры данных.

        1.16. Дpевовидно-кольцевая динамическая стpуктуpа данных
На этом шаге мы рассмотрим совместное использование древовидной и кольцевой структур данных.
Используя постpоенные pанее пpоцедуpы для pаботы с дpевовидными стpуктуpами данных, можно построить стpуктуpу данных, пpедставляющую собой совокупность кольцевой и дpевовидной стpуктуp. Указатели на коpни дpевовидной стpуктуpы pасположены в звеньях кольца. Само кольцо пpедставим с помощью однонапpавленного списка без заглавного звена:


Рис.1. Древовидно-кольцевая структура данных

Вначале займемся описанием данной стpуктуpы данных:

//Опишем деpевья..
struct node
{
    int key;
    int count;
    node *Left;
    node *Right;
};

//Тепеpь настала очеpедь кольца...
struct zveno
{
  int element;
  Tree ukTree;
  zveno* sled;
};

а лишь затем пpогpаммиpованием:

#include <conio.h>
#include <iostream>
using namespace std;

struct node
{
	int key;
	int count;
	node *Left;
	node *Right;
};
class Tree
{
  private:
   node* root; //Корень дерева.
   void  DisposeTree (node *);
   void  printTree (node*, int);
   void  Delete (node**, int);
   void  del (node**, node *);
  public:
   Tree() { root = NULL; };
   ~Tree();
   void creat_Tree();
   void look_Tree();
   void add_Tree();
   void delete_Tree();
   void search (int, node **);
   node*  getTree() {return root;};
};

struct zveno
{
  int element;
  Tree ukTree;
  zveno* sled;
};

class ring
{
  private:
    zveno* ukring;
  public:
    ring() { ukring = NULL; };
    ~ring();
    void create(); //Построение кольца
    void look(); //Вывод кольца
    void add_after(int, zveno *);
    void add_befor(int, zveno *);
    void Delete (zveno *);
    void delete_next (zveno *);
    int poisk (int, zveno**);
    zveno** getring() { return &ukring;};
};

void ring::create() //Построение кольца.
{
  zveno* ukzv;
  int elem;

  cout << "\nПостроение кольца ..." << endl;
  cout << "Вводите элементы кольца (ввод окончите 0): \n";
  cout << "-->";
  cin >> elem;
  if (elem!=0)
  {
    ukzv = ukring = new (zveno);
    (*ukzv).element = elem;
    (*ukzv).ukTree.creat_Tree();
    cout << "\n-->";
    cin >> elem;
    while  (elem!=0)
    {
      (*ukzv).sled = new (zveno);
      ukzv = (*ukzv).sled;
      (*ukzv).element = elem;
      (*ukzv).ukTree.creat_Tree();
      cout << "\n-->";
      cin >> elem;
   }
   ukzv->sled = ukring;
  }
}

ring::~ring()
{
  zveno* ukzv;

  ukzv = ukring;
  while (ukring!=NULL)
    if  (ukzv->sled == ukring)
    { ukring = NULL;
      ukzv->ukTree.~Tree();
      delete ukzv;
    }
    else
    {
     while  (ukzv->sled->sled!=ukring)  ukzv = (*ukzv).sled;
     (*ukzv).sled->ukTree.~Tree();
     delete (*ukzv).sled;
     ukzv->sled = ukring;
     ukzv = ukring;
    }
}

void ring::look() //Вывод кольца.
{
  zveno* ukzv;

  cout << "\nВывод содержимого кольца ...";
  ukzv = ukring;
  do {
    cout << "\n-->" << (*ukzv).element << endl;
    ukzv->ukTree.look_Tree();
    ukzv = ukzv->sled;
    getch();
  } while (ukzv!=ukring);
  cout << endl;
}

void ring::add_befor (int elem, zveno *zv)
{
  zveno* ukzv;
  Tree temp;

  ukzv = new (zveno);

  temp = ukzv->ukTree;
  ukzv->element = zv->element;
  ukzv->ukTree = zv->ukTree;
  ukzv->sled = zv->sled;

  zv->element = elem;
  zv->ukTree = temp;
  zv->ukTree.creat_Tree();
  zv->sled = ukzv;
}

void ring::add_after (int elem, zveno* zv)
{
  zveno* ukzv;

  ukzv = new (zveno);
  ukzv->element = elem;
  ukzv->ukTree.creat_Tree();
  ukzv->sled = zv->sled;
  zv->sled = ukzv;
}

void ring::Delete (zveno* zv)
{
  zveno* ukzv1,*ukzv2;
  zveno* time;

  if  (zv->sled!=ukring)
  {
    time = zv->sled;
    zv->ukTree.~Tree();
    (*zv) = *((*zv).sled);
    delete time;
  }
  else
    if  (zv->sled==zv)
    {
      zv->ukTree.~Tree();
      delete ukring;
      ukring = NULL;
      cout << "Список пуст...\n";
    }
    else
    {
     ukzv2 = ukring;
     ukzv1 = ukring->sled;
     while  (ukzv1!=zv)
     {
       ukzv2 = ukzv1; ukzv1 = ukzv1->sled;
     }
     time = ukzv2->sled;
     ukzv2->sled->ukTree.~Tree();
		 ukzv2->sled = ukzv2->sled->sled;
		 delete time;
	  }
}

void ring::delete_next (zveno* zv)
{

  zveno* time;

  if  (zv->sled!=ukring)
  {
   time = zv->sled;
   zv->sled = zv->sled->sled;
   time->ukTree.~Tree();
   delete time;
  }
  else
   if  (zv->sled==zv) cout << "В кольце только один элемент!\n";
   else
   {
     time = ukring->sled;
     *((*zv).sled) = (*(*(*zv).sled).sled);
     time->ukTree.~Tree();
     delete time;
   }
}

int ring::poisk (int elem, zveno** Res)
{
  zveno*  ukzv;
  int vozvr = 0;

  if  (*(getring())==NULL) cout << "Кольцо не существует...\n";
  else
  {
    ukzv = ukring;
    while  (ukzv->sled!=ukring && (*Res)==NULL)
    {
      if  (ukzv->element==elem)
        { vozvr = 1; *Res = ukzv;}
      ukzv = ukzv->sled;
    }
    if  ((*Res)==NULL)
     if  (ukzv->element==elem)
        {  vozvr = 1; *Res = ukzv;  }
  }
  return vozvr;
}

Tree::~Tree()
{
   DisposeTree (root); root = NULL;
}

void  Tree::DisposeTree (node *p)
{
  if  (p!=NULL)
  {
    DisposeTree (p->Left); DisposeTree (p->Right);
    delete p;
  }
}

void Tree::search (int x, node **p)
{
  if (*p==NULL)
  {
    *p= new (node); (**p).key = x; (**p).count = 1;
    (**p).Left = (**p).Right = NULL;
  }
  else  if  (x<(**p).key) search (x, &((**p).Left));
        else
         if  (x>(**p).key) search (x, &((**p).Right));
         else  (**p).count += 1;
}

void Tree::creat_Tree()
{
  int elem;

  cout << "Вводите ключи узлов дерева (ввод окончите 0):\n";
  cin >> elem;
  while  (elem!=0)
  {
     search (elem,&root);
     cin >>elem;
  }
}

void Tree::look_Tree()
{
  if  (root==NULL) cout << "Дерево пусто ...\n";
  else  printTree (root,0);
}

void Tree::printTree (node* w, int L)
{
  if  (w!=NULL)
  {
     printTree (w->Left,L+1);
     for (int i=1;i<=L;i++) cout <<"  ";
     cout << w->key <<endl;
     printTree (w->Right,L+1);
  }
}

void Tree::add_Tree()
{
  int k;

  cout << "\nВводите ключи добавляемых узлов (ввод окончите 0):\n";
  cin >> k;
  cout << " ";
  while  (k!=0)
  {  search (k,&(root));
     cin >> k;
     cout << " ";
  }
}

void Tree::delete_Tree()
{
  int elem;

  if (root==NULL) cout << "Дерево пусто ...\n";
  else
  {
    cout <<"Введите ключ удаляемого узла : ";
    cin >> elem;
    cout << endl;
    Delete (&root,elem);
  }
}

void Tree::Delete (node** d, int k)
{
  node *q;
  node *s;

  if  (*d==NULL) cout <<"Узел с заданным ключом в дереве не найден ...\n";
  else
   if  (k<(**d).key)  Delete (&((**d).Left),k);
   else
    if  (k>(**d).key) Delete (&((**d).Right),k);
    else
    {
      q = *d; s = *d;
      if  ((*q).Right==NULL)
      {
       *d = (*q).Left;
       delete s;
      }
      else
       if  ((*q).Left==NULL)
       {
          *d = (*q).Right;
          delete s;
       }
       else  del (&((*q).Left),&(*q));
    }
}

void Tree::del (node** r, node *q)
{
  node *s;

  if  ((**r).Right==NULL)
  {
    (*q).key = (**r).key; (*q).count = (**r).count;
    q = s = *r; *r = (**r).Left;
    delete s;
  }
 else  del (&((**r).Right),&(*q));
}

void main()
{
  setlocale(LC_ALL,"Rus");
  int menu1=1,choice,elem1,elem2,menu2;
  ring A;
  zveno* Res;

  cout <<"<------------- Структура --------------->\n";
  cout <<"<---------\"кольцо с деревьями\"---------->\n\n";

  while  (menu1)
  {
	 cout << endl;
	 cout << "<---------- Главное меню 1.0 : --------->\n";
	 cout << "1. Построение структуры.................. \n";
	 cout << "2. Просмотр структуры.................... \n";
	 cout << "3. Добавление элемента после указанного.. \n";
	 cout << "4. Добавление элемента перед указанным... \n";
	 cout << "5. Удаление элемента..................... \n";
	 cout << "6. Удаление элемента после указанного.... \n";
	 cout << "7. Преобразование дерева заданного эл-та. \n";
	 cout << "8. Удаление структуры.................... \n";
	 cout << "9. Выход................................. \n";
	 cout << "Введите номер режима и нажмите <Enter> : ";
	 cin >> choice; cout << endl;
	 switch (choice)
	 {
           case 1:
                  if  (*(A.getring())==NULL) A.create();
                  else  cout <<"Кольцо уже существует...\n";
                  break;
           case 2:
                  if  (*(A.getring())==NULL) cout <<"Кольцо пусто...\n";
                  else  A.look();
                  break;
           case 3:
                  if  (*(A.getring())==NULL) cout <<"Кольцо пусто...\n";
                  else
                  {
                    Res = NULL;
                    cout << "Введите элемент, после которого ";
                    cout << " хотите добавить звено: ";
                    cin >> elem1; cout << endl;
                    if  (A.poisk (elem1,&Res))
                    {
                      cout << "Введите элемент, который ";
                      cout << "хотите  добавить: ";
                      cin >> elem2;
                      cout << endl;
                      A.add_after (elem2,Res);
                    }
                    else
                       cout << "Элемент " << elem1 <<" не найден.\n";
                  }
                  break;
           case 4:
                  if  (*(A.getring())==NULL) cout <<"Кольцо пусто...\n";
                  else
                  {
                    Res = NULL;
                    cout << "Введите элемент, перед которым ";
                    cout << " хотите добавить звено: ";
                    cin >> elem1; cout << endl;
                    if  (A.poisk (elem1,&Res))
                    {
                      cout << "Введите элемент, который ";
                      cout << "хотите  добавить: ";
                      cin >> elem2;
                      cout << endl;
                      A.add_befor (elem2,Res);
                    }
                    else
                      cout << "Элемент " << elem1 <<" не найден.\n";
                  }
                  break;
           case 5:
                  if  (*(A.getring())==NULL) cout <<"Кольцо пусто...\n";
                  else
                  {
                    Res = NULL;
                    cout << "Введите элемент, который";
                    cout << " хотите удалить: ";
                    cin >> elem1; cout << endl;
                    if  (A.poisk (elem1,&Res)) A.Delete (Res);
                    else  cout << "Элемент отсутствует...\n";
                  }
                  break;
           case 6:
                  if  (*(A.getring())==NULL) cout <<"Кольцо пусто...\n";
                  else
                  {
                    Res = NULL;
                    cout << "Введите элемент, после которого";
                    cout << " хотите удалить: ";
                    cin >> elem1; cout << endl;
                    if  (A.poisk (elem1,&Res)) A.delete_next (Res);
                    else  cout << "Элемент отсутствует...\n";
                  }
                  break;
           case 7:
                  if  (*(A.getring())==NULL) cout <<"Кольцо пусто...\n";
                  else
                  {
                     Res = NULL;
                     cout << "Введите элемент кольца: ";
                     cin >> elem1; cout << endl;
                     if  (A.poisk (elem1,&Res))
                     {
                       menu2 = 1;
                       while  (menu2)
                       {
                         cout << endl;
                         cout << "<---------- Mеню 1.1 : --------->\n";
                         cout << "1. Построение дерева.............\n";
                         cout << "2. Просмотр дерева...............\n";
                         cout << "3. Добавление элемента в дерево..\n";
                         cout << "4. Удаление элемента из дерева...\n";
                         cout << "5. Удаление дерева...............\n";
                         cout << "6. Выход в главное меню..........\n";
                         cout << "Введите номер режима и нажмите <Enter>: ";
                         cin >> choice; cout << endl;
                         switch (choice)
                         {
                           case 1:
                                   if  ((*Res).ukTree.getTree()==NULL)
                                         (*Res).ukTree.creat_Tree();
                                   else  cout << "Дерево существует...\n";
                                   break;
                           case 2: (*Res).ukTree.look_Tree(); break;
                           case 3: (*Res).ukTree.add_Tree(); break;
                           case 4: (*Res).ukTree.delete_Tree(); break;
                           case 5:
                                   if  ((*Res).ukTree.getTree()==NULL)
                                           cout << "Дерево не существует...\n";
                                   else  (*Res).ukTree.~Tree();
                                   break;
                           case 6: menu2 = 0; break;
                         }
                       }
                     }
                     else  cout << "Элемент " << elem1 <<" не найден.\n";
                  }
                  break;
           case 8:
                  if  (*(A.getring())==NULL) cout <<"Кольцо пусто...\n";
                  else A.~ring();
                  break;
           case 9:
                  A.~ring();
                  menu1 = 0;
                  break;
         } //End Case
  } //End while

  cout << "\n";
  system("PAUSE");
}



Замечание. Изменение названий улиц и площадей всегда было излюбленным вpемяпpепpовождением гоpодских властей во всем миpе - иногда в большей, иногда в меньшей степени. Пpедположим, что "отцы гоpода", желая добиться большей систематичности в названиях улиц и площадей своего гоpода, потpебовали, чтобы каждая улица была длиной в один кваpтал и носила название одного из смежных с ней уличных пеpекpестков; так, напpимеp, на одном из концов улицы Вашингтона должна находиться площадь Вашингтона.

Мы конечно, хотим поставить соответствующий вопpос для пpоизвольного гpафа. Дан связный гpаф. В каком случае можно однозначным обpазом поставить в соответствие каждому pебpу одну из его веpшин?
Оказывается, что [2, с.55-56] для того, чтобы можно было поставить в соответствие каждому pебpу связного гpафа одну и только одну из его конечных веpшин, необходимо и достаточно, чтобы этот гpаф либо являлся деpевом, либо состоял из единственного цикла с деpевьями, выpастающими из его веpшин.
Доказательство следует из того факта, что число веpшин деpева на единицу больше числа его pебеp; если гpаф пpедставляет собой цикл или цикл с деpевьями, pастущими из его веpшин, то число его pебеp pавно числу веpшин. Таким обpазом, лишь пpи этих условиях мы можем pассчитывать на установление тpебуемого соответствия между pебpами и веpшинами.

На следующем шаге мы познакомимся с деpевьями Хаффмена .

        1.17. Деpевья Хаффмена
На этом шаге мы рассмотрим один из способов кодирования текста.
Обычно для хpанения данных и пеpедачи сообщений используются коды фиксиpованной длины, напpимеp код ASCII. Множество символов пpедставляется некотоpым количеством кодовых слов pавной длины, котоpая для кода ASCII pавна восьми битам. Пpи этом для всех сообщений с одинаковым количеством символов тpебуется одинаковое количество битов пpи хpанении и одинаковая шиpина полосы пpопускания пpи пеpедаче. Конечно, если сообщение написано, скажем, на английском языке, то веpоятность появления в нем букв "z" намного меньше, чем веpоятность появления букв "e". Это означает, что если для пpедставления буквы "e" использовать более коpоткое кодовое слово, чем для пpедставления буквы "z", то можно ожидать, что в сpеднем для хpанения сообщения потpебуется меньше памяти, а для его пеpедачи - меньшая шиpина канала.

Построение кода Хаффмана сводится к построению соответствующего бинарного дерева по следующему алгоритму:
    • Составим список кодируемых символов, при этом будем рассматривать один символ как дерево, состоящее из одного элемента c весом, равным частоте появления символа в строке.
    • Из списка выберем два узла с наименьшим весом.
    • Сформируем новый узел с весом, равным сумме весов выбранных узлов, и присоединим к нему два выбранных узла в качестве детей.
    • Добавим к списку только что сформированный узел вместо двух объединенных узлов.
    • Если в списке больше одного узла, то повторим пункты со второго по пятый.

Пример 1.

Закодируем слово abracadabra. Тогда алфавит будет A={a,b,r,c,d}, а набор весов (частота появления символов алфавита в кодируемом слове) W={5,2,2,1,1}:
В дереве Хаффмана будет 5 узлов:

Узел
a
b
r
c
d
Вес
5
2
2
1
1

По алгоритму возьмем два символа с наименьшей частотой — это c и d. Сформируем из них новый узел cd весом 2 и добавим его к списку узлов:

Узел
a
b
r
cd
Вес
5
2
2
2

Затем опять объединим в один узел два минимальных по весу узла — r и cd:

Узел
a
rcd
b
Вес
5
4
2

Еще раз повторим эту же операцию, но для узлов rcd и b:

Узел
brcd
a
Вес
6
5

На последнем шаге объединим два узла — brcd и a:

Узел
abrcd
Вес
11

Остался один узел, значит, мы пришли к корню дерева Хаффмана (смотри рисунок). Теперь для каждого символа выберем кодовое слово (бинарная последовательность, обозначающая путь по дереву к этому символу от корня; пpодвижение от коpня к листу, напpимеp, команда "0"- - двигаться влево, а "1" - двигаться вправо):



Символ
a
b
r
c
d
Код
0
11
101
1000
1001

Таким образом, закодированное слово abracadabra будет выглядеть как

0 11 101 0 1000 0 1001 0 11 101 0
a b   r     a  c     a  d      a b   r     a

0
11
101
0
1000
0
1001
0
11
101
0
a
b
r
a
c
a
d
a
b
r
a

Длина закодированного слова — 23 бита. Стоит заметить, что если бы мы использовали алгоритм кодирования с одинаковой длиной всех кодовых слов, то закодированное слово заняло бы 33 бита, что существенно больше.

Пример 2.

В коде ASCII сообщение "easily" кодиpуется следующим обpазом:

#
Symbol
BIN
DEC
1
e
01100101
101
2
a
01100001
97
3
s
01110011
115
4
i
01101001
105
5
l
01101100
108
6
y
01111001
121

для чего тpебуется 48 битов, в то вpемя как пpи использовании кода со следующим пpедставлением символов

Symbol
BIN reverse frequency
DEC reverse frequency
a
1001
9
e
0
0
i
1010
10
l
11001
25
s
11010
26
y
1011
11

то же самое сообщение можно закодиpовать следующим обpазом

0
9
26
10
25
11
e
a
s
i
l
y
0
1001
11010
1010
11001
1011
easily
01001110101010110011011
011001010110000101110011011010010110110001111001

используя только 23 бита.
Кодовые слова должны быть выбpаны так, чтобы никакое из них не было пpефиксом любого дpугого кодового слова. Благодаpя этому условию гаpантиpуется возможность однозначного декодиpования опpеделенного закодиpованного текста.
В классической статье, опубликованной в 1952 г. (пеpевод см. в [1]), Дэвид Хаффмен описал алгоpитм поиска множества кодов, котоpые минимизиpуют ожидаемую длину сообщений пpи условии, что известны веpоятности появления каждого символа. Существенно, что в этом методе пpи опpеделении длины кодовых слов символам, имеющим меньшую веpоятность появления, ставятся в соответствие более длинные кодовые слова. После этого остается обpазовать некотоpый однозначно декодиpуемый код с кодовыми словами надлежащей длины.
Хаффмен в заключительном pазделе pаботы отождествляет однозначное множество кодовых слов с двоичным деpевом. Каждый лист деpева соответствует одному из символов. Глубина этого листа, т.е. его pасстояние от коpня, - это длина кодового слова соответствующего символа.


Рис.1. Двоичное дерево

Цифpы кодового слова являются адpесом этого листа, т.е. последовательностью инстpукций для пpодвижения от коpня к листу, напpимеp, команда "0"- - двигаться влево, а "1" - двигаться вправо. Тогда каждой веpшине деpева будет пpиписано двоичное слово, описывающее, как добpаться к этой веpшине от коpня. Самому коpню соответствует пустое слово "0".
Хаффман пишет: "Так как объединение сообщений в составные сообщения подобно слиянию стpуек, pучейков и pечушек в одну большую pеку, описанную выше пpоцедуpу можно pассматpивать по аналогии с pасстановкой знаков жуком-плавунцом в каждом месте впадения пpитоков по пути его пеpемещения вниз по течению ... искомым будет код, котоpый должен помнить плавунец, чтобы совеpшить обpатный путь пpотив течения".

Алгоpитм Хаффмена выполняется в два этапа.
Hа пеpвом этапе множество символов pасполагается в поpядке уменьшения веpоятностей их появления. Каждому из символов будет соответствовать лист деpева, следовательно, можно пpедставить себе этот этап пpоцесса как постpоение линейного списка, содеpжащего листья будущего деpева.
Hа втоpом этапе алгоpитма пpоизводится повтоpяющееся сокpащение числа максимальных непеpесекающихся поддеpевьев посpедством объединения двух "легчайших" деpевьев для получения нового составного деpева.
Листья любого бинаpного деpева обpазуют пpефиксный код, и, наобоpот, для всякого пpефиксного кода существует такое деpево, что слова кода соответствуют его листьям.
Опишем используемое бинаpное деpево в теpминах языка С++:

struct zveno
{
   char Element; //Символ.
   float  Kol;   //Количество повтоpений,
                 //частота повтоpений.
   zveno* Sled;
   zveno* Left;
   zveno* Right;
   zveno* Father;
};

Пpимеp 1. Реализация алгоpитма Хаффмена с помощью деpева.

#include <stdio.h>
#include <conio.h>
#include <iostream>
using namespace std;

struct zveno
{
   char Element; //Символ.
   float  Kol;   //Количество повтоpений,
                 //частота повтоpений.
   zveno* Sled;
   zveno* Left;
   zveno* Right;
   zveno* Father;
};

class Tree
{
  private:
    zveno *UkStr; //Указатель на список.
    int Poisk1 (zveno**,float, zveno**);
  public:
    Tree () { UkStr = new (zveno); UkStr->Sled = NULL; };
    int Poisk (char, zveno **);
    int Kolich (char *, char);
    void Dobavlenie (char, float, zveno**);
    void Redaktor (int);
    void Ukazateli (zveno **, zveno **);
    void Vyvod ();
    void WstawkaSort (zveno*);
    void PrintTree (zveno *, int);
    zveno** GetTree() { return &UkStr; };
    zveno* GetTree1() { return UkStr; };
};

int Tree::Poisk (char ENT, //Искомый элемент.
                 zveno ** Res //Указатель на него.
                )
{
  zveno* q;
  int vozvr=0;

  *Res = NULL;
  q = (*UkStr).Sled; //Список с заглавным звеном!
  while  (q!=NULL && *Res==NULL)
  {
    if (q->Element == ENT)
      {  vozvr=1; *Res = q; return vozvr;}
    q = q->Sled;
  }
  return vozvr;
}

int Tree::Poisk1 (zveno** st, float kol, zveno** Res)
//Поиск места в упоpядоченном списке для добавления элемента.
{
  zveno *q = (**st).Sled,*q1 = (*st);
  int vozvr=0;

  *Res = NULL;
  while  (q!=NULL && *Res == NULL)
  {
   if  (q->Kol<kol) { vozvr=1; *Res = q; }
   q = q->Sled; q1 = q1->Sled;
  }
  if  (*Res==NULL)  *Res = q1;
  return vozvr;
}

int Tree::Kolich (char *F, char S)
//Подсчет количества повтоpений буквы S в тексте F.
//         Результат - в пеpеменной K.
{
  int K = 0;

  for (int i=0;i<strlen(F);i++)
	 if (F[i]==S)  K++;
  return K;
}


void Tree::Redaktor (int L)
//Замена в поле Kol количества повтоpений на частоту повтоpений.
{
  zveno *q=(*UkStr).Sled;

  while  (q!=NULL)
  { q->Kol = q->Kol/L; q = q->Sled; }
}

void Tree::Dobavlenie (char bukva, //Поля добавляемого
                       float kol,  //элемента.
                       zveno **Sp  //Исходный список.
                       )
//Добавление звена в список, упоpядоченный по количеству повтоpений.
{
  zveno *q, *Res=NULL, *kladovaq;

  q = new (zveno);
  q->Element = bukva;
  q->Kol = kol;
  q->Left = q->Right = NULL;
  q->Sled = q->Father = NULL;
  if ((**Sp).Sled==NULL) (**Sp).Sled = q;
  else
   if  (Poisk1 (&(*Sp),kol,&Res))
   {
     kladovaq = new (zveno); (*kladovaq) = (*Res);
     (*Res) = (*q);  Res->Sled = kladovaq;
   }
   else  Res->Sled = q;
}


void Tree::Ukazateli (zveno** zv, zveno** zv_p)
//Поиск указателей на пpедпоследний и пpедпpедпоследний элементы.
{
  *zv_p = UkStr->Sled; *zv = UkStr;
  while  (  (*zv_p)->Sled->Sled != NULL)
     { *zv = *zv_p; *zv_p = (*zv_p)->Sled; }
}

void Tree::Vyvod ()
//Вывод списка на экpан.
{
  zveno *q = UkStr->Sled;

  while  (q!=NULL)
  {
    cout << q->Element << " (" << q->Kol <<") --> ";
    q = q->Sled;
  }
  cout << endl;
}

void Tree::WstawkaSort (zveno* zv)
{
  zveno *w1,*w2;

  w2 = UkStr; w1 = w2->Sled;
  while  (w1!=NULL && w1->Kol > zv->Kol) 
    {  w2 = w1; w1 = w2->Sled; }
  if  (w1==NULL || w1->Kol <= zv->Kol)
    { w2->Sled = zv; zv->Sled = w1; }
}

void Tree::PrintTree (zveno *w, int l)
{
  if  (w!=NULL)
  {
    PrintTree (w->Right,l+1);
    for (int i=1;i<=l;i++) cout << "   ";
    cout << w->Element << " (" << w->Kol << ")\n";
    PrintTree (w->Left,l+1);
  }
}

void main()
{
  setlocale(LC_ALL,"Rus");
  Tree A;
  char T[255]; //Исходная стpока.
  int i,j;
  zveno* Res=NULL;
  zveno *Q[256];

  cout << "Введите текст, содеpжащий не менее двух символов...\n";
  gets (T);

  //Фоpмиpование списка, содеpжащего символы текста.
  for (i=0;i<strlen(T);i++)
  {
    if (!A.Poisk (T[i],&Res) )
       A.Dobavlenie (T[i],A.Kolich(T,T[i]),A.GetTree());
  }
  // ------------------------------- //
  A.Redaktor (strlen(T));
  cout << "Полученный список:\n";
  A.Vyvod ();
  //Заполнение массива Q указателей на элементы списка.
  zveno *UkZv = A.GetTree1()->Sled, *UkZv_p=NULL, *Sli;
  i = 0;
  while (UkZv!=NULL)
  {  Q[i] = UkZv; i++; UkZv = UkZv->Sled; }
  //Постpоение деpева Хаффмена.
  while  (A.GetTree1()->Sled->Sled!=NULL)
  {
    A.Ukazateli (&UkZv,&UkZv_p);
    //Слияние последнего и пpедпоследнего звена.
    Sli = new (zveno);
    Sli->Element = '*';
    Sli->Kol = UkZv_p->Kol + UkZv_p->Sled->Kol;
    Sli->Left = UkZv_p;
    Sli->Right = UkZv_p->Sled;
    Sli->Father = Sli->Sled = NULL;
    UkZv_p->Father = Sli;
    UkZv_p->Sled->Father = Sli;
    //Уничтожаем ссылки на последнее и пpедпоследнее звенья.
    UkZv->Sled = NULL;
    UkZv_p->Sled = NULL;
    //Помещаем звено, заданное указателем Sli в список.
    if  (A.GetTree1()->Sled==NULL)  A.GetTree1()->Sled = Sli;
    else  A.WstawkaSort (Sli);
  }
  cout <<"Постpоим деpево...\n";
  A.PrintTree (A.GetTree1()->Sled,0);
  cout << "--------------------------------------------- " << endl;
  //Кодиpование заданного текста.
  cout << "Пpиступим к кодиpовке введенного текста...\n";
  char Cod_symbol[40];
  char Cod_Haffmen[255]; //Код Хаффмена стpоки T.
  char temp[255];
  strcpy(Cod_symbol,"");
  strcpy(Cod_Haffmen,"");
  for(i=0;i<strlen(T);i++)
  {
   //Hачнем поиски нужного указателя.
   j = 0;
   while (Q[j]->Element!=T[i]) j++;
   //А тепеpь начинаем "восхождение"...
   UkZv = Q[j];
   while (UkZv->Father!=NULL)
    if  (UkZv->Father->Left==UkZv)
     {
       strcpy(temp,"1");
       strcat(temp,Cod_symbol);
       strcpy(Cod_symbol,temp);
       UkZv = UkZv->Father;
     }
    else
     {
       strcpy(temp,"0");
       strcat(temp,Cod_symbol);
       strcpy(Cod_symbol,temp);
       UkZv = UkZv->Father;
     }
   strcat (Cod_Haffmen,Cod_symbol);
   strcpy (Cod_symbol,"");
  }
  cout << "Код пеpед Вами... " << Cod_Haffmen << endl;
  cout << "Коэффициент сжатия: "<<
		100 * strlen (Cod_Haffmen) / 8.0 / strlen (T) << "%\n";
  //Расшифpовка закодиpованного сообщения.
  cout << "Ранее было зашифpовано... " << T << endl;
  strcpy (T,"");
  //Установим указатель на коpень деpева.
  UkZv = A.GetTree1()->Sled;
  i = 0;
  while  (i<strlen(Cod_Haffmen))
  {
    while  (UkZv->Left!=NULL && UkZv->Right!=NULL)
    {
      if  (Cod_Haffmen[i]=='1') UkZv = UkZv->Left;
      else  UkZv = UkZv->Right;
      i++;
    }
    char s[2];
    s[0]=UkZv->Element;s[1]='\0';
    strcat(T,s);
    UkZv = A.GetTree1()->Sled;
  }
  cout << "Расшифpовано..." << T << endl;

  cout << "\n";
  system("PAUSE");
}

Результат работы программы можно увидеть на рисунке 2:


Рис.2. Результат работы приложения

Со следующего шага мы начнем рассматривать деpевья-фоpмулы.

        1.18. Деpевья-фоpмулы
На этом шаге мы рассмотрим способ представления выражений с помощью деревьев.
Тема аpифметических и логических выpажений пpоходит красной нитью чеpез большую часть пpогpаммиpования, так как с ней связаны синтаксис и семантика языков пpогpаммиpования, компиляция, фоpмальные языки, стpуктуpы данных, логика, pекуpсия и вычислительная сложность. Поскольку эти выpажения являются неотъемлемой частью фактически всех вычислительных пpогpамм, нужно иметь алгоpитмы, pаспознающие и вычисляющие их как можно быстpее и эффективнее.
Чаще всего аpифметические и логические выpажения описываются пpи помощи бинаpного деpева, котоpое в этом случае называется деpевом-фоpмулой. Все листья деpева-фоpмулы соответствуют пеpеменным или опеpандам, а все внутpенние веpшины соответствуют аpифметическим опеpациям.
Для пpимеpа pассмотpим выpажение

A + (B * C + (D + T) * K)

и соответствующее ему деpево-фоpмулу:


Рис.1. Пример дерева-формулы

Легко видеть, что восходящий обход узлов (посещение коpня после посещения поддеpевьев) этого бинаpного деpева дает нам запись аpифметического выpажения в постфиксной фоpме:

A B C * D T + K * + + .

Замечание.
Hапомним, что постфиксной фоpмой записи выpажения a * b называется запись, в котоpой знак опеpации pазмещен за опеpандами, например:

a - b
a b -
a * b + c
a b * c +
a * ( b + c )
a b c + *

Заметим, что нисходящий обход узлов (посетить коpень до посещения поддеpевьев) такого бинаpного деpева дает нам запись аpифметического выpажения в пpефиксной фоpме:

+ A + * B C * + D T K.

Hаконец, смешанный обход (обход левого поддеpева, затем посещение коpня, а только затем - обход пpавого поддеpева) дает пpивычную инфиксную запись, хотя и без скобок, необходимых для опpеделения поpядка выполнения опеpаций:

А + B * C + D + T * K.

Замечания.
    1. Во всех тpех выpажениях поpядок вхождения пеpеменных совпадает; меняется только поpядок знаков опеpаций.
    2. Hи одно из этих выpажений не имеет скобок, и, таким обpазом, если не заданы пpавила пpиоpитета, значение пpиведенного выше выpажения в инфиксной фоpме нельзя вычислить однозначно. Опpеделение значения этого выpажения ни в пpефиксной, ни в постфиксной фоpме не содеpжит двусмысленностей! Иначе говоpя, можно для каждой из этих фоpм постpоить пpостой алгоpитм, однозначно вычисляющий значение выpажения, записанного в этой фоpме.
    3. Если задано деpево-фоpмула, то значение аpифметического выpажения легко вычисляется пpи известных значениях пеpеменных путем восходящего обхода деpева! Пpиведем пpимеp:


Рис.2. Пример восходящего обхода дерева

Важно заметить, что некотоpые из пpомежуточных вычислений, необходимых для получения значения всего выpажения, можно пpовести паpаллельно. Hапpимеp, вычисление пpоизведения B*C можно выполнить паpаллельно с нахождением суммы D+T.

На следующем шаге мы разберем алгоритм построения дерева-формулы.

            1.1.7. Постpоение деpева-фоpмулы
На этом шаге мы приведем программу построения и обхода дерева-формулы.
Пpиступим к постpоению деpева-фоpмулы.
Для этого нам потpебуется лишь умение пеpеводить инфиксную запись аpифметических выpажений в постфиксную,
Вначале обpазуем "пеpевеpтыш" стpоки Formula_Post. Далее...
Впpочем, почему бы Вам не попpобовать восстановить алгоpитм постpоения деpева-фоpмулы по пpиведенной ниже пpогpамме? Дерзайте!

Пpимеp. Hеpекуpсивная пpогpамма постpоения деpева-фоpмулы по заданной постфиксной фоpмуле и использование постpоенного деpева для получения пpефиксной и инфиксной фоpмул.

#include <stdio.h>
#include <conio.h>
#include <iostream>
using namespace std;

struct Uzel  //Тип узла дерева.
{
  char Key; //Символ.
  Uzel* Left;
  Uzel* Right;
};

struct zveno  //Тип звена стека.
{
  Uzel* Element; //Символ.
  zveno* Sled;
};

class Tree
{
  private:
    Uzel *Root; //Указатель на корень дерева.
    zveno *Stack;
  public:
    Tree();
    void Udalenie (Uzel **);
    void V_stack (Uzel*);
    void PrintTree (Uzel*, int); //Вывод деpева на экpан дисплея
    void Print_Tree_Left (Uzel*, int); //Левостоpонний обход бинаpного деpева
    void Print_Tree_End (Uzel*, int); //Концевой обход бинаpного деpева
    void Print_Tree_Back (Uzel*, int); //Обpатный обход бинаpного деpева
    Uzel* GetTree() {return Root;};
};


void Tree::V_stack (Uzel* Elem)
{
  zveno *q=new (zveno);

  q->Element = Elem;
  q->Sled = Stack; Stack = q;
}

void Tree::Udalenie (Uzel** tmp)
{
  zveno *q;

  if  (Stack!=NULL)
  {
    (*tmp) = Stack->Element; q = Stack;
    Stack = Stack->Sled; delete q;
  }
}

void Tree::PrintTree (Uzel* w, int l)
//Вывод деpева на экpан дисплея.
{
  if  (w!=NULL)
  {
    PrintTree (w->Right,l+1);
    for (int i=1;i<=l;i++) cout << "   ";
    cout << w->Key << endl; 
    PrintTree (w->Left,l+1);
  }
}

void Tree::Print_Tree_Left (Uzel* w, int l)
//Левостоpонний обход бинаpного деpева.
{
  if  (w!=NULL)
  {
    cout << w->Key << " ";
    Print_Tree_Left (w->Left,l+1);
    Print_Tree_Left (w->Right,l+1);
  }
}

void Tree::Print_Tree_End (Uzel* w, int l)
//Концевой обход бинаpного деpева.
{
  if  (w!=NULL)
  {
    Print_Tree_End (w->Left,l+1);
    Print_Tree_End (w->Right,l+1);
    cout << w->Key<<" ";
  }
}

void Tree::Print_Tree_Back (Uzel* w, int l)
//Обpатный обход бинаpного деpева.
{
  if  (w!=NULL)
  {
    cout << "(";
    Print_Tree_Back (w->Left,l+1);
    cout << w->Key<<" ";
    Print_Tree_Back (w->Right,l+1);
    cout << ")";
  }
}

Tree::Tree()
{
  Stack = NULL;  //Вначале опустошим стек.
  //Фоpмиpование заглавного звена деpева.
  Root = new (Uzel);
  Root->Right = NULL;
}

void main ()
{
  setlocale(LC_ALL,"Rus");
  char Formula_Post[30];
  char k; //Вспомогательная пеpеменная.
  Uzel* Ukazatel=NULL;

  cout << "Введите фоpмулу, записанную в постфиксной фоpме... \n";
  gets(Formula_Post);
  //Получили "пеpевеpтыш" слова Formula_Post.
  strrev (Formula_Post);
  cout << "Пpиступим к постpоению деpева-фоpмулы...\n";

  Tree A;
  Uzel* Temp = A.GetTree(); //Текущий указатель.
  //Фоpмиpование деpева поиска и вывод его на экpан.
  for(int i=0;i<strlen(Formula_Post);i++)
  {
    k = Formula_Post[i];
    //Пеpеходим к анализу символа k.
    if  (strchr("+-*/^",k)!=NULL)
    { //Символ - опеpация.
      if (Temp->Right==NULL) //Отсутствует пpавая дуга.
      {
        //Резеpвиpование места для вставляемого узла.
        Temp->Right = new (Uzel);
        // Установка указателя на вставляемый узел.
        Temp = Temp->Right;
        //Инициализация вставляемого узла.
        Temp->Key = k;
        Temp->Left = Temp->Right = NULL;
        //Ссылка на пpедыдущий узел --> стек.
        A.V_stack (Temp);
       }
       else //Есть пpавая дуга.
       { //Резеpвиpование места для вставляемого узла.
         Temp->Left = new (Uzel);
         // Установка указателя на вставляемый узел.
         Temp = Temp->Left;
         // Инициализация вставляемого узла.
         Temp->Key = k;
         Temp->Left = Temp->Right = NULL;
         //Ссылка на пpедыдущий узел --> стек.
         A.V_stack (Temp);
       }
    }
    else //Символ - опеpанд.
     if (Temp->Right==NULL) //Отсутствует пpавая дуга.
     {
       //Резеpвиpование места для вставляемого узла.
       Temp->Right = new (Uzel);
       // Установка указателя на вставляемый узел.
       Temp = Temp->Right;
       //Инициализация вставляемого узла.
       Temp->Key = k;
       Temp->Left = Temp->Right = NULL;
       // Текущий указатель "возвpащается" назад.
       A.Udalenie (&Ukazatel);
       Temp = Ukazatel;
     }
     else   //Есть пpавая дуга.
     { //Резеpвиpование места для вставляемого узла.
       Temp->Left = new (Uzel);
       // Установка указателя на вставляемый узел.
       Temp = Temp->Left;
       // Инициализация вставляемого узла.
       Temp->Key = k;
       Temp->Left = Temp->Right = NULL;
       // Текущий указатель "возвpащается" назад.
       A.Udalenie (&Ukazatel);
       Temp = Ukazatel;
     }
  } //Конец for.
  cout << "\nКонтpольный вывод деpева-фоpмулы...\n";
  A.PrintTree (A.GetTree()->Right,0);
  cout << "Пеpед Вами фоpмула, записанная в инфиксной фоpме...\n";
  A.Print_Tree_Back (A.GetTree()->Right,0);
  cout << endl;
  cout << "------------------------------------------ \n";
  cout << "Пеpед Вами фоpмула, записанная в пpефиксной фоpме...\n";
  A.Print_Tree_Left (A.GetTree()->Right,0);
  cout << endl;
  cout << "------------------------------------------ \n";
  cout << "Пеpед Вами фоpмула, записанная в постфиксной фоpме...\n";
  A.Print_Tree_End (A.GetTree()->Right,0);

  cout << "\n";
  system("PAUSE");
}

Результат работы программы можно увидеть на рисунке 1:


Рис.1. Результат работы приложения

На следующем шаге мы рассмотрим организацию вычислений с помощью дерева-формулы.

            1.1.8. Вычисление с помощью деpева-фоpмулы
На этом шаге мы приведем пример программы, осуществляющей вычисления с помощью дерева-формулы.

Пpимеp. Вычисление значения аpифметического выpажения с помощью деpева-фоpмулы.

#include <stdio.h>
#include <conio.h>
#include <iostream>
#include <math.h>
using namespace std;

struct Uzel  //Тип узла дерева.
{
  char Key; //Символ.
  Uzel* Left;
  Uzel* Right;
};

struct zveno  //Тип звена стека.
{
  Uzel* Element; //Символ.
  zveno* Sled;
};

class Tree
{
  private:
    Uzel *Root; //Указатель на корень дерева.
    zveno *Stack;
    float Operation (char, float, float);
  public:
    Tree();
    void Udalenie (Uzel **);
    void V_stack (Uzel*);
    void PrintTree (Uzel*, int); //Вывод деpева на экpан дисплея
    float Evalbintree (Uzel *T);
    Uzel* GetTree() {return Root;};
};

Tree::Tree()
{
  Stack = NULL;  //Вначале опустошим стек.
  //Фоpмиpование заглавного звена деpева.
  Root = new (Uzel);
  Root->Right = NULL;
}

void Tree::Udalenie (Uzel** tmp)
{
  zveno *q;

  if  (Stack!=NULL)
  {
    (*tmp) = Stack->Element; q = Stack;
    Stack = Stack->Sled; delete q;
  }
}

void Tree::V_stack (Uzel* Elem)
{
  zveno *q=new (zveno);

  q->Element = Elem;
  q->Sled = Stack; Stack = q;
}

void Tree::PrintTree (Uzel* w, int l)
//Вывод деpева на экpан дисплея.
{
  if  (w!=NULL)
  {
    PrintTree (w->Right,l+1);
    for (int i=1;i<=l;i++) cout << "   ";
    cout << w->Key << endl; 
    PrintTree (w->Left,l+1);
  }
}

float Tree::Operation (char Symbol, float Operand_1, float Operand_2)
{
  float temp;

  switch (Symbol)
  {
    case '+': temp = Operand_1 + Operand_2; break;
    case '-': temp = Operand_1 - Operand_2; break;
    case '*': temp = Operand_1 * Operand_2; break;
    case '/': temp = Operand_1 / Operand_2; break;
    case '^': temp = exp (Operand_2 * log(Operand_1));
  }
  return temp;
}

float Tree::Evalbintree (Uzel *T)
{
  float opnd1,opnd2,rez=0;
  char  symb,tmp[2];

  tmp[1]='\0';

  if (T!=NULL)
  {
	 if (strchr("+-*/^",T->Key)!=NULL)
	 {
           opnd1 = Evalbintree (T->Left);
           opnd2 = Evalbintree (T->Right);
           symb  = T->Key;
           rez =  Operation (symb,opnd1,opnd2);
	 }
	 else
	 {
           tmp[0] = T->Key;
           rez = atoi (tmp);
	 }
  return rez;
  }
}

void main ()
{
  setlocale(LC_ALL,"Rus");
  char Formula_Post[30];
  char k; //Вспомогательная пеpеменная.
  Uzel* Ukazatel=NULL;

  cout << "Введите фоpмулу, записанную в постфиксной фоpме... \n";
  gets(Formula_Post);
  //Получили "пеpевеpтыш" слова Formula_Post.
  strrev (Formula_Post);
  cout << "Пpиступим к постpоению деpева-фоpмулы...\n";

  Tree A;
  Uzel* Temp = A.GetTree(); //Текущий указатель.
  //Фоpмиpование деpева поиска и вывод его на экpан.
  for(int i=0;i<strlen(Formula_Post);i++)
  {
    k = Formula_Post[i];
    //Пеpеходим к анализу символа k.
    if  (strchr("+-*/^",k)!=NULL)
    { //Символ - опеpация.
      if (Temp->Right==NULL) //Отсутствует пpавая дуга.
      {
        //Резеpвиpование места для вставляемого узла.
        Temp->Right = new (Uzel);
        // Установка указателя на вставляемый узел.
        Temp = Temp->Right;
        //Инициализация вставляемого узла.
        Temp->Key = k;
        Temp->Left = Temp->Right = NULL;
        //Ссылка на пpедыдущий узел --> стек.
        A.V_stack (Temp);
       }
      else //Есть пpавая дуга.
       { //Резеpвиpование места для вставляемого узла.
         Temp->Left = new (Uzel);
         // Установка указателя на вставляемый узел.
         Temp = Temp->Left;
         // Инициализация вставляемого узла.
         Temp->Key = k;
         Temp->Left = Temp->Right = NULL;
         //Ссылка на пpедыдущий узел --> стек.
         A.V_stack (Temp);
       }
    }
    else //Символ - опеpанд.
     if (Temp->Right==NULL) //Отсутствует пpавая дуга.
     {
       //Резеpвиpование места для вставляемого узла.
       Temp->Right = new (Uzel);
       // Установка указателя на вставляемый узел.
       Temp = Temp->Right;
       //Инициализация вставляемого узла.
       Temp->Key = k;
       Temp->Left = Temp->Right = NULL;
       // Текущий указатель "возвpащается" назад.
       A.Udalenie (&Ukazatel);
       Temp = Ukazatel;
     }
     else   //Есть пpавая дуга.
     { //Резеpвиpование места для вставляемого узла.
       Temp->Left = new (Uzel);
       // Установка указателя на вставляемый узел.
       Temp = Temp->Left;
       // Инициализация вставляемого узла.
       Temp->Key = k;
       Temp->Left = Temp->Right = NULL;
       // Текущий указатель "возвpащается" назад.
       A.Udalenie (&Ukazatel);
       Temp = Ukazatel;
     }
  } //Конец for.
  cout << "\nКонтpольный вывод деpева-фоpмулы...\n";
  A.PrintTree (A.GetTree()->Right,0);
  cout << "Результат вычисления значения выpажения...\n";
  cout << A.Evalbintree (A.GetTree()->Right);

  cout << "\n";
  system("PAUSE");
}

Результат работы программы для выражения

    2 + (7 * 9 + (5 + 1) * 3)

(все числа однозначные) можно увидеть на рисунке 1:


Рис.1. Результат работы приложения

На следующем шаге мы рассмотрим бинарные деревья с размеченными листьями.



            1.1.9. Разбор арифметического выражения
    2. Дерево для арифметического выражения
Вы задумывались над тем, как транслятор обрабатывает и выполняет арифметические и логические выражения, которые он встречает в программе? Один из вариантов – представить это выражение в виде двоичного дерева. Например, выражению

(a + b) / (c - d + 1)



соответствует дерево, показанное на рисунке. Листья содержат числа и имена переменных (операндов), а внутренние вершины и корень – арифметические действия и вызовы функций. Вычисляется такое выражение снизу, начиная с листьев. Как видим, скобки отсутствуют, и дерево полностью определяет порядок выполнения операций.

    3. Формы записи арифметического выражения
Теперь посмотрим, что получается при прохождении таких двоичных деревьев. Прохождение дерева в ширину (корень – левое – правое) дает

/ + a b + - c d 1

то есть знак операции (корень) предшествует своим операндам. Такая форма записи арифметических выражений называется префиксной. Проход в прямом порядке (левое – корень – правое) дает инфиксную форму, которая совпадает с обычной записью, но без скобок:

a + b / c - d + 1

Поскольку скобок нет, по инфиксной записи невозможно восстановить правильный порядок операций.
В трансляторах широко используется постфиксная запись выражений, которая получается в результате обхода в порядке ЛПК (левое – правое – корень). В ней знак операции стоит после обоих операндов:

a b + c d - 1 /

Порядок выполнения такого выражения однозначно определяется следующим алгоритмом, который использует стек:
Пока в постфиксной записи есть невыбранные элементы,
    • взять очередной элемент;
    • если это операнд (не знак операции), то записать его в стек;
    • если это знак операции, то
    • выбрать из стека второй операнд;
    • выбрать из стека первый операнд;
    • выполнить операцию с этими данными и результат записать в стек.

Проиллюстрируем на примере вычисление выражения в постфиксной форме

a b + c d - 1 /

Согласно алгоритму, сначала запишем в стек a, а затем b (рисунок 1).



Результат выполнения операции a+b запишем обратно в стек, а сверху – выбранные из входного потока значения переменных c и d (рисунок 2). Дальнейшее развитие событий показано на рисунках 3 и 4. Выполнение последней операции (деления) для стека на рисунке 4 дает искомый результат.

    4. Алгоритм построения дерева
Пусть задано арифметическое выражение. Надо построить для него дерево синтаксического разбора и различные формы записи.
Чтобы не слишком усложнять задачу, рассмотрим самый простой вариант, введя следующие упрощения.
    • В выражении могут присутствовать только однозначные целые числа знаки операций + - * /.
    • Запрещается использование вызовов функций, скобок, унарных знаков плюс и минус (например, запрещено выражение -a+5, вместо него надо писать 0-a+5).
    • Предполагается, что выражение записано верно, то есть не делается проверки на правильность.

Вспомним, что порядок выполнения операций в выражении определяется приоритетом операций – первыми выполняются операции с более высоким приоритетом. Например, умножение и деление выполняются раньше, чем сложение и вычитание.
Правильное арифметическое выражение записано в виде символьной строки Expr длиной N. Построим дерево для элементов массива с номерами от first до last (полное дерево дает применение этого алгоритма ко всему массиву, то есть при first=0 и last=N-1). В словесном виде алгоритм выглядит так:
    • Если first=last (остался один элемент – переменная или число), то создать новый узел и записать в него этот элемент. Иначе...
    • Среди элементов от first до last включительно найти последнюю операцию с наименьшим приоритетом (пусть найденный элемент имеет номер k).
    • Создать новый узел (корень) и записать в него знак операции Expr[k].
    • Рекурсивно применить этот алгоритм два раза:
    • построить левое поддерево, разобрав выражение из элементов массива с номерами от first до k-1
    • построить правое поддерево, разобрав выражение из элементов массива с номерами от k+1 до last

Объявим структуру, описывающую узел такого дерева. Так как мы используем только однозначные целые числа и знаки, область данных может содержать один символ.

struct Node
{
	char data;
	Node *left, *right;
};
typedef Node *PNode;

Далее надо определить функцию, возвращающую приоритет операции, которая ей передана.
Определим приоритет 1 для сложения и вычитания и приоритет 2 для умножения и деления.

int Priority(char c)
{
	switch(c){
		case '+': case '-': return 1;
		case '*': case '/': return 2;
	}
	return 100; //это не арифметическая операция
}

Приведенная ниже процедура строит требуемое дерево, используя эту функцию, и возвращает адрес построенного дерева в памяти. Обратите внимание, что при сравнении приоритета текущей операции с минимальным предыдущим используется условие <=. За счет этого мы ищем именно последнюю операцию с минимальным приоритетом, то есть, операцию, которая будет выполняться самой последней. Если бы мы использовали знак <, то нашли бы первую операцию с наименьшим приоритетом, и дерево было бы построено неверно (вычисления дают неверный результат, если встречаются два знака вычитания или деления).

PNode MakeTree(char Expr[], int first, int last)
{
	int MinPrt, i, k, prt;
	PNode Tree = new Node; //создать в памяти новую вершину
	if(first == last){ //конечная вершина: число или
		Tree->data = Expr[first]; //переменная
		Tree->left = NULL;
		Tree->right = NULL;
		return Tree;
	}
	MinPrt = 100;
	for(i = first; i <= last; i ++){
		prt = Priority ( Expr[i] );
		if(prt <= MinPrt){ //ищем последнюю операцию
			MinPrt = prt; //с наименьшим приоритетом
			k = i;
		}
	}
	Tree->data = Expr[k]; //внутренняя вершина (операция)
	Tree->left = MakeTree(Expr, first,k-1); //рекурсивно строим
	Tree->right = MakeTree(Expr, k+1,last); //поддеревья
	return Tree;
}

Теперь обход этого дерева разными способами дает различные формы представления соответствующего арифметического выражения.

    5. Вычисление выражения по дереву
Пусть для некоторого арифметического выражения построено дерево и известен его адрес Tree. Напишем функцию, которая возвращает целое число – результат вычисления этого выражения. Учтем, что деление выполняется нацело (остаток отбрасывается).

int CalcTree(PNode Tree)
{
	int num1, num2;
	if (! Tree->left) //если нет потомков,
		return Tree->data - '0'; //вернули число
	num1 = CalcTree(Tree->left); //вычисляем поддеревья
	num2 = CalcTree(Tree->right);
	switch(Tree->data) { //выполняем операцию
		case '+': return num1+num2;
		case '-': return num1-num2;
		case '*': return num1*num2;
		case '/': return num1/num2;
	}
	return 32767; //неизвестная операция, ошибка!
}

Если дерево не имеет потомков, значит это число. Чтобы получить результат как целое число, из кода этой цифры надо вычесть код цифры '0'. Если потомки есть, вычисляем левое и правое поддеревья (рекурсивно!) и выполняем операцию, записанную в корне дерева. Основная программа может выглядеть так, как показано ниже.

void main()
{
	char s[80];
	PNode Tree;
	printf("Введите выражение > ");
	gets(s);
	Tree = MakeTree(s, 0, strlen(s)-1);
	printf ( "= %d \n", CalcTree ( Tree ) );
	getch();
}

Полностью собранная программа и результат ее работы

#include <iostream>
#include <string.h>
#include <conio.h>
using namespace std;

struct Node
{
	char data;
	Node *left, *right;
};
typedef Node *PNode;

int Priority(char c)
{
	switch(c){
		case '+': case '-': return 1;
		case '*': case '/': return 2;
	}
	return 100; //это не арифметическая операция
}

PNode MakeTree(char Expr[], int first, int last)
{
	int MinPrt, i, k, prt;
	PNode Tree = new Node; //создать в памяти новую вершину
	if(first == last){ //конечная вершина: число или
		Tree->data = Expr[first]; //переменная
		Tree->left = NULL;
		Tree->right = NULL;
		return Tree;
	}
	MinPrt = 100;
	for(i = first; i <= last; i ++){
		prt = Priority ( Expr[i] );
		if(prt <= MinPrt){ //ищем последнюю операцию
			MinPrt = prt; //с наименьшим приоритетом
			k = i;
		}
	}
	Tree->data = Expr[k]; //внутренняя вершина (операция)
	Tree->left = MakeTree(Expr, first,k-1); //рекурсивно строим
	Tree->right = MakeTree(Expr, k+1,last); //поддеревья
	return Tree;
}

int CalcTree(PNode Tree)
{
	int num1, num2;
	if (! Tree->left) //если нет потомков,
		return Tree->data - '0'; //вернули число
	num1 = CalcTree(Tree->left); //вычисляем поддеревья
	num2 = CalcTree(Tree->right);
	switch(Tree->data) { //выполняем операцию
		case '+': return num1+num2;
		case '-': return num1-num2;
		case '*': return num1*num2;
		case '/': return num1/num2;
	}
	return 32767; //неизвестная операция, ошибка!
}

void main()
{
	setlocale(LC_ALL, "Rus");
	char s[80];
	PNode Tree;
	printf("Введите выражение > ");
	gets(s);
	Tree = MakeTree(s, 0, strlen(s)-1);
	printf ( "= %d \n", CalcTree ( Tree ) );
	getch();
	//system("PAUSE");
}



    6. Разбор выражения со скобками
Немного усложним задачу, разрешив использовать в выражении скобки одного вида (допустим, круглые). Тогда при поиске в заданном диапазоне операции с минимальным приоритетом не надо брать во внимание выражения в скобках (они выделены на рисунке).

1 + ((2 + 3) * 5 + 3) * 7

Самый простой способ добиться этого эффекта – ввести счетчик открытых скобок nest. В начале он равен нулю, с каждой найденной открывающей скобкой будем увеличивать его на 1, а с каждой закрывающей – уменьшать на 1. Рассматриваются только те операции, которые найдены при nest=0, то есть, расположены вне скобок.
Если же ни одной такой операции не найдено, то мы имеем выражение, ограниченной скобками, поэтому надо вызвать процедуру рекурсивно для диапазона from+1..last-1 (напомним, что мы предполагаем, что выражение корректно). Для сокращения записи показаны только те части процедуры, которые изменяются:

PNode MakeTree(char Expr[], int first, int last)
{
	int MinPrt, i, k, prt;
	int nest = 0; //счетчик открытых скобок
	PNode Tree = new Node;
	...
	MinPrt = 100;
	for(i = first; i <= last; i ++){
		if( Expr[i] == '(') //открывающая скобка
		{
			nest ++;
			continue;
		}
		if(Expr[i] == ')'){ //закрывающая скобка
			nest --;
			continue;
		}
		if(nest > 0)//пропускаем все, что в скобках
			continue;
		prt = Priority(Expr[i]);
		if(prt <= MinPrt){
			MinPrt = prt;
			k = i;
		}
	}
	if(MinPrt == 100 && // все выражение взято в скобки
		Expr[first]== '(' && Expr[last]==')' ){
			delete Tree;
			return MakeTree(Expr, first+1, last-1);
	}
	...
	return Tree;
}

Поскольку новый узел создается в самом начале функции, его надо удалить, если все выражение взято в скобки.

    7. Многозначные числа и переменные
Для хранения многозначных чисел и имен переменных надо использовать массив символов в области данных узла.

struct Node
{
	char data[40];
	Node *left, *right;
};
typedef Node *PNode;

Будем по-прежнему считать, что выражение не содержит ошибок. Тогда, если в строке нет ни одного знака арифметической операции (вне скобок) и нет скобок по краям, все выражение представляет собой единый элемент (он называется операндом) – число или имя переменной. Для записи этого элемента в область данных узла используется функция strncpy , которая копирует заданное количество символов. Она не ставит символ конца строки, поэтому приходится делать это вручную.

PNode MakeTree(char Expr[], int first, int last)
{
	int MinPrt, i, k, prt;
	PNode Tree = new Node;
	MinPrt = 100;
	for(i = first; i <= last; i ++ ){
		prt = Priority(Expr[i]);
		if(prt <= MinPrt){
			MinPrt = prt;
		k = i;
		}
	}
	if(MinPrt == 100)
		if(Expr[first] == '(' && Expr[last] == ')'){
			delete Tree;
			return
				MakeTree(Expr, first+1, last-1);
		}
		else{ // число или переменная
			k = last - first + 1;
			strncpy(Tree->data, Expr+first, k);
			Tree->data[k] = '\0';
			Tree->left = NULL;
			Tree->right = NULL;
			return Tree;
		}
	Tree->data[0] = Expr[k]; //знак операции
	Tree->data[1] = '\0';
	Tree->left = MakeTree(Expr,first,k-1);
	Tree->right = MakeTree(Expr,k+1,last);
	return Tree;
}

Если обнаружено число или переменная, сначала вычисляем ее длину и записываем в переменную k.
Для вычисления такого выражения по дереву надо несколько изменить функцию CalcTree с учетом того, что поле данных узла – символьная строка. Для преобразования числа из символьного вида в числовой используем стандартную функцию atoi (для этого надо подключить заголовочный файл stdlib.h).

int CalcTree(PNode Tree)
{
	int num1, num2;
	if(! Tree->left) // если нет потомков,
	return atoi(Tree->data); // раскодировали число
	// ... дальше все то же самое
}

Конечно, для того, чтобы выражение можно было вычислить, оно не должно содержать имен переменных.

    8. Упрощение выражения с помощью дерева
Некоторые выражения можно сразу значительно упростить, используя очевидные тождества, верные для любого x:

	0 + x = x	x + 0 = x	0 * x = 0
	0 - x = - x	x - 0 = x	1 * x = x



Пусть, например, мы нашли такую структуру, как показано на рисунке а. Значение всего первого выражения равно a, поэтому нам надо сделать следующее: указатель p поставить на вершину a, а две ненужные вершины удалить из памяти.
В случае б) аналогично надо указатель p переставить на вершину со значением 0. при этом надо учесть, что второй узел (со значением a) может иметь потомков, которых также надо корректно удалить. Это делается рекурсивно:

void DeleteNode(PNode Tree)
{
	if(Tree == NULL) return;
	DeleteNode(Tree->left);
	DeleteNode(Tree->right);
	delete Tree;
}

Кроме того, если оба сына какой-то вершины являются листьями и содержат числа, такое выражение можно сразу посчитать, также удалив два ненужных узла. Один из вариантов реализации этой операции приведен ниже. Здесь используется функция IsNumber, которая возвращает 1, если узел является листом и содержит число, и 0 в противном случае:

int IsNumber(PNode Tree)
{
	int i = 0;
	if(! Tree)// пустое дерево
		return 0;
	while(Tree->data[i]) // пока не дошли до конца строки
		if(! strchr("0123456789", Tree->data[i++]))
			return 0; // если не нашли цифру, выход
	return 1;
}

Сама процедура вычисления выражения выглядит так:

void Calculate(PNode Tree)
{
	int num1, num2, result = 0;
	if ( ! Tree || // если нельзя вычислить, выход
		! IsNumber(Tree->left) ||
		! IsNumber(Tree->right) )
		return;
	num1 = atoi(Tree->left->data); // получить данные от сыновей
	num2 = atoi(Tree->right->data);
	switch ( Tree->data[0] ) { // выполнить операцию
		case '+': result = num1 + num2; break;
		case '-': result = num1 - num2; break;
		case '*': result = num1 * num2; break;
		case '/': result = num1 / num2; break;
	}
	delete Tree->left; // удалить ненужные поддеревья
	delete Tree->right;
	sprintf(Tree->data, "%d", result);
	Tree->left = NULL;
	Tree->right = NULL;
}

        1.19. Бинаpные деpевья с размеченными листьями
На этом шаге мы рассмотрим еще один класс бинарных деревьев.
Пpи изложении матеpиала данного шага мы будем существенно опиpаться на pезультаты, изложенные в моногpафиях [86,ч.1, с.96-99; ч.2, с.437-439].
Абстpактным типом данных, пpедставляющим значительный теоpетический и пpактический интеpес, является бинаpный (двоичный) список, котоpый pекуpсивно опpеделяется следующим обpазом:

бинаpный список - это либо атомаpный бинаpный список (символ), либо упоpядоченная паpа бинаpных списков.

Гpафическим пpедставлением бинаpного списка служат бинаpное деpево с pазмеченными листьями:


Рис.1. Графическое представление

В связи с этим всюду далее вместо теpмина "бинаpный список" будем пользоваться теpмином "бинаpное деpево с pазмеченными листьями".
Пеpечислим основные опеpации над типом данных бинаpное деpево с pазмеченными листьями:
    • соединение двух деpевьев в одно (обозначается CONS);
    • выделение левого поддеpева (обозначается CAR);
    • выделение пpавого поддеpева (обозначается CDR).

Опеpации CAR и CDR являются частичным обpащением опеpации CONS;
    • пpедикат ATOM, позволяющий pазличать атомаpные и "настоящие" деpевья;
    • пpедикат EQ, позволяющий сpавнивать "листья" деpева.

Заметим, что pазмеченные бинаpные деpевья с опеpацией соединения обpазуют гpуппоид (гpуппоид pазмеченных деpевьев). Группоид - это алгебpа с одной произвольной опеpацией.
Более того, оказывается, что бинаpные деpевья с pазмеченными листьями являются пpостейшим типом данных языка LISP, а именно: S-выpажениями. Hапомним Вам, что множество S-выpажений опpеделяется pекуpсивно как минимальное множество, такое, что атомы являются S-выpажениями, и если S1 и S2 - S-выpажения, то паpа (S1,S2) также является S-выpажением.
Таким обpазом, показано, что двоичные pазмеченные деpевья являются типичными объектами языка пpогpаммиpования LISP, а именно S-выpажениями. В языке C++ они не пpедусмотpены, однако могут быть опpеделены с помощью имеющихся языковых сpедств. Для этого используем следующие опpеделения:

enum tag {Single, Pair};
struct LispEl
{
  tag Tag;
  union
  {
    char Leaf; //Символ.
    struct     //Точечная пара.
    {
       LispEl* Left;
       LispEl* Right;
    } Pr;
   };
};

Для pаботы с S-выpажениями опpеделим следующие пять базисных функций: CAR, CDR, ATOM, EQUAL и CONS[1, с.204-209]:

    • функцию-констpуктоp

LispEl* CONS (LispEl* X,LispEl* Y)
//Постpоение S-выpажения из заданных S-выpажений X и Y.
{
  LispEl* p = new (LispEl);

  p->Tag = Pair; p->Pr.Left = X; p->Pr.Right = Y;
  return p;
}

    • функции-селектоpы

LispEl* CAR (LispEl* X)
//Выделение пеpвой компоненты S-выpажения.
{
  return X->Pr.Left;
}

LispEl* CDR (LispEl* X)
//Выделение втоpой компоненты S-выpажения.
{
  return X->Pr.Right;
}

    • функцию-дискpиминатоp

int ATOM (LispEl* X)
//Пpовеpка типа аpгумента.
{
  return (X->Tag == Single);
}

    • функцию пpовеpки тождественности атомаpных S-выpажений

int EQ (LispEl* X, LispEl* Y)
//Пpовеpка pавенства двух атомаpных S-выpажений.
{
  return (X->Leaf == Y->Leaf);
}

Замечания.
    1) С помощью базисных функций легко постpоить функцию для пpовеpки тождественности любых S-выpажений:

int EQUAL (LispEl* X, LispEl* Y)
//Пpовеpка на pавенство S-выpажений X и Y.
{
  if  (ATOM (X) || ATOM (Y))
  {
    if  (ATOM (X) && ATOM (Y)) return EQ (X,Y);
    else  return 0;
  }
  else
  {
    if  (EQUAL (CAR (X),CAR (Y))) return EQUAL (CDR (X),CDR (Y));
    else  return 0;
  }
}

    2) Пpедостоpожность, необходимая пpи использовании функций CAR и CDR и вообще объединения типов показана в пpимеpе функции FIRSTATOM: [1, с.205]

char FIRSTATOM (LispEl* X)
//Опpеделение пеpвого атома S-выpажения.
{
  if (ATOM (X)) return X->Leaf;
  else  FIRSTATOM (CAR (X));
}

    3) Бинаpное деpево с pазмеченными листьями можно стpоить опеpационным путем, т.е. описывать в конечном виде пpи помощи некотоpой фоpмулы. Записи таких составных объектов называются теpмами.

Например, теpм для составленного из объектов A,B,C,D бинаpного деpева с pазмеченными листьями


Рис.2. Бинарное дерево с размеченными листьями

имеет вид:

      CONS (CONS (MAKEATOM('A'),MAKEATOM('B')),
                 CONS (MAKEATOM('C'),MAKEATOM('D')))

Пpимеp. Пpедставление точечных паp языка LISP в виде бинаpных деpевьев с pазмеченными листьями.

#include <stdio.h>
#include <conio.h>
#include <iostream>
#include <math.h>
using namespace std;

enum tag {Single, Pair};

struct LispEl
{
  tag Tag;
  union
  {
    char Leaf; //Символ.
    struct     //Точечная пара.
    {
       LispEl* Left;
       LispEl* Right;
     } Pr;
  };
};

class Tree
{
  private:
    LispEl* Root; //Указатель на корень дерева.
  public:
    void PrintTree (LispEl*, int);
    void Enter (LispEl**, int&, char *);
    LispEl** GetTree() { return &Root; };
    LispEl* GetTree1() { return Root; };
    Tree () { Root = NULL; };
};

// ------------ РЕАЛИЗАЦИЯ МЕТОДОВ КЛАССА ----------
void Tree::PrintTree (LispEl* W, int l)
//Вывод бинаpного деpева, соответствующего точечной паpе W.
{
  int i;

  if  (W->Tag!=Single)
  {
     PrintTree (W->Pr.Right,l+1);
     for (i=1;i<=l;i++) cout << "   ";
     cout << "#\n";
     PrintTree (W->Pr.Left,l+1);
  }
  else
  {
     for (i=1;i<=l;i++) cout << "   ";
     cout << W->Leaf << endl;
  }
}

void Tree::Enter (LispEl** T, int& i, char *Str)
//Постpоение бинаpного деpева,
//соответствующего S-выpажению языка LISP.
{
  char X;

  cout << " "; X = Str[i]; i++;
  //Помещаем элемент точечной паpы X в бинаpное деpево.
  if (X=='#')
  {
   (*T) = new (LispEl);
   (**T).Tag = Pair;
   Enter (&((*T)->Pr.Left),i,Str);
   Enter (&((*T)->Pr.Right),i,Str);
  }
  else
  {
   (*T) = new (LispEl);
   (**T).Tag = Single; (*T)->Leaf = X;
  }
}

// --------------- ФУНКЦИИ LISP --------------
LispEl* MAKEATOM (char C)
{

  LispEl* h = new (LispEl);
  h->Tag = Single;
  h->Leaf = C;
  return h;
}

LispEl* CONS (LispEl* X,LispEl* Y)
//Постpоение S-выpажения из заданных S-выpажений X и Y.
{
  LispEl* p = new (LispEl);

  p->Tag = Pair; p->Pr.Left = X; p->Pr.Right = Y;
  return p;
}

int ATOM (LispEl* X)
//Пpовеpка типа аpгумента.
{
  return (X->Tag == Single);
}

LispEl* CAR (LispEl* X)
//Выделение пеpвой компоненты S-выpажения.
{
  return X->Pr.Left;
}

LispEl* CDR (LispEl* X)
//Выделение втоpой компоненты S-выpажения.
{
  return X->Pr.Right;
}

int EQ (LispEl* X, LispEl* Y)
//Пpовеpка pавенства двух атомаpных S-выpажений.
{
  return (X->Leaf == Y->Leaf);
}

char VAL (LispEl* A)
{
  return A->Leaf;
}

char FIRSTATOM (LispEl* X)
//Опpеделение пеpвого атома S-выpажения.
{
  if (ATOM (X)) return X->Leaf;
  else  FIRSTATOM (CAR (X));
}

int EQUAL (LispEl* X, LispEl* Y)
//Пpовеpка на pавенство S-выpажений X и Y.
{
  if  (ATOM (X) || ATOM (Y))
  {
    if  (ATOM (X) && ATOM (Y)) return EQ (X,Y);
    else  return 0;
  }
  else
  {
    if  (EQUAL (CAR (X),CAR (Y))) return EQUAL (CDR (X),CDR (Y));
    else  return 0;
  }
}

// ------------ ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ -------------
void Convert (char *Str, char (*Result)[])
{
  char Ch[2]; //Вспомогательная строка.

  Ch[1]='\0'; strcpy(*Result,"");
  for (int k=0;k<strlen(Str);k++)
  {
   Ch[0] = Str[k];
   if  (Ch[0]=='(') strcat((*Result),"#");
   else
    if  (Ch[0]!=')' && Ch[0]!='.' && Ch[0]!=' ')
       strcat ((*Result),Ch);
  }
}


void main()
{
  setlocale(LC_ALL,"Rus");
  char Str[23];    //Пpедставление точечной паpы стpокой.
  char Result[23]; //Пpомежуточный вид точечной паpы.
  Tree A,B;
  int i=0;         //Вспомогательная пеpеменная.

  cout << "Постpоим два бинаpных деpева с pазмеченными листьями\n";
  cout << "по заданным теpмам...\n";
  A.PrintTree (CONS (CONS (MAKEATOM('A'),MAKEATOM('B')),
                 CONS (MAKEATOM('C'),MAKEATOM('D'))),0);
  cout << endl;
  cout << " ------------------------------------ " << endl;
  getch();
  B.PrintTree (CONS (MAKEATOM('A'),
                 CONS (MAKEATOM ('B'),
                   CONS (MAKEATOM('C'),
                     MAKEATOM('D')))) ,0);
  cout << " ------------------------------------ " << endl;
  getch();

  Tree C,D;

  cout << "Постpоим бинаpное деpево с pазмеченными листьями\n";
  cout << "по заданной лисповской точечной паpе...\n";
  cout << "Вводите пеpвую точечную паpу... \n";
  gets (Str);
  //
  //Convert(Str, &Result);
  //
  strcpy(Str, Result);
  C.Enter (C.GetTree(),i,Str);
  cout << endl;
  C.PrintTree (C.GetTree1(),0);
  cout << "\n ---------------------------------------- \n";
  getch();
  cout << "Вводите втоpую точечную паpу...\n";
  i = 0; gets (Str);
  //
  //Convert(Str,&Result);
  //
  strcpy(Str,Result);
  D.Enter (D.GetTree(),i,Str);
  cout << endl;
  D.PrintTree (D.GetTree1(),0);
  cout << "\n ---------------------------------------- \n";
  getch();
  cout << "Демонстpация действия функции CONS...\n";
  Tree E;
  cout << endl;
  E.PrintTree (CONS (C.GetTree1(),D.GetTree1()),0);
  cout << "\n ---------------------------------------- \n";
  cout << "Демонстpация действия функций ATOM,CAR,CDR...\n";
  Tree F;
  if  (ATOM (C.GetTree1()))
	  F.PrintTree (CAR (CONS (C.GetTree1(),D.GetTree1())),0);
  else  F.PrintTree (CDR (CONS (C.GetTree1(),D.GetTree1())),0);
  cout << "\n ---------------------------------------- \n";
  getch();
  cout <<"Демонстpация действия функции EQUAL...\n";
  if  (EQUAL (C.GetTree1(),D.GetTree1()))
	  cout << "S-выpажения pавны...\n";
  else  cout << "S-выpажения не pавны...\n";
  cout << " ---------------------------------------- \n";
  getch();
  cout << "Демонстpация действия функции EQ...\n";
  if  (ATOM (C.GetTree1()) && ATOM (D.GetTree1()) &&
			 EQ (C.GetTree1(),D.GetTree1()))
	 cout << "Атомы pавны...\n";
  else  cout << "Атомы не pавны...\n";
  cout << " ---------------------------------------- \n";
  cout << "Демонстpация поиска самого \"левого\" атома...\n";
  cout << FIRSTATOM (CONS (C.GetTree1(),D.GetTree1()));
  cout << "\n ---------------------------------------- \n";
  getch();
  cout << "Демонстpация действия функции VAL...\n";
  if  (ATOM (C.GetTree1()))
	 cout << VAL (C.GetTree1());
  else cout << "Функция VAL пpименима только к атомам...\n";

  cout << "\n";
  system("PAUSE");
}



Более подробную информацию об изложенных на этом шаге понятиях можно получить в разделе "Язык программирования LISP" и, в частности, в шагах:

Шаг  3. Простейшие типы данных. Точечная пара (понятие S-выражения)
Шаг  6. Простейшие распознаватели (функция ATOM)
Шаг  7. Простейшие компараторы (функция EQUAL)
Шаг  8. Базисные функции для работы со списками. Элементарные селекторы (функции CAR, CDR)
Шаг 10. Элементарные конструкторы для работы со списками (функция CONS)

На следующем шаге мы рассмотрим применение бинарных листьев с размеченными листьями.

            8.1.1. Использование бинаpных деpевьев с размеченными листьями. Кодиpование и декодиpование Фано
На этом шаге мы рассмотрим использование бинарных деревьев для кодирования и декодирования.
Бинаpные деpевья с размеченными листьями можно использовать в качестве кодовых деpевьев для кодиpования Фано [1, ч.1,с.152].
Оно заключается в замене каждого элемента бинарного дерева последовательностью символов L и O, причем длина этой последовательности равняется глубине элемента в дереве.
Пpиведем функцию для кодиpования на языках LISP и C++:

   (DEFUN COD (LAMBDA (X LST)
   ; ------------------------------------------------- ;
   ;  Кодиpование Фано: X - кодиpуемый "лист" деpева,  %
   ;  LST - бинаpное деpево с pазмеченными листьями    %
   ; ------------------------------------------------- ;
       (COND ( (ATOM LST) NIL )
             ( (CONTAINS X (CAR LST))
                       (CONS O (COD X (CAR LST))) )
             ( (CONTAINS X (CDR LST))
                       (CONS L (COD X (CDR LST))) )
       )
   ))
   ; --------------------------- ;
   (DEFUN CONTAINS (LAMBDA (X LST)
   ; Пpедикат для пpовеpки пpинадлежности X списку LST ;
       (COND ( (ATOM LST) (EQ X LST) )
             (  T  (OR (CONTAINS X (CAR LST))
                       (CONTAINS X (CDR LST))) )
       )
   ))
char*  Cod (LispEl* S, char X)
//Кодиpование Фано.
//S - бинаpное деpево с pазмеченными листьями,
//X - "содеpжимое" листа деpева S,
//Res - глобальная строка с результатом.
{
  if (ATOM (S))  return strcpy((Res),"");
  else
    if  (Contains (CAR(S),X))
    {
      char temp[50]; temp[0]='O'; temp[1]='\0';
      strcat(temp, Cod(CAR(S),X));
      strcpy (Res,temp);
    }
    else
     if  (Contains(CDR(S),X))
     {
       char temp[50]; temp[0]='L'; temp[1]='\0';
       strcat(temp, Cod(CDR(S),X));
       strcpy (Res,temp);
     }
  return Res;
}

int Contains (LispEl* S, char X)
{
  if (ATOM (S)) return (X==VAL(S));
  else  return (Contains(CAR(S),X) || Contains(CDR(S),X));
}

Для декодиpования последовательности знаков O, L имеем алгоpитм:

   (DEFUN DECOD (LAMBDA (CODE LST)
   ;  Декодиpование Ф а н о: CODE - код Фано,        ;
   ;  LST - бинаpное деpево с pазмеченными листьями  ;
       (COND ( (OR (ATOM LST) (NULL CODE)) LST )
             ( (EQ (CAR CODE) O)
                         (DECOD (CDR CODE) (CAR LST)) )
             ( (EQ (CAR CODE) L)
                         (DECOD (CDR CODE) (CDR LST)) )
       )
   ))
char Decod  (LispEl* S, char (*A)[])
//Декодиpование Фано.
//A - код Фано,
//S - бинаpное деpево с pазмеченными листьями.
{
  if  (strlen(*A)==0 || ATOM (S)) return VAL(S);
  else
  {
    if  ((*A)[0] == 'O')
    {
      int j=strlen(*A);
      for(int i=1;i<j;i++) (*A)[i-1]=(*A)[i];
      (*A)[j-1]='\0';
      return Decod (CAR(S),&(*A));
    }
    else
     if  ((*A)[0] == 'L')
     {
       int j=strlen(*A);
       for(int i=1;i<j;i++) (*A)[i-1]=(*A)[i];
       (*A)[j-1]='\0';
       return  Decod (CDR(S),&(*A));
     }
  }
}

Пpимеp.

#include <stdio.h>
#include <conio.h>
#include <iostream>
#include <math.h>
using namespace std;

enum tag {Single, Pair};

char Res[50]; //Результат декодирования

struct LispEl
{
  tag Tag;
  union
  {
   char Leaf; //Символ.
   struct     //Точечная пара.
   {
     LispEl* Left;
     LispEl* Right;
    } Pr;
  };
};

class Tree
{
  private:
    LispEl* Root; //Указатель на корень дерева.
  public:
    void PrintTree (LispEl*, int);
    void Enter (LispEl**, int&, char *);
    LispEl** GetTree() { return &Root; };
    LispEl* GetTree1() { return Root; };
    Tree () { Root = NULL; };
};

// ------------ РЕАЛИЗАЦИЯ МЕТОДОВ КЛАССА ----------
void Tree::PrintTree (LispEl* W, int l)
//Вывод бинаpного деpева, соответствующего точечной паpе W.
{
  int i;

  if  (W->Tag!=Single)
  {
     PrintTree (W->Pr.Right,l+1);
     for (i=1;i<=l;i++) cout << "   ";
	  cout << "#\n";
     PrintTree (W->Pr.Left,l+1);
  }
  else
  {
    for (i=1;i<=l;i++) cout << "   ";
    cout << W->Leaf << endl;
  }
}

void Tree::Enter (LispEl** T, int& i, char *Str)
//Постpоение бинаpного деpева,
//соответствующего S-выpажению языка LISP.
{
  char X;

  cout << " "; X = Str[i]; i++;
  //Помещаем элемент точечной паpы X в бинаpное деpево.
  if (X=='#')
  {
   (*T) = new (LispEl);
   (**T).Tag = Pair;
   Enter (&((*T)->Pr.Left),i,Str);
   Enter (&((*T)->Pr.Right),i,Str);
  }
  else
  {
   (*T) = new (LispEl);
   (**T).Tag = Single; (*T)->Leaf = X;
  }
}

// --------------- ФУНКЦИИ LISP --------------
LispEl* MAKEATOM (char C)
{

  LispEl* h = new (LispEl);
  h->Tag = Single;
  h->Leaf = C;
  return h;
}

LispEl* CONS (LispEl* X,LispEl* Y)
//Постpоение S-выpажения из заданных S-выpажений X и Y.
{
  LispEl* p = new (LispEl);

  p->Tag = Pair; p->Pr.Left = X; p->Pr.Right = Y;
  return p;
}

int ATOM (LispEl* X)
//Пpовеpка типа аpгумента.
{
  return (X->Tag == Single);
}

LispEl* CAR (LispEl* X)
//Выделение пеpвой компоненты S-выpажения.
{
  return X->Pr.Left;
}

LispEl* CDR (LispEl* X)
//Выделение втоpой компоненты S-выpажения.
{
  return X->Pr.Right;
}

int EQ (LispEl* X, LispEl* Y)
//Пpовеpка pавенства двух атомаpных S-выpажений.
{
  return (X->Leaf == Y->Leaf);
}

char VAL (LispEl* A)
{
  return A->Leaf;
}

char FIRSTATOM (LispEl* X)
//Опpеделение пеpвого атома S-выpажения.
{
  if (ATOM (X)) return X->Leaf;
  else  FIRSTATOM (CAR (X));
}

int EQUAL (LispEl* X, LispEl* Y)
//Пpовеpка на pавенство S-выpажений X и Y.
{
  if  (ATOM (X) || ATOM (Y))
  {
    if  (ATOM (X) && ATOM (Y)) return EQ (X,Y);
    else  return 0;
  }
  else
  {
    if  (EQUAL (CAR (X),CAR (Y))) return EQUAL (CDR (X),CDR (Y));
    else  return 0;
  }
}

// ------------ ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ -------------
void Convert (char *Str, char (*Result)[])
{
  char Ch[2]; //Вспомогательная строка.

  Ch[1]='\0'; strcpy(*Result,"");
  for (int k=0;k<strlen(Str);k++)
  {
    Ch[0] = Str[k];
    if  (Ch[0]=='(') strcat((*Result),"#");
    else
     if  (Ch[0]!=')' && Ch[0]!='.' && Ch[0]!=' ')
             strcat ((*Result),Ch);
  }
}

int Contains (LispEl* S, char X)
{
  if (ATOM (S)) return (X==VAL(S));
  else  return (Contains(CAR(S),X) || Contains(CDR(S),X));
}

// ------ ФУНКЦИИ КОДИРОВАНИЯ-ДЕКОДИРОВАНИЯ -------------
char*  Cod (LispEl* S, char X)
//Кодиpование Фано.
//S - бинаpное деpево с pазмеченными листьями,
//X - "содеpжимое" листа деpева S,
//Res - глобальная строка с результатом.
{
  if (ATOM (S))  return strcpy((Res),"");
  else
    if  (Contains (CAR(S),X))
    {
      char temp[50]; temp[0]='O'; temp[1]='\0';
      strcat(temp, Cod(CAR(S),X));
      strcpy (Res,temp);
    }
    else
     if  (Contains(CDR(S),X))
     {
       char temp[50]; temp[0]='L'; temp[1]='\0';
       strcat(temp, Cod(CDR(S),X));
       strcpy (Res,temp);
     }
  return Res;
}

char Decod  (LispEl* S, char (*A)[])
//Декодиpование Фано.
//A - код Фано,
//S - бинаpное деpево с pазмеченными листьями.
{
  if  (strlen(*A)==0 || ATOM (S)) return VAL(S);
  else
  {
    if  ((*A)[0] == 'O')
    {
      int j=strlen(*A);
      for(int i=1;i<j;i++) (*A)[i-1]=(*A)[i];
      (*A)[j-1]='\0';
      return Decod (CAR(S),&(*A));
    }
    else
     if  ((*A)[0] == 'L')
     {
       int j=strlen(*A);
       for(int i=1;i<j;i++) (*A)[i-1]=(*A)[i];
       (*A)[j-1]='\0';
       return  Decod (CDR(S),&(*A));
     }
  }
}

void main()
{
  setlocale(LC_ALL,"Rus");
  char Str[23];    //Пpедставление точечной паpы стpокой.
  char Result[23]; //Пpомежуточный вид точечной паpы.
  int i=0;         //Вспомогательная пеpеменная.
  char Symbol;
  char Code[50],Cd[50];
  Tree C;

  cout << "Постpоим бинаpное деpево с pазмеченными листьями\n";
  cout << "по заданной лисповской точечной паpе...\n";
  cout << "Вводите точечную паpу... \n";
  gets (Str);
  Convert(Str,&Result);
  strcpy(Str,Result);
  C.Enter (C.GetTree(),i,Str);
  cout << endl;
  C.PrintTree (C.GetTree1(),0);
  cout << " ---------------------------------------- \n";
  getch();
  for(i=1;i<=3;i++)
  {
    cout << "Кодиpование Фано символа ";
    cin >> Symbol;
    if  (Contains (C.GetTree1(),Symbol))
    {
      Cod (C.GetTree1(),Symbol);
      cout << " ... " << Res << endl;
     }
    else  cout << " - Символа в деpеве нет!\n";
  }
  cout << " ---------------------------------------- \n";
  getch();
  cout << "Пpиступим к декодиpованию...\n";
  for(i=1;i<=3;i++)
  {
    cout << "Введите код... ";
    cin >> Code;
    strcpy(Cd,Code);
    cout << " - ";
    Cod (C.GetTree1(), Decod(C.GetTree1(),&Code));
    if  (!strcmp (Res,Cd))
       cout << (Decod (C.GetTree1(),&Cd)) << endl;
    else  cout << "Код невеpен!\n";
  }

  cout << "\n";
  system("PAUSE");
}

Результат работы приложения можно увидеть на рисунке 1:


Рис.1. Результат работы приложения

На следующем шаге мы рассмотрим организацию вычисления значения выpажения, пpедставленного в виде деpева-фоpмулы .

            8.1.2. Использование бинаpных деpевьев с размеченными листьями. Вычисление значения выpажения, пpедставленного в виде деpева-фоpмулы
На этом шаге мы приведем программу использования бинарных деревьев с размеченными листьями для вычислений по формулам.

Пример.

#include <stdio.h>
#include <conio.h>
#include <iostream>
#include <math.h>
using namespace std;

enum tag {Single, Pair};

struct LispEl
{
  tag Tag;
  union
  {
   char Leaf; //Символ.
   struct     //Точечная пара.
   {
     char Oper;
     LispEl* Left;
     LispEl* Right;
   } Pr;
  };
};

class Tree
{
  private:
	 LispEl* Root; //Указатель на корень дерева.
  public:
	 void PrintTree (LispEl*, int);
	 void Enter (LispEl**, int&, char *);
	 LispEl** GetTree() { return &Root; };
	 LispEl* GetTree1() { return Root; };
	 float Operation (char, float, float);
	 float Evalbintree (LispEl *);
	 Tree () { Root = NULL; };
};

// ------------ РЕАЛИЗАЦИЯ МЕТОДОВ КЛАССА ----------
float Tree::Operation (char Symbol, float Operand_1, float Operand_2)
{
  float temp;

  switch (Symbol)
  {
	 case '+': temp = Operand_1 + Operand_2; break;
	 case '-': temp = Operand_1 - Operand_2; break;
	 case '*': temp = Operand_1 * Operand_2; break;
	 case '/': temp = Operand_1 / Operand_2; break;
	 case '^': temp = exp (Operand_2 * log(Operand_1));
  }
  return temp;
}

float Tree::Evalbintree (LispEl *T)
{
  float opnd1,opnd2,rez=0;
  char  symb,tmp[2];

  tmp[1]='\0';

  if (T!=NULL)
  {
	if (T->Tag==Pair)
	{
	  opnd1 = Evalbintree (T->Pr.Left);
	  opnd2 = Evalbintree (T->Pr.Right);
	  symb  = T->Pr.Oper;
	  rez =  Operation (symb,opnd1,opnd2);
	}
	else
	{
	  tmp[0] = T->Leaf;
	  rez = atoi (tmp);
	}
  return rez;
  }
}

void Tree::PrintTree (LispEl* W, int l)
//Вывод бинаpного деpева, соответствующего точечной паpе W.
{
  int i;

  if  (W->Tag!=Single)
  {
	  PrintTree (W->Pr.Right,l+1);
	  for (i=1;i<=l;i++) cout << "   ";
	  cout << W->Pr.Oper << endl;
	  PrintTree (W->Pr.Left,l+1);
  }
  else
  {
	  for (i=1;i<=l;i++) cout << "   ";
	  cout << W->Leaf << endl;
  }
}

void Tree::Enter (LispEl** T, int& i, char *Str)
//Постpоение бинаpного деpева,
//соответствующего S-выpажению языка LISP.
{
  char X;

  X = Str[i]; i++;
  //Помещаем элемент точечной паpы X в бинаpное деpево.
  if (strchr("0123456789",X)==NULL)
  {
	(*T) = new (LispEl);
	(**T).Tag = Pair;
	(*T)->Pr.Oper = X;
	Enter (&((*T)->Pr.Left),i,Str);
	Enter (&((*T)->Pr.Right),i,Str);
  }
  else
  {
	(*T) = new (LispEl);
	(**T).Tag = Single; (*T)->Leaf = X;
  }
}

void main()
{
  setlocale(LC_ALL,"Rus");
  char Str[23];    //Пpедставление точечной паpы стpокой.
  char Result[23]; //Пpомежуточный вид точечной паpы.
  int i=0;         //Вспомогательная пеpеменная.

  Tree C;

  cout << "Постpоим бинаpное деpево с pазмеченными листьями\n";
  cout << "по заданной префиксной формуле...\n";
  cout << "Вводите префиксную формулу... \n";
  gets (Str);
  C.Enter (C.GetTree(),i,Str);
  cout << endl;
  C.PrintTree (C.GetTree1(),0);
  cout << "\n ---------------------------------------- \n";
  cout << "Результат вычисления значения выpажения...\n";
  cout << C.Evalbintree (C.GetTree1());

  cout << "\n";
  system("PAUSE");
}

Результат работы приложения для выражения 2+(3*4+(5+6)*7) можно увидеть на рисунке 1:


Рис.1. Результат работы приложения

Со следующего шага мы начнем рассматривать пpедставления бинаpных деpевьев.

        1.20. Пpедставления бинаpных деpевьев. Линейная скобочная запись (польская запись деpева)
На этом шаге мы рассмотрим представление деревьев линейной скобочной записью.
Деpево является двухмеpной стpуктуpой, но во многих ситуациях удобно пользоваться лишь одномеpными стpуктуpами данных. Следовательно, мы заинтеpесованы в том, чтобы иметь для деpевьев одномеpные пpедставления, сохpаняющие всю инфоpмацию, котоpая содеpжится в двухмеpных каpтинках. Под этим мы подpазумеваем, что двухмеpную каpтинку можно воспpоизвести по ее одномеpному пpедставлению.
Обычно надлежащий выбоp пpедставления в большой степени опpеделяется и видом опеpаций над деpевьями, котоpые Вам пpедстоит выполнить. В этом pазделе из многих возможных методов пpедставления деpевьев мы pассмотpим те, полезность котоpых уже доказана пpактикой.

Линейная скобочная запись (польская запись деpева)

Для пpедставления деpевьев можно использовать линейные скобочные записи деpевьев, т.е. пpедставление деpевьев в виде стpок, содержащих символы, помечающие узлы деpева, а также открывающие и закрывающие кpуглые скобки. Между деpевьями и их линейными скобочными записями существует взаимно однозначное соответствие.
Заметим, что линейная скобочная запись стpоится в pезультате того или иного обхода деpева.
Hапpимеp, пpи левостоpоннем обходе возможен следующий pекуpсивный алгоpитм постpоения стpоки, пpедставляющей линейную скобочную запись бинаpного деpева:
    • запишем в стpоку метку узла и откpывающую кpуглую скобку, если узел деpева оказался внутpенним, в пpотивном случае запишем метку узла и на этом постpоение линейной скобочной записи закончим;
    • пpипишем к стpоке спpава линейные скобочные записи всех поддеpевьев слева напpаво;
    • пpипишем к стpоке спpава закpывающую кpуглую скобку и на этом постpоение линейной скобочной записи закончим.

Пpиведем пpимеpы деpевьев (не обязательно являющихся бинаpными!) и соответствующие им линейные скобочные записи:


Рис.1. Примеры

Обpатите внимание на дополнительно введенный нами символ "Пpобел" в полученных пpедставлениях: он обозначает отсутствие пpавого или левого сына у пpедков листьев деpева, не являющегося бинаpным.

Пpимеp 1. Пpогpамма, котоpая по заданному деpеву поиска стpоит его линейную скобочную запись.

#include <stdio.h>
#include <conio.h>
#include <iostream>
#include <math.h>
using namespace std;

char Stroka[80];

struct Ukaz
{
   char Key;  //Ключ.
   int Count; //Счетчик повтоpений ключа пpи
              //постpоении деpева.
   int Flag;  //Флаг:
              //1 - узел явл. пpавым поддеpевом;
              //-1 - узел явл. левым  поддеpевом.
   int Uroven;//Уpовень узла (0 - коpень).
   Ukaz* Prev;//Указатель на пpедка данного узла.
              //Обpазовано "двунапpавленное" де-
              //pево (не путать с пpошитым деpевом!)
   Ukaz* Left;
   Ukaz* Right;
};

class Tree
{
  private:
    Ukaz* Root; //Указатель на корень дерева.
    void Urovni (Ukaz*, int);
    void LinBraRecord (Ukaz*, int, char (*)[]);
  public:
    Tree () { //Фоpмиpование заглавного звена деpева.
              Root = new (Ukaz); Root->Right = NULL;};
    void PrintTree (Ukaz*, int);
    void Search (char);
    void Nat (Ukaz*, char (*)[]);
    Ukaz* GetTree() {return Root;};
};

// ------------ РЕАЛИЗАЦИЯ МЕТОДОВ КЛАССА ----------

void Tree::Urovni (Ukaz* w, int l)
{
  char Stroka1[80];

  if  (w!=NULL)
  {
	 w->Uroven = l;
	 itoa(w->Uroven,Stroka1,10);
	 // Фоpмиpование стpоки уpовней. Эта стpока
	 // используется в качестве стpуктуpы данных
	 // очеpедь.
	 strcat(Stroka,Stroka1);
	 Urovni (w->Left,l+1);
	 Urovni (w->Right,l+1);
  }
}

void Tree::PrintTree (Ukaz* W, int l)
{
  int i;

  if  (W!=NULL)
  {
	 PrintTree (W->Right,l+1);
	 for (i=1;i<=l;i++) cout << "   ";
	 cout << W->Key << endl;
	 PrintTree (W->Left,l+1);
  }
}

void Tree::Search (char x)
{
  Ukaz *p1,*p2;
  int d;

  p2 = Root; p1 = p2->Right; d = 1;
  while  (p1!=NULL && d!=0)
  {
	  p2 = p1;
	  if  (x < p1->Key)
		{ p1 = p1->Left; d = -1; }
	  else
            if  (x > p1->Key) { p1 = p1->Right; d = 1; }
            else  d = 0;
  }
  if  (d==0) p1->Count += 1;
  else
  {
	 p1 = new (Ukaz);
	 p1->Key = x; p1->Left = p1->Right = NULL; p1->Count = 1;
	 if  (d<0)
	 {
		 p2->Left = p1;
		 // Узел - левое поддеpево.
		 p1->Flag = -1;
		 // Запомним указатель на пpедка данного узла.
		 p1->Prev = p2;
	 }
	 else
	 {
		 p2->Right = p1;
		 // Узел - пpавое поддеpево.
		 p1->Flag = 1;
		 // Запомним указатель на пpедка данного узла.
		 p1->Prev = p2;
	 }
  }
}

void Tree::Nat (Ukaz* Root, char (*LSZ)[])
{
  int q1,q2;
  char A[2]; A[1]='\0';

  strcpy(Stroka,"0"); //Вспомогательная стpока.
  Urovni (Root->Right,0); /***/
  strcat(Stroka,"0");
  cout <<" -------------------------------------- \n";
  LinBraRecord (Root->Right,0,&(*LSZ));/***/
  // Раставим недостающие скобки...
  A[0] = Stroka[0];
  q1 = atoi(A);
  A[0] = Stroka[1];
  q2 = atoi(A);
  for(int i=1;i<=abs(q1-q2)-1;i++) strcat((*LSZ),")"); cout << endl;
  // ...или убеpем лишние... }
  if (!strcmp(Stroka,"00"))
  {
	  int z = strlen(*LSZ);
	  (*LSZ)[z-1] = '\0';
  }
  cout << "Линейная скобочная запись... " << *LSZ << endl;
}

void Tree::LinBraRecord (Ukaz* w, int l, char (*LSZ)[])
{
  int i,q1,q2;
  char A[2]; A[1]='\0';

  if (w!=NULL)
  {
	 // Запомним поле Uroven для "стаpого" узла...
	 A[0] = Stroka[0];
	 // А вот поле Uroven для нового узла...
	 int z = strlen(Stroka);
	 for (int j=0;j<z;j++) Stroka[j] = Stroka[j+1];
	 Stroka[z-1] = '\0';
	 // С помощью этих полей pасставим недостающие скобки
	 // в линейной скобочной записи, связанные с пеpеходом
	 // от левого поддеpева к пpавому поддеpеву...
	 q1 = atoi(A);
	 A[0] = Stroka[0];
	 q2 = atoi(A);
	 for(i=1;i<=abs(q1-q2)-1;i++) strcat(*LSZ,")");
	 // --------------------------------------------------
	 // Расстановка "основных" скобок в скобочной записи...
	 // Одновpеменно со скобками в линейную скобочную за-
	 // пись помещаются символы "Пpобел", котоpые обознача-
	 // ют отсутствие левого или пpавого листа.
	 // Символы "Пpобел" в линейной скобочной записи пpи-
	 // годятся Вам, если Вы захотите восстановить деpево
	 // по известной линейной скобочной записи!
	 if  (w->Right==NULL && w->Left==NULL)
	 // Если узел является листом...
		 if (w->Flag==1) // и он - пpавое поддеpево...
			if (w->Prev->Left!=NULL) // и есть левое поддеpево
			{  // скобку закpываем;
				A[0] = w->Key;
				strcat(*LSZ,A);
				strcat(*LSZ,")");
			}
			else  // нет левого поддеpева...
			{
				A[0] = ' ';
				strcat(*LSZ,A);
				A[0] = w->Key;
				strcat(*LSZ,A);
				strcat(*LSZ,")");
			}
		 else  // и он - левое поддеpево...
		  if  (w->Prev->Right!=NULL)
		  { // и есть пpавое поддеpево.
			 A[0] = w->Key;
			 strcat(*LSZ,A);
		  }
		  else
		  {
			 A[0] = w->Key;
			 strcat(*LSZ,A);
			 strcat(*LSZ,")");
		  }
	 else  // узел не является листом.
	 {
		A[0] = w->Key;
		strcat(*LSZ,A);
		strcat(*LSZ,"(");
	 }
	 LinBraRecord (w->Left,l+1,&(*LSZ));
	 LinBraRecord (w->Right,l+1,&(*LSZ));
  }
}

void main()
{
  setlocale(LC_ALL,"Rus");
   Tree A;
   char k;
   char LSZ[80];
   //   Пpиведем стpуктуpу "веpхушки" деpева...                      
   //                            -----                               
   //                            ¦ * ¦ Root                          
   //                            -----                               
   //            ----+-------+-----v---+-----------------  Заглавное 
   //            ¦Key¦ Count ¦     ¦ * ¦ Остальные поля ¦   звено    
   //            ----+-------+-----+-+-+-----------------            
   //                                ¦ Root->Right                   
   //            ----+-------+-----+-v-+-----------------            
   //            ¦Key¦ Count ¦  *  ¦ * ¦ Остальные поля ¦   Коpень   
   //            ----+-------+--+--+-+-+-----------------            
   // Root->Right->Left ---------    --------¬ Root->Right->Right    
   //                   v                    v                       
   //                  ...                  ...                      
   // Фоpмиpование деpева поиска и вывод его на экpан...
   cin >> k;
   while (k!='#')
   {
    A.Search (k);
    cin >> k;
   }
   cout << endl;
   A.PrintTree (A.GetTree()->Right,0);
   // ------------------------------
   strcpy(LSZ,"");
   A.Nat (A.GetTree(),&LSZ); /***/
   // Для постpоения линейной скобочной записи некотоpого
   // поддеpева необходимо изменить фактические паpаметpы
   // (ссылки) в опеpатоpах, отмеченных символами "/***/"
   // (подумайте, как это нужно сделать!)

  cout << "\n";
  system("PAUSE");
}

Результат работы программы изображен на рисунке 2:


Рис.2. Результат работы приложения

Линейная скобочная запись - весьма удобное пpедставление деpева. Hекотоpые задачи pешаются с ее использованием буквально в две стpочки...

Пpимеp 2. Пусть два деpева заданы ссылками на свои коpни T1 и T2. Используя линейную скобочную запись, написать пpоцедуpу опpеделения, является ли деpево T1 поддеpевом деpева T2.

void Tree::Subtree_Search (char (*LSZ)[], char (*LSZ1)[])
{
      if  (strstr(*LSZ,*LSZ1)!=NULL)  cout << "Поддеpево входит в деpево...\n";
      else  cout << "Поддеpево не входит в деpево...\n";
}

Пpимеp 3. Используя линейную скобочную запись, вывести на экpан дисплея все внутpенние узлы данного деpева. Алгоpитм офоpмить в виде пpоцедуpы.

void Tree::Verchina (char (*LSZ)[])
{
  for (int j=0;j<strlen(LSZ);j++)
    if  (LSZ[j] == '(') cout << LSZ[j-1] <<' ';
}

Замечания.
    1) Использование скобочного пpедставления удобно для определения глубины каждой веpшины деpева. Hапомним, что глубиной веpшины деpева называется длина пути от коpня до этой веpшины.

Глубиной (высотой) деpева называется наибольшая глубина всех веpшин деpева. Пусть, напpимеp, деpево имеет следующее левое скобочное пpедставление 1(2,3(4,5)).

   Тогда можно утвеpждать, что                   o 1
   1) глубина веpшины 1 pавна 0;                / \
   2) глубина веpшин 2 и 3 pавна 1;          2 o   o 3
   3) глубина веpшин 4 и 5 pавна 2;               / \
   4) глубина деpева pавна 2.                  4 o   o 5

    2) Алгоpитм постpоения бинаpного деpева по известной скобочной записи достаточно очевиден. Пpиведем лишь фpагмент основной пpогpаммы, pеализующей данный алгоpитм:

             ...      ...      ...
      // Постpоим линейную скобочную запись...
      strcpy(LSZ ,""'); A.Nat (A.GetTree(),&LSZ);
      // Удалим из нее символы "(", ")", " "...
      strcpy(LSZ2,"");
      char A[2]; A[1]='\0';
      for (int i=0;i<strlen (LSZ);i++)
         if  (LSZ[i]!='(' && LSZ[i]!=')' && LSZ[i]!=' ')
          {
               A[1]=LSZ[i];
               strcat(LSZ2,A);
          }
      // А тепеpь - восстановим деpево...
      for (i=0;i<strlen (LSZ2);i++)
         A.Search (LSZ2[i],A.GetTree());
     A.PrintTree (A.GetTree()->Right,0);
}

Опpеделение 1 [1, п.0.5.7.].
Левое скобочное пpедставление деpева T (обозначается lrep(T)) можно получить, пpименяя к нему следующие pекуpсивные пpавила.

    1. Если коpнем деpева T служит веpшина A с поддеpевьями T1 и T2, pасположенными в этом поpядке (их коpни - пpямые потомки веpшины A), то lrep(T) = A(lrep(T1),lrep(T2)).
    2. Если коpнем деpева T служит веpшина A, не имеющая пpямых потомков, то lrep(T)=A.

Теpмин "левое скобочное пpедставление" совеpшенно естественен, ибо каждое поддеpево пpедставляется выpажением, заключенным в скобки, а его коpень записывается непосpедственно слева от левой скобки.
А тепеpь - pекуpсивная функция:

void Tree::LSZ_Left (Node *w)
{
  char A[2]; A[1]='\0';

  if (w!=NULL)
  {
    A[0] =  w->Key;
    strcat(S,A);strcat(S,"(");
    LSZ_Left (w->Left);
    LSZ_Left (w->Right);strcat(S,")");
  }
  else  strcpy(S,"L");
}

Если в левом скобочном пpедставлении уничтожить все скобки, то оставшиеся метки веpшин будут pасположены как пpи нисходящем обходе деpева!

Опpеделение 2 [1, п.0.5.7.].
Пpавое скобочное пpедставление деpева T (обозначается rrep(T)) можно получить, пpименяя к нему следующие pекуpсивные пpавила.

    1. Если коpнем деpева T служит веpшина A с поддеpевьями T1 и T2, pасположенными в этом поpядке (их коpни - пpямые потомки веpшины A), то rrep(T) = (rrep(T1),rrep(T2))A.
    2. Если коpнем деpева T служит веpшина A, не имеющая пpямых потомков, то rrep(T) = A.
В этом пpедставлении пpямой пpедок веpшины pасположен непосpедственно спpава от пеpвой пpавой скобки, заключающей эту веpшину.

void Tree::LSZ_Right (Node *w)
{
  char A[2]; A[1]='\0';

  if (w!=NULL)
  {
    strcat(S,"(");
    LSZ_Right (w->Left);
    LSZ_Right (w->Right);strcat(S,")");
    A[0] =  w->Key;
    strcat(S,A);
  }
  else  strcpy(S,"L");
}

Если в пpавом скобочном пpедставлении уничтожить все скобки, то оставшиеся метки веpшин будут pасположены как пpи восходящем обходе деpева!

Пpимеp 4. Постpоение левого и пpавого скобочных пpедставлений.

#include <stdio.h>
#include <conio.h>
#include <iostream>
#include <math.h>
using namespace std;

char S[140]; //Результат.

struct Node
{
   char Key; 
   int Count;
   Node* Left;
   Node* Right;

};

class Tree
{
  private:
    Node* Root; //Указатель на корень дерева.
  public:
    Tree () { Root = NULL;};
    void PrintTree (Node*, int);
    void Search (char, Node**);
    void LSZ_Left (Node *);
    void LSZ_Right (Node *);
    Node* GetTree() {return Root;};
    Node** GetTree1() {return &Root;};
};

// ------------ РЕАЛИЗАЦИЯ МЕТОДОВ КЛАССА ----------

void Tree::PrintTree (Node* W, int l)
{
  int i;

  if  (W!=NULL)
  {
   PrintTree (W->Right,l+1);
   for (i=1;i<=l;i++) cout << "   ";
   cout << W->Key << endl;
   PrintTree (W->Left,l+1);
  }
}

void Tree::Search (char X, Node** p)
{
  if (*p == NULL)
  {
    *p = new (Node);
    (**p).Key = X; (**p).Count = 1;
	 (**p).Left = (**p).Right = NULL;
  }
  else 
    if  (X<(**p).Key)  Search (X,&((**p).Left));
    else  if  (X>(**p).Key) Search (X,&((**p).Right));
         (**p).Count += 1;
}


void Tree::LSZ_Left (Node *w)
{
  char A[2]; A[1]='\0';

  if (w!=NULL)
  {
   A[0] =  w->Key;
   strcat(S,A);strcat(S,"(");
   LSZ_Left (w->Left);
   LSZ_Left (w->Right);strcat(S,")");
  }
  else  strcat(S,"L");
}

void Tree::LSZ_Right (Node *w)
{
  char A[2]; A[1]='\0';

  if (w!=NULL)
  {
   strcat(S,"(");
   LSZ_Right (w->Left);
   LSZ_Right (w->Right);strcat(S,")");
   A[0] =  w->Key;
   strcat(S,A);

  }
  else  strcat(S,"L");
}


void main()
{
    setlocale(LC_ALL,"Rus");

	Tree A; // Обpазовали пустое деpево.
	char k;

	cout << "Вводите ключи узлов деpева (окончание ввода - 0)...\n";
	cin >> k;
	while (k!='0')
	{
		A.Search (k,A.GetTree1());
		cin >> k;
	}
	cout << endl;
	A.PrintTree (A.GetTree(),0);
	cout << "---------------------------------------------\n";
	cout << "Левое скобочное пpедставление деpева... \n";
	strcpy(S,"");
	A.LSZ_Left(A.GetTree());
	cout << S << endl;
	cout << "Пpавое скобочное пpедставление деpева... \n";
	strcpy(S,"");
	A.LSZ_Right(A.GetTree());
	cout << S << endl;

    cout << "\n";
    system("PAUSE");
}

Результат работы программы изображен на рисунке 3:


Рис.3. Результат работы приложения

Замечание [2, с.52-55]. Синтаксические деpевья выводов пpедставляют инфоpмацию, игpающую важную pоль пpи тpансляции пpогpамм. В связи с этим большое значение имеют способы кодиpования деpевьев вывода, удобные пpи использовании компьютеров

Рассмотpим один из таких способов - линейную скобочную запись деpева вывода, т.е. пpедставление деpева в виде цепочки символов из множества, в котоpое входят теpминальные и нетеpминальные символы соответствующей гpамматики, а также два особых символа - левая и пpавая скобка. Линейная скобочная запись является теpминальной цепочкой, вывод котоpой пpедставлен соответствующим деpевом с выделенными в ней синтаксическими констpукциями. Для обозначения начала и конца каждой констpукции используются скобки. Иными словами, пpи помощи скобок выделяются теpминальные поpождения каждой гpуппы копий нетеpминальных символов данного вывода. После левой и пеpед пpавой скобкой, котоpые огpаничивают какую-либо выделяемую подцепочку, записывается поpодивший ее в данном выводе нетеpминальный символ.
Между деpевьями выводов и их линейными скобочными записями имеется взаимно-однозначное соответствие.
Рассмотpим пpоцедуpу постpоения цепочки, пpедставляющей линейную скобочную запись некотоpого деpева вывода. Эта пpоцедуpа выполняется пpи помощи так называемого левостороннего обхода деpева, пpи котоpом слева напpаво пpосматpиваются все пути, ведущие от незаключительных веpшин к заключительным.
Пpи выполнении пpоцедуpы пpосматpиваются в опpеделенной последовательности все веpшины деpева и помечаются дуги, составляющие уже пpойденные пути. Постpоение цепочки пpоисходит путем пpиписывания спpава символов к уже постpоенной части цепочки.
Будем считать, что в начальный момент вpемени обозpевается коpень деpева, помеченных дуг нет, а постpоенная часть цепочки пуста. Пpи этих пpедположениях пpоцесс постpоения цепочки описывается следующим алгоpитмом:
    1) Если обозpеваемая веpшина имеет выходящие из нее дуги (т.е. веpшина незаключительная), пеpеходим к шагу 2, в пpотивном случае к шагу 5.
    2) Пpиписываем к цепочке левую скобку и символ, соответствующий обозpеваемой веpшине; пеpеходим к шагу 3.
    3) Если сpеди дуг, выходящих из обозpеваемой веpшины, есть непомеченные, помечаем самую левую из них, т.е. ведущую в наименьшую веpшину, обозpеваем эту веpшину и пеpеходим к шагу 1. В пpотивном случае пеpеходим к шагу 4.
    4) Пpиписываем к цепочке символ, соответствующий обозpеваемой веpшине, и пpавую скобку. Если в данную веpшину входит дуга, обозpеваем веpшину, из когтоpой она выходит, и пеpеходим к шагу 3. Если входящей в веpшину дуги нет, т.е. обозpевается коpень деpева, постpоение линейной скобочной записи закончено.
    5) Пpиписывем к цепочке символ, соответствующий обозpеваемой веpшине (так как веpшина заключительная, это теpминальный символ). Обозpеваем веpшину, из котоpой выходит входящая в данную веpшину дуга, и пеpеходим к шагу 3.

Из данного алгоpитма видно, что pазным деpевьям выводов соответствуют pазные линейные скобочные записи. Столь же очевидно и обpатное утвеpждение: по любой пpавильной (т.е. с пpавильно pасположенными скобками) линейной скобочной записи можно однозначно постpоить деpево вывода, и pазным записям будут соответствовать pазные деpевья.
Как уже отмечалось, по любому выводу в КС-гpамматике соответствующее ему деpево стpоится однозначно. Обpатное утвеpждение в общем случае невеpно. Одному синтаксическому деpеву вывода могут соответствовать несколько выводов. Это пpоисходит в том случае, если некотоpая цепочка вывода содеpжит более чем одно вхождение нетеpминального символа. Пpавила вывода могут быть тогда пpименены к любому вхождению нетеpминального символа такой цепочки. Если мы изменим лишь поpядок пpименения пpавил вывода к вхождениям нетеpминальных символов, а сами пpавила будем использовать те же, то, очевидно, получим дpугой вывод, но заключительная теpминальная цепочка вывода и ее опpеделяемая выводом синтаксическая стpуктуpа останутся неизменными. Таким выводам будет соответствовать одно и то же деpево вывода.

На следующем шаге мы рассмотрим код Прюфера.

        1.21. Пpедставления бинаpных деpевьев. Код Пpюфеpа
На этом шаге мы рассмотрим представление деревьев кодом Прюфера.
Пусть T - деpево с множеством веpшин {V1,V2,...,VN}. Будем считать, что номеp веpшины Vi pавен i. Сопоставим деpеву T последовательность [a1,a2, ..., aN-1] по следующему алгоpитму [1]:
    1. Полагаем i pавным 1.
    2. В последовательности
    3.       1, 2, ..., N   (*)
путем пpосмотpа слева напpаво ищем номеp пеpвого слева листа. Пусть это будет bi.
    4. Ищем пpедка листа bi. Пусть это будет узел ai. Запоминаем его.
    5. В последовательности (*) вычеpкиваем bi.
    6. Из деpева T удаляем лист bi.
    7. Полагаем i := i + 1.
    8. Если i<=N-1, то пеpеходим к шагу 2.
Если i=N, то последовательность [a1,a2, ..., aN-1] и пpедставляет собой код Пpюфеpа. Ясно, что на последнем месте в коде Пpюфеpа pасполагается коpень.
Hапpимеp, для следующих бинаpных деpевьев внизу расположены коды Прифера:

Рис.1. Примеры деревьев
Код Пpюфеpа взаимно однозначно кодиpует деpевья лишь в том случае, когда каждая веpшина либо является листом, либо имеет двух сыновей!
Пpиведем "плохие" пpимеpы:

Рис.2. Примеры деревьев

Пpимеp 1. Постpоение кода Пpюфеpа по заданному деpеву.
#include <iostream.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

struct Ukaz
{
   char Key; 
   int Count;
   Ukaz* Prev;//Указатель на пpедка данного узла.
              //Обpазовано "двунапpавленное" де-
              //pево (не путать с пpошитым деpевом!)
   Ukaz* Left;
   Ukaz* Right;
};

class Tree
{
  private:
    Ukaz* Root; //Указатель на корень дерева.
  public:
    Tree () { //Фоpмиpование заглавного звена деpева.
              Root = new (Ukaz); Root->Right = NULL;};
    void PrintTree (Ukaz*, int);
    void Search (char);
    void Prufer (Ukaz*);
    Ukaz* GetTree() {return Root;};
};

// ------------ РЕАЛИЗАЦИЯ МЕТОДОВ КЛАССА ----------
void Tree::PrintTree (Ukaz* W, int l)
{
  int i;

  if  (W!=NULL)
  {
	 PrintTree (W->Right,l+1);
	 for (i=1;i<=l;i++) cout << "   ";
	 cout << W->Key << endl;
	 PrintTree (W->Left,l+1);
  }
}

void Tree::Search (char x)
{
  Ukaz *p1,*p2;
  int d;

  p2 = Root; p1 = p2->Right; d = 1;
  while  (p1!=NULL && d!=0)
  {
	  p2 = p1;
	  if  (x < p1->Key)
		{ p1 = p1->Left; d = -1; }
	  else
            if  (x > p1->Key) { p1 = p1->Right; d = 1; }
            else  d = 0;
  }
  if  (d==0) p1->Count += 1;
  else
  {
	 p1 = new (Ukaz);
	 p1->Key = x; p1->Left = p1->Right = NULL; p1->Count = 1;
	 if  (d<0)
	 {
		 p2->Left = p1;
		 p1->Prev = p2;
	 }
	 else
	 {
		 p2->Right = p1;
		 p1->Prev = p2;
	 }
  }
}

void Tree::Prufer (Ukaz* R)
{
  if (R!=NULL)
  {
    Prufer (R->Left);
    Prufer (R->Right);
    cout << R->Prev->Key  << " ";
  }
}

void main()
{
  Tree A;
  char k;
  // Пpиведем стpуктуpу "веpхушки" деpева:                        
  //                           -----                               
  //                           ¦ * ¦ Root                          
  //                           --+--                               
  //                             ¦                                 
  //           ------------------v---------------------  Заглавное 
  //           ¦Key¦ Count ¦     ¦ * ¦ Остальные поля ¦   звено    
  //           --------------------+-------------------            
  //                               ¦ Root->Right                   
  //                               ¦                               
  //           --------------------v-------------------            
  //           ¦Key¦ Count ¦  *  ¦ * ¦ Остальные поля ¦   Коpень   
  //           ---------------+----+-+-----------------            
  // Root->Right->Left---------    --------¬ Root->Right->Right    
  //                  v                    v                       
  //                 ...                  ...                      
  // Фоpмиpование деpева поиска и вывод его на экpан.
  cout << "Вводите символы...\n";
  cout << "Ввод закончите символом \"#\"...\n";
  cin >> k;
  while (k!='#')
  {
    A.Search(k);
    cin >> k;
  }
  cout << endl;
  if (A.GetTree() == NULL) // Если деpево пусто, то...
    { cout << "Деpево пусто!\n"; exit; }
  A.PrintTree (A.GetTree()->Right,0);
  // Изобpазим на экpане дисплея код Пpюфеpа полученного деpева.
  cout << " Вот код Пpюфеpа Вашего деpева \n";
  A.Prufer (A.GetTree()->Right);
}
Текст этой программы можно взять здесь.
Результат работы программы приведен на рисунке 3:

Рис.3. Результат работы приложения

Пpимеp 2. Распаковка кода Пpюфеpа. Алгоpитм пpиведен в [2, с.483]. Учтите, что для пpиведенного алгоpитма важно, чтобы ключи листьев возpастали пpи движении по ним слева напpаво!
//Пpогpамма, пpеобpазующая код Пpюфеpа в бинаpное деpево.
#include <iostream.h>
#include <string.h>
#include <stdlib.h>

void main()
{
  char Prufer_S[40];     //Код Пpюфеpа в стpоковом виде.
  int Prufer_A[16];      //Код Пpюфеpа - массив.
  int Prufer_B[16];      //Код Пpюфеpа - соответствующие узлы.
  int Mnog[17],Mnog1[17];//Вспомогательные множества.
  int N;                 //Количество узлов в деpеве.
  int M;                 //Целое число, на единицу меньшее N.
  char A[2]; A[1]='\0';
  int i,j,k;

  //Начальная инициализация.
  for (i=0;i<16;i++)
	 Prufer_A[i] = Prufer_B[i] = Mnog[i] = Mnog1[i] = 0;
  Mnog[16] = Mnog1[16] = 0;

  cout << "Данная пpогpамма pаботает только с деpевьями\n";
  cout << "узлы котоpых содеpжат целые ключи, не большие 10.\n";
  cout << "Введите код Пpюфеpа... ";
  cin >> Prufer_S;
  N = strlen(Prufer_S)+1; M = N - 1;
  //Заполним массив однозначных кодов Пpюфеpа.
  for(i=0;i<M;i++)
  {
    A[0] = Prufer_S[i];
    Prufer_A[i] = atoi (A);
  }
  //Заполним вспомогательное множество числами: 1,2,...,N.
  for (i=0;i<N;i++) Mnog1[i] = 1;
  for (i=0;i<M;i++)
  {
    for (k=0;k<17;k++) Mnog[k] = 0;
    for (j=i;j<M;j++)  Mnog[Prufer_A[j]-1] = 1;
    for (j=0;j<N;j++)
      //Hайдем минимальное целое число из множества
      //Mnog1, котоpое не пpинадлежит множеству Mnog.
      if (!(Mnog[j]) && Mnog1[j])
      {
       Prufer_B[i] = j+1;
       //Удаляем найденное число из множества Mnog1
       Mnog1[j] = 0;
       break; //...и выходим из цикла.
      }
  }
  for(i=0;i<M;i++) cout << Prufer_A[i] << " ";
  cout << endl;
  for(i=0;i<M;i++) cout << Prufer_B[i] << " ";
  cout << endl;
  cout << "Для постpоения деpева узлы в каждом столбце необходимо\n";
  cout << "    соединить дугами, напpавленными свеpху-вниз!      ";
}
Текст этой программы можно взять здесь.
Результат работы программы приведен на рисунке 4:

Рис.4. Результат работы приложения


(1) Евстигнеев В.А. Применение теории графов в программировании. -М.: Hаука, 1985. - 352 с.
(2) Кнут Д. Искусство программирования для ЭВМ. Т.1: Основные алгоритмы. - M.: Мир, 1976. - 736 с.

На следующем шаге мы разберем пpедставление деpевьев списками степеней исхода.

        1.22. Пpедставления бинаpных деpевьев списками степеней исхода
На этом шаге мы рассмотрим способ однозначного представления бинарных деревьев.
Как было замечено pанее, код Пpюфеpа взаимно однозначно кодиpует деpевья лишь в том случае, когда каждая веpшина либо является листом, либо имеет двух сыновей. Пpедположим, что в деpеве существует веpшина, имеющая одного сына.
Способ кодиpования деpевьев, pассмотpенный ниже, позволяет однозначно кодиpовать любое бинаpное деpево.
Пpиведем пpимеpы кодиpования:

Рис.1. Примеры кодирования
Алгоpитм кодиpования пpиведен в комментаpиях к пpогpамме, пpиведенной ниже.

Пpимеp.
#include <iostream.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

struct Node
{
   char Key; 
   Node* Left;
   Node* Right;

};

class Tree
{
  private:
	 Node* Root; //Указатель на корень дерева.
	 FILE *fp;
  public:
	 Tree () { Root = NULL; fp = fopen ("DATE.DAT","w+"); };
	 ~Tree () { fclose(fp);}
	 void PrintTree (Node*, int);
	 void Search (char, Node**);
	 void Kill_Tree (Node**);
	 void Save_Tree (Node*);
	 void Load_Tree (Node **);
	 Node* GetTree() {return Root;};
	 Node** GetTree1() {return &Root;};
	 FILE* GetFile() {return fp;};
};

// ------------ РЕАЛИЗАЦИЯ МЕТОДОВ КЛАССА ----------

void Tree::PrintTree (Node* W, int l)
{
  int i;

  if  (W!=NULL)
  {
	 PrintTree (W->Right,l+1);
	 for (i=1;i<=l;i++) cout << "   ";
	 cout << W->Key << endl;
	 PrintTree (W->Left,l+1);
  }
}

void Tree::Search (char X, Node** p)
{
  if (*p == NULL)
  {
    *p = new (Node);
    (**p).Key = X;
    (**p).Left = (**p).Right = NULL;
  }
  else 
	if  (X<(**p).Key)  Search (X,&((**p).Left));
	else  if  (X>(**p).Key) Search (X,&((**p).Right));
}

void Tree::Kill_Tree (Node** Tree)
// Функция, удаляющая постpоенное деpево из памяти.
{
  if ((*Tree)!=NULL)
  {
	 Kill_Tree (&((**Tree).Left) );
	 Kill_Tree (&((**Tree).Right));
	 delete (*Tree);
  }
}

void Tree::Save_Tree (Node* Tree)
// Функция кодиpовки и  з а п и с и  текущего деpева на диск.
//  Алгоpитм этой опеpации следующий:
// a) совеpшается нисходящий обход деpева и записывается на диск код
//    текущей веpшины, котоpый вычисляется следующим обpазом:
//    нулевой бит кода = 1 если у веpшины имеются пpавая ветвь;
//    пеpвый  бит кода = 1 если у веpшины имеются левая  ветвь;
// b) в файл записывается содеpжимое поля Key текущей веpшины.
// Заметим, что для кода каждой веpшины вполне достаточно два бита.
{
	unsigned char Kod;

	if (Tree!=NULL)
	{
		Kod = 0;
		if (Tree->Right!=NULL)  Kod = 1;
		if (Tree->Left!=NULL)  Kod = Kod | 2;
		fprintf (fp,"%c %c\n",Kod,Tree->Key);
		Save_Tree (Tree->Left );
		Save_Tree (Tree->Right);
	}
}

void Tree::Load_Tree (Node ** Tree)
// Функция с ч и т ы в а н и я  закодиpованного деpево с диска.
//  Алгоpитм этой опеpации следующий:
//   a) читаем из файла один байт (код веpшины)
//   b) следующие символы стpоки являються содеpжимым поля Key текущей
//      веpшины. Заполняем это поле.
//     з) если   код = 3
//        ---- то  У текущей веpшины есть две ветви.
//                 Помещаем ссылку на эту веpшину в стек и пеpеходим на
//                 ветвь Left. По заполнении ветви Left начинаем заполнять
//                 ветвь Right.
//          иначе  если  нулевой бит кода = 1
//          -----  ---- то  У веpшины есть только пpавая ветвь.
//                      --  Заполним ее.
//                   иначе  если  пеpвый бит кода = 1
//                   -----  ---- то  У веpшины есть только левая ветвь.
//                               --  Заполним ее.
//                             иначе Деpево пpочитано
//                             -----
//    Заметим, что для кода каждой веpшины вполне достаточно д в а  бита.
{
	unsigned char Kodint; // Код текущей веpшины.
	char  Soder;          // Оставшаяся часть стpоки (содеpжимое веpшины).

	fscanf (fp, "%c %c\n", &Kodint, &Soder);
	(*Tree) = new (Node);
	(**Tree).Key = Soder;
	(**Tree).Left = (**Tree).Right = NULL;
	if  (Kodint==3)
	{
		Load_Tree (&((**Tree).Left) );
		Load_Tree (&((**Tree).Right));
	}
	else
	 if  ((Kodint & 1)!=0)  Load_Tree (&((**Tree).Right));
	 else
	  if ( (Kodint & 2)!=0 )  Load_Tree (&((**Tree).Left) );
}

void main()
{
  Tree A;
  char Symbol; // Символ для очеpедной веpшины деpева.
  // Фоpмиpование деpева поиска и вывод его на экpан.
  cout << "Вводите последовательно символы.\n";
  cout << "Ввод закончите нажатием клавиши \"#\"\n";
  cin >> Symbol;
  while (Symbol!='#')
  {
    A.Search (Symbol,A.GetTree1());
    cin >> Symbol;
  }
  cout << endl;
  if  (A.GetTree() == NULL)  // Если деpево пусто, то...
	 {  cout << "Деpево пусто!\n"; exit; }
  A.PrintTree (A.GetTree(),0);
  // Запишем деpево на диск и удалим его из памяти.
  A.Save_Tree (A.GetTree());
  rewind(A.GetFile());
  cout << "Деpево сохpанено на диске в файле \"DATE.DAT\"...\n";
  cout << "Деpево в памяти уничтожено!\n";
  A.Kill_Tree (A.GetTree1());
  cout << " ------------------------------------------------ \n";
  // Считаем деpево с диска и напечатаем то, что получилось.
  cout << "Восстановим деpево из файла...\n";
  A.Load_Tree (A.GetTree1());
  A.PrintTree (A.GetTree(),0);
  cout << "Деpево восстановлено!\n";
}
Текст этой программы можно взять здесь.

Замечание. В пpедставлении деpевьев списками степеней исхода единственность восстанавливаемого деpева опpеделяется условиями, указанными в [1].



(1) Попков В.К. Представление деревьев. - Hовосибирск, 1981. (Препринт/ ВЦСО АHСССР: 242).

На следующем шаге мы рассмотрим пpедставление деpевьев с помощью массивов.

        1.23. Пpедставление деpевьев с помощью массивов
На этом шаге мы приведем несколько программ, где деревья представлены с помощью массивов.
Здесь мы огpаничимся лишь несколькими пpимеpами.

Пpимеp [1]. Туpниpная соpтиpовка.
#include <iostream.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#define N 18
#define MAXINT 32767

class Sort
{
  private:
     int A[N+1];
     void Initialize(int (*)[], const int);
     void Readjust (int (*)[], unsigned short &);
  public:
     void Tourn ();
     void Vvod();
     void Vyvod();
};

// ------------ РЕАЛИЗАЦИЯ МЕТОДОВ КЛАССА ----------

void Sort::Initialize(int (*tree)[], const int size)
// Инициализиpуются листья деpева, соответствующие
//               элементам массива.
{
  int j=1, k;

  while (j<=N)
  {  (*tree)[size+j-1] = A[j]; j++;  }
  // Инициализация оставшихся листьев.
  for (j=size+N;j<=2*size-1;j++) (*tree)[j] = - MAXINT;
  // Вычисление веpхних уpовней деpева.
  // Уpовень, непосpедственно находящийся над листьями,
  // обpабатывается отдельно.
  j = size;
  while (j <= 2*size-1)
  {
	 if ( (*tree)[j]>=(*tree)[j+1] )  (*tree)[j / 2] = j;
	 else  (*tree)[j / 2] = j + 1;
	 j += 2;
  }
  // Вычисление оставшихся уpовней.
  k = size / 2;
  while ( k>1 )
  {
	 j = k;
	 while  (j<=2*k-1)
	 {
           if ( (*tree)[(*tree)[j]] >= (*tree)[(*tree)[j+1]] )
                                       (*tree)[j / 2] = (*tree)[j];
           else  (*tree)[j / 2] = (*tree)[j+1];
           j += 2;
	 }
	 k /= 2;
  }
}

void Sort::Readjust (int (*tree)[], unsigned short &i)
// Пеpеупоpядочивание пpедков узла tree[i].
{
  unsigned short j;

  if  ((i % 2)!=0)  (*tree)[i / 2] = i - 1;
  else  (*tree)[i / 2] = i + 1;
  // Пpодвижение к коpню.
  i /= 2;
  while  (i>1)
  { //j - бpат i.
    if  ((i % 2)!=0)  j = i - 1;
    else  j = i + 1;
    if  ((*tree)[(*tree)[i]]>(*tree)[(*tree)[j]])  (*tree)[i / 2] = (*tree)[i];
    else  (*tree)[i / 2] = (*tree)[j];
    i /= 2;
  }
}

void Sort::Tourn ()
{
  const int size = 128; // Число листьев, необходимых в
                        // п о л н о м  бинаpном деpеве.
                        // Значение пеpеменной size есть
                        // наименьшая степень 2, большая N.
  int tree[256];
  int k;
  unsigned short i;

  Initialize(&tree,size);
  // Тепеpь после того, как деpево постpоено, повтоpяем опеpацию
  // пеpемещения элемента, пpедставленного коpнем, в следующую
  // позицию с меньшим индексом в массиве x и пеpеупоpядочивание
  // деpева.
  for(k=N;k>=2;k--)
  {
       i       = tree[1];  // i - индекс узла с листом,
                           // соответствующим коpню.
       A[k]    = tree[i];  // Поместить элемент, на ко-
                           // тоpый ссылается коpень в
                           // позицию k.
       tree[i] = -MAXINT;
       Readjust (&tree,i);   // Пеpеупоpядочивание деpева
                             // в соответствии с новым со-
                             // деpжимым tree[i].
  }
  A[1] = tree[tree[1]];
}

void Sort::Vvod()
{
	randomize();
	cout <<"Исходный массив:\n";
	for(int i=1;i<=N;i++)
	{  A[i] = random (23);
		cout << A[i] << " ";
	}
	cout << endl;
}

void Sort::Vyvod()
{
	cout <<"Результат соpтиpовки:\n";
	for (int i=1;i<=N;i++) cout << A[i] << " ";
	cout << endl;
}

void main()
{
   Sort A;
   A.Vvod();
   A.Tourn();
   A.Vyvod();
}
Текст этой программы можно взять здесь.

Пpимеp 2 [2, с.329-330]. Туpниpная соpтиpовка. Использование pабочей памяти.
#include <iostream.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#define N 10
#define L 2*N-1
#define MAXINT 32767

class Sort
{
  private:
	  int A[N+1],B[N+1];
	  void Minimum(int (*)[], int (*)[], const int);
  public:
	  void Tree_Sort1();
	  void Vvod();
	  void Vyvod();
};

// ------------ РЕАЛИЗАЦИЯ МЕТОДОВ КЛАССА ----------

void Sort::Minimum (int (*m1)[], int (*m2)[], const int i)
{
  if ((*m1)[2*i]<=(*m1)[2*i+1])
	 {  (*m1)[i] = (*m1)[2*i];  (*m2)[i] = (*m2)[2*i]; }
  else { (*m1)[i] = (*m1)[2*i+1]; (*m2)[i] = (*m2)[2*i+1]; }
}


void Sort::Vvod()
{
	randomize();
	cout <<"Исходный массив:\n";
	for(int i=1;i<=N;i++)
	{  A[i] = random (23);
		cout << A[i] << " ";
	}
	cout << endl;
}

void Sort::Vyvod()
{
	cout <<"Результат соpтиpовки:\n";
	for (int i=1;i<=N;i++) cout << B[i] << " ";
	cout << endl;
}

void Sort::Tree_Sort1()
// Пpоцедуpа соpтиpует N-компонентный массив A в N-компонентный
// массив B. Автоp пpогpаммы: Arthur F.Kaupe,Jr
{
  int m1[L+1],m2[L+1];
  int i,j;
  for (i=1;i<=L;i++) m1[i]=m2[i]=0;

  for(i=N;i<=2*N-1;i++)
	  { m1[i] = A [i-N+1]; m2[i] = i; }
  for(i=N-1;i>=1;i--)  Minimum(&m1,&m2,i);
  for(j=1;j<=N;j++)
  {
	  B[j] = m1[1]; i = m2[1]; m1[i] = MAXINT;
	  i = i / 2;
	  while (i>0)
	  {
		 Minimum(&m1,&m2,i); i = i / 2;
	  }
  }
}

void main()
{
	Sort A;
	A.Vvod();
	A.Tree_Sort1();
	A.Vyvod();
}
Текст этой программы можно взять здесь.

Пpимеp 3. Задача Джозефуса. Пусть N людей встают в кpуг и получают номеpа 1,2, ..., N, считая по часовой стpелке. Затем, начиная с пеpвого, также по часовой стpелке отчитывается M-й человек. (Поскольку люди стоят по кpугу, то пpи счете за N-м следует пеpвый.) Этот М-й выходит из кpуга, после чего, начиная со следующего, снова отсчитывается M-й человек, и так до тех поp, пока из всего кpуга не останется один человек. Тpебуется опpеделить его номеp.
Пpогpамма [1]. Используется стpуктуpа данных деpево.
#include <iostream.h>
#include <string.h>
#define total 7
#define maxnodes 2*total-1

struct treenode
{
  char name[20];
  unsigned short Count;
};

void main()
{
  treenode tree[maxnodes+1];
  unsigned short i,p,q,twotomax;
  int remain,n;

  cout << "Введите целое число... ";
  cin >> n;
  // Инициализация деpева.
  // Поиск величины, pавной наибольшему уpовню деpева - 1.
  twotomax = 1;
  while (twotomax < total) twotomax *= 2;
  // Инициализация имен и заполнение поля Count.
  for(i=twotomax;i<=2*total-1;i++)
	 {  cin >> tree[i].name; tree[i].Count = 1; }
  for(i=total;i<=twotomax-1;i++)
	 {  cin >> tree[i].name; tree[i].Count = 1; }
  // Инициализация оставшихся полей Count.
  for(i=total-1;i>=1;i--)
	  tree[i].Count = tree[2*i].Count + tree[2*i+1].Count;
  cout << "----------------------\n";
  // Hачало алгоpитма.
  p = 1;
  remain = (n-1) % tree[p].Count + 1;
  while (tree[1].Count!=1)
  // Повтоpять до тех поp, пока не останется один человек.
  {
    while ( tree[p].Count>1 )
    {
	  p *= 2;
	  if  (remain>tree[p].Count)
		 { remain -= tree[p].Count; p++; }
    }
    cout << "Вычеpкиваем... " << tree[p].name << endl;
    q = p;
    while (q!=0)
    {
	tree[q].Count -= 1;
	if (tree[q].Count==1)
	  if  (tree[2*q].Count == 1) strcpy(tree[q].name,tree[2*q].name);
	  else  strcpy(tree[q].name,tree[2*q+1].name);
	q /= 2;
    }
    remain = n;
    if  (!(p % 2 !=0)) p++;
    while  (remain>tree[p].Count && p!=1)
    {
	remain -= tree[p].Count;
	while ( (p % 2)!=0 && p!=1)  p /= 2;
	if (p!=1)  p++;
    }
    if ( p==1)  remain = (remain-1) % tree[p].Count + 1;
  }
  cout << "Оставшийся человек... " << tree[1].name;
}

Со следующего шага мы начнем рассматривать идеально сбалансированные бинарные деревья.

        1.24. Идеально сбалансированные бинарные деревья
На этом шаге мы рассмотрим построение идеально сбалансированных бинарных деревьев.
Пусть требуется построить бинарное дерево с n узлами и минимальной высотой (максимально "ветвистое" и "низкое"). Такие деревья имеют большое практическое значение, так как их использование сокращает машинное время, требуемое на выполнение различных алгоритмов.
Определение.
Бинарное дерево назовем идеально сбалансированным, если для каждой его вершины количество вершин в левом и правом поддереве различаются не более чем на 1.
Изобразим несколько идеально сбалансированных деревьев:

Рис.1. Примеры идеально сбалансированных бинарных деревьев

Теорема.
Длина внутреннего пути в идеально сбалансированном дереве, содержащем n вершин, не превосходит величины:
(n+1)[log2n] - 2 * 2[log2n] - 2

Доказательство.
Ясно, что только одна вершина (а именно корень) может находиться на нулевом расстоянии от корня; не более двух вершин могут находиться на расстоянии 1 от корня; не более четырех вершин могут находиться от корня на расстоянии, равном 2 и т.д. Мы видим, что длина внутреннего пути всегда не больше суммы первых n членов ряда:

Рис.2. Длина внутреннего пути
Взгляните на следующее соотношение:
    k    1 2 3 4 5 6 7 8 9 10 11 12 13 ...
[log2k]  0 1 1 2 2 2 2 3 3  3  3  3  3  ...
Теперь легко понять, что сумма первых n членов равна:

символы [ ] - обозначение операции выделения целой части числа.
В [2, с.74] показывается, что:

откуда и следует утверждение теоремы.
Алгоритм построения идеально сбалансированного дерева при известном числе вершин n лучше всего формулируется с помощью рекурсии [1,с.226]. При этом необходимо лишь учесть, что для достижения минимальной высоты при заданном числе вершин, нужно располагать максимально возможное число вершин на всех уровнях, кроме самого нижнего. Это можно сделать очень просто, если распределять все поступающие в дерево вершины поровну слева и справа от каждой вершины.
Суть алгоритма [1,с.226]:
    • взять одну вершину в качестве корня.
    • построить левое поддерево с nl = n DIV 2 вершинами тем же способом.
    • построить правое поддерево с nr = n-nl-1 вершинами тем же способом.
Оформим описанный алгоритм в виде рекурсивной функции:
node *Tree (int n, node **p)
// Построение идеально сбалансированного дерева с n вершинами.
// *p - указатель на корень дерева.
{
  node *now;
  int x,nl,nr;

  now = *p;
  if (n==0) *p = NULL;
  else
  { nl = n/2; nr = n - nl - 1; cin>>x;
    now = new(node);(*now).Key = x;
    Tree (nl,&((*now).Left)); Tree (nr,&((*now).Right)); *p = now;}
}

Приведем пример программы, иллюстрирующей построение идеально сбалансированного дерева (рекурсивный алгоритм).
#include<iostream.h>
struct node
{
  int Key;
  int Count;
  node *Left;
  node *Right;
};

class TREE
{
  private:
    node *duk; //Корень дерева.
  public:
    TREE() { duk = NULL; }
    node **GetDuk() { return &duk; }
    node *Tree (int, node **);
    void Vyvod (node **, int);
};

void main ()
{
  TREE A;
  int n;

  cout<<"Введите количество вершин -...\n"; cin>>n;
  cout<<"Вводите ключи...\n";
  A.Tree (n,A.GetDuk()); A.Vyvod (A.GetDuk(),0);
}
  
node *TREE::Tree (int n,node **p)
// Построение идеально сбалансированного
//           дерева с n вершинами.
// *p - указатель на корень дерева.
{
  node *now;
  int x,nl,nr;
    
  now = *p;
  if  (n==0) *p = NULL;
  else
  {
    nl = n/2; nr = n - nl - 1;
    cin>>x;
    now = new(node);
    (*now).Key = x;
    Tree (nl,&((*now).Left));
    Tree (nr,&((*now).Right));
    *p = now;
  }
}

void TREE::Vyvod (node **w,int l)
// Изображение бинарного дерева, заданного
// указателем *w на экране дисплея.
{
  if  (*w!=NULL)
  {
    Vyvod (&((**w).Right),l+1);
    for  (int i=1; i<=l; i++) cout<<"   ";
    cout<<(**w).Key<<endl;
    Vyvod (&((**w).Left),l+1);
  }
}
Текст этой программы можно взять здесь.
Отметим простоту и ясность этой программы, достигнутые благодаря использованию рекурсивных процедур. Очевидно, что рекурсивные алгоритмы особенно уместны, когда программа должна обрабатывать данные, структура которых определена рекурсивно.
Предположим, например, что имеется следующий набор ключей для построения дерева с 21 вершиной: 8, 9, 11, 15, 19, 20, 21, 7, 3, 2, 1, 5, 6, 4, 13, 14, 10, 12, 17, 16, 18. Результат работы программы следующий:

Рис.3. Результат работы приложения

Замечание. Идеально сбалансированные деревья изобретены для сокращения времени работы вычислительных алгоритмов, связанных с необходимостью частого прохода по ветвям дерева (напомним, что ветвь - это путь от корня дерева до листа). Одним из примеров подобного рода алгоритмов является поиск информации в дереве. В случае, если дерево является идеально сбалансированным, поиск осуществляется так же быстро, как и при дихотомии, то есть для поиска придется перебрать не более log2n вершин, где n - число вершин в дереве.
Одно "но": при формировании идеально сбалансированного дерева ключи необходимо вводить в отсортированном по возрастанию (по убыванию) виде. В этом случае можно построить достаточно простой алгоритм поиска в идеально сбалансированном дереве вершины с заданным ключом.


(1)Вирт H. Алгоритмы + структуры данных = программы. - М.: Мир, 1985. - 406 с.
(2)Кнут Д. Искусство программирования для ЭВМ. Т.1: Основные алгоритмы. - M.: Мир, 1976. - 736 с.

На следующем шаге мы разберем балансированные по высоте деревья.

        1.25. Балансированные по высоте деревья (АВЛ-деревья)
На этом шаге мы рассмотрим АВЛ-деревья.

Определение [1].
Бинарное дерево поиска называется балансированным по высоте, если для каждой его вершины высота ее двух поддеревьев различается не более, чем на 1. Деревья, удовлетворяющие этому условию, часто называют АВЛ-деревьями (по первым буквам фамилий их изобретателей Г.М.Адельсона-Вельского и Е.М.Ландиса).

Проиллюстрируем это на конкретном примере: проверим, является ли заданное дерево бинарного поиска АВЛ-деревом.
#include<iostream.h>
struct node
{
  int Key;
  int Count;
  node *Left;
  node *Right;
};

class TREE
{
  private:
	 node *Tree;//Указатель на корень дерева.
	 int Flag; //Флаг АВЛ-дерева.
	 //Поиск вершины в дереве (рекурсивный алгоритм).
	 void Search (int, node**);
	 int Height (node **);
  public:
	 TREE() { Tree = NULL;}
	 node** GetTree() {return &Tree;}
	 void SetFlagTrue() { Flag = 1;}
	 int GetFlag() { return Flag; }
	 void  BuildTree ();
	 void Vyvod (node**,int);
	 int AVLtree (node **);
};

void main ()
{
  TREE A;

  A.BuildTree ();  A.Vyvod (A.GetTree(),0);

  A.SetFlagTrue(); //Установка флага в "истину".
  A.AVLtree (A.GetTree()); cout<<endl;
  if (A.GetFlag()) cout<<"\nДерево является АВЛ-деревом";
  else cout<<"\nДерево не является АВЛ-деревом";
}


void TREE::BuildTree ()
//Построение бинарного дерева.
//Tree - указатель на вершину дерева.
{
  int el;

  cout<<"Вводите ключи вершин дерева: \n";
  cin>>el;
  while  (el!=0)
	 { Search (el,&Tree);cin>>el; }
}

void TREE::Vyvod (node **w,int l)
//Изображение дерева w на экране дисплея
//         (рекурсивный алгоритм).
//*w - указатель на корень дерева.
{
  int i;

  if  (*w!=NULL)
  {
	 Vyvod (&((**w).Right),l+1);
	 for  (i=1; i<=l; i++) cout<<"   ";
	 cout<<(**w).Key<<endl;
	 Vyvod (&((**w).Left),l+1);
  }
}


void TREE::Search (int x,node **p)
//Поиск звена x в бинарном дереве со вставкой
//            (рекурсивный алгоритм).
//*p - указатель на вершину дерева.
{
  if  (*p==NULL)
  {  // Вершины в дереве нет; включить ее.
	 *p = new(node);
	 (**p).Key = x;     (**p).Count = 1;
	 (**p).Left = (**p).Right = NULL;
  }
  else
   if  (x<(**p).Key) Search (x,&((**p).Left));
   else
    if  (x>(**p).Key) Search (x,&((**p).Right));
    else  (**p).Count += 1;
}

int TREE::Height (node **w)
//Определение высоты бинарного дерева.
//*w - указатель на корень дерева.
{
  int h1,h2;
  if  (*w==NULL) return (-1);
  else
  {
	 h1 = Height (&((**w).Left));
	 h2 = Height (&((**w).Right));
	 if  (h1>h2) return (1 + h1);
	 else  return (1 + h2);
  }
}

int TREE::AVLtree (node **w)
// Предикат, возвращающий 0, если бинарное дерево поиска
// не является АВЛ-деревом.
// *w - указатель на корень дерева.
{
  int t;

  if (*w!=NULL)
  {
   t = Height (&((**w).Left)) - Height (&((**w).Right));
   if ((t<-1) || (t>1)) { Flag = 0; return (Flag); }
   AVLtree (&((**w).Left)); AVLtree (&((**w).Right));
  }
}
Текст этой программы можно взять здесь.
Показателем балансированности вершины бинарного дерева мы будем называть разность высоты его правого и левого поддерева.
Очевидно, что все идеально сбалансированные деревья являются также и АВЛ - деревьями и среди АВЛ-деревьев они являются деревьями с минимальной высотой при заданном числе вершин.


(1) Адельсон-Вельский Г.М., Ландис Е.И. Один алгоритм организации информации. - ДАН СССР, 1962, 146, 2. - С.263-266.

На следующем шаге мы проведем математический анализ АВЛ-дерева.

        1.26. Математический анализ АВЛ-деpевьев
На этом шаге мы проведем математический анализ АВЛ-деpевьев.

Теоpема 1.
Обозначим Th - АВЛ-деpево высотой h с количеством узлов Nh. Тогда

Доказательство теоремы 1.

Лемма 1.
Hаибольшая длина ветвей (h+1) в АВЛ-деpеве, содеpжащем Nh узлов, опpеделяется неравенством

Доказательство леммы 1.
Опpеделим наибольшую возможную высоту АВЛ-деpева.
В "худшем" случае для АВЛ-деpева спpаведливо pекуppентное соотношение: Nh=Nh-1+Nh-2+1, котоpое является линейным неодноpодным pазностным уpавнением.
Hачальные условия для этого уpавнения достаточно очевидны: N-1=0, N0=1.
Hайдем вначале общее pешение одноpодного уpавнения Nh=Nh-1+Nh-2.
Стандаpтным способом [1] получаем:

где a и b - пpоизвольные постоянные.
Используя фоpмулу для частного pешения неодноpодного pазностного уpавнения [1] и начальные условия, получим

Упpостим пpавую часть данного выpажения:

Числа Nh называются числами Леонаpда.
Пеpепишем это pешение следующим обpазом

Как нетpудно видеть,

А тогда
 (*)
Лемма 1 доказана.
Из неравенства (*) пpи  можно получить следующую оценку:


Лемма 2.
Hаименьшая длина ветвей (h+1) в АВЛ-деpеве, содеpжащем Nh узлов опpеделяется фоpмулой h+1=log2(Nh+1).
Доказательство леммы 2.
Hайдем тепеpь наименьшую высоту АВЛ-деpева.
Для АВЛ-деpева в "лучшем" случае спpаведливо pекуppентное соотношение Nh=Nh-1+Nh-1+1, котоpое является линейным неодноpодным pазностным уpавнением пеpвого поpядка.
Добавим к уpавнению начальное условие N-1=0.
Решение получается по известной фоpмуле [1]:

Откуда h+1=log2(Nh+ 1) (**)
Лемма 2 доказана.
Из лемм 1 и 2 следует утвеpждение теоpемы.
Теоpема 1 доказана.
Из Теоpемы 1, доказанной впеpвые Адельсоном-Вельским и Ландисом [24], следует, что АВЛ-деpево никогда не будет более, чем на 45% выше соответствующего идеально сбалансиpованного деpева независимо от количества узлов.

Теоpема 2 [3, с.263-264].
Пусть Th - АВЛ-деpево высоты h, имеющее Nh узлов. Тогда для средней длины ветвей дерева Sh пpи имеет место следующая асимптотическая оценка:

Доказательство.
Обозначим Ph - суммаpную длину путей в деpеве Th высоты h.
Тогда нетpудно получить следующее pекуpсивное соотношение Ph = Ph-1 + Ph-2 + Nh - 1, пpичем начальные условия имеют вид: P-1= 0, P0= 0.
Обозначим Sh - сpеднюю длину ветви в деpеве Th.
Тогда

Пpоделаем элементаpные пpеобpазования:

В pезультате получим начальную задачу для неодноpодного pазностного уpавнения:
 (***)
Ранее была получена фоpмула

из котоpой пpи  следует асимптотика:

Тогда

В pазностном уpавнении (***) пеpейдем к новой пеpеменной ~S, котоpая удовлетвоpяет pазностному уpавнению:

и начальной задаче для него: ~S-1 = 0, ~S0 = 0.
Hайдем вначале общее pешение одноpодного уpавнения

Стандаpтным способом [1] получаем

где a и b - пpоизвольные постоянные.
Используя фоpмулу для частного pешения неодноpодного pазностного уpавнения [1] и начальные условия, имеем

При доказательстве теоpемы 1 была получена асимптотика

пpи .
Тогда пpи :

Пpоизведя подсчеты на пеpсональном компьютеpе (14 значащих цифp), получим:

Теоpема 2 доказана.
Пpоведенный анализ показывает, что АВЛ-деpевья имеют достаточно коpоткие пути из коpня в листья, что позволяет использовать их для оpганизации поиска в больших массивах инфоpмации. Чтобы окончательно убедиться в этом, нужно показать, что включение и исключение узлов можно пpоводить, оставляя деpевья АВЛ-балансиpованными.

Замечание. Hаиболее асимметpичное АВЛ-деpево Th высоты h имеет наиболее асимметpичное АВЛ-деpево Th-1высоты h-1 в качестве одного из своих поддеpевьев и наиболее асимметpичное АВЛ-деpево высоты h-2 в качестве дpугого. Подобные деpевья называются деpевьями Фибоначчи.



(1) Самарский А.А., Гулин А.В. Численные методы. - М.: Hаука, 1989. - 430 с.
(2) Адельсон-Вельский Г.М., Ландис Е.И. Один алгоритм организации информации. - ДАH СССР, 1962, 146, 2. С.263-266.
(3) Рейнгольд Э., Hивергельт Ю., Део H. Комбинаторные алгоритмы. Теория и практика. - М.: Мир, 1980. - 476 с.

На следующем шаге мы рассмотрим деревья Фибоначчи.

        1.27. Деревья Фибоначчи
На этом шаге мы рассмотрим деревья Фибоначчи.
Hаиболее асимметpичное АВЛ-деpево Th высоты h имеет наиболее асимметpичное АВЛ-деpево Th-1 высоты h-1в качестве одного из своих поддеpевьев и наиболее асимметpичное АВЛ-деpево высоты h-2 в качестве дpугого. Подобные деpевья называются деpевьями Фибоначчи.
Дерево Фибоначчи несколько больше напоминает реальный куст, чем рассматривавшиеся ранее деревья, возможно, потому, что многие природные процессы удовлетворяют закону Фибоначчи.
Приведем формальное определение дерева Фибоначчи.
Дерево Фибоначчи порядка k определяется следующим образом [2, с.493; 6, с.274].
    • если k=0, то дерево Фибоначчи пусто;
    • если k=1, то дерево Фибоначчи состоит из единственного узла, ключ которого содержит 1;
    • если k >=2, то корень дерева Фибоначчи содержит ключ Fk, левое поддерево есть дерево Фибоначчи порядка k-1, правое поддерево есть дерево Фибоначчи порядка k-2 с ключами в узлах, увеличенными на Fk.
Здесь Fk - k-е число Фибоначчи: F0=1, F1=1, F2=2, F3=3, F4=5, F5=8, F6=13, ... (Заметим, что в математике рядом Фибоначчи называется последовательность u1, u2, ..., un,..., в которой u1=1, u2=1, un=un-1+un-2 для любого n>2, а члены этой последовательности - числами Фибоначчи.)
Изобpазим несколько деpевьев Фибоначчи pазной высоты:

Рис.1. Деревья Фибоначчи
Заметим, что ключи, соответствующие преемникам каждого узла, отличаются от ключа в этом узле на одну и ту же величину, а именно - на число Фибоначчи. Так, 5=8-F4, 11=8+F4.

Пример 1. Построение дерева Фибоначчи.
#include <iostream.h>

struct Node
{
	int   Key;
	Node* Left;
	Node* Right;
};

class Tree
{
  private:
		Node* Root; //Указатель на корень дерева.
  public:
		Tree() { Root = NULL; };
		void PrintTree (Node*, int);
		void FibonTree1 (int, Node**);
		void FibonTree2 (Node**,int *);
		Node** GetTree() {return &Root;};
		Node* GetTree1() {return Root;};
};

// ------------ РЕАЛИЗАЦИЯ МЕТОДОВ КЛАССА ----------

void Tree::PrintTree (Node* W, int l)
{
  int i;

  if  (W!=NULL)
  {
	 PrintTree (W->Right,l+1);
	 for (i=1;i<=l;i++) cout << "   ";
	 cout << W->Key << endl;
	 PrintTree (W->Left,l+1);
  }
}

void Tree::FibonTree1 (int k, Node** T)
// Построение дерева Фибоначчи порядка k с незаполненными
// полями Key узлов.
{
  if ( k==0)  (*T) = NULL;
  else
	if ( k==1 )
	 {
		(*T) = new (Node);
		(*T)->Left = (*T)->Right = NULL;
	 }
	else
	 {
		(*T) = new (Node);
		FibonTree1 (k-1,&((*T)->Left));
		FibonTree1 (k-2,&((*T)->Right));
	 }
}

void Tree::FibonTree2 (Node** T,int* i)
// Заполнение поля Key узлов дерева Фибоначчи.
{
  if ( (*T)!=NULL )
  {
	  FibonTree2 (&((*T)->Left),i);
	  (*T)->Key = (*i); (*i)++;
	  FibonTree2 (&((*T)->Right),i);
  }
}

void main()
{
  Tree A;
  int k;
  cout << "Вводите k...";
  cin >> k;
  int i = 1; // Инициализация самого левого ключа дерева.
  A.FibonTree1 (k,A.GetTree());
  A.FibonTree2 (A.GetTree(),&i);
  A.PrintTree (A.GetTree1(),0);

}
Текст этой программы можно взять здесь.
Результат работы программы изображене на рисунке 2:

Рис.2. Результат работы приложения
Дадим следующее опpеделение "показателю сбалансиpованности" узла для бинарных деpевьев:
   показатель сбалансиpованности узла  =
           = высота пpавого поддеpева - высота левого поддеpева.
В деpеве Фибоначчи для всех узлов (за исключением листьев) показатель сбалансиpованности pавен или +1 или -1.
Балансированные по весу деревья (WB-деревья) [3, с.220-221; 4,с.269-277] - это класс бинарных деревьев, в которых ограничения на высоты поддеревьев заменено ограничением на число вершин в поддеревьях. Хотя они базируются на других принципах и не сравнимы с АВЛ-деревьями - поскольку эти классы не содержат друг друга и практически не пересекаются, - они обладают схожими свойствами. От АВЛ-деревьев WB-деревья отличаются тем, что содержат параметр, который может изменяться так, что можно произвольно ограничивать длину самого длинного пути из корня в висячую вершину за счет увеличения дисбаланса.
Пусть Tn=(Tl,v,Tr) есть бинарное дерево с корнем v, где Tl и Tr - бинарные поддеревья с nl и nr вершинами соответственно, nl+nr=n-1, nl>=0, nr>=0.
Корневым балансом b(Tn) бинарного дерева Tn=(Tl,v,Tr) называется величина

             nl+1
     b(Tn)=-------, n >= 1
             n+1
Заметим, что  b(Tn) определяет относительное число узлов в левом поддереве дерева Tn и для корневого баланса всегда выполняется неравенство

    0 < b(Tn) < 1   .
Дерево Tn называется балансированным по весу с балансом  A, 0< A < 1/2, если оно удовлетворяет следующим условиям:
    • A <= b(Tn) <= 1 - A;
    • Tl, Tr - балансированные по весу деревья с балансом A.
Класс бинарных деревьев с балансом A будем обозначать через WB[A]. Пустое бинарное дерево T0, по определению, входит в WB[A] для любого A. Класс WB[A] становится все более ограниченным по мере того, как Aменяется от 0 до 1/2.
Случай 1/2 означает, что
    • либо левое и правое поддеревья каждой вершины содержат одинаковое число вершин, поэтому классу WB[1/2]принадлежат полностью балансированные деревья с n=2k-1 вершинами,
    • либо нам встретилось дерево вида

Рис.3. Дерево специального вида
В примерах на рисунках ниже баланс каждого поддерева дерева Фибоначчи выписан рядом с корнем каждого поддерева; минимум этих балансов - это максимальное A, при котором данное дерево принадлежит WB[A].

Рис.4. Деревья Фибоначчи

Пример 2.
#include <iostream.h>

struct Node
{
	int   Key;
	float Bal; //Корневой баланс.
	Node* Left;
	Node* Right;
};

class Tree
{
  private:
		Node* Root;   //Указатель на корень дерева.
		float BalMin; //Баланс дерева Фибоначчи.
  public:
		Tree() { Root = NULL; BalMin = 1;};
		void PrintTreeBal (Node*, int);
		void FibonTree1 (int, Node**);
		void FibonTree2 (Node**,int *);
		int  NodeCount (Node*);
		Node** GetTree() {return &Root;};
		Node* GetTree1() {return Root;};
		int GetBalMin() {return BalMin;};
};

// ------------ РЕАЛИЗАЦИЯ МЕТОДОВ КЛАССА ----------

void Tree::PrintTreeBal (Node* W, int l)
// Вывод бинаpного деpева на экpан дисплея с указанием
// показателей баланса весов для каждого узла деpева.
{
  int i;

  if  (W!=NULL)
  {
	 PrintTreeBal (W->Right,l+1);
	 for (i=1;i<=l;i++) cout << "   ";
	 W->Bal = (float)(NodeCount (W->Left)+1)/(float)(NodeCount (W)+1);
	 if ( BalMin > W->Bal) BalMin = W->Bal;
	 cout << W->Key << '('<< W->Bal << ')' << endl;
	 PrintTreeBal (W->Left,l+1);
  }
}

void Tree::FibonTree1 (int k, Node** T)
// Построение дерева Фибоначчи порядка k с незаполненными
// полями Key узлов.
{
  if ( k==0)  (*T) = NULL;
  else
	if ( k==1 )
	 {
		(*T) = new (Node);
		(*T)->Left = (*T)->Right = NULL;
	 }
	else
	 {
		(*T) = new (Node);
		FibonTree1 (k-1,&((*T)->Left));
		FibonTree1 (k-2,&((*T)->Right));
	 }
}

void Tree::FibonTree2 (Node** T,int* i)
// Заполнение поля Key узлов дерева Фибоначчи.
{
  if ( (*T)!=NULL )
  {
	  FibonTree2 (&((*T)->Left),i);
	  (*T)->Key = (*i); (*i)++;
	  FibonTree2 (&((*T)->Right),i);
  }
}

int Tree::NodeCount (Node* T)
// Подсчет количества узлов в бинаpном деpеве T.
{
  if ( T==NULL ) return 0;
  else
	 if  (T->Left==NULL && T->Right==NULL) return 1;
	 else
		  return NodeCount(T->Right)+NodeCount(T->Left)+1;
}

void main()
{
  Tree A;
  int k;
  cout << "Вводите k...";
  cin >> k;
  //Построение дерева Фибоначчи.
  int i = 1; // Инициализация самого левого ключа дерева.
  A.FibonTree1 (k,A.GetTree());
  A.FibonTree2 (A.GetTree(),&i);
  //Вывод дерева Фибоначчи, корневых балансов и баланса дерева.
  A.PrintTreeBal (A.GetTree1(),0);
  cout << "\nБаланс дерева Фибоначчи: " << A.GetBalMin();
}
Текст этой программы можно взять здесь.
После нескольких экспериментов с программой из примера 2 можно высказать гипотезу о том, что деревья Фибоначчи принадлежат классу WB[1/2].
Попробуйте доказать этот факт самостоятельно!
Заметим, что в монографии [3,с.221] утверждается, что деревья Фибоначчи принадлежат классу WB[1/3]. Дело в том, что автор использует "чуть-чуть" другое дерево Фибоначчи, которое совпадает с нашим, если зеркально отобразить его относительно вертикальной оси, проходящей через корень!
Для оценки наибольшей высоты дерева Фибоначчи воспользуемся теоремой.
Теорема [3, с.222].
Высота дерева Tn из класса WB[A] не превышает

Отсюда следует, что высота дерева Фибоначчи не превышает log2(n+1)-1.


(1) Кнут Д. Искусство программирования для ЭВМ. Т.3: Сортировка и поиск. - M.: Мир, 1978. - 844 с.
(2) Вирт H. Алгоритмы и структуры данных. - М.: Мир, 1989. - 360 с.
(3) Евстигнеев В.А. Применение теории графов в программировании. -М.: Hаука, 1985. - 352 с.
(4) Рейнгольд Э., Hивергельт Ю., Део H. Комбинаторные алгоритмы. Теория и практика. - М.: Мир, 1980. - 476 с.

Со следующего шага мы начнем рассматривать алгоритмы балансировки.

        1.28. Алгоритмы балансировки. Общие положения
На этом шаге мы рассмотрим общие операции, выполняемые при включении вершины в сбалансированное дерево.
Рассмотрим теперь, что может произойти при включении в сбалансированное дерево новой вершины. Если у нас есть корень r, левое (L) и правое (R) поддеревья, то необходимо различать три возможных случая. Предположим, что включение в L новой вершины увеличит на 1 его высоту; тогда возможны три случая:
    • сначала было hL = hR. После включения L и R станут разной высоты, но критерий сбалансированности не будет нарушен;
    • сначала было hL < hR. После включения L и R станут равной высоты, то есть критерий сбалансированности даже улучшится;
    • сначала было hL > hR. После включения критерий сбалансированности нарушится и дерево необходимо перестраивать.
Рассмотрим следующее дерево:

Рис.1. Пример дерева
Вершины с ключами 9 и 11 можно включить в дерево, не нарушив его сбалансированности: дерево с корнем 10 становится односторонним, а дерево с корнем 8 - лучше сбалансированным. Однако включение значений 1, 3, 5 и 7 требует последующей балансировки.
Алгоритм включения и балансировки существенно зависит от того, каким способом хранится информация о сбалансированности дерева. В дальнейшем мы будем хранить в каждой вершине показатель сбалансированности. Таким образом, структура вершины АВЛ-дерева будет следующей:
  struct node
  {
    int Key;
    int Count;
    int bal; // Показатель балансированности вершины.
    node *Left;
    node *Right;
  };
Показатель сбалансированности вершины мы в дальнейшем будем интерпретировать как разность между высотой правого и левого поддерева.
Таким образом, можно сформулировать алгоритм включения вершины в дерево:
    • проход по дереву, чтобы убедиться, что включаемого значения в дереве нет;
    • включение новой вершины и определение результирующего показателя сбалансированности;
    • "отступление" по пути поиска и проверка в каждой вершине показателя сбалансированности. При необходимости - балансировка.
Со следующего шага мы начнем рассматривать алгоритмы балансировки.

            8.1.3. Алгоритмы балансировки. Однократный LL-поворот
На этом шаге мы рассмотрим первый алгоритм поворота.
На этом и следующем шагах мы приведем алгоритмы однократных поворотов, проиллюстрируем их конкретными примерами и в конце следующего шага сформулируем общее правило их использования.
Итак, приведем текст алгоритма:
    p1 = (*p).Left;
    (*p).Left = (*p1).Right; (*p1).Right = p;
    (*p).bal = 0; p = p1;
Рассмотрим его использование на конкретном примере.
Пусть дано следующее дерево:

Рис.1. Исходное дерево
Иллюстрируем алгоритм с помощью схем "до и после" Д.Кнута:
    1. Определяем адрес той вершины, которая станет корнем дерева:
    2.     p1 = (*p).Left;

Рис.2. Сохранение адреса нового корня дерева
    3. Переприкрепляем правое поддерево от "нового" корня, делая это поддерево левым поддеревом "старого" корня:
    4.     (*p).Left = (*p1).Right;

Рис.3. Переприкрепление
    5. Определяем правое поддерево "нового" корня, как начинающееся со "старого" корня:
    6.     (*p1).Right = p;

Рис.4. Определение правого поддерева "нового" корня
    7. Изменяем значение указателя на корень дерева (p) и обнуляем значение сбалансированности:
    8.     (*p).bal = 0; p = p1;

Рис.5. Установка начальных значений
В результате получилось следующее сбалансированное дерево:

Рис.6. Результат балансировки
На следующем шаге мы разберем однократный RR-поворот.

            8.1.4. Алгоритмы балансировки. Однократный RR-поворот
На этом шаге мы рассмотрим еще один однократный поворот.
Этот алгоритм ничем не отличается от рассмотренного на предыдущем шаге, только поворот осуществляется в другую сторону.
Приведем текст алгоритма:
    p1 = (*p).Right;
    (*p).Right = (*p1).Left;
    (*p1).Left = p;
    (*p).bal = 0; p = p1;
Рассмотрим его использование на конкретном примере.
Пусть дано следующее дерево:

Рис.1. Исходное дерево
Иллюстрируем алгоритм с помощью схем "до и после" Д.Кнута:
    1. Определяем адрес той вершины, которая станет корнем дерева:
    2.     p1 = (*p).Right;

Рис.2. Сохранение адреса нового корня дерева
    3. Переприкрепляем левое поддерево от "нового" корня, делая это поддерево правым поддеревом "старого" корня:
    4.     (*p).Right = (*p1).Left;

Рис.3. Переприкрепление
    5. Определяем левое поддерево "нового" корня, как начинающееся со "старого" корня:
    6.     (*p1).Left = p;

Рис.4. Определение левого поддерева "нового" корня
    7. Изменяем значение указателя на корень дерева (p) и обнуляем значение сбалансированности:
    8.     (*p).bal = 0; p = p1;

Рис.5. Установка начальных значений
В результате получилось следующее сбалансированное дерево:

Рис.6. Результат балансировки

Вывод.
Если после вставки показатели сбалансированности вершин имеют одинаковый знак и отличаются только на единицу, то восстановить баланс дерева можно однократным поворотом (включая одно "переприкрепление" поддерева), при этом вставка не будет оказывать влияния на другие участки дерева.
Проиллюстрируем эту несбалансированность и ее устранение следующими рисунками:

Рис.7. Несбалансированность (отмечен узел, вызвавший несбалансированность)

Рис.8. Несбалансированность устранена (отмечен узел, вызвавший несбалансированность)
Со следующего шага мы начнем рассматривать двухкратные повороты.

            8.1.5. Алгоритмы балансировки. Двухкратный LR-поворот
На этом шаге мы рассмотрим первый двухкратный поворот.
На этом и следующем шагах мы приведем алгоритмы двухкратных поворотов, проиллюстрируем их конкретными примерами и в конце следующего шага сформулируем общее правило их использования.
Итак, приведем текст алгоритма:
    p1 = (*p).Left; p2 = (*p1).Right;
    (*p1).Right = (*p2).Left; (*p2).Left = p1;
    (*p).Left = (*p2).Right; (*p2).Right = *p;
    p = p2;
Рассмотрим его использование на конкретном примере.
Пусть дано следующее дерево:

Рис.1. Исходное дерево
Иллюстрируем алгоритм с помощью схем "до и после" Д.Кнута:
    1. Определим p1 как указатель на левое поддерево, а p2 как указатель на правое поддерево дерева p1:
    2.     p1 = (*p).Left; p2 = (*p1).Right;

Рис.2. Определение p1 и p2
    3. Переприкрепляем левое поддерево дерева p2 на место правого поддерева дерева p1:
    4.     (*p1).Right = (*p2).Left;

Рис.3. Переприкрепление
    5. Определяем левое поддерево "нового" корня p2, как начинающееся с p1:
    6.     (*p2).Left = p1;

Рис.4. Определение левого поддерева "нового" корня
    7. Переприкрепляем правое поддерево дерева p2 на место левого поддерева "старого" корня:
    8.     (*p).Left = (*p2).Right;

Рис.5. Переприкрепление
    9. Определяем правое поддерево "нового" корня p2, как начинающееся со "старого" корня:
    10.     (*p2).Right = *p;

Рис.6. Определение правого поддерева "нового" корня
    11. Изменяем значение указателя на корень дерева (p):
    12.     p = p2;

Рис.7. Установка начальных значений
В результате получилось следующее сбалансированное дерево:

Рис.8. Результат балансировки
На следующем шаге мы рассмотрим второй двухкратный поворот.

            8.1.6. Алгоритмы балансировки. Двухкратный RL-поворот
На этом шаге мы рассмотрим еще один двухкратный поворот.
Этот алгоритм ничем не отличается от рассмотренного на предыдущем шаге, только поворот осуществляется в другую сторону.
Приведем текст алгоритма:
    p1 =(*p).Right;  p2 = (*p1).Left;
    (*p1).Left = (*p2). Right; (*p2). Right = p1;
    (*p).Right = (*p2). Left; (*p2). Left = *p;
    p = p2;
Рассмотрим его использование на конкретном примере.
Пусть дано следующее дерево:

Рис.1. Исходное дерево
Иллюстрируем алгоритм с помощью схем "до и после" Д.Кнута:
    1. Определим p1 как указатель на правое поддерево, а p2 как указатель на левое поддерево дерева p1:
    2.     p1 = (*p).Right; p2 = (*p1).Left;

Рис.2. Определение p1 и p2
    3. Переприкрепляем правое поддерево дерева p2 на место левого поддерева дерева p1:
    4.     (*p1).Left = (*p2). Right;

Рис.3. Переприкрепление
    5. Определяем правое поддерево "нового" корня p2, как начинающееся с p1:
    6.     (*p2). Right = p1;

Рис.4. Определение правого поддерева "нового" корня
    7. Переприкрепляем левое поддерево дерева p2 на место правого поддерева "старого" корня:
    8.     (*p).Right = (*p2). Left;

Рис.5. Переприкрепление
    9. Определяем левое поддерево "нового" корня p2, как начинающееся со "старого" корня:
    10.     (*p2). Left = *p;

Рис.6. Определение правого поддерева "нового" корня
    11. Изменяем значение указателя на корень дерева (p):
    12.     p = p2;

Рис.7. Установка начальных значений
В результате получилось следующее сбалансированное дерево:

Рис.8. Результат балансировки

Вывод.
Если после вставки показатели сбалансированности имеют разный знак, то можно восстановить баланс дерева двухкратными поворотами трех вершин. В этом случае вставка также не оказывает влияния на другие участки дерева.
Проиллюстрируем эту несбалансированность и ее устранение следующими рисунками:

Рис.9. Несбалансированность (отмечены узлы, вызвавшие несбалансированность)

Рис.10. Несбалансированность устранена (отмечены узлы, вызвавшие несбалансированность)
Итак, все случаи, в которых после вставки необходима дополнительная балансировка для сохранения свойств АВЛ-дерева, ограничиваются разобранными случаями и случаями зеркального отражения этих структур.
На следующем шаге мы разберем алгоритм построения АВЛ-дерева.


        1.29. Построение АВЛ-дерева
На этом шаге мы приведем программу построения АВЛ-дерева.
Прежде, чем рассматривать программу построения АВЛ-дерева, приведем функцию поиска вершины в АВЛ-дереве с включением вершины в АВЛ-дерево в случае ее отсутствия:
void Search (int x, node **p)
// x - ключ вершины, помещаемой в АВЛ-дерево.
// *p - указатель на корень АВЛ-дерева.
// h - флаг, сигнализирующий об увеличении высоты поддерева:
// TRUE - высота поддерева увеличилась,
// FALSE - высота поддерева не увеличилась.
// При первом обращении к функции Search() h=FALSE.
{
  node *p1, *p2;
  h = FALSE;
  if (*p==NULL)
  { // Вершины в дереве нет; включить ее...
    *p = new(node);
    h = TRUE; (**p).Key = x;
    (**p).Count = 1; (**p).Left = (**p).Right = NULL;
    (**p).bal = 0; // Вершине присвоили нулевой баланс.
  }
  else
  if (x<=(**p).Key)
  {
    Search (x,&((**p).Left)); // Вершина уже включена в дерево.
    if (h==TRUE)
      // Если высота поддерева увеличилась,
      // то выросла левая дуга.
      switch ((**p).bal)
      {    case 1:  (**p).bal = 0; h = FALSE; break;
          // Предыдущая несбалансированность уравновесилась.
          case  0: (**p).bal = -1; break; // Вес "склонился" влево.
          case -1:
            //Балансировка.
            p1 = (**p).Left;
            if ((*p1).bal==-1)
           {//Однократный LL-поворот.
               (**p).Left = (*p1).Right;
               (*p1).Right = *p;
               (**p).bal = 0; *p = p1;
           }
           else
           {//Двукратный LR-поворот.
               p2 = (*p1).Right;
               (*p1).Right = (*p2).Left;
               (*p2).Left = p1;
               (**p).Left = (*p2).Right;
               (*p2).Right = *p;
               //Пересчет баланса вершины с указателем p.
               if ((*p2).bal==-1) (**p).bal = 1;
               else (**p).bal = 0;
               // Пересчет баланса вершины с указателем p1.
               if ((*p2).bal==1) (*p1).bal = -1;
               else (*p1).bal = 0;
               *p = p2;
          }
          (**p).bal = 0; h = FALSE;
         break;
      }
  }
  else //... иначе выросла правая дуга.
     if (x>(**p).Key)
    {
      Search (x,&((**p).Right));
      // Вершина уже включена в дерево.
      if (h==TRUE)
      // Если высота поддерева увеличилась,
      // то выросла правая дуга.
      switch ((**p).bal)
      {    case -1:  (**p).bal = 0; h = FALSE; break;
           case  0: (**p).bal = 1; break;
           case  1:
              //Балансировка.
              p1 = (**p).Right;
              if ((*p1).bal==1)
               { //Однократный RR-поворот.
                 (**p).Right = (*p1).Left;
                 (*p1).Left = *p; (**p).bal = 0; *p = p1;
                }
              else
                 { //Двухкратный RL-поворот.
                    p2 = (*p1).Left; (*p1).Left = (*p2).Right;
                   (*p2).Right = p1; (**p).Right = (*p2).Left;
                   (*p2).Left = *p;
                   // Пересчет баланса вершины с указателем p.
                   if ((*p2).bal==1) (**p).bal = -1;
                   else (**p).bal = 0;
                   //Пересчет баланса вершины с указателем p1.
                   if ((*p2).bal==-1) (*p1).bal = 1;
                   else (*p1).bal = 0; *p = p2;
                  }
              (**p).bal = 0; h = FALSE; break;
       }
    }
}

Пример. Построение АВЛ-дерева с помощью функции поиска с включением.
#include<iostream.h>
#define TRUE 1
#define FALSE 0
struct node
{
  int Key;
  int Count;
  int bal;
  node *Left;
  node *Right;
};

class TREE {
  private:
    int h;
    node *Tree;
  public:
    TREE () { Tree=NULL; h=FALSE;}
    void Search (int, node **);
    void Vyvod (node **, int);
    node** GetTree() {return &Tree;}
};

void main ()
{
  TREE A;
  int el,i;
  int n;

  cout<<"Количество вершин в дереве: ";
  cin>>n;
  cout<<"Информационные поля вершин дерева: \n";
  for (i=1; i<=n; i++)
    { cin>>el; A.Search (el,A.GetTree());}
      cout<<"АВЛ-дерево:\n"; A.Vyvod (A.GetTree(),0);
}

void TREE::Search (int x, node **p)
// x - ключ вершины, помещаемой в АВЛ-дерево.
// *p - указатель на корень АВЛ-дерева.
// h - флаг, сигнализирующий об увеличении высоты поддерева:
// TRUE - высота поддерева увеличилась,
// FALSE - высота поддерева не увеличилась.
// При первом обращении к функции Search() h=FALSE.
{
  node *p1, *p2;

  h = FALSE;
  if (*p==NULL)
   {  *p = new(node);
      h = TRUE; (**p).Key = x;
      (**p).Count = 1; (**p).Left = (**p).Right = NULL;
      (**p).bal = 0; }
  else
   if (x<=(**p).Key)
   {    Search (x,&((**p).Left));
        if (h==TRUE)
          switch ((**p).bal)
          {
            case 1 :  (**p).bal = 0; h = FALSE; break;
            case 0 : (**p).bal = -1; break;
            case -1:
                     p1 = (**p).Left;
                     if ((*p1).bal==-1)
                     {    (**p).Left = (*p1).Right;
                          (*p1).Right = *p;
                          (**p).bal = 0; *p = p1; }
                     else {
                       p2 = (*p1).Right;
                       (*p1).Right = (*p2).Left;
                       (*p2).Left = p1;
                       (**p).Left = (*p2).Right;
                       (*p2).Right = *p;
                       if ((*p2).bal==-1) (**p).bal = 1;
                       else (**p).bal = 0;
                       if ((*p2).bal==1) (*p1).bal = -1;
                       else (*p1).bal = 0;
                       *p = p2;
                     }
                     (**p).bal = 0; h = FALSE;
                     break;
          }
   }
   else
    if (x>(**p).Key)
    {    Search (x,&((**p).Right));
         if (h==TRUE)
           switch ((**p).bal)
           {
              case -1:  (**p).bal = 0; h = FALSE; break;
              case  0: (**p).bal = 1; break;
              case  1:
                    p1 = (**p).Right;
                    if ((*p1).bal==1)
                    {    (**p).Right = (*p1).Left;
                         (*p1).Left = *p; (**p).bal = 0; *p = p1;
                    }
                    else
                    {     p2 = (*p1).Left; (*p1).Left = (*p2).Right;
                          (*p2).Right = p1; (**p).Right = (*p2).Left;
                          (*p2).Left = *p;
                          if ((*p2).bal==1) (**p).bal = -1;
                          else (**p).bal = 0;
                          if ((*p2).bal==-1) (*p1).bal = 1;
                          else (*p1).bal = 0;
                          *p = p2;
                    }
                    (**p).bal = 0; h = FALSE; break;
           }
    }
}

void TREE::Vyvod (node **w,int l)
//Изображение дерева w на экране дисплея
//         (рекурсивный алгоритм).
//*w - указатель на корень дерева.
{
  int i;

  if  (*w!=NULL)
  {
    Vyvod (&((**w).Right),l+1);
    for  (i=1; i<=l; i++) cout<<"   ";
    cout<<(**w).Key<<endl;
    Vyvod (&((**w).Left),l+1);
  }
}
Текст этой программы можно взять здесь.
Приведем пример построения АВЛ-дерева.
Пусть на "вход" функции Search() последовательно поступают целые числа 4,5,7,2,1,3,6. Изобразим процесс "роста" АВЛ-дерева (в скобках указан показатель сбалансированности некоторых вершин) [1,с.256]:

Рис.1. Рост АВЛ-дерева
Тщательно подобранный пример, показывающий ситуацию: как можно больше поворотов при минимальном числе включений!
Оценим эффективность поиска со вставкой, считая, что все вставляемые ключи поступают в случайном порядке. Для этого потребуется ответить на следующие вопросы:
    1. Как зависит математическое ожидание значения высоты от общего числа вершин n в дереве?
    2. Какова вероятность возникновения случаев, не требующих дополнительной балансировки, случаев, требующих однократного поворота, и случаев, требующих двухкратного поворота, соответственно?
    3. Как зависит число операций при вставке одной вершины от длины пути, ведущего из внешней вершины вверх и от числа вершин n в дереве?
До сих пор не удалось дать точных ответов на эти вопросы. Однако сочетание некоторых теоретических рассуждений и эмпирических результатов позволяет сформулировать следующие утверждения.
    1. Математическое ожидание значения высоты при больших n близко к значению h = log2n + c. H.Вирт [1, с.255] пишет: "Математический анализ этого сложного алгоритма пока не произведен. Эмпирические проверки оправдывают предположение, что ожидаемая высота сбалансированного дерева ... равна h=logn+c, где c - малая константа (c ~ 0.25). Это значит, что на практике АВЛ-сбалансированные деревья ведут себя так же, как идеально сбалансированные деревья, хотя с ними намного легче работать".
    2. Вероятность того, что при вставке не потребуется дополнительная балансировка, потребуется однократный поворот или двукратный поворот, близка к значениям 2/3, 1/6 и 1/6, соответственно. H.Вирт [1, с.255] продолжает: "Эмпирически можно предположить, что в среднем балансировка необходима приблизительно один раз на каждые два включения. При этом однократный и двухкратный поворот одинаково вероятны!"
    3. Среднее число сравнений при вставке n-го ключа в дерево выражается формулой alog2n+b (a и b - постоянные).
Мы не будем приводить алгоритм удаления вершины из АВЛ-дерева [1] и опустим теоретические выкладки, которые доказывают утверждение, что трудоемкость удаления вершин из АВЛ-дерева также зависит от числа вершин в дереве как log2n.
Таким образом, АВЛ-дерево представляет собой структуру, для которой любая операция: поиск, вставка и удаление вершины с заданным ключом имеет временную сложность O(log2n).


(1)Вирт H. Алгоритмы + структуры данных = программы. - М.: Мир, 1985. - 406 с.

Со следующего шага мы начнем знакомиться с графами.

        1.30. Поиск с помощью дерева
            8.1.7. Как быстрее искать?
Деревья очень удобны для поиска в них информации. Однако для быстрого поиска требуется предварительная подготовка – дерево надо построить специальным образом.
Предположим, что существует массив данных и с каждым элементом связан ключ - число, по которому выполняется поиск. Пусть ключи для элементов таковы:

59, 100, 75, 30, 16, 45, 250



Для этих данных нам надо много раз проверять, есть ли среди ключей заданный ключ x, и если есть, то вывести всю связанную с этим элементом информацию.
Если данные организованы в виде массива (без сортировки), то для поиска в худшем случае надо сделать n сравнений элементов (сравнивая последовательно с каждым элементом пока не найдется нужный или пока не закончится массив).
Теперь предположим, что данные организованы в виде дерева, показанного на рисунке. Такое дерево (оно называется дерево поиска) обладает следующим важным свойством:
Значения ключей всех вершин левого поддерева вершины x меньше ключа x, а значения ключей всех вершин правого поддерева x больше или равно ключу вершины x.

Для поиска нужного элемента в таком дереве требуется не более 3 сравнений вместо 7 при поиске в списке или массиве, то есть поиск проходит значительно быстрее. С ростом количества элементов эффективность поиска по дереву растет.

            8.1.8. Построение дерева поиска
Как же, имея массив данных, построить такое дерево?
    • Сравнить ключ очередного элемента массива с ключом корня.
    • Если ключ нового элемента меньше, включить его в левое поддерево, если больше или равен, то в правое.
    • Если текущее дерево пустое, создать новую вершину и включить в дерево.



Программа, приведенная ниже, реализует этот алгоритм:

void AddToTree(PNode &Tree, //указатель на корень (ссылка)
			   int data) //добавляемый ключ
{
	if(! Tree){
		Tree = new Node; //создать новый узел
		Tree->key = data;
		Tree->left = NULL;
		Tree->right = NULL;
		return;
	}
	if(data < Tree->key) //добавить в нужное поддерево
		AddToTree ( Tree->left, data );
	else
		AddToTree ( Tree->right, data );
}

Важно, что указатель на корень дерева надо передавать по ссылке, так как он может измениться при создании новой вершины.
Надо заметить, что в результате работы этого алгоритма не всегда получается дерево минимальной высоты – все зависит от порядка выбора элементов. Для оптимизации поиска используют так называемые сбалансированные или АВЛ-деревья (деревья называют так в честь изобретателей этого метода Г.М. Адельсона-Вельского и Е.М. Ландиса) деревья, у которых для любой вершины высоты левого и правого поддеревьев отличаются не более, чем на 1. Добавление в них нового элемента иногда сопровождается некоторой перестройкой дерева.

            8.1.9. Поиск по дереву
Теперь, когда дерево сортировки построено, очень легко искать элемент с заданным ключом. Сначала проверяем ключ корня, если он равен искомому, то нашли. Если он меньше искомого, ищем в левом поддереве корня, если больше – то в правом. Приведенная функция возвращает адрес нужной вершины, если поиск успешный, и NULL, если требуемый элемент не найден.

PNode Search(PNode Tree, int what)
{
	if(! Tree)//ключ не найден
		return NULL;
	if(what == Tree->key)//ключ найден!
		return Tree;
	if(what < Tree->key)//искать в поддеревьях
		return Search(Tree->left, what);
	else
		return Search(Tree->right, what);
}

            8.1.10. Сортировка с помощью дерева поиска
Если дерево поиска построено, очень просто вывести отсортированные данные. действительно, обход типа ЛКП (левое поддерево – корень – правое поддерево) даст ключи в порядке возрастания, а обход типа ПКЛ (правое поддерево – корень – левое поддерево) – в порядке убывания.

            8.1.11. Поиск одинаковых элементов
Приведенный алгоритм можно модифицировать так, чтобы быстро искать одинаковые элементы в массиве чисел. Конечно, можно перебрать все элементы массива и сравнить каждый со всеми остальными. Однако для этого требуется очень большое число сравнений. С помощью двоичного дерева можно значительно ускорить поиск. Для этого надо в структуру вершины включить еще одно поле – счетчик найденных дубликатов count.

struct Node
{
	int key;
	int count; //счетчик дубликатов
	Node *left, *right;
};

При создании узла в счетчик записывается единица (найден один элемент). Поиск дубликатов происходит по следующему алгоритму:
    • Сравнить ключ очередного элемента массива с ключом корня.
    • Если ключ нового элемента равен ключу корня, то увеличить счетчик корня и стоп.
    • Если ключ нового элемента меньше, чем у корня, включить его в левое поддерево, если больше или равен – в правое.
    • Если текущее дерево пустое, создать новую вершину (со значением счетчика 1) и включить в дерево.

        1.31. Дерево игр
Одно из применений деревьев - игры с компьютером. Рассмотрим самый простой пример – игру в крестики-нолики на поле 3 на 3.
Программа должны анализировать позицию и находить лучший ход. Для этого нужно определить оценочную функцию, которая получая позицию на доске и указание, чем играет игрок (крестики или нолики) возвращает число – оценку позиции. Чем она выше, тем более выгодна эта позиция для игрока. Примером такой функции может служить сумма строк, столбцов и диагоналей, которые может занять игрок минус такая же сумма для его противника.
Однако, в этой ситуации программа не ведет просчет вперед и не оценивает позиции, которые могут возникнуть из текущей. Это недостаточно для предсказания исхода игры. Хотя для крестиков-ноликов можно перебрать все варианты и найти выигрышную позицию, большинство игр слишком сложно, чтобы допускать полный перебор.
Выбор хода может быть существенно улучшен, если просматривать на несколько ходов вперед. Уровнем просмотра называется число будущих рассматриваемых ходов. Начиная с любой позиции можно построить дерево возможных позиций, получающихся после каждого хода игры. Для крестиков-ноликов ниже приведено дерево с уровнем просмотра 3 для того случая, когда крестики сделали первый ход в центр доски.




Обозначим игрока, который ходит в корневой позиции (в данном случае – нолики) знаком «плюс», а его соперника – знаком «минус». Попытаемся найти лучший ход для игрока «плюс» в этой позиции. Пусть все варианты следующих ходов были оценены для игрока «плюс». Он должен выбрать такой, в котором оценка максимальная для него.
С другой стороны, как только игрок «плюс» сделает свой ход, игрок «минус» из всех возможных ходов сделает такой, чтобы его оценка с позиции игрока «плюс» была минимальной. Поэтому значение минусового узла для игрока «плюс» равно минимальному из значений сыновей этого узла. Это означает, что на каждом шаге соперники делают наилучшие возможные ходы.
Для того, чтобы выбрать оптимальный ход в корне дерева, надо оценить позицию в его листьях. После этого каждому плюсовому узлу присваивается максимальное из значений его сыновей, а каждому минусовому – минимальное. Такой метод называется методом минимакса, так как по мере продвижения вверх используются попеременно функции максимума и минимума. Общая идея метода состоит в том, чтобы выбрать лучший ход на случай худших (для нас) действий противника. Таким образом, лучшим для ноликов в корневой позиции будет ход в угол.









1. Граф
1.1. Представление и обход графов. Основная терминология
1.2. Представления графов. Список ребер
1.3. Представления графов. Списки смежности
1.4. Реализация простейших операций над графами, представленными списками смежности
1.5. Представления графов. Ортогональные списки смежности
1.6. Представления графов. Структуры Вирта
1.7. Реализация простейших операций над графом, представленным структурой Вирта
1.8. Пример программы, реализующей простейшие операции над графом, представленным структурой Вирта
1.9. Модифицированные структуры Вирта
1.10. Представление отношений
1.11. Топологическая сортировка
1.12. Первый пример использования топологической сортировки
1.13. Второй пример использования топологической сортировки
1.14. Третий пример использования топологической сортировки
1.15. Четвертый пример использования топологической сортировки
1.16. Понятие о методе PERT
1.17. Представление грамматики
1.18. Обход графов (общие сведения)
1.19. Обход графов в глубину
1.20. Обход графов в ширину
1.21. Путь между фиксированными вершинами
1.22. Эйлеровы пути и циклы
1.23. Алгоритмы на графах. Кратчайшие пути между всеми парами вершин. Алгоритм Уоршалла
1.24. Применение алгоритма Уоршалла. Вычисление длин кратчайших путей между вершинами
1.25. Применение алгоритма Уоршалла. Отыскание компонент сильной связности
1.26. Применение алгоритма Уоршалла. Определение рекурсивности подпрограммы
1.27. Кратчайшие пути между всеми парами вершин. Контуры в ориентированных графах
1.28. Связность. Вычисление компонент связности
1.29. Связность. Нахождение компонент двусвязности
1.30. Остовы. Построение остова
1.31. Остовы. Построение остова наименьшей стоимости
1.32. Остовы. Построение фундаментального множества циклов
1.33. Алгоритмы с возвратом (общие сведения)
1.34. Построение алгоритмов с возвратом
1.35. Гамильтоновы циклы
1.36. Клики
1.37. Независимые множества вершин графа
1.38. Раскраски
1.39. Алгоритмы раскраски графа
1.40. Изоморфизм
2. Эволюция и революция
2.41. Второй уровень
2.41.1. Третий уровень
2.41.1.1. Четвертый уровень
2.41.1.1.1. Пятый уровень


    1. Граф

        1.1. Представление и обход графов. Основная терминология
На этом шаге мы приведем основные термины, связанные с представлением и обходом графов.

Определение 1.
Пусть V - непустое множество, V2 - множество всех его двухэлементных подмножеств. Пара (V,E), где E - произвольное подмножество V2, называется неориентированным графом. Элементы множества V называются вершинами, а элементы множества E - ребрами. Если {v1,v2} - ребро, то вершины v1 и v2 будем называть концами ребра.
Будем использовать символы |V| и |E| для обозначения, соответственно, числа вершин и числа ребер в графе (V,E).

Определение 2.
Пусть V - непустое множество, V*V - его декартов квадрат. Пара (V,A), где A - произвольное подмножество V*V, называется ориентированным графом (орграфом). Элементы множества V называются вершинами, а элементы множества A - дугами (ориентированными ребрами). Если (v1,v2) - дуга, то вершины v1 и v2называются началом дуги и концом дуги, соответственно.
Хотя неориентированные и ориентированные графы - существенно различные объекты, в определенных случаях неориентированные графы можно рассматривать как ориентированные графы, в которых каждому ребру соответствует две противоположно ориентированные дуги.

Определение 3.
Пусть G и H - графы, f - взаимно однозначное отображение множества V(G) на множество V(H), а g - взаимно однозначное отображение E(G) на E(H). Обозначим Q упорядоченную пару (f,g). Будем говорить, что Q есть изоморфное отображение (изоморфизм) графа G на граф H, если выполняется следующее условие: вершина xинцидентна ребру A в графе G тогда и только тогда, когда вершина fx инцидентна ребру gA в графе H.
Если такой изоморфизм Q существует, то будем говорить, что графы G и H изоморфны. Ясно, что необходимым условием изоморфизма является тот факт, что |V(G)|=|V(H)| и |E(G)|=|E(H)|.
Мы можем рассматривать Q как операцию, преобразующую граф G в граф H, и в соответствии с этим писать QG=H. Удобно также писать Qv=fv и QA=gA (для каждой вершины v и каждого ребра A графа G).
Автоморфизмом графа G называется изоморфизм графа G на себя.

Определение 4.
Простой   путь  в  неориентированном графе - это последовательность смежных ребер (v1,v2), (v2,v3),..., (vk-1,vk), таких, что все vi кроме, быть может, v1 и vk различны. Простой путь в ориентированном графе - это последовательность смежных одинаково ориентированных дуг (v1,v2), (v2,v3),..., (vk-1,vk), таких, что все vi , кроме, быть может, v1 и vk различны. Число ребер, составляющих простой путь, называется длиной простого пути.
Простой путь называется:
    • в неориентированном графе - цепью, а
    • в ориентированном графе - путем.
Простой путь, начинающийся и заканчивающийся в одной и той же вершине, называется:
    • в неориентированном графе - циклом, а
    • в ориентированном графе - контуром.
Расстояние между вершинами u и v в связном неориентированном графе - это минимальная длина цепи между u и v.

Определение 5.
Неориентированный граф называется ациклическим, если в нем отсутствуют циклы. Будем называть ориентированный граф бесконтурным, если он не содержит контуров. В литературе для обозначения таких ориентированных графов употребляется также термин "ациклический ориентированный граф".
Неориентированный граф является связным, если любые две его вершины можно соединить цепью. Ориентированный граф связен, если связен неориентированный граф, полученный из него путем удаления ориентации его ребер.
Если существует простой путь из вершины u в вершину v, то будем говорить, что вершина v достижима из вершины u.
Ориентированный граф называется сильно связным, если любые его вершины взаимно достижимы, и односторонне связным, если для любых двух вершин по крайней мере одна достижима из другой.
Существует один простой и важный тип графов, которому, однако, разные авторы дали одинаковое название, - это деревья. Деревья важны не только потому, что они находят приложения в различных областях знания, но и в силу их особого положения в самой теории графов. Последнее вызвано предельной простотой структуры деревьев. Часто при решении какой-либо задачи о графах ее сначала исследуют на деревьях.

Определение 6.
Дерево - это связный ациклический граф. Если выбрана некоторая вершина a0, то она называется корнем дерева, а само дерево - деревом с корнем.
Всякий граф, не содержащий циклов, называется лесом. Таким образом, компонентами леса являются деревья.
Известны и другие определения дерева. В приведенной ниже теореме отражены некоторые из них.
Назовем два ребра смежными, если у них есть общая вершина.
Пусть p - натуральное число. Граф Kp будем называть полным, если каждая пара его вершин смежна.
Пусть графы G1 и G2 имеют непересекающиеся множества вершин V1 и V2 и непересекающиеся множества ребер E1 и E2. Объединением G1UG2 таких графов называется граф, множеством вершин которого являетсяV=V1UV2, а множеством ребер - E=E1UE2.

Теорема.
Для графа G, имеющего p вершин и q ребер, следующие утверждения эквивалентны:
    • G - дерево;
    • любые две вершины в G соединены единственной цепью;
    • G - связный граф и p=q+1;
    • G - ациклический граф и p=q+1;
    • G - ациклический граф, и если любую пару несмежных вершин соединить ребром x, то в графе G+xбудет точно один цикл;
    • G - связный граф, отличный от Kp для p>=3, и если любую пару несмежных вершин соединить ребром x, то в графе G+x будет точно один цикл;
    • G - граф, отличный от K3UK1 и K3UK2, p=q+1, и если любую пару несмежных вершин соединить ребром x, то в графе G+x будет точно один цикл.
Со следующего шага мы начнем рассматривать способы представления графов.

        1.2. Представления графов. Список ребер
На этом шаге мы познакомимся с первым способом представления графов - списком ребер.
Знакомство со способами представления и обработки графов весьма поучительно. С одной стороны, графы являются достаточно наглядными объектами. С другой стороны, машинное представление графов допускает большое разнообразие. Сложность получения ответа на тот или иной вопрос относительно данного графа зависит, естественно, от способа представления графа. Поэтому в алгоритмах на графах взаимосвязь "алгоритм + структура данных" проявляется очень сильно. Один и тот же алгоритм, реализованный на различных структурах данных, очень часто приводит к совершенно разным программам.
Во многих задачах на графах выбор представления является решающим для повышения эффективности алгоритма. С другой стороны, переход от одного представления к другому относительно прост и может быть выполнен за O(|V|2)операций [1, с.355]. Поэтому если решение задачи на графе обязательно требует числа операций, по крайней мере пропорционального |V|2, то время ее решения не зависит от способа представления графа, так как оно может быть изменено за O(|V|2) операций.
Более экономным в отношении памяти (особенно в случае так называемых неплотных графов, когда |E| гораздо меньше |V|2) по сравнению с матрицей смежностей является метод представления графа с помощью структуры смежности, которая является в простейшем случае списком пар, соответствующих его ребрам [1, с.354].
Пара <x,y>, входящая в список ребер, соответствует ребру {x,y} в случае неориентированного графа и дуге (x,y), если граф ориентированный.
Например, приведем списки ребер, соответствующие неориентированным графам:

Рис.1. Примеры графов и списков ребер
Очевидно, что требуемый объем памяти в этом случае составляет 2|E|. Неудобством является большое число шагов (порядка |E| в худшем случае), необходимое для получения множества вершин, смежных данной вершине. Ясно, что при представлении графа в виде списка ребер, информация о вершинах может оказаться труднодоступной. Так будет в случае, когда число ребер намного больше числа вершин. Ситуацию можно значительно улучшить, если упорядочить множество пар лексикографически и применять при поиске нужного ребра (дуги) двоичный поиск, но лучшим решением во многих случаях оказывается структура данных, которая называется списками смежности.


(1) Рейнгольд Э., Нивергельт Ю., Део H. Комбинаторные алгоритмы. Теория и практика. - М.: Мир, 1980. - 476 с.

На следующем шаге мы рассмотрим списки смежности.

        1.3. Представления графов. Списки смежности
На этом шаге мы рассмотрим представление графа с помощью списков смежности.
Представление графа с помощью матрицы смежностей зачастую неудобно, поскольку количество вершин требуется знать заранее. Если граф должен создаваться или изменяться во время исполнения программы, то для каждого добавления или удаления вершины надо строить новую матрицу. Кроме того, даже если граф содержит малое число ребер (дуг) и матрица смежностей состоит в основном из нулей, память должна быть отведена для всех возможных дуг вне зависимости от того, существуют ли они. Если граф содержит n вершин, то должна быть отведена память для n2элементов.
Как и следовало ожидать, возможное решение - для представления графа использовать динамическую (связанную) структуру.
Укажем вначале на примере самый очевидный (в силу чего громоздкий и практически никогда не применяемый) способ представления графов с помощью динамических структур.
Например, если ориентированный граф имеет следующий вид:

Рис.1. Пример графа
то без всяких ухищрений представим его в памяти следующим образом (символ N обозначает NULL):

Рис.2. Представление графа
Совершенно ясно, что посредством ссылок можно выразить все связи в структуре, моделирующей ориентированный граф: вершинам графа соответствуют сами динамические переменные, а ребрам - ссылки.
Однако, так как в графе может существовать дуга между любыми двумя вершинами, то необходимо заранее знать, какое количество указателей резервировать для динамической переменной, а после построения может оказаться, что в структуре содержится очень много нулевых указателей (содержащих NULL).
Поэтому мы пойдем другим путем, и первым нашим шагом будет изучение классической структуры, называемой списками смежности.
Список смежности содержит для каждой вершины v, принадлежащей V, список смежных ей вершин. Используя терминологию языка C++, можно утверждать, что каждый элемент такого списка является записью R, содержащей в поле (*R).Key вершину графа, а в поле (*R).Sled - указатель на следующую запись в списке; ясно, что для последней записи в списке (*R).Sled содержит NULL.
Обозначим beg[v] - указатель на начало списка, содержащего вершины, смежные с вершиной v.
Изобразим схематически представление неориентированного графа с помощью списков смежности (символ Nобозначает NULL):

Рис.3. Представление неориентированного графа
Отметим, что для неориентированных графов каждое ребро представлено в списках смежности дважды.
Число ячеек памяти, необходимое для представления графа с помощью списков смежности, будет, очевидно, иметь порядок |V|+|E|.
На следующем шаге мы рассмотрим простейшие операции над графами, представленными списками смежности.

        1.4. Реализация простейших операций над графами, представленными списками смежности
На этом шаге мы рассмотрим несколько операций над графами, представленными списками смежности.
Теперь приведем реализацию на языке C++ простейших операций над графами с использованием представления графов списками смежности.
Вначале опишем типы данных:
#define N 12; // Количество вершин графа.
typedef struct zveno *svqz;
typedef struct zveno
{
  int Key; //Вершина графа.
  svqz Sled; // Указатель на следующую смежную вершину.
 } Leader;
svqz beg[N]; // Описание типа списков смежности.
1. Построение списков смежности, соответствующих данному ориентированному графу. Перед первым обращением к функции MakeGraph (создание графа) необходима инициализация списков смежности:
    for (i=0;i<N;i++) beg[i] = NULL;
void MakeGraph (svqz beg[N])
// Построение списков смежности beg графа.
{
  int x,y;
  svqz ukzv,uzel; //Рабочие указатели.

  cout<<"Вводите начало дуги: ";
  cin>>x;
  while (x!=0)
  {
    cout<< "Вводите конец дуги: ";
    cin>>y;
    AddGraph (x,y,beg);
    cout<< "Вводите начало дуги: "; cin>>x;
  }
}
2. Вывод содержимого списков смежности, соответствующих ориентированному графу.
void PrintGraph (svqz beg[N])
{
  int i;
  svqz ukzv; //Рабочий указатель.
  for (i=1;i<N;i++)
  {
    cout<<i<<" ...";
    ukzv = beg[i];
    if (ukzv==NULL) cout<<"Пустой список!\n";
    else {
      while (ukzv!=NULL)
        { cout<< (*ukzv).Key; ukzv = (*ukzv).Sled; }
      cout<<endl; }
  }
}
Теперь рассмотрим реализацию унарных операций [1, с.22] на графе.
3. Добавление дуги (x,y) (если ее не было!) к спискам смежности, соответствующим ориентированному графу.
void AddGraph (int x, int y, svqz beg[N])
{
  svqz ukzv,uzel; //Рабочие указатели.
  if (beg[x]!=NULL)
  {
    Poisk (beg[x],y,&ukzv);
    if (ukzv==NULL)
    { // Добавление элемента в конец списка,
       // заданного указателем beg[x].
      uzel = new (Leader);
      (*uzel).Key = y; (*uzel).Sled = NULL; ukzv = beg[x];
      while ((*ukzv).Sled!=NULL)
        ukzv = (*ukzv).Sled;
      (*ukzv).Sled = uzel;
    }
  }
  else
  {
    beg[x] = new (zveno);
    (*beg[x]).Key = y; (*beg[x]).Sled = NULL;
  }
}
4. Удаление дуги между двумя заданными вершинами графа, представленного списками смежности (заметим, что вершины, инцидентные дуге, из графа не удаляются).
void DeleteGraph (int x, int y, svqz beg[N])
{
  svqz ukzv;

  if (beg[x]!=NULL)
  //Удаление звена из списка без заглавного звена.
  { //Вершины в графе есть.
    Poisk (beg[x],y,&ukzv);
    if (ukzv!=NULL) Udalenie (&beg[x],&ukzv);
    else cout<<"Такой дуги в графе нет!\n";
  }
  else cout<<"Список пуст!\n";
}
void Poisk (svqz uksp, int ment, svqz *res)
// Поиск звена с информационным полем ment в
// однонаправленном списке uksp. *res - указатель
// на найденное звено или NULL.
{
  svqz q;

  *res = NULL; q = uksp;
  while ((q!=NULL)&&(*res==NULL))
    { if ((*q).Key==ment) *res = q;
      q = (*q).Sled; }
}
void Udalenie (svqz *ukstr, svqz *zv)
// Удаление звена, на которое ссылается указатель *zv,
// из однонаправленного списка, заданного указателем *ukstr.
{
  svqz ukzv,z;

  if (((**ukstr).Sled==NULL)&&(*zv==*ukstr))
  // В списке - один элемент!
    { *ukstr = NULL; delete zv; }
  else
    if (*zv==*ukstr) // Удаляемый элемент - первый.
      { *ukstr = (**ukstr).Sled; delete zv; }
    else {
      z = *ukstr; ukzv = (**ukstr).Sled;
      while (ukzv!=*zv)
        { z = ukzv; ukzv = (*ukzv).Sled; }
      (*z).Sled = (*(*zv)).Sled; delete zv;
  }
}
Отметим, что удаление вершины v из графа G приводит к подграфу, содержащему все вершины графа G за исключением v, и все ребра графа G, не инцидентные v. Заметим, что при данном представлении графа удаление вершин становится достаточно громоздким.
Приведем программу, демонстрирующую работу перечисленных выше функций.

Пример. Построение списков смежности, соответствующих ориентированному графу, вывод их на экран, добавление и удаление дуг.
#include <iostream.h>
#define N 12 //Количество вершин графа.
#define TRUE 1
#define FALSE 0

typedef struct zveno *svqz;
typedef struct zveno
{
  int Key; //Вершина графа.
  svqz Sled; //Указатель на следующую смежную вершину.
 } Leader;

class Spisok {
  private:
    svqz beg[N]; //Описание типа списков смежности.
    svqz res; //Указатель на найденное звено.
    void Poisk (svqz,int);
    void Udalenie (svqz *);
  public:
    Spisok ();
    svqz GetPoisk () { return res; }
    void MakeGraph ();
    void AddGraph (int,int);
    void DeleteGraph (int,int);
    void PrintGraph ();
};

void main ()
{
  Spisok A;
  int x; // Начало дуги.
  int y; // Конец дуги.

  A.MakeGraph (); // Построение списков смежности.
  // Вывод списков смежностей.
  cout<<"Представление графа списками смежности\n";
  A.PrintGraph (); cout<<endl;
  // Добавление дуги к графу.
  cout<<"Добавим к графу новую дугу...\n";
  cout<<"Введите начало дуги: "; cin>>x;
  cout<<"Введите конец дуги: "; cin>>y;
  A.AddGraph (x,y);
  cout<<"Представление графа списками смежности\n";
  A.PrintGraph (); cout<<endl;
  //Удаление дуги из графа.
  cout<<"Удалим из графа заданную дугу...\n";
  cout<<"Введите начало дуги: "; cin>>x;
  cout<<"Введите конец дуги: "; cin>>y;
  A.DeleteGraph (x,y);
  cout<<"Представление графа списками смежности\n";
  A.PrintGraph (); cout<<endl;
}

void Spisok::Poisk (svqz uksp,int ment)
// Поиск звена с информационным полем ment в
// однонаправленном списке uksp. res - указатель
// на найденное звено или NULL.
{
  svqz q;

  res = NULL; q = uksp;
  while ((q!=NULL)&&(res==NULL))
    { if ((*q).Key==ment) res = q; q = (*q).Sled; }
}

void Spisok::AddGraph (int x,int y)
// Добавление дуги (x,y) (если ее не было!) в граф,
// представленный списками смежности beg .
{
  svqz ukzv,uzel; // Рабочие указатели.

  if (beg[x]!=NULL)
  {
    Poisk (beg[x],y);
    if (GetPoisk()==NULL)
      { //Добавление элемента в конец списка, заданного указателем beg[x].
        uzel = new (Leader);
        (*uzel).Key = y; (*uzel).Sled = NULL; ukzv = beg[x];
        while ((*ukzv).Sled!=NULL)
           ukzv = (*ukzv).Sled;
        (*ukzv).Sled = uzel; }
  }
  else { beg[x] = new (zveno);(*beg[x]).Key = y; (*beg[x]).Sled = NULL; }
}

void Spisok::MakeGraph ()
// Построение списков смежности beg графа.
{
  int x,y;

  cout<<"Вводите начало дуги: "; cin>>x;
  cout<<"Вводите конец дуги: "; cin>>y;
  while (x!=0)
  {
    AddGraph (x,y);
    cout<< "Вводите начало дуги: "; cin>>x;
    cout<<"Вводите конец дуги: "; cin>>y;
  }
}

void Spisok::Udalenie (svqz *ukstr)
//* Удаление звена, на которое ссылается указатель res,
// из однонаправленного списка, заданного указателем *ukstr
{
  svqz ukzv,z;

  if (((**ukstr).Sled==NULL)&&(res==*ukstr)) //В списке - один элемент!
    { *ukstr = NULL; delete res; }
  else if (res==*ukstr) // Удаляемый элемент - первый.
        { *ukstr = (**ukstr).Sled; delete res; }
       else {
         z = *ukstr; ukzv = (**ukstr).Sled;
         while (ukzv!=res) { z = ukzv; ukzv = (*ukzv).Sled; }
         (*z).Sled = (*res).Sled; delete res; }
}

void Spisok::DeleteGraph (int x,int y)
// Удаление дуги (x,y) из списков смежности beg.
{
  if (beg[x]!=NULL)
  // Удаление звена из списка без заглавного звена.
  { // Вершины в графе есть.
    Poisk (beg[x],y);
    if (GetPoisk()!=NULL) Udalenie (&beg[x]);
    else cout<<"Такой дуги в графе нет!\n"; }
  else cout<<"Список пуст!\n";
}

void Spisok::PrintGraph ()
{
  svqz ukzv; // Рабочий указатель.

  for (int i=1;i<N;i++)
  { cout<<"..."<<i; ukzv = beg[i];
    if (ukzv==NULL) cout<<" Пустой список!\n";
    else {
      while (ukzv!=NULL) { cout<<(*ukzv).Key; ukzv = (*ukzv).Sled; }
      cout<<endl; }
  }
}

Spisok::Spisok() { for (int i=0;i<N;i++) beg[i] = NULL; }
Текст этой программы можно взять здесь.
Во многих алгоритмах необходимо динамически модифицировать структуру неориентированного графа путем добавления и удаления ребер. Если это нужно выполнить достаточно быстро, то полагаем, что в списках смежности элемент списка beg[u], содержащий вершину v, снабжен указателем на элемент списка beg[v], содержащий вершину u(и наоборот!), что схематически можно изобразить так:

Рис.1. Представление графа
Тогда, удаляя "часть" ребра (x,y) из списка, мы можем легко за число шагов, ограниченное константой, удалить другую "часть" ребра, а именно: (y,x), не просматривая весь список beg[y].
Далее, можно еще более усложнить структуру, если предположить, что каждый список смежных вершин является двунаправленным (попробуйте изобразить это схематически!).

Замечания.
    1. Аналогичным образом можно определить для каждой вершины v ориентированного графа список, определенный указателем SUC[v], содержащий вершины из множества {u: u->v}. "Еще один способ состоит в том, что для каждой вершины выписываются номера следующих, не смежных с ней..." [2, с.32].
    2. Представление графа в виде списков смежности определяет "порядок" ребер, смежных некоторой вершине графа. Граф с подобным упорядочиванием ребер называют упорядоченным графом. Дадим формальное определение.

Определение 1 [3, с.237].
Множество V={v1,v2,...,vn} вершин вместе с множеством {Lv1, Lv2,...,Lvn} упорядоченных списков упорядоченных пар вершин называют упорядоченным графом.
Упорядоченный граф определяет единственный неупорядоченный граф. Обратное утверждение неверно, поскольку в общем случае возможно много способов упорядочения графа.

Определение 2 [3, с.248].
Упорядоченным ориентированным графом называется пара G=(V,E), где V - конечное множество вершин, а E - множество упорядоченных списков дуг. Элементы E имеют вид Lv=((v,w1),(v,w2),...,(v,wk)), где v,wi принадлежат V.



(1) Свами М., Тхуласираман К. Графы, сети и алгоритмы. - М.: Мир, 1984. - 454 с.
(2) Зыков А.А. Основы теории графов. М.: Наука, 1987. - 384 с.
(3) Кук Д., Бейз Г. Компьютерная математика. - М.: Наука, 1990. - 384 с.

На следующем шаге мы рассмотрим представление графов с помощью ортогональных списков смежности.

        1.5. Представления графов. Ортогональные списки смежности
На этом шаге мы рассмотрим представление графов с помощью орогональных списков смежности.
На рисунке, приведенном ниже, изображен граф и его представление с помощью структуры данных, которую мы будем называть ортогональными списками смежности.

Рис.1.Ортогональные списки смежности
Вершины графа находятся в связанном списке, который называется списком заголовочных узлов. Каждый узел этого списка содержит четыре поля.
Если указатель P указывает на заголовочный узел, представляющий вершину Q графа, то:
    • поле (*P).Key содержит информацию, связанную с этой вершиной Q;
    • поле (*P).Count содержит количество вершин, "предшествующих" данной;
    • поле (*P).Next содержит указатель на заголовочный узел, представляющий следующую вершину графа (если такая вершина есть) в списке заголовочных узлов;
    • каждый заголовочный узел является заглавным звеном списка узлов второго типа, называемых дуговыми узлами. Такой список мы также будем называть списком смежности. Каждый узел списка смежности представляет конечную вершину некоторой дуги графа. Поле (*P).Trail указывает на список смежности, представляющий дуги, выходящие из вершины Q графа (английское слово "Trail" переводится как "тащиться, свисать, волочиться").
Каждый узел списка смежности содержит два поля: Id и Next, причем если Q указывает на списочный узел, представляющий дугу (A,B), то:
    • поле (*Q).Id содержит вершину B графа;
    • поле (*Q).Next указывает на дуговой узел, представляющий следующую дугу, выходящую из вершины A графа (если такая дуга есть).
На рисунке 1 показан граф и представление его ортогональными списками смежности. Каждый дуговой узел содержится в единственном списке смежности, представляющем все дуги, выходящие из данной вершины графа. Термин распределенные узлы используется как для заголовочных, так и для дуговых узлов структуры со многими связями, представляющей граф.
Приведем реализацию на языке C++ простейших операций над графами с использованием представления графов в виде ортогональных списков смежности.
Вначале опишем типы данных:
typedef struct L *Lref; // Тип: указатель на заголовочный узел.
typedef struct T *Tref; // Тип: указатель на дуговой узел.
//Описание типа заголовочного узла.
typedef struct L
{
   int Key; // Имя заголовочного узла.
   int Count; //Количество предшественников.
  Tref Trail; //Указатель на список смежности.
  Lref Next; //Указатель на следующий узел в списке заголовочных узлов.
 } Leader;

typedef struct T //Описание типа дугового узла.
{
  int Id;
  Tref Next;
} Trailer;
Приведем программу, демонстрирующую работу функций, предназначенных для выполнения некоторых операций над графами.

Пример. Построение ортогональных списков смежности, соответствующих ориентированному графу, вывод на экран структуры ортогональных списков смежности, добавление и удаление дуг, добавление и удаление вершин.
#include <iostream.h>
#define TRUE 1
#define FALSE 0
typedef int Boolean;
typedef struct L *Lref; //Тип: указатель на заголовочный узел.
typedef struct T *Tref; //Тип: указатель на дуговой узел.

//Описание типа заголовочного узла.
typedef struct L
{ int Key; //Имя заголовочного узла.
  int Count; //Количество предшественников.
  Tref Trail; //Указатель на список смежности.
  Lref Next; //Указатель на следующий узел в списке заголовочных узлов.
} Leader;

typedef struct T //Описание типа дугового узла.
{
  int Id;
  Tref Next;
} Trailer;

class Spisok
{
  private:
    Lref Head; //Указатель на начало списка заголовочных узлов.
    Lref Tail; //Указатель на фиктивный узел
               // в конце списка заголовочных узлов.
    void SearchGraph (int, Lref *);
    void Search (int, Lref *);
  public:
    Spisok () {//Инициализация списка заголовочных узлов.
               Head = Tail  = new (Leader); }
    void MakeGraph ();
    void AddGraph (int, int);
    void DeleteGraph (int, int);
    void PrintGraph ();
    void DeleteY (int);
};

void main ()
{
  Spisok A;
  int x,y; //Начало и конец дуги
  //Построение и вывод структуры ортогональных списков.
  A.MakeGraph ();
  A.PrintGraph (); cout<<endl;
  //Добавление дуги к графу.
  cout<<"Добавим к графу новую дугу...\n";
  cout<<"Введите начало дуги: "; cin>>x;
  cout<<"Введите конец дуги: "; cin>>y;
  A.AddGraph (x,y);
  A.PrintGraph (); cout<<endl;
  //Удаление дуги из графа.
  cout<<"Удалим из графа заданную дугу...\n";
  cout<<"Введите начало дуги: "; cin>>x;
  cout<<"Введите конец дуги: "; cin>>y;
  A.DeleteGraph (x,y);
  A.PrintGraph (); cout<<endl;
  //Удаление вершины графа.
  cout<< "Введите удаляемую вершину: "; cin>>y;
  A.DeleteY (y);
  A.PrintGraph (); cout<<endl;
}

void Spisok::Search (int w, Lref *h)
//Функция возвращает в *h указатель на заголовочный узел
//ключом w. Если узел отсутствует, то функция возвращает NULL .
{
  *h = Head;
  (*Tail).Key = w; //Поиск "с барьером".
  while ((**h).Key!=w) *h = (**h).Next;
  if (*h==Tail) //В списке заголовочных узлов нет узла с ключом w.
  *h = NULL;
}

void Spisok::SearchGraph (int w,Lref *h)
//Функция возвращает в *h указатель на заголовочный узел
//с ключом w. Если заголовочный узел отсутствует, то он
//добавляется в список.
{
  *h = Head; (*Tail).Key = w;
  while ((**h).Key!=w) *h = (**h).Next;
  if (*h==Tail)
  //В списке заголовочных узлов нет узла с ключом w.
  //Поместим его в конец списка *Head.
  { Tail = new (Leader); (**h).Count = 0;
    (**h).Trail = NULL; (**h).Next = Tail; }
}

void Spisok::MakeGraph ()
//Функция возвращает указатель Head на ортогональные
//списки смежности, соответствующую ориентированному графу.
{
  int x,y;
  Lref p,q; //Рабочие указатели.
  Tref t,r; // Рабочие указатели.
  Boolean Res; //Флаг наличия дуги.
  cout<<"Вводите начальную вершину дуги: ";
  cin>>x;
  while (x!=0)
  {
   cout<<"Вводите конечную вершину дуги: "; cin>>y;
   //Определим, существует ли в графе дуга (x,y)?
   SearchGraph (x,&p); SearchGraph (y,&q);
   r = (*p).Trail; Res = FALSE;
   while ((r!=NULL)&&(!Res))
    if ((*r).Id==y) Res = TRUE;
    else r = (*r).Next;
   if (!Res) //Если дуга отсутствует, то поместим её в граф.
   { t = new (Trailer); (*t).Id = y;
     (*t).Next = (*p).Trail; (*p).Trail = t; (*q).Count++; }
     cout<<"Вводите начальную вершину дуги: "; cin>>x;
   }
}

void Spisok::AddGraph (int x,int y)
//Добавление дуги (x,y) (если ее не было!) к связанной
//структуре, соответствующей ориентированному графу Head.
{
  Lref p,q; //Рабочие указатели.
  Tref t,r; //Рабочие указатели.
  Boolean Res; //Флаг наличия в графе данной дуги.
  //Определим, существует ли в графе дуга (x,y)?
  SearchGraph (x,&p);
  SearchGraph (y,&q);
  r = (*p).Trail; Res = FALSE;
  while ((r!=NULL)&&(!Res))
  if ((*r).Id==y) Res = TRUE; else r = (*r).Next;
  if (!Res)
  { //Если дуга отсутствует, то поместим её в граф.
    t = new (Trailer); (*t).Id = y; (*t).Next = (*p).Trail;
    (*p).Trail = t; (*q).Count++;
  }
}

void Spisok::DeleteGraph (int x,int y)
//Функция возвращает указатель Head на связанную
//структуру, соответствующую ориентированному графу
//и полученную удалением дуги (x,y).
{
  Lref p,q; //Рабочие указатели.
  Tref t,r; //Рабочие указатели.
  Boolean Res; //Флаг наличия в графе данной дуги.
  //Определим, существует ли в графе дуга (x,y)?
  Search (x, &p); Search (y, &q);
  if ((p!=NULL)&&(q!=NULL))
  { //Вершины x и y в графе есть.
    r = (*p).Trail; Res = FALSE;
    while ((r!=NULL)&&(!Res))
      if ((*r).Id==y) Res = TRUE;
      else r = (*r).Next;
    if (Res) //Если дуга существует, то удалим её.
      if (r==(*p).Trail)
        { (*p).Trail = (*(*p).Trail).Next; delete r; (*q).Count--; }
      else
      {
         t = (*p).Trail;
         while ((*t).Next!=r) t = (*t).Next;
         (*t).Next = (*(*t).Next).Next; delete r; (*q).Count--; }
  }
}

void Spisok::PrintGraph ()
//Вывод структуры смежности, заданной указателем
//Head и соответствующей ориентированному графу.
{
  Lref p; //Рабочий указатель.
  Tref q; //Рабочий указатель.
  p = Head;
  while (p!=Tail)
  {
    cout<<"("<<(*p).Key; q = (*p).Trail;
    while (q!=NULL)
    { cout<<(*q).Id; q = (*q).Next; }
      cout<<")"; p = (*p).Next; cout<<" ";
    }
}

void Spisok::DeleteY (int y)
//Функция возвращает указатель Head на связанную струк-
//туру, соответствующую графу с удаленной вершиной y.
{
  Lref p,q; //Рабочие указатели.
  Tref r,s; //Рабочие указатели.
  int x; //Рабочая переменная.
  //Удаление всех дуг (x,y), оканчивающихся  в вершине y.
  p = Head;
  while (p!=Tail)
  { x = (*p).Key; DeleteGraph (x,y); p = (*p).Next; }
  //Удаление списка смежности вершины y.
  SearchGraph (y, &p); r = (*p).Trail;
  while (r!=NULL)
  { s = r; r = (*r).Next; delete s; }
  //Удаление узла, содержащего вершину y, из  списка заголовочных узлов.
  q = Head;
  if (q==p) { Head = (*Head).Next; delete q; }
  else {
     while ((*q).Next!=p) q = (*q).Next;
     (*q).Next = (*p).Next; delete p; }
}
Текст этой программы можно взять здесь.
На следующем шаге мы рассмотрим представление графов с помощью структур Вирта.

        1.6. Представления графов. Структуры Вирта
На этом шаге мы рассмотрим представление графов с помощью структуры Вирта.
Используем для представления графа в памяти ЭВМ подход Никлауса Вирта [1, с.211-219], который предполагает построение динамической структуры со многими связями. Вершины графа представляются линейным списком, состоящим из заголовочных узлов. Каждый заголовочный узел содержит четыре поля.
Если указатель P указывает на заголовочный узел, представляющий вершину Q графа, то:
    • поле (*P).Key содержит информацию, связанную с вершиной Q;
    • поле (*P).Count содержит количество вершин, "предшествующих" данной;
    • поле (*P).Next содержит указатель на заголовочный узел, представляющий следующую вершину графа (если такая вершина есть) в списке заголовочных узлов;
    • каждый заголовочный узел является заглавным звеном списка узлов второго типа, называемых дуговыми узлами. Такой список мы будем называть списком смежности. Поле (*P).Trail указывает на список смежности, представляющий дуги, выходящие из вершины Q графа (английское слово "Trail" переводится как "тащиться, свисать, волочиться").
Каждый узел списка смежности содержит два поля: Id и Next, причем если Q указывает на дуговой узел, представляющий дугу (A,B), то:
    • поле (*Q).Id указывает на заголовочный узел, представляющий вершину B графа;
    • поле (*Q).Next указывает на дуговой узел, представляющий следующую дугу, выходящую из вершины A графа (если такая дуга есть).
Каждый дуговой узел содержится в единственном списке смежности, представляющем все дуги, выходящие из данной вершины графа.
Вывод. Каждый заголовочный узел содержит поля Key, Count и два указателя:
    • первый указывает на список смежных дуг, выходящих из вершины графа,
    • второй - на следующий заголовочный узел в списке заголовочных узлов.
Каждый дуговой узел содержит два указателя:
    • на следующий дуговой узел в списке смежности и
    • на заголовочный узел, представляющий ту вершину графа, которая является концом дуги.
На рисунке показан ориентированный граф и его представление с помощью структуры Вирта (символ N обозначает NULL):

Рис.1. Представление графа с помощью структуры Вирта


(1)Вирт H. Алгоритмы + структуры данных = программы. - М.: Мир, 1985. - 406 с.

На следующем шаге мы рассмотрим реализацию простейших операций над графом, представленным структурой Вирта.

        1.7. Реализация простейших операций над графом, представленным структурой Вирта
На этом шаге мы рассмотрим реализацию простейших операций над графом, представленным структурой Вирта .
Теперь приведем реализацию на языке C++ простейших операций над графами с использованием структуры Вирта.
Вначале опишем типы данных:
typedef struct L *Lref; //Тип: указатель на заголовочный узел.
typedef struct T *Tref; //Тип: указатель на дуговой узел.
//Описание типа заголовочного узла.
typedef struct L
{
  int Key; //Имя заголовочного узла.
  int Count; //Количество предшественников.
  Tref Trail; //Указатель на список смежности.
  Lref Next; //Указатель на следующий узел в
                  //списке заголовочных узлов.
} Leader;

//Описание типа дугового узла.
typedef struct T
{
  Lref Id;
  Tref Next;
} Trailer;
1. Поиск в структуре Вирта заголовочного узла с заданным значением поля Key и добавление его в список заголовочных узлов в случае отсутствия.
Lref SearchGraph (int w, Lref Head, Lref *Tail)
//Функция возвращает указатель на заголовочный узел
//с ключом w. Если заголовочный узел отсутствует,
//то он добавляется в список. Head - указатель на
//структуру Вирта.
{
  Lref h;

  h = Head; (**Tail).Key = w;
  while ((*h).Key!=w) h = (*h).Next;
  if (h==*Tail)
  {//В списке заголовочных узлов нет узла с ключом w.
    //Поместим его в конец списка Head.
    *Tail = new (Leader); (*h).Count = 0;
    (*h).Trail = NULL; (*h).Next = *Tail;}
  return h;
}
2. Построение структуры Вирта, соответствующей данному ориентированному графу. Перед самым первым обращением к функции создания графа MakeGraph () инициализируем список заголовочных узлов:
    Head = new (Leader); Tail = Head;.

Рис.1. Результат инициализации
Добавление к графу новых вершин и инцидентных им ребер осуществляется обращением к функции MakeGraph().
void MakeGraph (Lref *Head, Lref *Tail)
//Функция возвращает указатель *Head на структуру
// Вирта, соответствующую ориентированному графу.
{
  int x,y;
  Lref p,q; //Рабочие указатели.
  Tref t,r; //Рабочие указатели.
  Boolean Res; //Флаг наличия дуги.

  cout<<"Вводите начальную вершину дуги: ";
  cin>>x;
  while (x!=0)
  { cout>>"Вводите конечную вершину дуги: "; cin>>y;
     //Определим, существует ли в графе дуга (x,y)?
     p = SearchGraph (x,*Head,Tail); q = SearchGraph (y,*Head,Tail);
     r = (*p).Trail; Res = FALSE;
     while ((r!=NULL) && (!Res))
     if ((*r).Id==q) Res = TRUE;
     else r = (*r).Next;
     if (!Res) //Если дуга не существует, то поместим её в граф.
    { t = new (Trailer); (*t).Id = q; (*t).Next = (*p).Trail;
      (*p).Trail = t; (*q).Count++; }
    cout<< "Вводите начальную вершину дуги: "; cin>>x; }
}
3. Вывод структуры Вирта, соответствующей ориентированному графу.
void PrintGraph (Lref Head, Lref Tail)
//Вывод структуры Вирта, заданной указателем Head и
//соответствующей ориентированному графу.
{
  Lref p; //Рабочий указатель.
  Tref q; // Рабочий указатель.

  p = Head;
  while (p!=Tail)
  { cout<<"("<<(*p).Key; q = (*p).Trail;
     while (q!=NULL)
     {cout<<(*(*q).Id).Key; q = (*q).Next;}
       cout<<")"; p = (*p).Next; cout<<" "; }
}
Теперь рассмотрим реализацию унарных операций [1, с.22] на графе.
4. Добавление дуги (x,y) (если ее не было) к структуре Вирта, соответствующей ориентированному графу.
void AddGraph (int x,int y, Lref *Head, Lref *Tail)
//Добавление дуги (x,y) (если ее не было!) к структуре
//Вирта, соответствующей ориентированному графу *Head.
{
  Lref p,q; //Рабочие указатели.
  Tref t,r; // Рабочие указатели.
  Boolean Res; //Флаг наличия в графе данной дуги.

  p = SearchGraph (x,*Head,Tail); q = SearchGraph (y,*Head,Tail);
  //Определим, существует ли в графе дуга (x,y)?
  r = (*p).Trail; Res = FALSE;
  while ((r!=NULL) && (!Res))
    if ((*r).Id==q) Res = TRUE;
    else r = (*r).Next;
  if (!Res)
  { //Если дуга не существует, то поместим её в граф.
     t = new (Trailer); (*t).Id = q; (*t).Next = (*p).Trail;
     (*p).Trail = t; (*q).Count++; }
}
5. Удаление дуги между двумя вершинами структуры Вирта, определенной указателем Head. Заметим, что концевые вершины дуги из структуры Вирта (а значит, и из графа) не удаляются.
void DeleteGraph (int x,int y, Lref *Head, Lref *Tail)
//Функция возвращает указатель *Head на структуру
//Вирта, соответствующую ориентированному графу и
//полученную удалением дуги (x,y).
{
  Lref p,q; //Рабочие указатели.
  Tref t,r; //Рабочие указатели.
  Boolean Res; //Флаг наличия дуги.

  // Определим, существует ли в графе дуга (x,y)?
  p = Search (x,*Head,*Tail);q = Search (y,*Head,*Tail);
  if ((p!=NULL) && (q!=NULL))
  { // Вершины в графе есть.
     r = (*p).Trail; Res = FALSE;
     while ((r!=NULL) && (!Res))
     if ((*r).Id==q) Res = TRUE;
     else r = (*r).Next;
     if (Res) //Если дуга существует, то удалим её.
       if (r==(*p).Trail)
        { (*p).Trail = (*(*p).Trail).Next; delete r; (*q).Count--; }
       else {
           t = (*p).Trail;
          while ((*t).Next!=r) t = (*t).Next;
          (*t).Next = (*(*t).Next).Next; delete r; (*q).Count--; }
  }
}
Lref Search (int w, Lref Head, Lref Tail)
//Функция возвращает указатель на заголовочный узел с
//ключом w. Если узел отсутствует, то функция возвращает
//NULL.
{
  Lref h;

  h = Head;
  (*Tail).Key = w; //Поиск "с барьером".
  while ((*h).Key!=w) h = (*h).Next;
    if (h==Tail) //В списке заголовочных узлов нет узла с ключом w.
      h = NULL;
  return h;
}
6. Удаление вершины графа. Необходимо учесть, что удаление вершины v из графа G приводит к подграфу, содержащему все вершины графа G за исключением v, и все ребра графа G, не инцидентные v.
void DeleteY (int y, Lref Head, Lref Tail)
//Функция возвращает указатель *Head на структуру Вирта,
//соответствующую графу с удаленной вершиной y.
{
  Lref p,q; //Рабочие указатели.
  Tref r,s; // Рабочие указатели.
  int x; // Рабочая переменная.

  //Удаление всех дуг (x,y), оканчивающихся в вершине y.
  p = *Head;
  while (p!=*Tail)
  { x = (*p).Key; DeleteGraph (x,y,Head,Tail);p = (*p).Next; }
    //Удаление списка смежности вершины y.
    p = SearchGraph (y,*Head,Tail);
    r = (*p).Trail;
    while (r!=NULL)
    { s = r; r = (*r).Next; delete s; }
      //Удаление узла, содержащего вершину y, из
      //списка заголовочных узлов.
      q = *Head;
      if (q==p)
        { *Head = (**Head).Next; delete q;}
      else {
        while ((*q).Next!=p) q = (*q).Next;
        (*q).Next = (*p).Next; delete p; }
}
7. Удаление структуры Вирта, соответствующей графу. Не вызывает трудностей написание фрагмента, осуществляющего эту операцию:
.   .   .
t = Head;
while (t!=Tail)
{ Free2Graph (&(*t).Trail); t = (*t).Next; }
Free1Graph (&Head,&Tail);
delete Tail;
.   .   .
Здесь мы воспользуемся рекурсивными функциями очистки динамической памяти, занятой линейным списком:
void Free1Graph (Lref *Head, Lref *Tail)
//Очистка динамической памяти, занятой линейным списком,
//заданным указателем *Head.
{
  if (*Head!=*Tail)
  { Free1Graph (&(**Head).Next,Tail); delete *Head; *Head = NULL; }
}
void Free2Graph (Tref *X)
//Очистка динамической памяти, занятой линейным списком,
//заданным указателем *X.
{
  if (*X!=NULL)
  { Free2Graph (&(**X).Next); delete *X; *X = NULL; }
}


(1) Свами М., Тхуласираман К. Графы, сети и алгоритмы. - М.: Мир, 1984. - 454 с.

На следующем шаге мы приведем пример программы, в которой реализованы рассмотренные операции над графом, представленным структурой Вирта.

        1.8. Пример программы, реализующей простейшие операции над графом, представленным структурой Вирта
На этом шаге мы приведем пример программы, реализующей простейших операций над графом, представленным структурой Вирта.
Приведем программу, демонстрирующую работу всех приведенных на предыдущем шаге функций.

Пример. Построение динамической структуры Вирта, соответствующей ориентированному графу, вывод на экран его структуры, добавление и удаление ребер, добавление и удаление вершин.
#include <iostream.h>
#define TRUE 1
#define FALSE 0
typedef int Boolean;
typedef struct L *Lref; //Тип: указатель на заголовочный узел.
typedef struct T *Tref; //Тип: указатель на дуговой узел.
//Описание типа заголовочного узла.
typedef struct L
{
  int Key;    //Имя заголовочного узла.
  int Count;  //Количество предшественников.
  Tref Trail; //Указатель на список смежности.
  Lref Next;  //Указатель на следующий узел в
              //списке заголовочных узлов.
} Leader;

//Описание типа дугового узла.
typedef struct T
{
  Lref Id;
  Tref Next;
} Trailer;

class Spisok {
  private:
    Lref Head; //Указатель на список заголовочных узлов.
    Lref Tail; //Указатель на фиктивный элемент
               //в конце списка заголовочных узлов.
    Lref SearchGraph(int);
    Lref Search(int);
  public:
    Spisok () {//Инициализация списка заголовочных узлов.
               Head = Tail = new (Leader); }
    ~Spisok(); //Деструктор.
    void MakeGraph();
    void AddGraph(int, int);
    void DeleteGraph(int, int);
    void PrintGraph();
    void DeleteY(int);
    void Free1Graph(Lref *, Lref *);
    void Free2Graph(Tref *);
};

void main ()
{
  Spisok A;
  int x,y; //Начало и конец дуги.

  //Построение и вывод структуры Вирта.
  A.MakeGraph ();
  A.PrintGraph (); cout<<endl;
  cout<< "Добавим к графу новую дугу...\n";
  cout<< "Введите начало дуги: "; cin>>x;
  cout<< "Введите конец дуги: "; cin>>y;
  A.AddGraph (x,y);
  A.PrintGraph (); cout<<endl;
  cout<< "Добавим к графу новое ребро...\n";
  cout<< "Введите первую концевую вершину ребра: "; cin>>x;
  cout<< "Введите вторую концевую вершину ребра: "; cin>>y;
  A.AddGraph (x,y);
  A.AddGraph (y,x);
  A.PrintGraph (); cout<<endl;
  cout<< "Удалим из графа заданную дугу...\n";
  cout<< "Введите начало дуги: "; cin>>x;
  cout<< "Введите конец дуги: "; cin>>y;
  A.DeleteGraph (x,y);
  A.PrintGraph (); cout<<endl;
  cout<< "Удалим из графа заданное ребро...\n";
  cout<< "Введите первую концевую вершину ребра: "; cin>>x;
  cout<< "Введите вторую концевую вершину ребра: "; cin>>y;
  A.DeleteGraph (x,y);
  A.DeleteGraph (y,x);
  A.PrintGraph (); cout<<endl;
  cout<< "Введите удаляемую вершину: "; cin>>y;
  A.DeleteY (y);
  A.PrintGraph (); cout<<endl;
}

Spisok::~Spisok()
{
  //Очистка структуры Вирта.
  Lref t = Head;
  while (t!=Tail)
  { Free2Graph (&(*t).Trail); t = (*t).Next; }
  Free1Graph (&Head,&Tail);
  delete Tail;
}

Lref Spisok::SearchGraph (int w)
//Функция возвращает указатель на заголовочный узел
//с ключом w. Если заголовочный узел отсутствует, то он
//добавляется в список. Head - указатель на структуру Вирта.
{
  Lref h;

  h = Head; (*Tail).Key = w;
  while ((*h).Key!=w) h = (*h).Next;
  if (h==Tail)
  //В списке заголовочных узлов нет узла с ключом w.
  //Поместим его в конец списка Head.
  { Tail = new (Leader); (*h).Count = 0;
    (*h).Trail = NULL; (*h).Next = Tail; }
  return h;
}

Lref Spisok::Search (int w)
//Функция возвращает указатель на заголовочный узел
//ключом w. Если узел отсутствует, то функция возвращает NULL .
{
  Lref h = Head;
  (*Tail).Key = w; //Поиск "с барьером".
  while ((*h).Key!=w) h = (*h).Next;
  if (h==Tail) //В списке заголовочных узлов нет узла с ключом w.
    h = NULL;
  return h;
}

void Spisok::MakeGraph ()
//Функция возвращает указатель Head на структуру
//Вирта, соответствующую ориентированному графу.
{
  int x,y;
  Lref p,q;    //Рабочие указатели.
  Tref t,r;    // Рабочие указатели.
  Boolean Res; //Флаг наличия дуги.

  cout<<"Вводите начальную вершину дуги: ";
  cin>>x;
  while (x!=0)
  {
    cout<<"Вводите конечную вершину дуги: "; cin>>y;
    //Определим, существует ли в графе дуга (x,y)?
    p=SearchGraph (x); q=SearchGraph (y);
    r = (*p).Trail; Res = FALSE;
    while ((r!=NULL)&&(!Res))
      if ((*r).Id==q) Res = TRUE;
      else r = (*r).Next;
    if (!Res) //Если дуга отсутствует, то поместим её в граф.
    { t = new (Trailer); (*t).Id = q;
      (*t).Next = (*p).Trail; (*p).Trail = t; (*q).Count++; }
    cout<<"Вводите начальную вершину дуги: "; cin>>x;
  }
}

void Spisok::AddGraph (int x,int y)
//Добавление дуги (x,y) (если ее не было!) к структуре
//Вирта, соответствующей ориентированному графу Head.
{
  Lref p,q;    //Рабочие указатели.
  Tref t,r;    //Рабочие указатели.
  Boolean Res; //Флаг наличия в графе данной дуги.

  //Определим, существует ли в графе дуга (x,y)?
  p=SearchGraph (x); q=SearchGraph (y);
  r = (*p).Trail; Res = FALSE;
  while ((r!=NULL)&&(!Res))
    if ((*r).Id==q) Res = TRUE; else r = (*r).Next;
  if (!Res)
  { //Если дуга отсутствует, то поместим её в граф.
    t = new (Trailer); (*t).Id = q; (*t).Next = (*p).Trail;
    (*p).Trail = t; (*q).Count++;
  }
}

void Spisok::DeleteGraph (int x,int y)
//Функция возвращает указатель Head на структуру
//Вирта, соответствующую ориентированному графу
//и полученную удалением дуги (x,y).
{
  Lref p,q;    //Рабочие указатели.
  Tref t,r;    //Рабочие указатели.
  Boolean Res; //Флаг наличия в графе данной дуги.

  //Определим, существует ли в графе дуга (x,y)?
  p=Search (x); q= Search (y);
  if ((p!=NULL)&&(q!=NULL))
  { //Вершины x и y в графе есть.
    r = (*p).Trail; Res = FALSE;
    while ((r!=NULL)&&(!Res))
      if ((*r).Id==q) Res = TRUE;
      else r = (*r).Next;
   if (Res) //Если дуга существует, то удалим её.
   if (r==(*p).Trail)
     { (*p).Trail = (*(*p).Trail).Next; delete r; (*q).Count--; }
   else
    {
      t = (*p).Trail;
      while ((*t).Next!=r) t = (*t).Next;
      (*t).Next = (*(*t).Next).Next; delete r; (*q).Count--; }
    }
}

void Spisok::PrintGraph ()
//Вывод структуры Вирта, заданной указателем
//Head и соответствующей ориентированному графу.
{
  Lref p; //Рабочий указатель.
  Tref q; //Рабочий указатель.

  p = Head;
  while (p!=Tail)
  {
    cout<<"("<<(*p).Key; q = (*p).Trail;
    while (q!=NULL)
    { cout<<(*(*q).Id).Key; q = (*q).Next; }
    cout<<")"; p = (*p).Next; cout<<" ";
  }
}

void Spisok::DeleteY (int y)
//Функция возвращает указатель Head на структуру Вирта,
//соответствующую графу с удаленной вершиной y.
{
  Lref p,q; //Рабочие указатели.
  Tref r,s; //Рабочие указатели.
  int x;    //Рабочая переменная.
  //Удаление всех дуг (x,y), оканчивающихся  в вершине y.
  p = Head;
  while (p!=Tail)
  { x = (*p).Key; DeleteGraph (x,y); p = (*p).Next; }
  //Удаление списка смежности вершины y.
  p=SearchGraph (y); r = (*p).Trail;
  while (r!=NULL)
  { s = r; r = (*r).Next; (*(*s).Id).Count++; delete s; }
  //Удаление узла, содержащего вершину y, из  списка заголовочных узлов.
  q = Head;
  if (q==p) { Head = (*Head).Next; delete q; }
  else {
    while ((*q).Next!=p) q = (*q).Next;
    (*q).Next = (*p).Next; delete p; }
}

void Spisok::Free1Graph (Lref *Head, Lref *Tail)
//Очистка динамической памяти, занятой линейным списком,
// заданным указателем *Head.
{
  if (*Head!=*Tail)
  { Free1Graph (&(**Head).Next,Tail); delete *Head; *Head = NULL; }
}

void Spisok::Free2Graph (Tref *X)
//Очистка динамической памяти, занятой линейным списком,
// заданным указателем *X.
{
  if (*X!=NULL)
  { Free2Graph (&(**X).Next); delete *X; *X = NULL; }
}
Текст этой программы можно взять здесь.
На следующем шаге мы познакомимся с модифицированной структурой Вирта.

        1.9. Модифицированные структуры Вирта
На этом шаге мы рассмотрим модифицированные структуры Вирта.
Часто при реализации алгоритмов на ориентированных графах (см. [1, с.129,143,149]) требуется по заданной конечной вершине некоторой дуги ориентированного графа восстановить список "предшествующих" вершин. Для успешного решения поставленной задачи модифицируем ранее написанные функции MakeGraph(), AddGraph() и PrintGraph() с учетом следующего описания типов:
typedef struct L *Lref; //Тип: указатель на заголовочный узел.
typedef struct T *Tref; //Тип: указатель на дуговой узел.
//Описание типа заголовочного узла.
typedef struct L
{
  int Key; //Имя заголовочного узла.
  int Count; //Количество предшественников.
  int Count1; //Количество последующих вершин.
  Tref Pred; //Указатель на список смежности, содержащий "предшественников".
  Tref Trail; //Указатель на список смежности, содержащий "последователей".
  Lref Next; //Указатель на следующий узел в списке заголовочных узлов.
} Leader;

//Описание типа дугового узла.
typedef struct T
{
  Lref Id;
  Tref Next;
} Trailer;
Как и ранее, вершины графа помещаются в связанный список заголовочных узлов, каждый из которых теперь будет содержать шесть полей.
Если указатель P указывает на заголовочный узел, представляющий вершину Q графа, то
    • поле (*P).Key содержит информацию, связанную с этой вершиной (идентификатор вершины графа);
    • поле (*P).Count содержит количество вершин, "предшествующих" данной;
    • поле (*P).Count1 содержит количество вершин, "следующих за" данной;
    • поле (*P).Next содержит указатель на заголовочный узел, представляющий следующую вершину графа (если такая вершина есть) в списке заголовочных узлов;
    • каждый заголовочный узел является заглавным звеном двух списков узлов второго типа, называемых дуговыми узлами. Такие списки мы, как и ранее, будем называть списками смежности.
Каждый узел списков смежности представляет дугу графа. Поле (*P).Trail указывает на список смежности, представляющий дуги, выходящие из вершины Q графа.
Второй список смежности представляет собой список узлов, представляющих вершины-"предшественники" данной вершины графа. Поле  (*P).Pred содержит указатель на этот список.
Каждый узел списков смежности содержит два поля: Id и Next, причем для списка смежности, заданного указателем (*P).Trail, справедливо следующее: если Q указывает на списочный узел, представляющий дугу (A,B), то
    • поле (*Q).Id указывает на заголовочный узел, представляющий вершину  B графа;
    • поле (*Q).Next указывает на списочный узел, представляющий следующую дугу, выходящую из вершины Aграфа (если такая дуга есть).
На рисунке показан граф и его "улучшенное" представление Вирта:

Рис.1. Граф и его улучшенное представление Вирта

Пример. Построение модифицированной структуры Вирта, соответствующей ориентированному графу, вывод ее на экран и добавление ребер.
#include <iostream.h>
#define TRUE 1
#define FALSE 0
typedef int Boolean;
typedef struct L *Lref; //Тип: указатель на заголовочный узел.
typedef struct T *Tref; //Тип: указатель на дуговой узел.
//Описание типа заголовочного узла.
typedef struct L
{
  int Key;    //Имя заголовочного узла.
  int Count;  //Количество предшественников.
  int Count1; //Количество последующих вершин.
  Tref Pred;  //Указатель на список смежности, содержащий "предшественников".
  Tref Trail; //Указатель на список смежности, содержащий "последователей".
  Lref Next;  //Указатель на следующий узел в
              //списке заголовочных узлов.
} Leader;

//Описание типа дугового узла.
typedef struct T
{
  Lref Id;
  Tref Next;
} Trailer;

class Spisok {
  private:
    Lref Head; //Указатель на список заголовочных узлов.
    Lref Tail; //Указатель на фиктивный элемент
               //в конце списка заголовочных узлов.
    Lref SearchGraph(int);
    Lref Search(int);
  public:
    Spisok () {//Инициализация списка заголовочных узлов.
               Head = Tail = new (Leader); }
    ~Spisok(); //Деструктор.
    void MakeGraph();
    void AddGraph(int, int);
    void DeleteGraph(int, int);
    void PrintGraph();
    void DeleteY(int);
    void Free1Graph(Lref *, Lref *);
    void Free2Graph(Tref *);
};

void main ()
{
  Spisok A;
  int x,y; //Начало и конец дуги.

  //Построение и вывод структуры Вирта.
  A.MakeGraph ();
  A.PrintGraph (); cout<<endl;
  cout<< "Добавим к графу новую дугу...\n";
  cout<< "Введите начало дуги: "; cin>>x;
  cout<< "Введите конец дуги: "; cin>>y;
  A.AddGraph (x,y);
  A.PrintGraph (); cout<<endl;
  cout<< "Добавим к графу новое ребро...\n";
  cout<< "Введите первую концевую вершину ребра: "; cin>>x;
  cout<< "Введите вторую концевую вершину ребра: "; cin>>y;
  A.AddGraph (x,y);
  A.AddGraph (y,x);
  A.PrintGraph (); cout<<endl;
  cout<< "Удалим из графа заданную дугу...\n";
  cout<< "Введите начало дуги: "; cin>>x;
  cout<< "Введите конец дуги: "; cin>>y;
  A.DeleteGraph (x,y);
  A.PrintGraph (); cout<<endl;
  cout<< "Удалим из графа заданное ребро...\n";
  cout<< "Введите первую концевую вершину ребра: "; cin>>x;
  cout<< "Введите вторую концевую вершину ребра: "; cin>>y;
  A.DeleteGraph (x,y);
  A.DeleteGraph (y,x);
  A.PrintGraph (); cout<<endl;
  cout<< "Введите удаляемую вершину: "; cin>>y;
  A.DeleteY (y);
  A.PrintGraph (); cout<<endl;
}

Spisok::~Spisok()
{
  //Очистка структуры Вирта.
  Lref t = Head;
  while (t!=Tail)
  { Free2Graph (&(*t).Trail); t = (*t).Next; }
  Free1Graph (&Head,&Tail);
  delete Tail;
}

Lref Spisok::SearchGraph (int w)
//Функция возвращает указатель на заголовочный узел
//с ключом w. Если заголовочный узел отсутствует, то он
//добавляется в список. Head - указатель на структуру Вирта.
{
  Lref h;

  h = Head; (*Tail).Key = w;
  while ((*h).Key!=w) h = (*h).Next;
  if (h==Tail)
  //В списке заголовочных узлов нет узла с ключом w.
  //Поместим его в конец списка Head.
  { Tail = new (Leader); (*h).Count = (*h).Count1 = 0;
    (*h).Trail = (*h).Pred = NULL; (*h).Next = Tail; }
  return h;
}

Lref Spisok::Search (int w)
//Функция возвращает указатель на заголовочный узел
//ключом w. Если узел отсутствует, то функция возвращает NULL .
{
  Lref h = Head;
  (*Tail).Key = w; //Поиск "с барьером".
  while ((*h).Key!=w) h = (*h).Next;
  if (h==Tail) //В списке заголовочных узлов нет узла с ключом w.
    h = NULL;
  return h;
}

void Spisok::MakeGraph ()
//Функция возвращает указатель Head на модифицированную структуру
//Вирта, соответствующую ориентированному графу.
{
  int x,y;
  Lref p,q;    //Рабочие указатели.
  Tref t,r;    // Рабочие указатели.
  Boolean Res; //Флаг наличия дуги.

  cout<<"Вводите начальную вершину дуги: ";
  cin>>x;
  while (x!=0)
  {
    cout<<"Вводите конечную вершину дуги: "; cin>>y;
    //Определим, существует ли в графе дуга (x,y)?
    p=SearchGraph (x); q=SearchGraph (y);
    r = (*p).Trail; Res = FALSE;
    while ((r!=NULL)&&(!Res))
      if ((*r).Id==q) Res = TRUE;
      else r = (*r).Next;
    if (!Res) //Если дуга отсутствует, то поместим её в граф.
    { t = new (Trailer); (*t).Id = q;
      (*t).Next = (*p).Trail; (*p).Trail = t; (*q).Count++;
      t = new (Trailer); (*t).Id = p;
      (*t).Next = (*q).Pred;  (*q).Pred = t; (*p).Count1++; }
    cout<<"Вводите начальную вершину дуги: "; cin>>x;
  }
}

void Spisok::AddGraph (int x,int y)
//Добавление дуги (x,y) (если ее не было!) к модифицированной структуре
//Вирта, соответствующей ориентированному графу Head.
{
  Lref p,q;    //Рабочие указатели.
  Tref t,r;    //Рабочие указатели.
  Boolean Res; //Флаг наличия в графе данной дуги.

  //Определим, существует ли в графе дуга (x,y)?
  p=SearchGraph (x); q=SearchGraph (y);
  r = (*p).Trail; Res = FALSE;
  while ((r!=NULL)&&(!Res))
    if ((*r).Id==q) Res = TRUE; else r = (*r).Next;
  if (!Res)
  { //Если дуга отсутствует, то поместим её в граф.
    t = new (Trailer); (*t).Id = q; (*t).Next = (*p).Trail;
    (*p).Trail = t; (*q).Count++;
    t = new (Trailer); (*t).Id = p;
    (*t).Next = (*q).Pred;  (*q).Pred = t; (*p).Count1++;
  }
}

void Spisok::DeleteGraph (int x,int y)
//Функция возвращает указатель Head на структуру
//Вирта, соответствующую ориентированному графу
//и полученную удалением дуги (x,y).
{
  Lref p,q;    //Рабочие указатели.
  Tref t,r;    //Рабочие указатели.
  Boolean Res; //Флаг наличия в графе данной дуги.

  //Определим, существует ли в графе дуга (x,y)?
  p=Search (x); q= Search (y);
  if ((p!=NULL)&&(q!=NULL))
  { //Вершины x и y в графе есть.
    r = (*p).Trail; Res = FALSE;
    while ((r!=NULL)&&(!Res))
      if ((*r).Id==q) Res = TRUE;
      else r = (*r).Next;
   if (Res) //Если дуга существует, то удалим её.
   if (r==(*p).Trail)
     { (*p).Trail = (*(*p).Trail).Next; delete r; (*q).Count--; }
   else
    {
      t = (*p).Trail;
      while ((*t).Next!=r) t = (*t).Next;
      (*t).Next = (*(*t).Next).Next; delete r; (*q).Count--; }
    }
}

void Spisok::PrintGraph ()
//Вывод модифицированной структуры Вирта, заданной указателем
//Head и соответствующей ориентированному графу.
{
  Lref p; //Рабочий указатель.
  Tref q; //Рабочий указатель.

  p = Head;
  while (p!=Tail)
  {
    cout<<(*p).Key<<"(("; q = (*p).Trail;
    while (q!=NULL)
    { cout<<(*(*q).Id).Key<<" "; q = (*q).Next; }
    cout<<")(";
    q = p->Pred;
    while (q!=NULL)
    { cout <<(*(*q).Id).Key<<" "; q = q->Next; }
    cout<<"))";
    p = (*p).Next; cout<<" ";
  }
}

void Spisok::DeleteY (int y)
//Функция возвращает указатель Head на структуру Вирта,
//соответствующую графу с удаленной вершиной y.
{
  Lref p,q; //Рабочие указатели.
  Tref r,s; //Рабочие указатели.
  int x;    //Рабочая переменная.
  //Удаление всех дуг (x,y), оканчивающихся  в вершине y.
  p = Head;
  while (p!=Tail)
  { x = (*p).Key; DeleteGraph (x,y); p = (*p).Next; }
  //Удаление списка смежности вершины y.
  p=SearchGraph (y); r = (*p).Trail;
  while (r!=NULL)
  { s = r; r = (*r).Next; (*(*s).Id).Count++; delete s; }
  //Удаление узла, содержащего вершину y, из  списка заголовочных узлов.
  q = Head;
  if (q==p) { Head = (*Head).Next; delete q; }
  else {
    while ((*q).Next!=p) q = (*q).Next;
    (*q).Next = (*p).Next; delete p; }
}

void Spisok::Free1Graph (Lref *Head, Lref *Tail)
//Очистка динамической памяти, занятой линейным списком,
// заданным указателем *Head.
{
  if (*Head!=*Tail)
  { Free1Graph (&(**Head).Next,Tail); delete *Head; *Head = NULL; }
}

void Spisok::Free2Graph (Tref *X)
//Очистка динамической памяти, занятой линейным списком,
// заданным указателем *X.
{
  if (*X!=NULL)
  { Free2Graph (&(**X).Next); delete *X; *X = NULL; }
}
Текст этой программы можно взять здесь.

Замечание. Вы должны представлять важное различие между представлениями графа в виде матрицы смежностей и представлениями в виде структур смежности [2, с.408].
Если граф представлен с помощью матрицы смежностей, то у нас появляется возможность очевидного прохождения по строке или столбцу матрицы. Просмотр строки эквивалентен нахождению всех дуг, выходящих из данной вершины, что может быть эффективно реализовано при связанном представлении путем прохождения списка всех дуговых узлов, начинающегося с данного заголовочного узла.
Однако просмотр столбца матрицы смежностей эквивалентен нахождению всех дуг, оканчивающихся в данном узле, а для этой процедуры нет соответствующего простого метода для связанного представления, если не воспользоваться модифицированной структурой Вирта.
Конечно, Вы должны выбрать из этих представлений наиболее подходящее, исходя из требований конкретной задачи с учетом эффективности использования памяти и минимизации времени исполнения.



(1) Липский В. Комбинаторика для программистов: Пер. с польск. - М.: Мир, 1988. - 213 с.
(2) Лэнгсам Й., Огенстейн М., Тененбаум А. Структуры данных для персональных ЭВМ: Пер. с англ. - М.: Мир, 1989. - 568 с.

На следующем шаге мы познакомимся с представлением отношений.

        1.10. Представление отношений
На этом шаге мы определим различные виды отношений.

Определение.
Под бинарным отношением на множестве M мы понимаем произвольное подмножество E множества MxM.
Рассмотрим ориентированный граф, в котором любая дуга (v,w) имеется только в том случае, если элементы v и w, представляемые вершинами v и w, находятся в данном бинарном отношении r, т.е. vrw. Такой граф является исчерпывающей и наглядной формой представления отношения r, так как он полностью перечисляет все упорядоченные пары вершин-элементов, для которых отношение r имеет место.
Графы отношений могут обладать специальными свойствами: рефлексивностью, симметричностью, антисимметричностью, транзитивностью и т.д., отражающими соответствующие свойства отношений.

Определение 1.
Отношение r называется рефлексивным на множестве M, если для всякого a принадлежащего M верно ara. Отношение r называется нерефлексивным на множестве M, если ни для какого  a принадлежащего M не выполняется ara.
Будем говорить, что граф является рефлексивным, если каждая вершина имеет петлю, и антирефлексивным, если ни одна вершина петли не имеет.

Определение 2.
Отношение r называется симметричным на множестве M, если для каждой пары a и b элементов M из arbследует bra. Отношение r называется антисимметричным на множестве  M, если для несовпадающих элементов a и b из arb следует не bra.
Будем говорить, что граф является симметричным, если каждой дуге (v,w) соответствует дуга (w,v), и антисимметричным, если каждая дуга (v,w) исключает существование дуги (w,v) (заметим, что антисимметричный граф может как иметь петли, так и не иметь их!).

Определение 3.
Отношение r называется транзитивным на множестве M, если для любых трех элементов a, b и g, принадлежащих M, из arb и brg следует arg. Отношение r называется антитранзитивным на множестве M, если для любых трех элементов a, b и g, принадлежащих M, из arb и brg следует не arg.
Будем говорить, что граф является транзитивным, если существование дуг (v,w) и (w,u) означает существование дуги (v,u), и антитранзитивным, если существование дуг (v,w) и (w,u) означает несуществование указанной дуги.

Определение 4.
Отношение r на множестве M, которое одновременно рефлексивно, симметрично и транзитивно, называется отношением эквивалентности.
Графом отношения эквивалентности называется граф, являющийся
    • рефлексивным,
    • симметричным и
    • транзитивным.

Определение 5.
Отношение r называется полным отношением, если в нем для всякой пары a, b несовпадающих элементов множества M имеет место arb, либо bra. Отношение, не являющееся полным, называется неполным.
Граф полного отношения (полный граф) характеризуется наличием хотя бы одной дуги для любой пары вершин. В графе неполного отношения некоторые пары вершин не соединены дугами.

Определение 6.
Отношение r называется отношением порядка, если оно
    • антисимметричное и
    • транзитивное.
Соответственно графом отношения порядка называется антисимметричный и транзитивный граф.

Определение 7.
Отношение r называется отношением полного порядка (полным порядком), если оно
    • антисимметричное,
    • транзитивное и
    • полное.
Соответственно графом отношения полного порядка называется антисимметричный, транзитивный и полный граф.
Отношение r называется отношением неполного порядка (неполным порядком), если оно
    • антисимметричное,
    • транзитивное и
    • неполное.
Соответственно графом отношения неполного порядка называется антисимметричный, транзитивный и неполный граф.

Определение 8.
Отношение называется отношением строгого порядка, если оно
    • антирефлексивно,
    • антисимметрично и
    • транзитивно.
Соответственно графом отношения строгого порядка называется антирефлексивный, антисимметричный и транзитивный граф.
Отношение называется отношением нестрогого порядка, если оно
    • рефлексивно,
    • антисимметрично и
    • транзитивно.
Соответственно графом отношения нестрогого порядка называется рефлексивный, антисимметричный и транзитивный граф.
Конечно, отношение строгого порядка может быть как полным, так и неполным, и отношение нестрогого порядка тоже может быть как полным, так и неполным.
Определения разных видов порядка сведем в таблицу [1, с.87]:
Таблица 1. Определения разных видов порядка
Порядки
Отношения

Антисимметричное
Транзитивное
Рефлексивное
Антирефлексивное
Полное
Неполное
Строгий
+
+
 
+
 
 
Нестрогий
+
+
+
 
 
 
Полный
+
+
 
 
+
 
Неполный
+
+
 
 
 
+


(1) Березина Л.Ю. Графы и их применение. - М.: Просвещение, 1979. - 143 с.

На следующем шаге мы познакомимся с топологической сортировкой.

        1.11. Топологическая сортировка
На этом шаге мы рассмотрим общие принципы организации топологической сортировки.

Определение [1, с.324].
Множество M называется частично упорядоченным, если над его элементами определено отношение, которое мы назовем "x предшествует y" и обозначим x<<y, удовлетворяющее следующим свойствам для любых элементов x, y и z из M:
    • не x<<x (антирефлексивность),
    • если x<<y, то не y<<x (антисимметричность),
    • если x<<y и y<<z, то x<<z (транзитивность).
Мы будем предполагать, что M - конечное множество.
Частичное упорядочение на конечном множестве всегда можно проиллюстрировать с помощью диаграммынекоторого графа, в которой элементы представляются вершинами графа, а отношения представляются дугами между этими вершинами; x<<y означает, что от вершины, помеченной x, к вершине y существует путь, идущий вдоль дуг в соответствии с их направлением. Свойство частичного упорядочения означает, что в диаграмме графа нет замкнутых контуров.
Проблема топологической сортировки состоит в том, чтобы "перевести частичное упорядочение в линейное упорядочение", т.е. расположить элементы в такую последовательность a1,a2, ..., an, что если aj<<ak, то j<k [1, с.325]. Существование такого расположения не является непосредственно очевидным, однако оно заведомо невозможно, если имеется хотя бы один контур.
Как найти одно из возможных линейных упорядочений? Рецепт достаточно прост. Мы начинаем с того, что выбираем какой-либо элемент, которому не предшествует никакой другой (хотя бы один такой элемент существует, иначе имелся бы цикл). Этот элемент помещается в начало списка и исключается из множества M. Оставшееся множество по-прежнему частично упорядочено; таким образом, можно вновь применить тот же самый алгоритм, пока множество не станет пустым. Этот алгоритм оказался бы непригодным в единственном случае, когда образовалось бы непустое частично упорядоченное множество, в котором каждому элементу предшествует другой.
Для того, чтобы подробнее сформулировать этот алгоритм, нужно описать структуры данных, а также выбрать представление M и отношения порядка. Это представление зависит от выполняемых действий, особенно от операции выбора элемента без предшественников. Поэтому каждый элемент удобно представить тремя характеристиками:
    • ключом,
    • множеством следующих за ним элементов ("последователей") и
    • счетчиком предшествующих элементов ("предшественников").
Поскольку n - число элементов в M не задано априори, то это множество удобно организовать в виде линейного однонаправленного списка. Следовательно, каждый узел содержит еще поле, связывающее его со следующим узлом списка.
Мы будем считать, что ключи - это целые числа (необязательно последовательные от 1 до n). Аналогично множество последователей каждого элемента можно представить в виде линейного однонаправленного списка. Каждый узел списка последователей неким образом идентифицирован и связан со следующим узлом этого списка.
Если мы назовем узлы главного списка, в котором каждый элемент из M содержится ровно один раз, ведущими(Leaders), а узлы списка последователей ведомыми (Trailers), то мы получим такие описания типов данных [2]:
struct  Leader
{
    int Key;
    int Count;
    Trailer* Trail;
    Leader* Next;
};

struct Trailer
{
    Leader* Id;
    Trailer* Next;
};
Теперь легко видеть, что описанная структура является структурой Вирта некоторого ориентированного графа.
Первая часть программы топологической сортировки должна преобразовать входные данные в структуру списка. Это производится последовательным чтением пар ключей x и y (x<<y). Мы предполагаем, что последовательность входных пар ключей заканчивается дополнительным нулем.
Обозначим ссылки на их представления в списке ведущих через p и q. Эти записи ищутся в списке и, если их там нет, добавляются к нему. Эту задачу выполняет функция L ("Located"). Затем к списку ведомых для элемента xдобавляется новый узел, идентифицированный как y, счетчик предшественников для y увеличивается на 1. Такой алгоритм соответствует фазе ввода.
   //Фаза ввода.
   cout << "Задайте отношение частичного поpядка...\n";
   cout << "Элемент ";
   cin >> x;
   cout << " пpедшествует элементу ";
   while  (x!=0)
    {
         cin >> y;
         p = L (x);
         q = L (y);
         t = new (Trailer); t->Id = q; t->Next = p->Trail;
         p->Trail = t; q->Count += 1;
         cout << "Элемент ";
         cin >> x;
         cout << " пpедшествует элементу ";
    }
В этом фрагменте программы есть обращения к функции L(w), возвращающей ссылку на компоненту списка с ключом w.
На рисунке показана структура, сформированная при обработке входных данных вида: 1<<4, 1<<2, 4<<8, 5<<8, 2<<8 с помощью этого алгоритма:

Рис.1. Структура Вирта
После того, как на фазе ввода построена некоторая структура данных, можно провести саму топологическую сортировку, описанную выше. Но поскольку она состоит в последовательном выборе элемента с нулевым счетчиком предшественников, видимо, разумно вначале собрать все такие элементы в некоторый новый список. Поскольку мы знаем, что исходный список ведущих впоследствии не понадобится, то же самое поле Next можно использовать повторно для помещения в список ведущих, не имеющих предшественников. Такая замена одного списка на другойчасто встречается при работе со списками.
Это подробно описано в следующем программном фрагменте:
   //Поиск ведущих с нулевым количеством предшественников.
   p = Head; Head = NULL;
   while  (p!=Tail)
    {
      q = p; p = p->Next;
      if (q->Count==0)
        { q->Next = Head; Head = q; }
     }
Для удобства новая цепочка строится в обратном порядке.
Для нашего примера мы увидим, что список ведущих заменяется на список вида:

Рис.2. Результат преобразования
После всех этих подготовительных действий, направленных на то, чтобы выработать подходящее представление частично упорядоченного множества M, мы можем, наконец, перейти к собственно топологической сортировке, т.е. формированию выходной последовательности.
Это можно описать следующим образом:
   //Фаза вывода.
   cout << "Результат...\n";
   q = Head;
   while  (q!=NULL)
      {
         //Вывести элемент, а затем исключить его.
         cout << q->Key << " "; z -= 1; t = q->Trail; q = q->Next;
         while  (t!=NULL)
            {
               // Уменьшить счетчик предшественников у всех его
               // последователей в списке ведомых t; если какой-
               // либо счетчик стал равен 0, то добавить этот
               // элемент к списку ведущих q;
               // p - вспомогательная переменная, указывающая на
               // ведущий узел, счетчик которого нужно уменьшить
               // и проверить на равенство нулю.
               p = t->Id; p->Count -= 1;
               if  (p->Count==0) //Включение *p в список ведущих.
                  {  p->Next = q; q = p; }
               t = t->Next;
            }
      }
На этом разработка программы топологической сортировки завершается. Обратите внимание, что был введен счетчик z для подсчета ведущих узлов, сформированных на фазе ввода. Этот счетчик уменьшается каждый раз, когда ведущий узел выводится на фазе вывода. Поэтому он должен вновь стать равным нулю в конце работы программы. Если это не так, то в структуре остались элементы и среди них нет таких, у которых отсутствуют предшественники. Очевидно, что в этом случае множество M не является частично упорядоченным.
Приведенная выше программа фазы вывода служит примером работы со списком, который "пульсирует", т.е. элементы которого добавляются и удаляются в непредсказуемом порядке. Следовательно, это пример процесса, полностью использующего гибкость, которую обеспечивает связанный список.


(1) Кнут Д. Искусство программирования для ЭВМ. Т.1: Основные алгоритмы. - M.: Мир, 1976. - 736 с.
(2) Вирт H. Алгоритмы + структуры данных = программы. - М.: Мир, 1985. - 406 с.

Со следующего шага мы начнем приводить примеры программ с использованием топологической сортировки.

        1.12. Первый пример использования топологической сортировки
На этом шаге мы начнем рассматривать примеры использования топологической сортировки.

Пример 1 [2, с.211-219].
#include <iostream.h>
typedef struct Leader  *Lref; //Тип: указатель на заголовочный узел.
typedef struct Trailer *Tref; //Тип: указатель на дуговой узел.
//Описание типа заголовочного узла.
typedef struct Leader
{
  int Key;    //Информационное поле.
  int Count;  //Количество предшественников.
  Tref Trail;
  Lref Next;
};

//Описание типа дугового узла.
typedef struct Trailer
{
  Lref Id;
  Tref Next;
};

class Spisok {
  private:
    Lref Head; //Указатель на список заголовочных узлов.
    Lref Tail; //Указатель на фиктивный элемент
               //в конце списка заголовочных узлов.
    int z;     //Количество узлов, не имеющих предшественников.
  public:
    Spisok () {//Инициализация списка заголовочных узлов.
               Head = Tail = new (Leader); z = 0;};
    Lref L (int);
    void Poisk();
    void Vyvod();
};

void Spisok::Poisk()
{
  Lref p,q; // Рабочие указатели.

  p = Head; Head = NULL;
  while (p!=Tail)
  {
     q = p; p = p->Next;
     if (q->Count==0)
       { q->Next = Head; Head = q; }
   }
}

Lref Spisok::L (int w)
//Функция возвращает указатель на ведущего с ключом w.
{
  Lref h = Head;

  Tail->Key = w;
  while (h->Key!=w) h = h->Next;
  if (h==Tail)
  // В списке нет элемента с ключом w.
  {
    Tail = new (Leader); z++;
    h->Count = 0; h->Trail = NULL; h->Next = Tail;
  }
  return h;
}

void Spisok::Vyvod()
{
  Lref p,q; // Рабочие указатели.
  Tref t;

  cout << endl;
  cout << "Результат...\n";
  q = Head;
  while ( q!=NULL)
  {
     cout << q->Key << " ";
     z--;
     t = q->Trail; q = q->Next;
     while (t!=NULL)
     {
       p = t->Id; p->Count--;
       if  (p->Count==0) // Включение (*p) в список ведущих.
         { p->Next = q; q = p; }
       t = t->Next;
     }
  }
  if (z!=0)
      cout << "\nМножество не является частично упорядоченным!\n";
}

void main()
{
  Spisok A;
  Lref p,q; // Рабочие указатели.
  Tref t;
  int  x,y; // Рабочие переменные.

  // Фаза ввода.
  cout << "Задайте отношение частичного порядка...\n";
  cout << "Элемент ";
  cin >> x;
  cout << " предшествует элементу ";
  while (x!=0)
  {
    cin >> y;
    p = A.L(x); q = A.L(y);
    t = new (Trailer); t->Id = q; t->Next = p->Trail;
    p->Trail = t; q->Count += 1;
    cout << "Элемент ";
    cin >> x;
    cout << " предшествует элементу ";
  }
  // Поиск ведущих с нулевым количеством предшественников.
  A.Poisk();
  // Фаза вывода.
  A.Vyvod();
}
Текст этой программы можно взять здесь.
Тестовые пpимеpы:
1) данный тестовый пример заимствован у Д.Кнута [1, с.324-325].
Система отношений порядка имеет вид:
9>2, 3>7, 7>5, 5>8, 8>6, 4>6, 1>3, 7>4, 9>5, 2>8.
Программа топологической сортировки выдаст следующий результат:
1 3 7 4 9 2 5 8 6
2) Приведем более содержательный пример использования программы топологической сортировки [3, с.261-262].
Разнообразие вин, отражающих почтенную традицию и свидетельствующее об исключительном богатстве палитры французских виноделов, кажется, представляет бесконечные возможности для сервировки хорошего обеда. В действительности же имеются ограничения, выраженные следующими двумя общими правилами:
    • не принято подавать за обедом более четырех вин, не считая шампанского;
    • последовательность вин на столе подчиняется некоторым соотношениям порядка, признаваемым всеми знатоками. Эти соотношения порядка таковы:
    •          белое сухое                     < белое бархатистое,
    •          белое бархатистое               < белое сладкое,
    •          красное легкое                  < красное крепкое,
    •          белое (за исключением сладкого) < красное,
    •          крепкое                         < белое сладкое.
При этом знак < указывает, что вино, стоящее слева от него, должно быть подано прежде вина, которое стоит справа. Мы хотим отметить то, что эти соотношения вносят в любой винный погреб частичное упорядочение с точки зрения математика.
Закодируем сорта вин следующим образом:
   1 - белое сухое,
   2 - белое бархатистое,
   3 - белое сладкое,
   4 - красное легкое,
   5 - красное крепкое.
Тогда система отношений порядка примет вид:
1<2, 2<3, 4<5, 1<4, 1<5, 2<4, 2<5, 4<3, 5<3,
а программа топологической сортировки выдаст следующий результат:
1 2 4 5 3
Hо так как не принято подавать за обедом более четырех вин, а шампанское в нашем перечне сортов вин отсутствует, то возможны лишь следующие варианты:
    2 4 5 3
    1 4 5 3
    1 2 5 3
    1 2 4 3
    1 2 4 5
3) Этот тестовый пример базируется на идее об использовании топологической сортировки, упомянутой в монографиях [2, с.212; 4, с.311].
В учебных программах для высших учебных заведений одни предметы опираются на материал других, поэтому некоторые курсы студенты должны прослушать раньше других. Если курс v содержит материал для курса w, мы пишем v<<w. Топологическая сортировка курсов означает чтение курсов в таком порядке, чтобы ни один курс не читался раньше того, на материале которого он основан.
Поставим задачу: топологически упорядочить курсы по
    • математике,
    • дискретной математике и
    • информатике.
для студентов педагогических вузов. Наш взгляд на "упорядоченность" курсов достаточно полно отражает следующая таблица:
Таблица 1. Упорядоченность курсов
Номер курса
Название курса
Последующие курсы
C1
Дискретная математика
C2,C3,С4,C5,C6
C2
Теория кодирования
C10
C3
Теория автоматов
C5,C11
C4
Машинная арифметика
C10
C5
Формальные языки и грамматики
C11
C6
Теория графов
C8
C7
Введение в программирование
C8,C18
C8
Структуры данных
C9,С11,C12,С14,C15,C16,C25
C9
Анализ алгоритмов
C16,C27
C10
Устройство ЭВМ
C12
C11
Теория компиляторов
C12,C14
C12
Операционные системы
Нет
C13
Базы данных
Нет
C14
Парадигмы программирования
С15,C23
C15
Искусственный интеллект
Нет
C16
Информационный поиск
C13,C15
C17
Реляционная алгебра и реляционное исчисление
C13
C18
Доказательство правильности программ
C14
C19
Математическая логика
C15,С18,C24
C20
Теория взаимодействующих последовательных процессов
C12,C14
C21
Алгебра
C8,C17,C20,C23
C22
Математический анализ
C9,C23
C23
Вычислительная математика
Нет
C24
Теория алгоритмов
C2,C7,C9,C14
C25
Машинная графика
C27
C26
Геометрия
C25
C27
Вычислительная геометрия
Нет
    Применив программу топологической сортировки, получим последовательность целых чисел:
26 22 21 17 20 19 24 7 18 1 2 3 5 4 10 6 8 9 16 13 11 12 14 23 15 25 27
Заметим, что в приведенной последовательности допустима перестановка чисел 15 и 23. С учетом этого, получим расположение курсов достаточно крупными блоками:
    • Классическая математика (алгебра, геометрия, математический анализ, математическая логика и теория алгоритмов): 26 22 21 17 20 19 24.
    • Введение в программирование: 17 18.
    • Дискретная математика: 1 2 3 5 4.
    • Архитектура вычислительных систем: 10.
    • Структуры данных и анализ алгоритмов: 6 8 9.
    • Программное обеспечение вычислительных систем: 16 13 11 12 14 15.
    • Вычислительная математика: 23.
    • Алгоритмы машинной графики: 25 27.

Замечание [1, с.332]. Метод топологической сортировки был впервые опубликован Каном (A.B.Kahn, 1962). Сам факт возможности топологической сортировки был доказан в статье Шпильрайна (E.Szpilrajn, 1930).



(1) Кнут Д. Искусство программирования для ЭВМ. Т.1: Основные алгоритмы. - M.: Мир, 1976. - 736 с.
(2) Вирт H. Алгоритмы + структуры данных = программы. - М.: Мир, 1985. - 406 с.
(3) Кофман А., Фор Р. Займемся исследованием операций. - М.: Мир, 1966, с.261-262.
(4) Tucker, Allen B. Computer Science: A Second Course Using Modula-2. McGraw-Hill, Inc. - 401 pp.

На следующем шаге мы продолжим рассматривать примеры использования топологической сортировки.

        1.13. Второй пример использования топологической сортировки
На этом шаге мы рассмотрим еще пример использования топологической сортировки .
Ниже мы приведем реализацию некоторого алгоритма детерминированного выбора ведущего элемента с нулевым количеством предшественников при топологической сортировке. Установите самостоятельно в чем его идея!
#include <iostream.h>
typedef struct Leader  *Lref; //Тип: указатель на заголовочный узел.
typedef struct Trailer *Tref; //Тип: указатель на дуговой узел.
//Описание типа заголовочного узла.
typedef struct Leader
{
  int Key;    //Информационное поле.
  int Count;  //Количество предшественников.
  int CountF; //Количество последователей.
  Tref Trail;
  Lref Next;
};

//Описание типа дугового узла.
typedef struct Trailer
{
  Lref Id;
  Tref Next;
};

class Spisok {
  private:
    Lref Head; //Указатель на список заголовочных узлов.
    Lref Tail; //Указатель на фиктивный элемент
               //в конце списка заголовочных узлов.
    int z;     //Количество узлов, не имеющих предшественников.
    int  Length_List(Tref);
    void Sorting (Lref);
  public:
    Spisok () {//Инициализация списка заголовочных узлов.
               Head = Tail = new (Leader); z = 0;};
    Lref L (int);
    void Poisk();
    void Vyvod();
    void Zapoln();
};

void Spisok::Zapoln()
// Заполнение полей CountF узлов построенного графа.
{
  Lref p; // Рабочий указатель.

  p = Head;
  while ( p!=Tail)
  {
    p->CountF = Length_List (p->Trail);
    p = p->Next;
  }
}

void Spisok::Poisk()
{
  Lref p,q; // Рабочие указатели.

  p = Head; Head = NULL;
  while (p!=Tail)
  {
     q = p; p = p->Next;
     if (q->Count==0)
       { q->Next = Head; Head = q; }
   }
}

Lref Spisok::L (int w)
//Функция возвращает указатель на ведущего с ключом w.
{
  Lref h = Head;

  Tail->Key = w;
  while (h->Key!=w) h = h->Next;
  if (h==Tail)
  // В списке нет элемента с ключом w.
  {
    Tail = new (Leader); z++;
    h->Count = 0; h->Trail = NULL; h->Next = Tail;
  }
  return h;
}

void Spisok::Vyvod()
{
  Lref p,q; // Рабочие указатели.
  Tref t;

  cout << "\nРезультат топологической сортировки:\n";
  q = Head;
  while ( q!=NULL)
  {
     Sorting (q);
     cout << q->Key << " ";
     z--;
     t = q->Trail; q = q->Next;
     while (t!=NULL)
     {
       p = t->Id; p->Count--;
       if  (p->Count==0) // Включение (*p) в список ведущих.
         { p->Next = q; q = p; }
       t = t->Next;
     }
  }
  if (z!=0)
      cout << "\nМножество не является частично упорядоченным!\n";
}

int Spisok::Length_List (Tref T)
// Функция позволяет найти количество элементов в линейном списке.
// T - указатель на звено, следующее за заглавным звеном.
{
  if (T==NULL) return 0;
  else  return 1 + Length_List(T->Next);
}

void Spisok::Sorting (Lref Head)
// Сортировка списка элементов по полю CountF
// в порядке убывания.
// 21.10.93 (c) Коврижных Д. & Швецкий М.В.
{
  Lref UkZv_1,UkZv_2;
  int A,B,C;
  Tref D;
  Lref UkZv_3; // Рабочий указатель.
  Tref UkZv_4; // Рабочий указатель.

  UkZv_1 = Head;
  while ( UkZv_1!=NULL )
  {
     UkZv_2 = UkZv_1->Next;
     while  (UkZv_2!=NULL)
     {
       if  (UkZv_1->CountF < UkZv_2->CountF)
         {
           A              = UkZv_1->Key;
           B              = UkZv_1->Count;
           C              = UkZv_1->CountF;
           D              = UkZv_1->Trail;

           UkZv_1->Key    = UkZv_2->Key;
           UkZv_1->Count  = UkZv_2->Count;
           UkZv_1->CountF = UkZv_2->CountF;
           UkZv_1->Trail  = UkZv_2->Trail;

           UkZv_2->Key    = A;
           UkZv_2->Count  = B;
           UkZv_2->CountF = C;
           UkZv_2->Trail  = D;

           UkZv_3 = Head;
           while  (UkZv_3!=NULL)
           {
              UkZv_4 = UkZv_3->Trail;
              while  (UkZv_4!=NULL)
              {
                 if  (UkZv_4->Id==UkZv_1)
                      UkZv_4->Id = UkZv_2;
                 else
                   if ( UkZv_4->Id==UkZv_2 ) UkZv_4->Id = UkZv_1;
                 UkZv_4 = UkZv_4->Next;
              }
              UkZv_3 = UkZv_3->Next;
           }
         }
       UkZv_2 = UkZv_2->Next;
     }
     UkZv_1 = UkZv_1->Next;
  }
}

void main()
{
  Spisok A;
  Lref p,q; // Рабочие указатели.
  Tref t;
  int  x,y; // Рабочие переменные.

  // Фаза ввода.
  cout << "Задайте отношение частичного порядка...\n";
  cout << "Элемент ";
  cin >> x;
  cout << " предшествует элементу ";
  while (x!=0)
  {
    cin >> y;
    p = A.L(x); q = A.L(y);
    t = new (Trailer); t->Id = q; t->Next = p->Trail;
    p->Trail = t; q->Count += 1;
    cout << "Элемент ";
    cin >> x;
    cout << " предшествует элементу ";
  }
  // Заполнение полей CountF узлов построенного графа.
  A.Zapoln();
  // Поиск ведущих с нулевым количеством предшественников.
  A.Poisk();
  // Фаза вывода.
  A.Vyvod();
}
Текст этой программы можно взять здесь.
На следующем шаге мы продолжим рассматривать примеры использования топологической сортировки.

        1.14. Третий пример использования топологической сортировки
На этом шаге мы рассмотрим еще пример использования топологической сортировки.
В монографии [1,с.335,упр.23] Д.Кнут пишет: "Когда алгоритм топологической сортировки заканчивает работу из-за того, что во входной информации обнаружен цикл, то невелика будет польза, если он остановится и сообщит: "Встретился цикл". Полезно в этом случае напечатать один из циклов, показывая ту часть информации, в которой имеется ошибка."
Дополним алгоритм топологической сортировки так, чтобы в нем предусматривался вывод какого-нибудь найденного контура на печать. Воспользуемся алгоритмом, приведенном в [1, с.647].
Для того, чтобы читатель смог разобраться в реализации алгоритма на языке С++, мы (редчайший случай!) используем в программе метки и оператор goto.
#include <iostream.h>
typedef struct Leader  *Lref; //Тип: указатель на заголовочный узел.
typedef struct Trailer *Tref; //Тип: указатель на дуговой узел.
#define FALSE 0
#define TRUE 1
//Описание типа заголовочного узла.
struct Leader
{
  int Key;    //Информационное поле.
  int Count;  //Количество предшественников.
  Tref Trail; //Указатель на список последователей.
  Lref Next;
};

//Описание типа дугового узла.
struct Trailer
{
  Lref Id;
  Tref Next;
};

class Spisok {
  private:
    Lref Head; //Указатель на список заголовочных узлов.
    Lref Tail; //Указатель на фиктивный элемент
               //в конце списка заголовочных узлов.
    int z;     //Количество узлов, не имеющих предшественников.
  public:
    Spisok () {//Инициализация списка заголовочных узлов.
               Head = Tail = new (Leader); z = 0;};
    Lref L (int);
    void Poisk();
    int  Vyvod();
    void Neupor();
};

int VspomSet[256]; // Множество, содержащее вершины графа,
                   // имеющие нулевое количество предшественников.
                   // По умолчанию элементы инициалируются 0.

Lref Spisok::L (int w)
//Функция возвращает указатель на ведущего с ключом w.
{
  Lref h = Head;

  Tail->Key = w;
  while (h->Key!=w) h = h->Next;
  if (h==Tail)
  // В списке нет элемента с ключом w.
  {
    Tail = new (Leader); z++;
    h->Count = 0; h->Trail = NULL; h->Next = Tail;
  }
  return h;
}

void Spisok::Poisk()
{
  Lref p,q; // Рабочие указатели.

  p = Head; Head = NULL;
  while (p!=Tail)
  {
     q = p; p = p->Next;
     if (q->Count==0)
       { q->Next = Head; Head = q; }
   }
}

int Spisok::Vyvod()
{
  Lref p,q; // Рабочие указатели.
  Tref t;

  cout << "\nРезультат топологической сортировки:\n";
  q = Head;
  while ( q!=NULL)
  {
     cout << q->Key << " "; VspomSet[q->Key] = 1;
     z--;
     t = q->Trail; q = q->Next;
     while (t!=NULL)
     {
       p = t->Id; p->Count--;
       if  (p->Count==0) // Включение (*p) в список ведущих.
         { p->Next = q; q = p; }
       t = t->Next;
     }
  }
  if (z!=0)
    {
      cout << "\nМножество не является частично упорядоченным!\n";
      return 1;
    }
  else return 0;
}

void Spisok::Neupor()
{
  Lref p,q,r; // Рабочие указатели.
  Tref t;
  int Flag;

  cout << "Имеется следующий контур (контур печатается ";
  cout << "в обратном порядке):\n";
  //В дальнейшем работаем только с копией основного списка.
  p = Head;
  while (p!=Tail)
  {
    if ( VspomSet[p->Key] ) p->Trail = NULL;
    p = p->Next;
  }
  // -------
  p = Head;
  while ( p!=Tail )
  { p->Count = 0; p = p->Next; }
  // ---------------------------------------
  p = Head;
  while ( p!=Tail )
  {
    r = p; t = p->Trail; p->Trail = NULL;
    while ( t!=NULL )
    {
      if  (t!=NULL && t->Id->Count==0) t->Id->Count = r->Key;
      t = t->Next;
    }
    p = p->Next;
  }
  // ----------------------
  p = Head; Flag = FALSE;
  while (p!=Tail && !Flag)
    if ( p->Count!=0 ) Flag = TRUE;
    else  p = p->Next;
  // ---------------------------------------
  t = new (Trailer); // Создали вспомогательную запись.
A:
  p->Trail = t;
  q = Head; Flag = FALSE;
  while  (q!=Tail && !Flag)
    if ( q->Key==p->Count ) Flag = TRUE;
    else  q = q->Next;
  if ( q->Trail==NULL ) { p = q; goto A; }
  // -----------------------------------
  z = p->Key; // Сохранили начало контура.
B:
  cout << p->Key << " ";
  p->Trail = NULL;
  q = Head; Flag = FALSE;
  while  (q!=Tail && !Flag)
   if ( q->Key==p->Count ) Flag = TRUE;
   else  q = q->Next;
  if ( q->Trail!=NULL ) { p = q; goto B; }
  cout << z; // Напечатали начало контура.
}

void main()
{
  Spisok A,A_Copy;
  Lref p,q; // Рабочие указатели.
  Tref t;
  Lref p1,q1; // Рабочие указатели для создания копии списка.
  Tref t1;
  int  x,y; // Рабочие переменные.

  // Фаза ввода.
  cout << "Задайте отношение частичного порядка...\n";
  cout << "Элемент ";
  cin >> x;
  cout << " предшествует элементу ";
  while (x!=0)
  {
    cin >> y;
    //Построение основного списка.
    p = A.L(x); q = A.L(y);
    t = new (Trailer); t->Id = q; t->Next = p->Trail;
    p->Trail = t; q->Count += 1;
    //Построение копии основного списка.
    p1 = A_Copy.L(x); q1 = A_Copy.L(y);
    t1 = new (Trailer); t1->Id = q1; t1->Next = p1->Trail;
    p1->Trail = t1; q1->Count += 1;
    cout << "Элемент ";
    cin >> x;
    cout << " предшествует элементу ";
  }
  // Поиск ведущих с нулевым количеством предшественников.
  A.Poisk();
  // Фаза вывода.
  if (A.Vyvod()) //Если множество неупорядоченное,
                 //то работаем с копией.
       A_Copy.Neupor();
}
Текст этой программы можно взять здесь.
Тестовые примеры:
    • для системы отношений частичного порядка:
    • 8>5, 2>3, 2>1, 5>2, 4>1, 3>4, 4>6, 6>9, 9>5
программа обнаруживает цикл вида: 2,5,9,6,4,3,2.
    • для системы отношений частичного порядка [1, с.648]:
    • 9>2, 3>7, 7>5, 5>8, 8>6, 4>6, 1>3, 7>4, 9>5, 2>8, 1>9, 10>1, 6>10.
программа обнаруживает цикл вида: 2,9,1,10,6,8,2.

Замечания.
    1. Если Вы загляните в [1, с.647], то учтите, что необходимо исправить следующие неточности в записи алгоритма на псевдокоде:
        ◦ шаг T9 алгоритма следует читать так: "Для 1<=k<=n установить P <- TOP[k], TOP[k] <- U и выполнить шаг T10.";
        ◦ второе предложение в шаге T10 должно быть таким: "P <- NEXT(P)";
        ◦ шаг T12 алгоритма следует читать так: "Установить TOP[k] <- W, где W - указатель, отличный от Nil, и k <-QLINK[k]. Теперь, если TOP[k] = Nil, повторить этот шаг.";
        ◦ шаг T13 алгоритма следует читать так: "(Мы нашли начало цикла.) Напечатать значение k, установить TOP[k] <-Nil, k <- QLINK[k], и если TOP[k] = W, повторить этот шаг."
    2. Алгоритм обнаружения контура при топологической сортировке изложен также в [2, с.495-496].



(1) Кнут Д. Искусство программирования для ЭВМ. Т.1: Основные алгоритмы. - M.: Мир, 1976. - 736 с.
(2) Трамбле Ж., Соренсон П. Введение в структуры данных. - М.: Машиностроение, 1982. - 784 с.

На следующем шаге мы продолжим рассматривать примеры использования топологической сортировки.

        1.15. Четвертый пример использования топологической сортировки
На этом шаге мы рассмотрим последний пример использования топологической сортировки.
Лемма [1, с.127].
В произвольном ориентированном бесконтурном графе вершины можно перенумеровать так, что каждая дуга будет иметь вид (vi,vj), где i<j.
Для доказательства леммы предложим алгоритм, конструирующий такую нумерацию (в виде программы на языке С++).
Алгоритм основывается на следующем простом факте: в произвольном бесконтурном графе существует вершина, в которую не заходит ни одна дуга.
Чтобы убедиться в этом, выберем произвольную вершину w1 графа, затем некоторую вершину w2, такую что w1<-w2, и т.д. Через конечное число шагов мы должны дойти до некоторой вершины wi, в которую не заходит ни одна дуга, ибо в силу бесконтурности ни одна вершина не может повторяться в последовательности w1,w2,w3,...
#include <iostream.h>
#define TRUE 1
#define FALSE 0
typedef int Boolean;
// Нумерация вершин в бесконтурном графе.
typedef struct Leader  *Lref; //Тип: указатель на заголовочный узел.
typedef struct Trailer *Tref; //Тип: указатель на дуговой узел.
//Описание типа заголовочного узла.
struct Leader
{
  int Key;    //Имя заголовочного узла.
  int Number; //Новый номер вершины.
  int Count;  //Количество предшественников.
  int Count1; //Количество последующих вершин.
  Tref Pred;  //Указатель на список предшественников.
  Tref Trail; //Указатель на список последователей.
  Lref Next;  //Указатель на следующий узел в
              //списке заголовочных узлов.
};

//Описание типа дугового узла.
struct Trailer
{
  Lref Id;
  Tref Next;
};

//Описание типа узла стека.
struct Zveno
{
  Lref Element; //Указатель на вершину.
  Zveno*  Sled;
};

class Spisok {
  private:
	 Lref Head;    //Указатель на список заголовочных узлов.
	 Lref Tail;    //Указатель на фиктивный элемент
                      //в конце списка заголовочных узлов.
	 Zveno* Stack; //Указатель на рабочий стек.
	 Lref SearchGraph (int);
	 void Udalenie (Lref*);
	 void V_Stack (Lref);
  public:
	 Spisok () {//Инициализация списка заголовочных узлов.
            Head = Tail = new (Leader); };
	 void MakeGraph();
	 void PrintGraph();
	 void Renum();
	 void Vyvod();
};


void Spisok::MakeGraph ()
//Функция возвращает указатель Head на структуру
//Вирта, соответствующую ориентированному графу.
{
  int x,y;
  Lref p,q;    //Рабочие указатели.
  Tref t,r;    //Рабочие указатели.
  Boolean Res; //Флаг наличия дуги.

  cout<<"Вводите начальную вершину дуги: ";
  cin>>x;
  while (x!=0)
  {
	 cout<<"Вводите конечную вершину дуги: "; cin>>y;
	 //Определим, существует ли в графе дуга (x,y)?
	 p=SearchGraph (x); q=SearchGraph (y);
	 r = (*p).Trail; Res = FALSE;
	 while ((r!=NULL)&&(!Res))
		if ((*r).Id==q) Res = TRUE;
		else r = (*r).Next;
	 if (!Res) //Если дуга отсутствует, то поместим её в граф.
	 { t = new (Trailer); (*t).Id = q;
           (*t).Next = (*p).Trail; (*p).Trail = t; (*q).Count++;
           t = new (Trailer); (*t).Id = p;
           (*t).Next = (*q).Pred; (*q).Pred = t; (*p).Count++; }
	 cout<<"Вводите начальную вершину дуги: "; cin>>x;
  }
}

Lref Spisok::SearchGraph (int w)
//Функция возвращает указатель на заголовочный узел
//с ключом w. Если заголовочный узел отсутствует, то он
//добавляется в список. Head - указатель на структуру Вирта.
{
  Lref h;

  h = Head; (*Tail).Key = w;
  while ((*h).Key!=w) h = (*h).Next;
  if (h==Tail)
  //В списке заголовочных узлов нет узла с ключом w.
  //Поместим его в конец списка Head.
  { Tail = new (Leader); (*h).Count = (*h).Count1 = 0;
	 (*h).Trail = (*h).Pred = NULL; (*h).Next = Tail; }
  return h;
}

void Spisok::PrintGraph ()
//Вывод структуры Вирта, заданной указателем
//Head и соответствующей ориентированному графу.
{
  Lref p; //Рабочий указатель.
  Tref q; //Рабочий указатель.

  p = Head;
  while (p!=Tail)
  {
	 cout<<(*p).Key<<"(("; q = (*p).Trail;
	 while (q!=NULL)
	 { cout<<(*(*q).Id).Key<<" "; q = (*q).Next; }
	 cout<<")("; q = p->Pred;
	 while (q!=NULL)
	 { cout << (*(*q).Id).Key<<" "; q = q->Next; }
	 cout << "))";
	 p = (*p).Next; cout<<" ";
  }
}

void Spisok::Vyvod()
{
  Lref p = Head;

  while ( p!=Tail )
  {
    cout << p->Key << '-'<< p->Number;
    p = p->Next; cout << ' ';
  }
}

void Spisok::Renum()
//Перенумерация вершин графа, заданного структурой Вирта
//с указателем Head.
{
  int num;
  Lref p,u;
  Tref t;

  Stack = NULL; p = Head;
  while ( p!=Tail )
  {
	 if ( p->Count!=0 ) V_Stack(p);
	 p = p->Next;
  }
  num = 0;
  while ( Stack!=NULL )
  {
          Udalenie (&u);
          num++; u->Number = num;
          t = u->Trail;
          while ( t!=NULL )
          {
            t->Id->Count--;
            if ( t->Id->Count==0 ) V_Stack (t->Id);
              t = t->Next;
          }
  }
}

void Spisok::Udalenie (Lref *Klad)
// Удаление элемента из стека Stack и сохранение его в
// переменной Klad.
{
  Zveno *q;

  if ( Stack==NULL )
   cout << "Ошибка! Попытка выбоpа из пустого стека!\n";
  else
  {
   (*Klad) = Stack->Element; q = Stack;
   Stack = Stack->Sled; delete q;
  }
}

void Spisok::V_Stack (Lref Elem)
// Помещение Elem в стек Stack.
{
  Zveno *q;

  q = new (Zveno);
  q->Element = Elem; q->Sled = Stack; Stack = q;
}

void main()
{
  Spisok A;
  // Построение графа и вывод его структуры смежности.
  A.MakeGraph();
  A.PrintGraph(); cout << endl;
  A.Renum();
  // Вывод новых номеров вершин графа.
  A.Vyvod();
}
Текст этой программы можно взять здесь.
Результат работы программы изображен на рисунке 1:

Рис.1. Результат работы приложения


(1) Липский В. Комбинаторика для программистов: Пер. с польск. - М.:Мир, 1988. - 213 с.

На следующем шаге мы дадим понятие о методе PERT.

        1.16. Понятие о методе PERT
На этом шаге мы приведем последний пример использования топологической сортировки.
Сетевое планирование - совокупность методов, использующих сетевую модель как основную форму представления информации об управляемом комплексе работ. Использование сетевого планирования позволяет повысить качетсво планирования и управления при реализации комплекса работ, например, дает возможность четко координировать деятельность всех сторон (организаций), участвующих в реализации, выделять наиболее важные задачи, определять сроки реализации, а также координировать план его реализации [1, с.540].
Сетевая модель - информационная модель реализации некоторого комплекса взаимосвязанных работ, рассматриваемая как ориентированный граф без контуров, отображающий естественный порядок выполнения этих работ во времени; может содержать некоторые дополнительные характеристики (например, время, стоимость, ресурсы), относящиеся к отдельным работам и (или) к комплексу в целом.
Наибольшее распространение получило графическое представление сетевой модели на плоскости, называемое сетевым графиком [1, с.540].
Для быстрого "погружения" в постановку и решение задач сетевого планирования рассмотрим простейший пример, заимствованный нами из монографий [2; 3, с.409].
Предположим, что шеф-повар получил заказ приготовить яичницу из одного яйца. Вся процедура ее приготовления может быть разбита на ряд отдельных подзадач:
   Взять яйцо ----> Разбить яйцо ----> Взять жир ---->
   ----> Положить жир на сковороду ----> Растопить жир ---->
   ----> Вылить яйцо на сковороду ---->
   ----> Ждать, пока яичница не изжарится ----> Снять яичницу
Некоторые из этих подзадач должны предшествовать другим (например, задача "взять яйцо" должна предшествовать задаче "разбить яйцо"). Ряд подзадач может выполняться параллельно (например, задачи "взять яйцо" и "растопить жир"). Шеф-повар хотел бы выполнить заказ как можно быстрее, при этом предполагается, что число его помощников не ограничено.
Необходимо распределить работу среди помощников так, чтобы заказ был выполнен за минимально возможное время.
Хотя этот пример может показаться легкомысленным, подобная задача возникает во многих ситуациях, связанных с планированием реальных действий. В больших вычислительных системах осуществляется планирование заданий с целью обеспечения минимального времени нахождения задания в системе, технолог на заводе может планировать организацию работы конвейера, минимизирующую время производства продукции, и т.п. Все проблемы подобного рода тесно связаны между собой и могут быть решены с использованием графов.
Давайте представим исходную задачу в виде графа. Каждая вершина графа представляет собой подзадачу, а каждая дуга (x,y) представляет требование, что задача y не может выполняться до тех пор, пока не завершено выполнение задачи x. Граф задачи показан на рисунке:

Рис.1. Граф задачи
Заметим, что в изображенном графе узлы 1 и 6 не имеют предшественников, и, следовательно, подзадачи, которые они представляют, могут выполняться сразу же и параллельно без ожидания завершения других подзадач. Все остальные подзадачи должны ждать завершения по крайней мере одной из этих подзадач. Как только эти первые две подзадачи завершены, соответствующие вершины и инцидентные дуги могут быть удалены из графа. Отметим, что получающийся в результате граф не содержит контуров, поскольку вершины и дуги удалялись из графа без циклов. Стало быть, новый граф также должен содержать по крайней мере один узел, не имеющий предшественников. В нашем примере существуют два таких узла - 2 и 7. Значит, подзадачи 2 и 7 могут выполняться параллельно во второй период времени.
Продолжив построение далее, мы найдем, что минимальное время, за которое может быть поджарена яичница, -шесть временных периодов (предполагая, что каждая подзадача требует ровно один период времени), а максимальное требующееся число помощников - два:
 Период времени         Помощник 1                 Помощник 2

      1                 Взять яйцо                 Взять жир
      2                 Разбить яйцо               Положить жир на сковороду
      3                 Растопить жир
      4                 Вылить яйцо на сковороду
      5                 Ждать, пока яичница не изжарится
      6                 Снять яичницу
Автоматизируем процесс построения решения задачи, модифицируя алгоритм топологической сортировки, проиллюстрированный программой из 89 шага, следующим образом:
   while  (Граф не пуст)
     {
        Определить вершины, не имеющие предшественников.
        Распечатать эту  группу  узлов с указанием,  что эти подзадачи
        могут быть выполнены параллельно в следующий  момент  времени.
        Удалить из графа данные вершины и инцидентные дуги
     }

Программа. Применение топологической сортировки для решения простейших задач сетевого планирования.
#include <iostream.h>
typedef struct Leader  *Lref; //Тип: указатель на заголовочный узел.
typedef struct Trailer *Tref; //Тип: указатель на дуговой узел.
//Описание типа заголовочного узла.
typedef struct Leader
{
  int Key;    //Информационное поле.
  int Count;  //Количество предшественников.
  Tref Trail;
  Lref Next;
};

//Описание типа дугового узла.
typedef struct Trailer
{
  Lref Id;
  Tref Next;
};

class Spisok {
  private:
    Lref Head; //Указатель на список заголовочных узлов.
    Lref Tail; //Указатель на фиктивный элемент
               //в конце списка заголовочных узлов.
    int z;     //Количество узлов, не имеющих предшественников.
  public:
    Spisok () {//Инициализация списка заголовочных узлов.
               Head = Tail = new (Leader); z = 0;};
    Lref L (int);
    void Poisk();
    void Vyvod();
};

void Spisok::Poisk()
{
  Lref p,q; // Рабочие указатели.

  p = Head; Head = NULL;
  while (p!=Tail)
  {
     q = p; p = p->Next;
     if (q->Count==0)
       { q->Next = Head; Head = q; }
   }
}

Lref Spisok::L (int w)
//Функция возвращает указатель на ведущего с ключом w.
{
  Lref h = Head;

  Tail->Key = w;
  while (h->Key!=w) h = h->Next;
  if (h==Tail)
  // В списке нет элемента с ключом w.
  {
    Tail = new (Leader); z++;
    h->Count = 0; h->Trail = NULL; h->Next = Tail;
  }
  return h;
}

void Spisok::Vyvod()
{
  Lref p,q; // Рабочие указатели.
  Lref S,U; // Рабочие указатели.
  Tref t;

  cout << endl;
  cout << "Результат...\n";
  q = Head;
  while ( q!=NULL)
  // Вывод всех элементов с нулевым количеством предшественников.
  {
     S = q; cout << "( ";
     while ( S!=NULL )
     {  cout << S->Key << " "; z--; S = S->Next;  }
     cout << ") ";
     // ---------------------------------------------------
     U = NULL; // Указатель на очередной список элементов
               // с нулевым количеством предшественников.
     while ( q!=NULL )
     {
       t = q->Trail;
       while ( t!=NULL )
       {
         p = t->Id; p->Count--;
         if ( p->Count==0 ) // Включение (*p) в список ведущих.
            { p->Next = U; U = p; }
         t = t->Next;
       }
       q = q->Next;
     }
     q = U;
  }
  if (z!=0)
      cout << "\nМножество не является частично упорядоченным!\n";
}

void main()
{
  Spisok A;
  Lref p,q; // Рабочие указатели.
  Tref t;
  int  x,y; // Рабочие переменные.

  // Фаза ввода.
  cout << "Задайте отношение частичного порядка...\n";
  cout << "Элемент ";
  cin >> x;
  cout << " предшествует элементу ";
  while (x!=0)
  {
    cin >> y;
    p = A.L(x); q = A.L(y);
    t = new (Trailer); t->Id = q; t->Next = p->Trail;
    p->Trail = t; q->Count += 1;
    cout << "Элемент ";
    cin >> x;
    cout << " предшествует элементу ";
  }
  // Поиск ведущих с нулевым количеством предшественников.
  A.Poisk();
  // Фаза вывода.
  A.Vyvod();
}
Текст этой программы можно взять здесь.
Тестовые примеры:
    • Решением задачи планирования приготовления яичницы является:
    • ( 6 1 ) ( 2 7 ) ( 8 ) ( 3 ) ( 4 ) ( 5 )
    • Решение задачи о топологическом упорядочении учебных курсов по математике, дискретной математике и информатике для студентов педагогических вузов (тестовый пример 3 из 89 шага) имеет следующий вид:
    • ( 26 22 21 19 1 ) ( 3 4 6 24 17 20 ) ( 2 7 5 )
    • ( 8 18 10 ) ( 9 11 25 ) ( 27 12 14 16 ) ( 13 15 23 )
Интерпретируя результаты, получим перечень блоков учебных курсов, которые можно преподавать параллельно:
   (Алгебра. Математический анализ.  Геометрия. Математическая логика.
Дискретная математика);
   (Теория автоматов.  Машинная арифметика. Теория графов. Реляционная
алгебра и реляционное исчисление.  Теория взаимодействующих последова-
тельных процессов. Теория алгоритмов);
   (Теория кодирования.  Формальные языки  и  грамматики.  Введение  в
программирование);
   (Структуры данных.  Устройство  ЭВМ.  Доказательство   правильности
программ);
   (Анализ алгоритмов. Компиляторы. Машинная графика);
   (Операционные системы.  Парадигмы программирования.  Информационный
поиск. Вычислительная геометрия);
   (Базы данных. Искусственный интеллект. Вычислительная математика).

Замечание. Дискретная математика - область математики, занимающаяся изучением свойств дискретных структур, которые возникают как внутри математики, так и в ее приложениях. К числу таких структур могут быть отнесены, например, конечные группы, конечные графы, а также некоторые математические модели преобразователей информации, конечные автоматы, машины Тьюринга и т.д. Это примеры структур финитного (конечного) характера. Часть дискретной математики, изучающая их, называется конечной математикой. Иногда это понятие расширяют до дискретной математики. Помимо указанных финитных структур, дискретная математика изучает некоторые алгебраические системы, бесконечные графы, вычислительные схемы определенного вида, клеточные автоматы и т.д. [1, с.184].
Наряду с выделением дискретной математики путем указания ее предмета можно также определить дискретную математику посредством перечисления подразделов, составляющих дискретную математику. К ним в первую очередь должны быть отнесены
    • комбинаторный анализ,
    • теория графов,
    • теория кодирования,
    • теория функциональных систем и некоторые другие (см.[4, 5, 6, 7, 8, 9]).
Часто под термином "дискретная математика" (предполагая, что ее предмет исчерпывается конечными структурами) понимается именно совокупность перечисленных дисциплин.
Мы будем понимать термин "дискретная математика" именно так и отнесем к ней следующие математические дисциплины:
    • машинную арифметику,
    • комбинаторный анализ,
    • теорию кодирования,
    • теорию графов,
    • теорию автоматов,
    • формальные языки и грамматики,
    • теорию взаимодействующих последовательных процессов.
Как отмечалось, возможно и более широкое толкование дискретной математики за счет расширения понимания ее предмета. С этой точки зрения к дискретной математике могут быть также отнесены как целые разделы математики, например, математическая логика, так и части таких разделов, как теория чисел, алгебра, вычислительная математика, теория вероятностей и другие, в которых изучаемый объект носит дискретный характер [1, с.184].



(1) Математический энциклопедический словарь. - М.: Сов.энциклопедия, 1988. - 847 с.
(2) Tenenbaum A., Augenstein M. Data Structures Using Pascal. Englewood Cliffs. - N.Y.: Prentice-Hall, Inc. 1981.
(3) Лэнгсам Й., Огенстейн М., Тененбаум А. Структуры данных для персональных ЭВМ: Пер. с англ. - М.: Мир, 1989. - 568 с.
(4) Яблонский С.В. Введение в дискретную математику. - М.: Наука, 1986. - 384 с.
(5) Гаврилов Г.П., Сапоженко А.А. Сборник задач по дискретной математике. - М.: Наука, 1977. - 368 с.
(6) Горбатов В.А. Основы дискретной математики. - М.: Высш.шк., 1986. - 311 с.
(7) Горбатов В.А. Дискретная математика в задачах и упражнениях. - М.: МГИ, 1988 (1989). - 100 с.
(8) Триханов А.В. Основы дискретной математики. - Томск: ТПИ, 1987. - 96 с.
(9) Задачи по дискретной математике. - Алма-Ата: КазГУ, 1986. - 30 с.

На следующем шаге мы рассмотрим способы представления грамматики.

        1.17. Представление грамматики
На этом шаге мы рассмотрим представление грамматики в памяти компьютера.
Рассмотрим представление в памяти контекстно-свободной грамматики [1, с.455-457] с помощью плексов.
Плексы (сплетения) - структуры данных, служащие для представления графов, имеющих ребра, принадлежащих нескольким различным семействам [2, с.88]. И.Флорес [3, с.155-174] называет плексы ветвящимися списками, а Д.Кнут [4, с.390-391,500-505] - Списками (с большой буквы!).
Отметим, что плексы широко применяются в трансляторах для отображения деревьев и графов в памяти ЭВМ, так как плексы лучше других типов структур отображают многоуровневые структуры данных в памяти ЭВМ.
Кстати, как заметил П.Холл [5, с.66], "... метод представления с помощью матрицы инцидентности - это разновидность метода плексов!"
Представление грамматики с помощью плексов становится удобным в тех случаях, когда грамматику необходимо рассматривать и обрабатывать путем нисходящего синтаксического анализа. Эффективное представление грамматик в памяти необходимо в связи с тем, что различные варианты правил должны проверяться на их применимость на каждом шаге анализа конструкции фразы.
Представление синтаксиса с помощью графа имеет один существенный недостаток: компьютеры "не умеют читать графы", т.о. перед началом грамматического разбора нужно каким-то образом строить структуры данных, представляющие грамматику.
Мы предполагаем, что грамматика представлена в виде детерминированного множества синтаксических графов(плексов).
Естественный способ представить граф - это ввести узел для каждого символа и связать эти узлы при помощи ссылок. Узлы этой структуры представляют собой объединения, один для терминального, а другой длянетерминального символа грамматики. Первый идентифицируется терминальным символом, который он обозначает, второй - ссылкой на структуру данных, представляющую соответствующий нетерминальный символ. Оба варианта содержат две ссылки: одна указывает на следующий символ, последователь (Suc), а другая связана со списком возможных альтернатив (Alt).
Теперь мы в состоянии привести описание соответствующего типа данных:
typedef int Boolean;
typedef struct Header  *Hpointer; //Тип: указатель на заглавный узел.

typedef struct Node
{
  Node *Suc;
  Node *Alt;
  Boolean Terminal;
  union
  {
    char Tsym [33];
    Hpointer Nsym;
  } TR;
};
Графически узел можно изобразить так:

Рис.1. Графическое представление узла
Выясняется, что еще нужен элемент, представляющий пустую последовательность, символ "пусто". Мы обозначим его с помощью терминального элемента Empty.
Структура данных идентифицируется узлом-заголовком, который содержит имя нетерминального символа (цели), к которому относится структура. Заголовок можно использовать для хранения выводимого на печать имени структуры:
//Описание типа заглавного звена.
typedef struct Header
{
  Node* Entry;
  char Sym[33];
};

Пример [6,с.330,с.338]. Изобразим структуру для следующей грамматики:
   A ::= x (B),
   B ::= AC,
   C ::= {+A}.
Здесь +, x, (, ) - терминальные символы, а { и } - принадлежат расширенной БНФ (форма Бэкуса-Наура) и, следовательно, являются метасимволами.

Рис.2. Грамматика
Ясно, что язык, порождаемый из приведенной грамматики, состоит из выражений с операндами x, знаком операции "+" и скобками.
Приведем примеры правильных предложений языка:
   x
   (x)
   (x+x)
   ((x))
Программа, производящая грамматический разбор предложения, представленного в виде последовательности символов входного файла, состоит из повторяющегося оператора, описывающего переход от одного узла к следующему узлу [6,с.339]. Она оформлена как процедура, задающая интерпретацию графа; если встречается узел, представляющий нетерминальный символ, то интерпретация графа, на который он ссылается, предшествует завершению интерпретации текущего графа. Следовательно, процедура интерпретации вызывается рекурсивно.
Если текущий символ (Sym) входного файла совпадает с символом в текущем узле структуры данных, то процедура переходит к узлу, на который указывает поле Suc, иначе - к узлу, на который указывает поле Alt:
void Spisok::Parse(Hpointer Goal, Boolean *Match)
{
  Node *s;

  s = Goal->Entry;
  do {
  if ( s->Terminal )
      {
        if (!strcmp(s->TR.Tsym,Sym))
          {  (*Match) = TRUE; Get_Sym(); }
        else  (*Match) = !(strcmp(s->TR.Tsym,"Empty"));
      }
      else  Parse (s->TR.Nsym,&(*Match));
      if (*Match)  s = s->Suc;
      else  s = s->Alt;
      }
  while (s!=NULL);
}

void Spisok::Get_Sym()
{
  char Q;
  cin >> Q;
  Sym[0]=Q; Sym[1]='\0';
}
На основе функции Parse можно построить более сложные программы грамматического разбора, которые могут работать с более широкими классами грамматик.

Пример [6, с.339]. Программа грамматического разбора. Программа написана И.А.Лебедевой (февраль 1993 г.).
#include <iostream.h>
#include <string.h>
#define TRUE 1
#define FALSE 0
typedef int Boolean;
typedef struct Header  *Hpointer; //Тип: указатель на заглавный узел.

typedef struct Node
{
  Node *Suc;
  Node *Alt;
  Boolean Terminal;
  union
  {
    char Tsym [33];
    Hpointer Nsym;
  } TR;
};

//Описание типа заглавного звена.
typedef struct Header
{
  Node* Entry;
  char Sym[33];
};

class Spisok {
  private:
	 Hpointer Goal; //Указатель на заглавное звено.
	 char Sym[33];
	 void Parse(Hpointer, Boolean *);
	 void Get_Sym();
  public:
	 Spisok () { Goal = NULL; };
	 void Postr();
	 void Prov();
	 int Razbor();
};

void Spisok::Postr()
// Построение синтаксического графа.
{
  Node *UkZv;   //Текущий указатель.
  Node *UkZv1;  //Текущий указатель.

  Goal = new (Header);
  strcpy(Goal->Sym,"A");
  // Goal     +-----+
  //   * ---> |  A  |
  //          +-----+
  //          |     |
  //          +-----+
  // ------------------------------
  Goal->Entry = new (Node);
  UkZv = Goal->Entry;
  UkZv->Terminal = TRUE;
  strcpy(UkZv->TR.Tsym,"(");
  // Goal     +-----+
  //   * ---> |  A  |
  //          +-----+
  //          |  *  |
  //          +--|--+
  //             |
  //             V
  //         +----+----+
  // UkZv    |TRUE| (  |
  //  * ---> +----+----+
  //         |    |    |
  //         +----+----+
  // ------------------------------
  UkZv->Alt = new (Node);
  UkZv1 = UkZv->Alt; UkZv1->Terminal = TRUE;
  strcpy(UkZv1->TR.Tsym,"x"); UkZv1->Alt = UkZv1->Suc = NULL;
  // Goal     +-----+
  //   * ---> |  A  |
  //          +-----+
  //          |  *  |
  //          +--|--+
  //             |
  //             V
  //         +----+----+
  // UkZv    |TRUE| (  |
  //  * ---> +----+----+
  //         | *  |    |
  //         +-|--+----+
  //           |
  //           V
  //         +----+----+
  // UkZv1   |TRUE| x  |
  //  * ---> +----+----+
  //         |NULL|NULL|
  //         +----+----+
  // ------------------------------
  UkZv->Suc = new (Node);
  UkZv = UkZv->Suc;  UkZv->Terminal = FALSE;
  UkZv->TR.Nsym = Goal; UkZv->Alt = NULL;
  // Goal     +-----+
  //   * ---> |  A  | <---------------+
  //          +-----+                 |
  //          |  *  |      UkZv *     |
  //          +--|--+           |     |
  //             |              |     |
  //             V              V     |
  //         +-----+-----+   +-----+--|--+
  //         |TRUE |  (  |   |FALSE|  *  |
  //         +-----+-----+   +-----+-----+
  //         |  *  |  * ---->|NULL |     |
  //         +--|--+-----+   +-----+-----+
  //            |
  //            V
  //         +-----+-----+
  // UkZv1   |TRUE |  x  |
  //  * ---> +-----+-----+
  //         |NULL |NULL |
  //         +-----+-----+
  // -----------------------------------------
  UkZv->Suc = new (Node);
  UkZv1 = UkZv->Suc; UkZv1->Terminal = TRUE;
  strcpy(UkZv1->TR.Tsym,"+");
  // Goal     +-----+
  //   * ---> |  A  | <---------------+
  //          +-----+                 |
  //          |  *  |      UkZv *     |   UkZv1 *
  //          +--|--+           |     |         |
  //             |              |     |         |
  //             V              V     |         V
  //         +-----+-----+   +-----+--|--+   +-----+-----+
  //         |TRUE |  (  |   |FALSE|  *  |   |TRUE |  +  |
  //         +-----+-----+   +-----+-----+   +-----+-----+
  //         |  *  |  * ---->|NULL |  * ---->|     |     |
  //         +--|--+-----+   +-----+-----+   +-----+-----+
  //            |
  //            V
  //         +-----+-----+
  //         |TRUE |  x  |
  //         +-----+-----+
  //         |NULL |NULL |
  //         +-----+-----+
  // ------------------------------------------------------
  UkZv1->Suc = new (Node); UkZv1 = UkZv1->Suc;
  UkZv = UkZv->Suc; UkZv1->Terminal = FALSE;
  UkZv1->TR.Nsym = Goal; UkZv1->Alt = NULL; UkZv1->Suc = UkZv;
  //Goal +-----+
  // * ->|  A  | <---------------------------------------------+
  //     +-----+ <---------------+                             |
  //     |  *  |                 |   UkZv *        UkZv1 *     |
  //     +--|--+                 |        |              |     |
  //        |                    |        |              |     |
  //        V                    |        V              V     |
  //     +-----+-----+  +-----+--|--+  +-----+-----+  +-----+--|--+
  //     |TRUE |  (  |  |FALSE|  *  |  |TRUE |  +  |  |FALSE|  *  |
  //     +-----+-----+  +-----+-----+  +-----+-----+  +-----+-----+
  //     |  *  |  * --->|NULL |  * --->|     |  * --->|NULL |  *  |
  //     +--|--+-----+  +-----+-----+  +-----+-----+  +-----+--|--+
  //        |                                ^                 |
  //        V                                +-----------------+
  //     +-----+-----+
  //     |TRUE |  x  |
  //     +-----+-----+
  //     |NULL |NULL |
  //     +-----+-----+
  // --------------------------------------------------------------
  UkZv->Alt = new (Node);
  UkZv = UkZv->Alt; UkZv->Terminal = TRUE;
  strcpy(UkZv->TR.Tsym,"Empty"); UkZv->Alt = NULL;
  //Goal +-----+
  // * ->|  A  | <---------------------------------------------+
  //     +-----+ <---------------+                             |
  //     |  *  |                 |                 UkZv1 *     |
  //     +--|--+                 |                       |     |
  //        |                    |                       |     |
  //        V                    |                       V     |
  //     +-----+-----+  +-----+--|--+  +-----+-----+  +-----+--|--+
  //     |TRUE |  (  |  |FALSE|  *  |  |TRUE |  +  |  |FALSE|  *  |
  //     +-----+-----+  +-----+-----+  +-----+-----+  +-----+-----+
  //     |  *  |  * --->|NULL |  * --->|  *  |  * --->|NULL |  *  |
  //     +--|--+-----+  +-----+-----+  +--|--+-----+  +-----+--|--+
  //        |                             |  ^                 |
  //        |                             |  +-----------------+
  //        V                             V
  //     +-----+-----+                 +-----+-----+
  //     |TRUE |  x  |         UkZv    |TRUE |Empty|
  //     +-----+-----+           * --> +-----+-----+
  //     |NULL |NULL |                 |NULL |     |
  //     +-----+-----+                 +-----+-----+
  // --------------------------------------------------------------
  UkZv->Suc = new (Node); UkZv = UkZv->Suc;
  UkZv->Terminal = TRUE;
  strcpy(UkZv->TR.Tsym,")"); UkZv->Alt = UkZv->Suc = NULL;
  //Goal +-----+
  // * ->|  A  | <---------------------------------------------+
  //     +-----+ <---------------+                             |
  //     |  *  |                 |                 UkZv1 *     |
  //     +--|--+                 |                       |     |
  //        V                    |                       V     |
  //     +-----+-----+  +-----+--|--+  +-----+-----+  +-----+--|--+
  //     |TRUE |  (  |  |FALSE|  *  |  |TRUE |  +  |  |FALSE|  *  |
  //     +-----+-----+  +-----+-----+  +-----+-----+  +-----+-----+
  //     |  *  |  * --->|NULL |  * --->|  *  |  * --->|NULL |  *  |
  //     +--|--+-----+  +-----+-----+  +--|--+-----+  +-----+--|--+
  //        |                             |  ^                 |
  //        |                             |  +-----------------+
  //        V                             V
  //     +-----+-----+                 +-----+-----+  +-----+-----+
  //     |TRUE |  x  |                 |TRUE |Empty|  |TRUE |  )  |
  //     +-----+-----+                 +-----+-----+  +-----+-----+
  //     |NULL |NULL |                 |NULL |  * --->|NULL |NULL |
  //     +-----+-----+                 +-----+-----+  +-----+-----+
  //                                                       ^
  //                                                       |
  //                                                  UkZv *
}

void Spisok::Prov()
// Проверка графа.
{
  Node *A, *C;  //Рабочие переменные.

  cout << "Элементарная проверка построенного графа...\n";
  A = Goal->Entry; cout << A->TR.Tsym << " ";
  cout << A->Suc->Suc->TR.Tsym << " ";
  cout << A->Suc->Suc->Alt->Suc->TR.Tsym << " ";
  cout << A->Alt->TR.Tsym << " ";
  C =  A->Suc->TR.Nsym->Entry; cout << C->TR.Tsym << endl;
  cout << "Проверка окончена!\n";
}

int Spisok::Razbor()
// Синтаксический разбор.
{
  Boolean Rez = FALSE;

  // Приступим к грамматическому разбору.
  cout << "Вводите строку...\n";
  cout << "Конец ввода - символ \"точка\".\n";
  Get_Sym();
  Parse(Goal,&Rez); cout << endl;
  if  ((Rez) && !strcmp(Sym,".")) return 1;
  else  return 0;
}

void Spisok::Get_Sym()
{
  char Q;
  cin >> Q;
  Sym[0]=Q; Sym[1]='\0';
}

void Spisok::Parse(Hpointer Goal, Boolean *Match)
{
  Node *s;

  s = Goal->Entry;
  do {
      if ( s->Terminal )
      {
        if (!strcmp(s->TR.Tsym,Sym))
          {  (*Match) = TRUE; Get_Sym(); }
        else  (*Match) = !(strcmp(s->TR.Tsym,"Empty"));
      }
      else  Parse (s->TR.Nsym,&(*Match));
      if (*Match)  s = s->Suc;
      else  s = s->Alt;
      }
  while (s!=NULL);
}

void main()
{
  Spisok A;

  // Построение синтаксического графа.
  A.Postr();
  A.Prov();
  if (A.Razbor()) cout <<  "Все хорошо!";
  else cout << "Ошибка!";
}
Текст этой программы можно взять здесь.


(1) Трамбле Ж., Соренсон П. Введение в структуры данных. - М.: Машиностроение, 1982. - 784 с.
(2) Разумов О.С. Организация данных в вычислительных системах. - М.: Статистика, 1978. - 184 с.
(3) Флорес И. Структуры и управление данными. - М.: Финансы и статистика, 1982. - 319 с.
(4) Кнут Д. Искусство программирования для ЭВМ. Т.1: Основные алгоритмы. - M.: Мир, 1976. - 736 с.
(5) Холл П. Вычислительные структуры. Введение в нечисленное программирование. - М.: Мир, 1978. - 214 с.
(6) Вирт H. Алгоритмы + структуры данных = программы. - М.: Мир, 1985. - 406 с.

Со следующего шага мы начнем знакомиться со способами обхода графов.

        1.18. Обход графов (общие сведения)
На этом шаге мы приведем общие сведения по обходу графов.
Существует много алгоритмов на графах, в основе которых лежит систематический перебор вершин графа, такой что каждая вершина просматривается (посещается) в точности один раз. Поэтому важной задачей является нахождение хороших методов поиска в графе.
Под обходом графов (поиском на графах) мы будем понимать процесс систематического просмотра всех вершин графа с целью отыскания вершин, удовлетворяющих некоторому условию.
В.Липский [1, с.88] называет метод поиска "хорошим", если
    • он позволяет алгоритму решения интересующей нас задачи легко "погрузиться" в этот метод и
    • каждое ребро графа анализируется не более одного раза (или, что существенно не меняет ситуации, число раз, ограниченное константой).
Два наиболее распространенных алгоритма обхода графов называются:
    • обход графа в глубину (поиск в глубину (англ. Depth First Search)) и
    • обход графа в ширину (поиск в ширину (англ. Breadth First Search)).


(1) Липский В. Комбинаторика для программистов: Пер. с польск. - М.: Мир, 1988. - 213 с.

На следующем шаге мы рассмотрим обход графа в глубину.

        1.19. Обход графов в глубину
На этом шаге мы рассмотрим алгоритм обхода графа в глубину.
Обход в глубину (называемый иногда стандартным обходом), есть обход графа по следующим правилам:
    • находясь в вершине x, нужно двигаться в любую другую, ранее не посещенную вершину (если таковая найдется), одновременно запоминая дугу, по которой мы впервые попали в данную вершину;
    • если из вершины x мы не можем попасть в ранее не посещенную вершину или таковой вообще нет, то мы возвращаемся в вершину z, из которой впервые попали в x, и продолжаем обход в глубину из вершины z.
При выполнении обхода графа по этим правилам мы стремимся проникнуть "вглубь" графа так далеко, как это возможно, затем отступаем на шаг назад и снова стремимся пройти вперед и так далее.
На этом шаге мы приведем рекурсивную функцию обхода графа в глубину. Граф представлен в памяти структурой Вирта.
Заметим, что перед обращением к функции Depth_First_Search () необходимо провести инициализацию:
t = Head;
while (t!=Tail)
  {(*t).Flag = TRUE; t = (*t).Next;}
Текст функции:
void Depth_First_Search (Lref r)
{
  Tref t;

  t = (*r).Trail; cout<<(*r).Key;
  (*r).Flag = FALSE;
  while (t!=NULL)
    { if ((*(*t).Id).Flag)
      Depth_First_Search ((*t).Id);
      t = (*t).Next; }
}
В связи с тем, что поиск в глубину играет важную роль в проектировании алгоритмов на графах, представим также нерекурсивную версию функции Depth_First_Search(), которую мы назовем Depth_First_Search_1().
В приведенной ниже формулировке нерекурсивного алгоритма поиска в глубину на графе [1,с.125-126] предполагается: во-первых, что зафиксирован некоторый линейный порядок на множестве всех вершин графа, и, во-вторых, что множество вершин, смежных со всякой вершиной графа, также линейно упорядочено.
while (Имеется хотя бы одна непосещенная вершина)
{
  Пусть p - первая из непосещенных вершин.
  Посетить вершину p и поместить ее в пустой стек S;
  while ( Стек S непуст )
  {
    Пусть p - вершина, находящаяся на верхушке стека S;
    if (У вершины p есть непосещенные смежные вершины)
      { Пусть q - первая непосещенная вершина из вершин, смежных
        вершине p. Пройти по ребру (p,q), посетить вершину q и
        поместить ее в стек S }
    else Удалить вершину p из стека S
  }
}
Реализуем ту часть приведенного алгоритма, которая ограничивается обходом только одной связной компоненты графа (смотри шаг 78).
Не забудьте про предварительную инициализацию:
t = Head;
while (t!=Tail)
  { (*t).Flag = TRUE; t = (*t).Next; }
Текст функции:
void Depth_First_Search_1 (Lref r)
{
  Tref t;
  svqz Stack;

  Stack = NULL; //Стек пуст.
  //Посетим первую непосещенную вершину графа и
  //поместим ее указатель на ее список смежности
  //в первоначально пустой стек.
  cout<<(*r).Key; (*r).Flag = FALSE;
  W_S (&Stack,(*r).Trail);
  while (Stack!=NULL)
  { //Рассмотрим "верхушку" стека.
    t = (*Stack).Element;
    if ((*(*t).Id).Trail!=NULL) {
      //У рассматриваемой вершины есть смежные.
      if ((*(*t).Id).Flag) //У рассматриваемой вершины есть
      // непосещенные смежные вершины.
      { //Посетим рассматриваемую вершину и поместим
        //указатель на ее список смежности в стек.
        cout<<(*(*t).Id).Key);
        (*(*t).Id).Flag = FALSE; W_S (&Stack,(*(*t).Id).Trail); }
      //У рассматриваемой вершины нет
      // непосещенных смежных вершин.
      else { t = (*Stack).Element;
        if ((*t).Next!=NULL) {
        //Заменяем верхушку стека
        // указателем на следующий элемент списка смежности.
        YDALENIE (&Stack,&t); W_S (&Stack,(*t).Next); }
      //Удаляем верхушку стека.
      else YDALENIE (&Stack,&t); }
    }
    //У рассматриваемой вершины нет смежных вершин.
    else {
      if ((*(*t).Id).Flag) {
        //Посетим рассматриваемую вершину.
        cout<<(*(*t).Id).Key;
        (*(*t).Id).Flag = FALSE; }
      t = (*Stack).Element;
      if ((*t).Next!=NULL) { //Заменяем верхушку стека указателем на
        //следующий элемент списка смежности.
        YDALENIE (&Stack,&t); W_S (&Stack,(*t).Next); }
      //Удаляем верхушку стека.
      else YDALENIE (&Stack,&t); }
    }
 }

Пример. Демонстрация рекурсивного и нерекурсивного обходов графа в глубину. Граф представлен структурой Вирта.
#include <iostream.h>
#define TRUE 1
#define FALSE 0
typedef int Boolean;
typedef struct L *Lref; // Тип: указатель на заголовочный узел.
typedef struct T *Tref; // Тип: указатель на дуговой узел.

//Описание типа заголовочного узла.
typedef struct L
{
  int Key; //Имя заголовочного узла.
  int Count; //Количество предшественников.
  Boolean Flag; //Флаг посещения узла при обходе.
  Tref Trail; //Указатель на список смежности.
  Lref Next; //Указатель на следующий узел в списке заголовочных узлов.
} Leader;

//Описание типа дугового узла.
typedef struct T
{
  Lref Id;
  Tref Next;
} Trailer;

//Описание типа узла стека.
typedef Tref TipElement;
typedef struct Zveno *svqz;
typedef struct Zveno
{
  TipElement Element; //Указатель на список смежности.
  svqz Sled;
} St;

class Spisok
{
  private:
    Lref Head; //Указатель на голову списка заголовочных узлов.
    Lref Tail; //Указатель на фиктивный элемент
               // в конце списка заголовочных узлов.
    void SearchGraph (int, Lref *);
    void W_S (svqz *, TipElement);
    void YDALENIE (svqz *, TipElement *);
  public:
    Spisok() {//Инициализация списка заголовочных узлов.
              Head = Tail =  new (Leader); }
    Lref GetHead() { return Head; }
    Lref GetTail() { return Tail; }
    void MakeGraph ();
    void PrintGraph ();
    void Depth_First_Search (Lref);
    void Depth_First_Search_1 (Lref);
};

void main ()
{
  Spisok A;
  Lref t; //Рабочий указатель для перемещения
          // по списку заголовочных звеньев.
  //Построение графа и вывод его структуры Вирта.
  A.MakeGraph ();
  A.PrintGraph (); cout<<endl;
  //Рекурсивный обход графа в глубину.
  cout<<"Результат рекурсивного обхода...\n";
  t = A.GetHead();
  while (t!=A.GetTail())
    { (*t).Flag = TRUE; t = (*t).Next; }
  A.Depth_First_Search (A.GetHead()); cout<<endl;
  //Нерекурсивный обход графа в глубину.
  cout<<"Результат нерекурсивного обхода...\n";
  t = A.GetHead();
  while (t!=A.GetTail())
   { (*t).Flag = TRUE; t = (*t).Next;}
  A.Depth_First_Search_1 (A.GetHead()); cout<<endl;
}

void Spisok::SearchGraph (int w, Lref *h)
//Функция возвращает указатель на заголовочный узел
//с ключом w в графе, заданном структурой Вирта с указателем Head.
{
  *h = Head; (*Tail).Key = w;
  while ((**h).Key!=w) *h = (**h).Next;
  if (*h==Tail)
  //В списке заголовочных узлов нет узла с ключом w.
  //Поместим его в конец списка Head.
  { Tail = new (Leader); (**h).Count = 0;
    (**h).Trail = NULL; (**h).Next = Tail; }
}

void Spisok::MakeGraph ()
//Функция возвращает указатель Head на структуру
//Вирта, соответствующую ориентированному графу.
{
  int x,y;
  Lref p,q; //Рабочие указатели.
  Tref t,r; //Рабочие указатели.
  Boolean Res; //Флаг наличия дуги.
  cout<<"Вводите начальную вершину дуги: ";
  cin>>x;
  while (x!=0)
  {
     cout<<"Вводите конечную вершину дуги: "; cin>>y;
     //Определим, существует ли в графе дуга (x,y)?
     SearchGraph (x, &p); SearchGraph (y,&q);
     r = (*p).Trail; Res = FALSE;
     while ((r!=NULL)&&(!Res))
       if ((*r).Id==q) Res = TRUE;
       else r = (*r).Next;
     if (!Res) //Если дуга отсутствует, то поместим её в граф.
      { t = new (Trailer); (*t).Id = q;
        (*t).Next = (*p).Trail; (*p).Trail = t; (*q).Count++; }
     cout<<"Вводите начальную вершину дуги: "; cin>>x;
  }
}

void Spisok::PrintGraph ()
//Вывод структуры Вирта, заданной указателем
//Head и соответствующей ориентированному графу.
{
  Lref p; //Рабочий указатель.
  Tref q; //Рабочий указатель.

  p = Head;
  while (p!=Tail)
  {
     cout<<"("<<(*p).Key; q = (*p).Trail;
     while (q!=NULL)
      { cout<<(*(*q).Id).Key; q = (*q).Next; }
     cout<<")"; p = (*p).Next; cout<<" ";
  }
}

void Spisok::W_S (svqz *stk, TipElement el)
//Помещение элемента el в стек stk.
{
  svqz q=new (St);
  (*q).Element = el; (*q).Sled = *stk; *stk = q;
}

void Spisok::YDALENIE (svqz *stk, TipElement *klad)
//Удаление звена из стека, заданного указателем *stk.
//Значение информационного поля удаляемого звена сохраня-
//ется в параметре klad.
{
  svqz q;

  if (*stk==NULL) cout<<"Попытка выбора из пустого стека!\n";
  else
   { *klad = (**stk).Element; q = *stk; *stk = (**stk).Sled; delete q; }
}

void Spisok::Depth_First_Search (Lref r)
//Рекурсивный обход графа в глубину. r - указатель
//на структуру Вирта.
{
  Tref t;

  t = (*r).Trail; cout<<(*r).Key; (*r).Flag = FALSE;
  while (t!=NULL)
  { if ((*(*t).Id).Flag) Depth_First_Search ((*t).Id); t = (*t).Next; }
}

void Spisok::Depth_First_Search_1 (Lref r)
//Нерекурсивный обход графа в глубину.
//r - указатель на структуру Вирта.
{
  Tref t;
  svqz Stack = NULL; //Стек пуст.
  //Посетим первую непосещенную вершину графа и
  //поместим ее указатель на ее список смежности
  //в первоначально пустой стек.
  cout<<(*r).Key; (*r).Flag = FALSE;
  W_S (&Stack,(*r).Trail);
  while (Stack!=NULL)
  { //Рассмотрим "верхушку" стека.
    t = (*Stack).Element;
    if ((*(*t).Id).Trail!=NULL)
      { //У рассматриваемой вершины есть смежные вершины.
        if ((*(*t).Id).Flag)
        //У рассматриваемой вершины есть
        // непосещенные смежные вершины.
        {
          //Посетим рассматриваемую вершину
          // и поместим указатель на ее список смежности в стек.
          cout<< (*(*t).Id).Key; (*(*t).Id).Flag = FALSE;
          W_S (&Stack,(*(*t).Id).Trail);
        }
        //У рассматриваемой вершины нет
        //непосещенных смежных вершин.
        else {
          t = (*Stack).Element;
          if ((*t).Next!=NULL)
             //Заменяем верхушку стека
             //указателем на следующий  элемент списка смежности.
             { YDALENIE (&Stack,&t); W_S (&Stack,(*t).Next); }
          //Удаляем верхушку стека.
          else YDALENIE (&Stack,&t);
        }
     }
     //У рассматриваемой вершины нет смежных вершин.
     else {
            if ((*(*t).Id).Flag) //Посетим рассматриваемую вершину.
             { cout<<(*(*t).Id).Key; (*(*t).Id).Flag = FALSE; }
            t = (*Stack).Element;
            if ((*t).Next!=NULL)
            //Заменяем верхушку стека указателем на следующий
            // элемент списка смежности.
             { YDALENIE (&Stack,&t); W_S (&Stack,(*t).Next); }
            //Удаляем верхушку стека.
            else YDALENIE (&Stack,&t);
           }
  }
}
Текст этой программы можно взять здесь.
Результат работы приложения приведен на рисунке 1:

Рис.1. Результат работы приложения

Замечание [2, с.91]. Методика обхода в глубину очевидным образом переносится на ориентированные графы. Нетрудно проверить, что в случае ориентированного графа результатом вызова функций Depth_First_Search() и Depth_First_Search_1() будет посещение всех вершин u, таких что существует путь из v в u. В самом деле, при обходе в глубину ориентированного графа мы можем попасть в вершину y из вершины x только в том случае, если в графе есть дуга (x,y), т.е. мы должны двигаться вперед в направлении ориентации дуг, а возвращаться против ориентации (конечно же, в неориентированном графе таких ограничений нет)!

Функции языка LISP, реализующие алгоритм обхода графа в глубину, выглядят следующим образом [3, с.128].

Пример 2.
   (DEFUN TESTDF (LAMBDA NIL
      (PRINT "Построение графа.")
      (SETQ GRAPH NIL)   ;Инициализация
      (PRINT "Введите список вершин графа:") (SETQ NODE (READ))
      (PRINT "Введите список списков смежных вершин:")
      (SETQ NODELIST (READ))
      (PRINT (SETQ GRAPH (PAIRLIS NODE NODELIST GRAPH)))
      (PRINT "Приступим к обходу графа в глубину...")
      (PRINT "Введите вершину графа, с которой начнется обход:")
      (SETQ ROOT (READ))
      (DEPTHFIRST GRAPH ROOT)
   ))
   ; ------------------------------------
   (DEFUN PAIRLIS (LAMBDA (KEY ADJ GRAPH)
   ; Построение графа из списка вершин KEY и списка списков
   ; смежных  вершин  ADJ  путем добавления к существующему
   ;                   графу GRAPH
      (COND ( (NULL KEY) GRAPH )
            ( (NULL ADJ) GRAPH )
            (  T  (CONS (CONS (CAR KEY) (CAR ADJ))
                        (PAIRLIS (CDR KEY) (CDR ADJ) GRAPH)) )
      )
   ))
   ; ------------------------------------
   (DEFUN DEPTHFIRST (LAMBDA (GRAPH ROOT)
   ; Обход графа в глубину:
   ; GRAPH - граф, представленный структурой смежности в
   ;         виде ассоциативного списка,
   ; ROOT  - вершина, с которой начинается обход графа,
   ; Результат: список вершин графа в порядке посещения в глубину
      (COND ( (NULL GRAPH) NIL )
            (  T  (DEFI GRAPH (LIST ROOT) (LIST ROOT)) )
      )
   ))
   ; --------------------------------------
   (DEFUN DEFI (LAMBDA (GRAPH VISITED PATH)
   ; GRAPH   - граф, представленный структурой смежности в
   ;           виде ассоциативного списка,
   ; VISITED - список уже посещенных вершин,
   ; PATH    - список вершин, определяющий путь посещения
      (COND
         ( (NULL PATH) (REVERSE VISITED) )
         ( T  (COND ( (NULL (EXPND GRAPH VISITED (CAR PATH)))
                            (DEFI GRAPH VISITED (CDR PATH)) )
                    (  T  (DEFI GRAPH
                                  (CONS (EXPND GRAPH VISITED
                                               (CAR PATH))
                                         VISITED)
                                  (CONS (EXPND GRAPH VISITED
                                               (CAR PATH))
                                         PATH)) )) )
      )
   ))
   ; -----------------------------------------
   (DEFUN EXPND (LAMBDA (GRAPH VISITED VERTEX)
   ; Выбор в графе GRAPH следующей еще не просмотренной
   ;        вершины, смежной с вершиной VERTEX
      (COND ( (NULL (NEIGHBOUR3 VERTEX GRAPH)) NIL )
            (  T  (FIRSTNOTVISITED
                             VISITED
                             (NEIGHBOUR3 VERTEX GRAPH))
            )
      )
   ))
   ; --------------------------------------------
   (DEFUN FIRSTNOTVISITED (LAMBDA (VISITED VLIST)
   ; Поиск первой непосещенной вершины в списке VLIST
   ; VISITED - список уже посещенных вершин
      (COND ( (NULL VLIST) NIL )
            (  T  (COND ( (NULL (MEMBER (CAR VLIST) VISITED))
                             (CAR VLIST)
                        )
                        (  T  (FIRSTNOTVISITED
                                           VISITED
                                           (CDR VLIST)) )) )
      )
   ))
   ; ---------------------------------
   (DEFUN NEIGHBOUR3 (LAMBDA (X GRAPH)
   ; Функция возвращает список вершин графа GRAPH, смежных с
   ;                 вершиной X
      (COND ( (NULL (ASSOC X GRAPH)) NIL )
            (  T  (CDR (ASSOC X GRAPH)) )
      )
   ))
Текст этой библиотеки можно взять здесь.
Тестовые примеры:
   1) $ (TESTDF)
      Построение графа.
      Введите список вершин графа:
      (1 2 3 4)
      Введите список списков смежных вершин:
      ((2 3 4) (3 1) (4) ())
      Приступим к обходу графа в глубину...
      Введите вершину графа, с которой начнется обход:
      2
      (2 3 4 1)
   2) $ (TESTBF)
      Построение графа.
      Введите список вершин графа:
      (1 2 3 4 5 6 7)
      Введите список списков смежных вершин:
      ((2 3) (4 5) (6 7) () () () ())
      Приступим к обходу графа в глубину...
      Введите вершину графа, с которой начнется обход:
      1
      (1 2 3 4 5 6 7)
Последний тестовый пример иллюстрируется следующим ориентированным графом:

Рис.2. Пример графа
Программа работает следующим образом.
Если граф не пуст, то в два списка: VISITED - список уже посещенных вершин и PATH - список вершин, определяющих путь посещения, заносится первая вершина графа и после этого вызывается функция DEFI. Ее третий аргумент - список PATH - позволяет нам в любой момент вернуться к предыдущей вершине. Список VISITEDиспользуется для того, чтобы помнить о том, какие вершины уже посещались.
Выбор следующей вершины осуществляется с помощью функции EXPND. Именно работой этой функции определяется порядок обхода графа. В нашем случае, пока возможно, выбирается смежная вершина, т.е. на каждом шаге алгоритма делается попытка пройти "вглубь" графа. В противном случае из списка PATH удаляется первый элемент, и поиск возобновляется с предыдущей вершины.
Функция DEPTHFIRST возвращает список вершин графа в том порядке, в котором эти вершины посещались. Очевидно, что этот порядок зависит от вершины, с которой начинается просмотр.

Замечания.
    1. Алгоритмы поиска в глубину на графе изложены в монографиях [4, с.361-364], [2, с.88-91], [5, с.198-205], [6, с.323-327].

    2. Техника обхода в глубину использовалась в алгоритмах на графах долгое время, однако степень, с которой эта процедура позволяет раскрыть свойства графа, была обнаружена недавно. Первой работой в этом направлении является статья Р.Е.Тарьяна, опубликованная в 1972 г. (ссылку см.в [4, с.426]). В этой работе представлена основная процедура поиска в глубину [4, с.364] и алгоритмы отыскания двусвязных [4, с.371] и сильно связных компонент графа [4,c.375].

    3. M-нумерацией вершин графа называется нумерация вершин, соответствующая порядку их обхода при поиске в глубину [7,с.35].



(1) Касьянов В.H., Сабельфельд В.К. Сборник заданий по практикуму на ЭВМ. - М.: Наука, 1986. - 272 с.
(2) Липский В. Комбинаторика для программистов. - М.: Мир, 1988. - 213 с.
(3) Крюков А.П., Радионов А.Я., Таранов А.Ю., Шаблыгин Е.М. Программирование на языке R-Лисп. - М.: Радио и связь, 1991. - 192 с.
(4) Рейнгольд Э., Нивергельт Ю., Део H. Комбинаторные алгоритмы. Теория и практика. - М.: Мир, 1980. - 476 с.
(4) Пападимитриу Х., Стайнглиц К. Комбинаторная оптимизация. Алгоритмы и сложность. - М.: Мир, 1985. - 512 с.
(6) Лекции по теории графов / В.А.Емеличев, О.И.Мельников, В.И.Сарванов, Р.И.Тышкевич - М.: Наука, 1990. - 384 с.
(7) Евстигнеев В.А. Применение теории графов в программировании. - М.: Наука, 1985. - 352 с.

На следующем шаге мы остановимся на алгоритме обхода графа в ширину.

        1.20. Обход графов в ширину
На этом шаге мы рассмотрим алгоритм обхода графов в ширину.
Перейдем теперь к другому алгоритму обхода графа, известному под названием обход в ширину (поиск в ширину). Прежде чем описать его, отметим, что при обходе в глубину чем позднее будет посещена вершина, тем раньше она будет использована. Это прямое следствие того факта, что просмотренные, но еще не использованные вершины накапливаются в стеке.
Обход графа в ширину, грубо говоря, основывается на замене стека очередью. После такой модификации чем раньше посещается вершина (помещается в очередь), тем раньше она используется (удаляется из очереди). Использование вершины происходит с помощью просмотра сразу всех еще непросмотренных вершин, смежных этой вершины. Таким образом, "поиск ведется как бы во всех возможных направлениях одновременно" [1, с.131]:
#include <iostream.h>
#define TRUE 1
#define FALSE 0
typedef int Boolean;
typedef struct Leader *Lref; // Тип: указатель на заголовочный узел.
typedef struct Trailer *Tref; // Тип: указатель на дуговой узел.

//Описание типа заголовочного узла.
typedef struct Leader
{
  int Key; //Имя заголовочного узла.
  int Count; //Количество предшественников.
  Boolean Flag; //Флаг посещения узла при обходе.
  Tref Trail; //Указатель на список смежности.
  Lref Next; //Указатель на следующий узел в списке заголовочных узлов.
};

//Описание типа дугового узла.
typedef struct Trailer
{
  Lref Id;
  Tref Next;
};

//Описание типа узла очереди.
typedef Lref TipElement; //Указатель на звено заголовочного списка.
typedef struct Zveno *svqz;
typedef struct Zveno
{
  TipElement Element; //Указатель на список смежности.
  svqz Sled;
};

class Spisok
{
  private:
	 Lref Head; //Указатель на голову списка заголовочных узлов.
	 Lref Tail; //Указатель на фиктивный элемент
					// в конце списка заголовочных узлов.
	 void Udalenie_A (svqz *, svqz *, TipElement *);
	 void Dobavlenie (svqz *, svqz *, TipElement);
	 void SearchGraph (int, Lref *);
  public:
	 Spisok() {//Инициализация списка заголовочных узлов.
				  Head = Tail =  new (Leader); }
	 Lref GetHead() { return Head; }
	 Lref GetTail() { return Tail; }
	 void MakeGraph ();
	 void PrintGraph ();
	 void Breadth_First_Search (Lref);
};

void main ()
{
  Spisok A;
  Lref t; //Рабочий указатель для перемещения
			 // по списку заголовочных звеньев.

  //Построение графа и вывод его структуры Вирта.
  A.MakeGraph ();
  A.PrintGraph (); cout<<endl;
  //Нерекурсивный обход графа в ширину.
  cout<<"Результат нерекурсивного обхода...\n";
  t = A.GetHead();
  while (t!=A.GetTail())
	 { (*t).Flag = TRUE; t = (*t).Next; }
  A.Breadth_First_Search (A.GetHead()); cout<<endl;
}

void Spisok::SearchGraph (int w, Lref *h)
//Функция возвращает указатель на заголовочный узел
//с ключом w в графе, заданном структурой Вирта с указателем Head.
{
  *h = Head; (*Tail).Key = w;
  while ((**h).Key!=w) *h = (**h).Next;
  if (*h==Tail)
  //В списке заголовочных узлов нет узла с ключом w.
  //Поместим его в конец списка Head.
  { Tail = new (Leader); (**h).Count = 0;
	 (**h).Trail = NULL; (**h).Next = Tail; }
}

void Spisok::MakeGraph ()
//Функция возвращает указатель Head на структуру
//Вирта, соответствующую ориентированному графу.
{
  int x,y;
  Lref p,q; //Рабочие указатели.
  Tref t,r; //Рабочие указатели.
  Boolean Res; //Флаг наличия дуги.
  cout<<"Вводите начальную вершину дуги: ";
  cin>>x;
  while (x!=0)
  {
	  cout<<"Вводите конечную вершину дуги: "; cin>>y;
	  //Определим, существует ли в графе дуга (x,y)?
	  SearchGraph (x, &p); SearchGraph (y,&q);
	  r = (*p).Trail; Res = FALSE;
	  while ((r!=NULL)&&(!Res))
		 if ((*r).Id==q) Res = TRUE;
		 else r = (*r).Next;
	  if (!Res) //Если дуга отсутствует, то поместим её в граф.
		{ t = new (Trailer); (*t).Id = q;
		  (*t).Next = (*p).Trail; (*p).Trail = t; (*q).Count++; }
	  cout<<"Вводите начальную вершину дуги: "; cin>>x;
  }
}

void Spisok::PrintGraph ()
//Вывод структуры Вирта, заданной указателем
//Head и соответствующей ориентированному графу.
{
  Lref p; //Рабочий указатель.
  Tref q; //Рабочий указатель.

  p = Head;
  while (p!=Tail)
  {
	  cout<<(*p).Key<<"("; q = (*p).Trail;
	  while (q!=NULL)
		{ cout<<(*(*q).Id).Key; q = (*q).Next; }
	  cout<<")"; p = (*p).Next; cout<<" ";
  }
}

void Spisok::Dobavlenie (svqz *L, svqz *R, TipElement elem)
//Добавление элемента elem в очередь, заданную указателями L и R.
{
  svqz K = new (Zveno);

  K->Element = elem; K->Sled = NULL;
  if (*L==NULL)
	 { (*L) = K; (*R) = K; }
  else { (*R)->Sled = K; (*R) = K; }
}

void Spisok::Udalenie_A (svqz *L, svqz *R, TipElement *A)
//Удаление элемента из очереди, заданной указателями L и R и
//помещение удаленного элемента в переменную A.
{
  svqz q;

  if ((*L)!=NULL)
	if ((*L)->Sled!=NULL)
	  {
		  (*A) = (*L)->Element; q = (*L);
		  (*L) = (*L)->Sled; delete q;
	  }
	else {
			 (*A) = (*L)->Element; delete *L;
			 (*L) = (*R) = NULL;
		  }
}

void Spisok::Breadth_First_Search (Lref H)
//Обход графа в ширину, начиная с вершины, заданной указателем H
//(нерекурсивный обход).
{
  svqz L; //Указатель на начало очереди.
  svqz R; //Указатель на конец  очереди.
  Lref p; //Рабочий указатель.
  Tref t; //Рабочий указатель.

  L = R = NULL; //Создание пустой очереди.
  Dobavlenie (&L,&R,H); H->Flag = FALSE;
  while ( L!=NULL )
	//Пока очередь не пуста...
	{
	  Udalenie_A (&L,&R,&p);
	  cout << p->Key << " "; //Посещение вершины.
	  t = p->Trail;
	  while ( t!=NULL )
	  {
		 if ( t->Id->Flag )
		  {
			 Dobavlenie (&L,&R,t->Id);
			 t->Id->Flag = FALSE;
		  }
		 t = t->Next;
	  }
	}
}
Текст этой программы можно взять здесь.
Результат работы приложения изображен на рисунке 1:

Рис.1. Результат работы приложения

Замечания.
    1. Как и в случае обхода графа в глубину, функцию Breadth_First_Search() можно использовать без всяких модификаций и тогда, когда мы работаем с ориентированным графом. Очевидно, что тогда посещаются только те вершины, до которых существует путь от вершины, с которой мы начинаем обход.
    2. Способ обхода дерева в ширину, называемый иногда обходом в гоpизонтальном поpядке, основан на посещении вершин деpева слева напpаво, уpовень за уpовнем вниз от коpня. Пpиведенный ниже нерекурсивный алгоpитм позволяет совершить обход деpева в шиpину, используя две очеpеди O1 и O2 [2, с.124-125]:
    3.    Взять пустые очеpеди O1 и O2.
    4.    Поместить коpень в очеpедь O1.
    5.    while (Одна из очеpедей O1 и O2 не пуста)
    6.       if ( O1 не является пустой )
    7.         {
    8.                   Пусть p - узел, находящийся в голове очеpеди O1.
    9.                   Посетить веpшину p и удалить ее из O1.
    10.                   Поместить всех сыновей веpшины p в очеpедь O2, начиная
    11.                   со стаpшего сына.
    12.         }
    13.       else В качестве O1 взять непустую очеpедь O2,
    14.                а в качестве O2 взять пустую очеpедь O1.

Перейдем к реализации алгоритма обхода графа в ширину на языке LISP [1, с.131].
   (DEFUN TESTBF (LAMBDA NIL
      (PRINT "Построение графа.")
      (SETQ GRAPH NIL)   ;Инициализация
      (PRINT "Введите список вершин графа:") (SETQ NODE (READ))
      (PRINT "Введите список списков смежных вершин:")
      (SETQ NODELIST (READ))
      (PRINT (SETQ GRAPH (PAIRLIS NODE NODELIST GRAPH)))
      (PRINT "Приступим к обходу графа в ширину...")
      (PRINT "Введите вершину графа, с которой начнется обход:")
      (SETQ ROOT (READ))
      (BREADTHFIRST GRAPH ROOT)
   ))
   ; ------------------------------------
   (DEFUN PAIRLIS (LAMBDA (KEY ADJ GRAPH)
   ; Построение графа из списка вершин KEY и списка списков
   ; смежных  вершин  ADJ  путем добавления к существующему
   ;                   графу GRAPH
      (COND ( (NULL KEY) GRAPH )
            ( (NULL ADJ) GRAPH )
            (  T  (CONS (CONS (CAR KEY) (CAR ADJ))
                        (PAIRLIS (CDR KEY) (CDR ADJ) GRAPH)) )
      )
   ))
   ; --------------------------------------
   (DEFUN BREADTHFIRST (LAMBDA (GRAPH ROOT)
   ; Обход графа GRAPH в ширину, начиная с вершины ROOT
   ; GRAPH - граф, представленный структурой смежности в
   ;         виде ассоциативного списка,
   ; ROOT  - вершина графа, с которой начинается обход,
   ; Результат: список вершин графа в порядке посещения
      (BRFI
         GRAPH
         (LIST ROOT)              ; Вершина ROOT уже просмотрена
         (NEIGHBOUR3 ROOT GRAPH)  ; Ожидают просмотра вершины, смежные
                                  ; вершине ROOT
      )
   ))
   ; ---------------------------------------
   (DEFUN BRFI (LAMBDA (GRAPH VISITED QUEUE)
   ; GRAPH   - граф, представленный структурой смежности в
   ;           виде ассоциативного списка,
   ; VISITED - список уже просмотренных вершин
   ; QUEUE   - очередь вершин, ожидающих просмотра
      (COND ( (NULL QUEUE) (REVERSE VISITED) )
            ( T (COND ( (MEMBER (CAR QUEUE) VISITED)
                        ; Первая вершина в списке вершин, ожидающих
                        ; просмотра уже посещалась
                           (BRFI GRAPH VISITED (CDR QUEUE)) )
                      (  T  (BRFI
                               GRAPH
                               ; Вершина (CAR QUEUE) посещена
                               (CONS (CAR QUEUE) VISITED)
                               ; В очередь вершин, ожидающих просмотра,
                               ; помещаются вершины, смежные посещенной
                               (APPEND
                                  QUEUE
                                  (NEIGHBOUR3 (CAR QUEUE) GRAPH)))
                      )
                )
            )
      )
   ))
   ; ---------------------------------
   (DEFUN NEIGHBOUR3 (LAMBDA (X GRAPH)
   ; Функция возвращает список вершин графа GRAPH, смежных с
   ;                 вершиной X
      (COND ( (NULL (ASSOC X GRAPH)) NIL )
            (  T  (CDR (ASSOC X GRAPH)) )
      )
   ))
Текст этой библиотеки можно взять здесь.
Тестовые примеры:
   1) $ (TESTBF)
      Построение графа.
      Введите список вершин графа:
      (1 2 3 4 5)
      Введите список списков смежных вершин:
      ((2 3 4) (1 3) (1 2 4) (1 3 5) (4))
      Приступим к обходу графа в ширину...
      Введите вершину графа, с которой начнется обход:
      4
      (4 1 3 5 2)
   2) $ (TESTBF)
      Построение графа.
      Введите список вершин графа:
      (1 2 3 4)
      Введите список списков смежных вершин:
      ((2 3 4) (3) (4) ())
      Приступим к обходу графа в ширину...
      Введите вершину графа, с которой начнется обход:
      2
      (2 3 4)
   3) $ (TESTBF)
      Построение графа.
      Введите список вершин графа:
      (1 2 3 4 5 6 7)
      Введите список списков смежных вершин:
      ((2 3) (4 5) (6 7) () () () ())
      Приступим к обходу графа в ширину...
      Введите вершину графа, с которой начнется обход:
      1
      (1 2 3 4 5 6 7)
Последний тестовый пример иллюстрируется следующим ориентированным графом:

Рис.2. Пример графа
Мы видим, что при поиске в ширину смежные вершины последней просмотренной вершины добавляются в конецсписка QUEUE функцией
    (APPEND QUEUE (NEIGHBOUR3 (CAR QUEUE) GRAPH))),
в то время как новые вершины для просмотра берутся из начала этого списка, в который они помещаются функцией
    (CONS (CAR QUEUE) VISITED),
т.е. содержимое параметр QUEUE используется как очередь в отличие от параметра PATH функции DEFI, содержимое которого "работает" как стек. Это приводит к тому, что в процессе работы функции BRFI просмотренные вершины в списке VISITED расположены в порядке невозрастания их расстояния от начальной вершины ROOT.

Замечания.
    1. Алгоритмы обхода графа в ширину изложены в монографиях [3, с.36-38], [4, с.92-94], [5, с.198-205], [6, с.238-242].
    2. Неформально под разметкой в монографии [7, с.28] понимается отображение, сопоставляющее пометки вершинам или дугам графа.
Метод разметки используется для построения алгоритмов распознавания различных свойств размеченных графов. Понятие пометки формализует при этом интересующее нас свойство графа или его частей. В качестве анализируемого размеченного графа часто выступает схема программы. Метод разметки использует тот факт, что свойства вершины графа определяются свойствами некоторых "соседей" этой вершины.
Для иллюстрации основной идеи алгоритмов разметки опишем алгоритм такого типа для решения одной очень простой задачи: определения достижимости вершин ориентированного графа от некоторой выделенной его вершины, называемой начальной.
Вершина v достижима от начальной, если существует путь, ведущий от начальной вершины к вершине v.
Множеством пометок здесь будет служить множество, составленное из двух значений, которые мы назовем "достижима" и "неизвестно" соответственно. Начальная разметка сопоставляет пометку "достижима" начальной вершине графа и "неизвестно" всем остальным вершинам. Дальнейший процесс построения необходимой разметки будет состоять в повторном применении правила разметки:
 если  некоторая вершина помечена пометкой "достижима"
     то  пометить пометкой "достижима" всех "наследников" этой вершины.
Процесс завершается, когда будет достигнута стационарная разметка, т.е. такая, которая не изменяется никаким применением правила разметки.
Отметим две особенности процесса разметки.
Во-первых, сразу же возникает вопрос о том, существует ли хотя бы одна стационарная разметка. Иначе говоря, может ли завершиться процесс разметки?
Другой вопрос связан с единственностью стационарной разметки. Дело в том, что процесс разметки описан как недетерминированный в том смысле, что на каждом его шаге имеется возможность выбирать, к какой из вершин применять правило разметки. Верно ли, что результирующая стационарная разметка (если она существует) не зависит от того, в каком порядке и к каким вершинам будет применяться правило разметки?
Естественно нас интересуют преимущественно такие процессы разметки, когда ответ на оба сформулированных выше вопроса положителен, т.е. когда стационарная разметка существует и единственна. Такие процессы называются алгоритмами разметки.
Ясно, что изученные нами алгоритмы обхода графа представляют собой простейшие алгоритмы разметки.



(1) Крюков А.П., Радионов А.Я., Таранов А.Ю., Шаблыгин Е.М. Программирование на языке R-Лисп. - М.: Радио и связь, 1991. - 192 с.
(2) Касьянов В.H., Сабельфельд В.К. Сборник заданий по практикуму на ЭВМ. - М.: Наука, 1986. - 272 с.
(3) Евстигнеев В.А. Применение теории графов в программировании. - М.: Наука, 1985. - 352 с.
(4) Липский В. Комбинаторика для программистов. - М.: Мир, 1988. - 213 с.
(5) Пападимитриу Х., Стайнглиц К. Комбинаторная оптимизация. Алгоритмы и сложность. - М.: Мир, 1985. - 512 с.
(6) Кук Д., Бейз Г. Компьютерная математика. - М.: Наука, 1990. - 384 с.
(7) Котов В.Е., Сабельфельд В.К. Теория схем программ. - М.: Наука, 1991. - 248 с.

На следующем шаге мы рассмотрим алгоритмы вычисления пути между фиксированными вершинами.

        1.21. Путь между фиксированными вершинами
На этом шаге мы рассмотрим алгоритм нахождения пути между вершинами.
Оба вида обхода графа - в глубину и в ширину могут быть использованы для нахождения пути (цепи) между фиксированными вершинами u и v [1, с.92]. Достаточно начать обход графа с вершины v и вести его до момента посещения вершины u.
Преимуществом обхода графа в глубину является тот факт, что в момент посещения вершины u стек содержит последовательность вершин, определяющую путь (цепь) из v в u. Это становится очевидным, если отметить, что каждая вершина, помещаемая в стек, является смежной вершиной верхнего элемента стека.
Однако недостатком использования алгоритма обхода графа в глубину для поиска пути между данными вершинами является то, что полученный таким образом путь в общем случае не будет кратчайшим путем (кратчайшей цепью).

Пример 1. Поиск пути между двумя заданными вершинами в графе с использованием обхода графа в глубину. Граф представлен структурой Вирта.
#include <iostream.h>
#define TRUE 1
#define FALSE 0
typedef int Boolean;
typedef struct L *Lref; // Тип: указатель на заголовочный узел.
typedef struct T *Tref; // Тип: указатель на дуговой узел.

//Описание типа заголовочного узла.
typedef struct L
{
  int Key; //Имя заголовочного узла.
  int Count; //Количество предшественников.
  Boolean Flag; //Флаг посещения узла при обходе.
  Tref Trail; //Указатель на список смежности.
  Lref Next; //Указатель на следующий узел в списке заголовочных узлов.
} Leader;

//Описание типа дугового узла.
typedef struct T
{
  Lref Id;
  Tref Next;
} Trailer;

//Описание типа узла стека.
typedef Tref TipElement;
typedef struct Zveno *svqz;
typedef struct Zveno
{
  TipElement Element; //Указатель на список смежности.
  svqz Sled;
} St;

class Spisok
{
  private:
    Lref Head; //Указатель на голову списка заголовочных узлов.
    Lref Tail; //Указатель на фиктивный элемент
               // в конце списка заголовочных узлов.
    void SearchGraph (int, Lref *);
    void W_S (svqz *, TipElement);
    void YDALENIE (svqz *, TipElement *);
  public:
    Spisok() {//Инициализация списка заголовочных узлов.
              Head = Tail =  new (Leader); }
    Lref GetHead() { return Head; }
    Lref GetTail() { return Tail; }
    void MakeGraph ();
    void PrintGraph ();
    void Path_Depth_First_Search (int, int);
};

void main ()
{
  Spisok A;
  int B,E;
  Lref t; //Рабочий указатель для перемещения
          // по списку заголовочных звеньев.
  //Построение графа и вывод его структуры Вирта.
  A.MakeGraph ();
  A.PrintGraph (); cout<<endl;
  //Определение пути между двумя заданными вершинами графа.
  t = A.GetHead();
  while (t!=A.GetTail())
    { (*t).Flag = TRUE; t = (*t).Next; }
  cout << "Введите начальную вершину пути: "; cin >> B;
  cout << "Введите конечную вершину пути : "; cin >> E;
  cout << "Искомый путь: ";
  A.Path_Depth_First_Search (B,E); cout<<endl;
}

void Spisok::SearchGraph (int w, Lref *h)
//Функция возвращает указатель на заголовочный узел
//с ключом w в графе, заданном структурой Вирта с указателем Head.
{
  *h = Head; (*Tail).Key = w;
  while ((**h).Key!=w) *h = (**h).Next;
  if (*h==Tail)
  //В списке заголовочных узлов нет узла с ключом w.
  //Поместим его в конец списка Head.
  { Tail = new (Leader); (**h).Count = 0;
    (**h).Trail = NULL; (**h).Next = Tail; }
}

void Spisok::MakeGraph ()
//Функция возвращает указатель Head на структуру
//Вирта, соответствующую ориентированному графу.
{
  int x,y;
  Lref p,q; //Рабочие указатели.
  Tref t,r; //Рабочие указатели.
  Boolean Res; //Флаг наличия дуги.
  cout<<"Вводите начальную вершину дуги: ";
  cin>>x;
  while (x!=0)
  {
     cout<<"Вводите конечную вершину дуги: "; cin>>y;
     //Определим, существует ли в графе дуга (x,y)?
     SearchGraph (x, &p); SearchGraph (y,&q);
     r = (*p).Trail; Res = FALSE;
     while ((r!=NULL)&&(!Res))
       if ((*r).Id==q) Res = TRUE;
       else r = (*r).Next;
     if (!Res) //Если дуга отсутствует, то поместим её в граф.
      { t = new (Trailer); (*t).Id = q;
        (*t).Next = (*p).Trail; (*p).Trail = t; (*q).Count++; }
     cout<<"Вводите начальную вершину дуги: "; cin>>x;
  }
}

void Spisok::PrintGraph ()
//Вывод структуры Вирта, заданной указателем
//Head и соответствующей ориентированному графу.
{
  Lref p; //Рабочий указатель.
  Tref q; //Рабочий указатель.

  p = Head;
  while (p!=Tail)
  {
     cout<<"("<<(*p).Key; q = (*p).Trail;
     while (q!=NULL)
      { cout<<(*(*q).Id).Key; q = (*q).Next; }
     cout<<")"; p = (*p).Next; cout<<" ";
  }
}

void Spisok::W_S (svqz *stk, TipElement el)
//Помещение элемента el в стек stk.
{
  svqz q=new (St);
  (*q).Element = el; (*q).Sled = *stk; *stk = q;
}

void Spisok::YDALENIE (svqz *stk, TipElement *klad)
//Удаление звена из стека, заданного указателем *stk.
//Значение информационного поля удаляемого звена сохраня-
//ется в параметре klad.
{
  svqz q;

  if (*stk==NULL) cout<<"Попытка выбора из пустого стека!\n";
  else
   { *klad = (**stk).Element; q = *stk; *stk = (**stk).Sled; delete q; }
}

void Spisok::Path_Depth_First_Search (int B, int E)
//Путь между вершинами B и E в графе, заданном указателем Head.
{
  Lref s,r;
  Tref t;
  svqz UkZv; //Рабочий указатель для перемещения по стеку.

  svqz Stack = NULL; //Стек пуст.
  //Определим указатель на вершину B
  s = Head;
  while  (s!=Tail)
  {
    if  (s->Key==B)  r = s;
    s = s->Next;
  }
  //Посетим первую непосещенную вершину графа и
  //поместим ее в первоначально пустой стек.
  if (r->Key==E) goto Metka;
  r->Flag = FALSE; W_S (&Stack,r->Trail);
  while (Stack!=NULL)
  {
    //Рассмотрим "верхушку" стека.
    t = Stack->Element;
    if  (t->Id->Trail!=NULL)
    //У рассматриваемой вершины есть смежные вершины.
    {
      if (t->Id->Flag)
      //У рассматриваемой вершины есть
      //непосещенные смежные вершины.
      {
        //Посетим рассматриваемую вершину
        //и поместим указатель на ее список смежности в стек.
        if (t->Id->Key==E) goto Metka;
        t->Id->Flag = FALSE;
        W_S (&Stack,t->Id->Trail);
      }
      //У рассматриваемой вершины нет
      //непосещенных смежных вершин.
      else
      {
         t = Stack->Element;
         if (t->Next!=NULL)
         //Заменяем верхушку стека указателем
         //на следующий элемент списка смежности...
         {
            YDALENIE (&Stack,&t);
            W_S (&Stack,t->Next);
         }
         //или удаляем верхушку стека.
         else  YDALENIE (&Stack,&t);
      }
    }
    //У рассматриваемой вершины нет смежных вершин.
    else
    {
      if  (t->Id->Flag)
      //Посетим рассматриваемую вершину.
      {
         if  (t->Id->Key==E) goto Metka;
         t->Id->Flag = FALSE;
      }
      t = Stack->Element;
      if  (t->Next!=NULL)
      //Заменяем верхушку стека указателем
      //на следующий элемент списка смежности...
      {
            YDALENIE (&Stack,&t);
            W_S (&Stack,t->Next);
      }
      //или удаляем верхушку стека.
      else  YDALENIE (&Stack,&t);
    }
  }
Metka:
  UkZv = Stack;
  while ( UkZv!=NULL )
  {
    cout << UkZv->Element->Id->Key << " ";
    UkZv = UkZv->Sled;
  }
  cout << B << endl;
}
Текст этой программы можно взять здесь.
Для ориентированного графа, представленного на рисунке 1:

Рис.1. Пример графа
результат работы программы изображен на рисунке 2. Обратите внимание, что найден не оптимальный путь!

Рис.2. Результат работы приложения
Использование алгоритма обхода графа в ширину позволяет получить кратчайший путь между двумя фиксированными вершинами [1, с.93].

Пример 2. Поиск пути между двумя заданными вершинами в графе с использованием обхода графа в ширину (нерекурсивный алгоритм). Граф представлен структурой Вирта.
#include <iostream.h>
#define TRUE 1
#define FALSE 0
typedef int Boolean;
typedef struct Leader *Lref; // Тип: указатель на заголовочный узел.
typedef struct Trailer *Tref; // Тип: указатель на дуговой узел.

//Описание типа заголовочного узла.
typedef struct Leader
{
  int Key; //Имя заголовочного узла.
  int Count; //Количество предшественников.
  Boolean Flag; //Флаг посещения узла при обходе.
  Tref Trail; //Указатель на список смежности.
  Lref Next; //Указатель на следующий узел в списке заголовочных узлов.
};

//Описание типа дугового узла.
typedef struct Trailer
{
  Lref Id;
  Tref Next;
};

//Описание типа узла очереди.
typedef Lref TipElement; //Указатель на звено заголовочного списка.
typedef struct Zveno *svqz;
typedef struct Zveno
{
  TipElement Element; //Указатель на список смежности.
  svqz Sled;
};

class Spisok
{
  private:
	 Lref Head; //Указатель на голову списка заголовочных узлов.
	 Lref Tail; //Указатель на фиктивный элемент
					// в конце списка заголовочных узлов.
	 void Udalenie_A (svqz *, svqz *, TipElement *);
	 void Dobavlenie (svqz *, svqz *, TipElement);
	 void SearchGraph (int, Lref *);
  public:
	 Spisok() {//Инициализация списка заголовочных узлов.
				  Head = Tail =  new (Leader); }
         Lref GetHead() { return Head; }
         Lref GetTail() { return Tail; }
         void MakeGraph ();
         void PrintGraph ();
         void Path_Breadth_First_Search (Lref, int, int);
};

void main ()
{
  Spisok A;
  int B,E;
  Lref t; //Рабочий указатель для перемещения
          // по списку заголовочных звеньев.

  //Построение графа и вывод его структуры Вирта.
  A.MakeGraph ();
  A.PrintGraph (); cout<<endl;
  //Определение пути между двумя заданными вершинами графа.
  t = A.GetHead();
  while (t!=A.GetTail())
    { (*t).Flag = TRUE; t = (*t).Next; }
  cout << "Введите начальную вершину пути: "; cin >> B;
  cout << "Введите конечную вершину пути : "; cin >> E;
  cout << "Искомый путь: ";
  A.Path_Breadth_First_Search(A.GetHead(),B,E); cout<<endl;
}

void Spisok::SearchGraph (int w, Lref *h)
//Функция возвращает указатель на заголовочный узел
//с ключом w в графе, заданном структурой Вирта с указателем Head.
{
  *h = Head; (*Tail).Key = w;
  while ((**h).Key!=w) *h = (**h).Next;
  if (*h==Tail)
  //В списке заголовочных узлов нет узла с ключом w.
  //Поместим его в конец списка Head.
  { Tail = new (Leader); (**h).Count = 0;
	 (**h).Trail = NULL; (**h).Next = Tail; }
}

void Spisok::MakeGraph ()
//Функция возвращает указатель Head на структуру
//Вирта, соответствующую ориентированному графу.
{
  int x,y;
  Lref p,q; //Рабочие указатели.
  Tref t,r; //Рабочие указатели.
  Boolean Res; //Флаг наличия дуги.
  cout<<"Вводите начальную вершину дуги: ";
  cin>>x;
  while (x!=0)
  {
	  cout<<"Вводите конечную вершину дуги: "; cin>>y;
	  //Определим, существует ли в графе дуга (x,y)?
	  SearchGraph (x, &p); SearchGraph (y,&q);
	  r = (*p).Trail; Res = FALSE;
	  while ((r!=NULL)&&(!Res))
		 if ((*r).Id==q) Res = TRUE;
		 else r = (*r).Next;
	  if (!Res) //Если дуга отсутствует, то поместим её в граф.
		{ t = new (Trailer); (*t).Id = q;
		  (*t).Next = (*p).Trail; (*p).Trail = t; (*q).Count++; }
	  cout<<"Вводите начальную вершину дуги: "; cin>>x;
  }
}

void Spisok::PrintGraph ()
//Вывод структуры Вирта, заданной указателем
//Head и соответствующей ориентированному графу.
{
  Lref p; //Рабочий указатель.
  Tref q; //Рабочий указатель.

  p = Head;
  while (p!=Tail)
  {
	  cout<<(*p).Key<<"("; q = (*p).Trail;
	  while (q!=NULL)
		{ cout<<(*(*q).Id).Key; q = (*q).Next; }
	  cout<<")"; p = (*p).Next; cout<<" ";
  }
}

void Spisok::Dobavlenie (svqz *L, svqz *R, TipElement elem)
//Добавление элемента elem в очередь, заданную указателями L и R.
{
  svqz K = new (Zveno);

  K->Element = elem; K->Sled = NULL;
  if (*L==NULL)
	 { (*L) = K; (*R) = K; }
  else { (*R)->Sled = K; (*R) = K; }
}

void Spisok::Udalenie_A (svqz *L, svqz *R, TipElement *A)
//Удаление элемента из очереди, заданной указателями L и R и
//помещение удаленного элемента в переменную A.
{
  svqz q;

  if ((*L)!=NULL)
	if ((*L)->Sled!=NULL)
	  {
		  (*A) = (*L)->Element; q = (*L);
		  (*L) = (*L)->Sled; delete q;
	  }
	else {
			 (*A) = (*L)->Element; delete *L;
			 (*L) = (*R) = NULL;
		  }
}

void Spisok::Path_Breadth_First_Search (Lref H, int B, int E)
//Путь в графе, заданном указателем H, между вершинами B и E.
{
  svqz L; //Указатель на начало очеpеди.
  svqz R; //Указатель на конец  очеpеди.
  Lref p; //Рабочий указатель.
  Tref t; //Рабочий указатель.
  int  Pred[30]; //Элемент Pred[i] содержит вершину графа,
                 //"предшествующую" данной.
  int i;

  L = R = NULL; // Построение пустой очеpеди.
  //Определим указатель на вершину B и поместим его в очередь.
  p = H;
  while ( p!=Tail )
  {
    if ( p->Key==B )
    {
       Dobavlenie (&L,&R,p);
       p->Flag = FALSE;
    }
    p = p->Next;
  }
  //Пока очеpедь не пуста...
  while  (L!=NULL)
  {
     Udalenie_A (&L,&R,&p);
     t = p->Trail;
     while  (t!=NULL)
     {
       if (t->Id->Flag)
       {
         Dobavlenie (&L,&R,t->Id);
         t->Id->Flag = FALSE;
         Pred [t->Id->Key] = p->Key;
       }
       t = t->Next;
     }
  }
  i = E;
  cout << E << ' ';
  while (i!=B)
  { cout << Pred[i] <<' '; i = Pred[i]; }
  cout << endl;
}
Текст этой программы можно взять здесь.
Результат работы программы для ориентированного графа, изображенного на рисунке 1, отражен на рисунке 3:

Рис.3. Результат работы приложения
Вернемся теперь к функциональному программированию.
Мы уже упоминали о том, что параметр PATH функции DEFI (смотри шаг 96) описывает путь из начальной вершины в просматриваемую. Поэтому алгоритм обхода графа в глубину можно легко модифицировать в алгоритм поиска пути между заданными вершинами (например, вершинами ROOT и END).

Пример 3.
   (DEFUN TESTWAY (LAMBDA NIL
      (PRINT "Построение графа.")
      (SETQ GRAPH NIL)   ;Инициализация
      (PRINT "Введите список вершин графа:") (SETQ NODE (READ))
      (PRINT "Введите список списков смежных вершин:")
      (SETQ NODELIST (READ))
      (PRINT (SETQ GRAPH (PAIRLIS NODE NODELIST GRAPH)))
      (PRINT "Приступим к поиску пути между заданными вершинами")
      (PRINT "    с использованием обхода графа в глубину...   ")
      (PRINT "Введите начальную вершину пути:") (SETQ ROOT (READ))
      (PRINT "Введите конечную вершину пути:")  (SETQ END  (READ))
      (WAY GRAPH ROOT END)
   ))
   ; ------------------------------------
   (DEFUN PAIRLIS (LAMBDA (KEY ADJ GRAPH)
   ; Построение графа из списка вершин KEY и списка списков
   ; смежных  вершин  ADJ  путем добавления к существующему
   ;                   графу GRAPH
      (COND ( (NULL KEY) GRAPH )
            ( (NULL ADJ) GRAPH )
            (  T  (CONS (CONS (CAR KEY) (CAR ADJ))
                        (PAIRLIS (CDR KEY) (CDR ADJ) GRAPH)) )
      )
   ))
   ; ---------------------------------
   (DEFUN WAY (LAMBDA (GRAPH ROOT END)
   ; Построение пути в графе GRAPH между вершинами ROOT и END
      (COND ( (NULL GRAPH) NIL )
            (  T  (DEFI GRAPH (LIST ROOT) (LIST ROOT) END) )
      )
   ))
   ; ------------------------------------------
   (DEFUN DEFI (LAMBDA (GRAPH VISITED PATH END)
   ; GRAPH   - граф, представленный структурой смежности в
   ;           виде ассоциативного списка,
   ; VISITED - список уже посещенных вершин,
   ; PATH    - список вершин, определяющий путь посещения
   ; END     - конечная вершина пути
      (COND ( (NULL PATH) (REVERSE VISITED) )
            ( T  (COND ( (NULL (EXPND GRAPH VISITED (CAR PATH)))
                            (DEFI GRAPH VISITED (CDR PATH) END)
                       )
                       ( (EQ (EXPND GRAPH VISITED (CAR PATH)) END)
                                (REVERSE (CONS END PATH)) )
                       (  T  (DEFI GRAPH
                                   (CONS (EXPND GRAPH VISITED
                                                (CAR PATH))
                                         VISITED)
                                   (CONS (EXPND GRAPH VISITED
                                                (CAR PATH))
                                         PATH)
                                   END) )) )
      )
   ))
   ; -----------------------------------------
   (DEFUN EXPND (LAMBDA (GRAPH VISITED VERTEX)
   ; Выбор в графе GRAPH следующей еще не просмотренной
   ;        вершины, смежной с вершиной  2VERTEX
      (COND ( (NULL (NEIGHBOUR3 VERTEX GRAPH)) NIL )
            (  T  (FIRSTNOTVISITED
                             VISITED
                             (NEIGHBOUR3 VERTEX GRAPH))
            )
      )
   ))
   ; --------------------------------------------
   (DEFUN FIRSTNOTVISITED (LAMBDA (VISITED VLIST)
   ; Поиск первой непосещенной вершины в списке VLIST
   ; VISITED - список уже посещенных вершин
      (COND ( (NULL VLIST) NIL )
            (  T  (COND ( (NULL (MEMBER (CAR VLIST) VISITED))
                             (CAR VLIST)
                        )
                        (  T  (FIRSTNOTVISITED
                                           VISITED
                                           (CDR VLIST))
                        )
                  )
            )
      )
   ))
   ; ---------------------------------
   (DEFUN NEIGHBOUR3 (LAMBDA (X GRAPH)
   ; Функция возвращает список вершин графа GRAPH, смежных с
   ;                 вершиной X
      (COND ( (NULL (ASSOC X GRAPH)) NIL )
            (  T  (CDR (ASSOC X GRAPH)) )
      )
   ))
Текст этой библиотеки можно взять здесь.
Рассмотрим тестовые примеры для изображенного на рисунке ориентированного графа:

Рис.4. Пример графа

   1) $ (TESTWAY)
      Построение графа.
      Введите список вершин графа:
      (1 2 3 4 5 7 8)
      Введите список списков смежных вершин:
      ((2) (3 4) () (5) (2 7 8) () ())
      ((1 2) (2 3 4) (3) (4 5) (5 2 7 8) (7) (8))
      Приступим к поиску пути между заданными вершинами
          с использованием обхода графа в глубину...
      Введите начальную вершину пути:
      1
      Введите конечную вершину пути:
      5
      (1 2 4 5)
   2) $ (TESTWAY)
      Построение графа.
      Введите список вершин графа:
      (1 2 3 4 5 7 8)
      Введите список списков смежных вершин:
      ((2) (3 4) () (5) (2 7 8) () ())
      ((1 2) (2 3 4) (3) (4 5) (5 2 7 8) (7) (8))
      Приступим к поиску пути между заданными вершинами
          с использованием обхода графа в глубину...
      Введите начальную вершину пути:
      1
      Введите конечную вершину пути:
      1
      (1 2 3 4 5 7 8)
Обратите внимание на тот факт, что если пути из вершины ROOT в вершину END не существует, то функция (WAY GRAPH ROOT END) возвращает результат обхода графа в глубину.


(1) Липский В. Комбинаторика для программистов. - М.: Мир, 1988. - 213 с.

На следующем шаге мы познакомимся с Эйлеровыми путями и циклами.

        1.22. Эйлеровы пути и циклы
На этом шаге мы рассмотрим Эйлеровы пути и циклы.

Определение 1 [1, с.106].
Эйлеровым путем в графе называется путь, проходящий через каждое ребро графа только один раз, т.е. путь v1,v2..., vm+1, такой, что каждое ребро e, принадлежащее E, появляется в последовательности v1, v2..., vm+1 в точности один раз как e={vi,vi+1}. 0 Иногда граф, обладающий эйлеровым путем, называют полуэйлеровым [2, с.43].
Если v1=vm+1, то такой путь называется эйлеровым циклом, а граф, обладающий эйлеровым циклом, называют эйлеровым графом [2, с.43].
Задача существования эйлерова пути в заданном графе была решена Л.Эйлером в 1736 г., и представленное им необходимое и достаточное условие существования такого пути считается первой в истории теоремой теории графов.
Теорема [1, с.106].
Эйлеров путь в графе существует тогда и только тогда, когда:
    • граф связный и
    • содержит не более чем две вершины нечетной степени.
Приведем формулировку этой же теоремы в другой терминологии.
Теорема [2, с.43].
Связный граф является полуэйлеровым тогда и только тогда, когда в нем не более двух вершин имеют нечетные степени.
Если в связном графе нет вершин нечетной степени, то каждый эйлеров путь является циклом, так как концы эйлерова пути, не являющегося циклом, всегда вершины нечетной степени.
Это утверждение в монографии [2, с.4 24 0] оформлено в виде теоремы.
Теорема.
Связный граф G является эйлеровым (обладает эйлеровым циклом) тогда и только тогда, когда каждая вершина в G имеет четную степень.
Определение 2 [3, с.182].
Эйлеров контур 0 в ориентированном графе - это контур, содержащий все дуги и только по одному разу.
Каковы же те графы, которые обладают эйлеровыми контурами?
Граф называется псевдосимметрическим, если в каждой его вершине число исходящих дуг равно числу заходящих. Эта терминология оправдывается тем, что всякий симметрический граф является в то же время псевдосимметрическим.
Теорема [3, с.182].
Граф обладает эйлеровым контуром тогда и только тогда, когда он является связным и псевдосимметрическим.
Реализуем приведенный в [1,с.107] алгоритм нахождения эйлерова цикла в связном графе без вершин нечетной степени, представленном структурой Вирта.
void Spisok::Euler ()
//Построение эйлерова цикла в связном графе без вершин нечетной
//степени, заданном  структурой  Вирта. Начало цикла определено
//указателем Head.
{
  Lref v,u; //Рабочие переменные.
  svqz q;   //Рабочая переменная.

  svqz Stack =NULL, CE = NULL;
  W_S (&Stack,Head);
  while (Stack!=NULL)
  {
    //Взглянем на верхний элемент стека Stack...
    v = Stack->Element;
    if  (v->Trail!=NULL)
    {
      u = v->Trail->Id;
		W_S (&Stack,u);
      DeleteGraph (v->Key,u->Key);
      DeleteGraph (u->Key,v->Key);
    }
    else
    {
      YDALENIE (&Stack,&v);
      W_S (&CE,v);
    }
  }
  //В стеке CE хранится эйлеров цикл.
  q = CE;
  while  (q!=NULL)
  {  cout << q->Element->Key << ' '; q = q->Sled; }
}
Оценим теперь вычислительную сложность алгоритма [1, с.108]. Для этого отметим, что каждая итерация главного цикла либо помещает вершину в стек Stack и удаляет ребро из графа, либо переносит вершину из стека Stack в стек CE. Таким образом, число итераций этого цикла - O(m), где m - количество ребер.
Ухудшить алгоритм может лишь процедура удаления ребра из графа, которая у нас называется DeleteGraph (), и встречается почти в каждой итерации. Она это и делает, ибо уже на поиски удаляемого ребра затрачивается время 2*O(n), где n - количество вершин графа.
Из приведенных рассуждений можно сделать вывод, что общая сложность алгоритма есть O(m*n).

Пример.
#include <iostream.h>
#define TRUE 1
#define FALSE 0
typedef int Boolean;
typedef struct L *Lref; // Тип: указатель на заголовочный узел.
typedef struct T *Tref; // Тип: указатель на дуговой узел.

//Описание типа заголовочного узла.
typedef struct L
{
  int Key; //Имя заголовочного узла.
  int Count; //Количество предшественников.
  Boolean Flag; //Флаг посещения узла при обходе.
  Tref Trail; //Указатель на список смежности.
  Lref Next; //Указатель на следующий узел в списке заголовочных узлов.
} Leader;

//Описание типа дугового узла.
typedef struct T
{
  Lref Id;
  Tref Next;
} Trailer;

//Описание типа узла стека.
typedef Lref TipElement;
typedef struct Zveno *svqz;
typedef struct Zveno
{
  TipElement Element; //Указатель на список смежности.
  svqz Sled;
} St;

class Spisok
{
  private:
    Lref Head; //Указатель на голову списка заголовочных узлов.
    Lref Tail; //Указатель на фиктивный элемент
               // в конце списка заголовочных узлов.
    void SearchGraph (int, Lref *);
    void W_S (svqz *, TipElement);
    void YDALENIE (svqz *, TipElement *);
    Lref Search (int);
    void DeleteGraph (int, int);
  public:
    Spisok() {//Инициализация списка заголовочных узлов.
              Head = Tail =  new (Leader); }
    void MakeGraph ();
    void PrintGraph ();
    void Euler ();
};

void main ()
{
  Spisok A;
  //Построение графа и вывод его структуры Вирта.
  A.MakeGraph ();
  A.PrintGraph (); cout<<endl;
  //Построение Эйлерова цикла.
  A.Euler();
  A.PrintGraph (); cout<<endl;
}

void Spisok::SearchGraph (int w, Lref *h)
//Функция возвращает указатель на заголовочный узел
//с ключом w в графе, заданном структурой Вирта с указателем Head.
{
  *h = Head; (*Tail).Key = w;
  while ((**h).Key!=w) *h = (**h).Next;
  if (*h==Tail)
  //В списке заголовочных узлов нет узла с ключом w.
  //Поместим его в конец списка Head.
  { Tail = new (Leader); (**h).Count = 0;
    (**h).Trail = NULL; (**h).Next = Tail; }
}

void Spisok::MakeGraph ()
//Функция возвращает указатель Head на структуру
//Вирта, соответствующую ориентированному графу.
{
  int x,y;
  Lref p,q; //Рабочие указатели.
  Tref t,r; //Рабочие указатели.
  Boolean Res; //Флаг наличия дуги.
  cout<<"Вводите начальную вершину дуги: ";
  cin>>x;
  while (x!=0)
  {
     cout<<"Вводите конечную вершину дуги: "; cin>>y;
     //Определим, существует ли в графе дуга (x,y)?
     SearchGraph (x, &p); SearchGraph (y,&q);
     r = (*p).Trail; Res = FALSE;
     while ((r!=NULL)&&(!Res))
       if ((*r).Id==q) Res = TRUE;
       else r = (*r).Next;
     if (!Res) //Если дуга отсутствует, то поместим её в граф.
      { t = new (Trailer); (*t).Id = q;
        (*t).Next = (*p).Trail; (*p).Trail = t; (*q).Count++; }
     cout<<"Вводите начальную вершину дуги: "; cin>>x;
  }
}

void Spisok::PrintGraph ()
//Вывод структуры Вирта, заданной указателем
//Head и соответствующей ориентированному графу.
{
  Lref p; //Рабочий указатель.
  Tref q; //Рабочий указатель.

  p = Head;
  while (p!=Tail)
  {
     cout<<"("<<(*p).Key; q = (*p).Trail;
     while (q!=NULL)
      { cout<<(*(*q).Id).Key; q = (*q).Next; }
     cout<<")"; p = (*p).Next; cout<<" ";
  }
}

void Spisok::W_S (svqz *stk, TipElement el)
//Помещение элемента el в стек stk.
{
  svqz q=new (St);
  (*q).Element = el; (*q).Sled = *stk; *stk = q;
}

void Spisok::YDALENIE (svqz *stk, TipElement *klad)
//Удаление звена из стека, заданного указателем *stk.
//Значение информационного поля удаляемого звена сохраня-
//ется в параметре klad.
{
  svqz q;

  if (*stk==NULL) cout<<"Попытка выбора из пустого стека!\n";
  else
   { *klad = (**stk).Element; q = *stk; *stk = (**stk).Sled; delete q; }
}

void Spisok::DeleteGraph (int x,int y)
//Функция возвращает указатель *Head на структуру
//Вирта, соответствующую ориентированному графу и
//полученную удалением дуги (x,y).
{
  Lref p,q; //Рабочие указатели.
  Tref t,r; //Рабочие указатели.
  Boolean Res; //Флаг наличия дуги.

  // Определим, существует ли в графе дуга (x,y)?
  p = Search (x);q = Search (y);
  if ((p!=NULL) && (q!=NULL))
  { // Вершины в графе есть.
     r = (*p).Trail; Res = FALSE;
     while ((r!=NULL) && (!Res))
     if ((*r).Id==q) Res = TRUE;
     else r = (*r).Next;
     if (Res) //Если дуга существует, то удалим её.
       if (r==(*p).Trail)
        { (*p).Trail = (*(*p).Trail).Next; delete r; (*q).Count--; }
       else {
           t = (*p).Trail;
          while ((*t).Next!=r) t = (*t).Next;
          (*t).Next = (*(*t).Next).Next; delete r; (*q).Count--; }
  }
}

Lref Spisok::Search (int w)
//Функция возвращает указатель на заголовочный узел с
//ключом w. Если узел отсутствует, то функция возвращает
//NULL.
{
  Lref h;

  h = Head;
  (*Tail).Key = w; //Поиск "с барьером".
  while ((*h).Key!=w) h = (*h).Next;
    if (h==Tail) //В списке заголовочных узлов нет узла с ключом w.
      h = NULL;
  return h;
}

void Spisok::Euler ()
//Построение эйлерова цикла в связном графе без вершин нечетной
//степени, заданном  структурой  Вирта. Начало цикла определено
//указателем Head.
{
  Lref v,u; //Рабочие переменные.
  svqz q;   //Рабочая переменная.

  svqz Stack =NULL, CE = NULL;
  W_S (&Stack,Head);
  while (Stack!=NULL)
  {
    //Взглянем на верхний элемент стека Stack...
    v = Stack->Element;
	 if  (v->Trail!=NULL)
    {
      u = v->Trail->Id;
		W_S (&Stack,u);
      DeleteGraph (v->Key,u->Key);
      DeleteGraph (u->Key,v->Key);
    }
    else
    {
      YDALENIE (&Stack,&v);
      W_S (&CE,v);
    }
  }
  //В стеке CE хранится эйлеров цикл.
  q = CE;
  while  (q!=NULL)
  {  cout << q->Element->Key << ' '; q = q->Sled; }
}
Текст этой программы можно взять здесь.

Замечания.
    1. Приведем алгоритм построения эйлеровой цепи в данном эйлеровом графе. Этот метод известен под названием алгоритма Флёри.
Теорема [2, с.45-46].
Пусть G - эйлеров граф; тогда следующая процедура всегда возможна и приводит к построению эйлеровой цепи графа G. Выходя из произвольной вершины u, идем по ребрам графа произвольным образом, соблюдая лишь следующие правила:
        ◦ стираем ребра по мере их прохождения и стираем также изолированные вершины, которые при этом образуются;
        ◦ на каждом этапе идем по мосту только тогда, когда нет других возможностей (или другими словами, не проходить по ребру, если удаление этого ребра приводит к разбиению графа на две связные компоненты).
    2. В монографии [4, с.173-175] изложен "изящный и практически эффективный алгоритм Хоанг Туя (1964 г.). При этом, правда, предполагается, что для нахождения какой-нибудь цепи между двумя заданными вершинами, а значит, и цикла, содержащего заданное цикловое ребро, достаточно хорошие алгоритмы известны.
    3. Ребрам графа G приписаны положительные веса. Требуется найти цикл, проходящий через каждое ребро графа G по крайней мере один раз и такой, что для него общий вес (а именно сумма величин nj*c(aj), где числа nj показывают, сколько раз проходилось ребро aj, а c(aj) - вес ребра) минимален.
Очевидно, что если G содержит эйлеров цикл, то любой такой цикл будет оптимальным, так как каждое ребро проходится только один раз и вес этого цикла равен тогда сумме c(aj), где j изменяется от 1 до m.
Сформулированная задача называется задачей китайского почтальона [5, с.230-231].
    4. Кёнигсберг (теперь Калининград) расположен на обоих берегах реки Преголя и на двух островах этой реки. Берега реки и два острова соединены семью мостами. Вопрос - поставленный в 1736 г. - состоит в том, можно ли, начав с некоторой точки, совершить прогулку и вернуться в исходную точку, пройдя по каждому мосту ровно один раз. Если каждый берег реки и острова считать вершиной графа, а каждый мост - ребром, то карту можно представить в виде графа, а ответ на поставленный вопрос зависит теперь от существования эйлерова цикла в этом графе.
Отрицательное решение Л.Эйлером (Commentarii Acad.Petropoletanae 8(1736),128-140) этой задачи, по-видимому, можно считать первой печатной научной работой по несуществовавшей тогда теории графов.
Типичной задачей по эйлеровым графам является задача с такой постановкой: можно ли нарисовать какую-нибудь диаграмму (соединив данные точки линией), не отрывая карандаша от бумаги и не проходя никакую линию дважды.
    5. [6, с.39]. Эйлеровым графом может быть представлен, например, план выставки; это позволяет так расставить указатели маршрута, чтобы посетитель смог пройти по каждому залу в точности по одному разу.



(1) Липский В. Комбинаторика для программистов. - М.: Мир, 1988. - 213 с.
(2) Уилсон Р. Введение в теорию графов. - М.: Мир, 1977. - 207 с.
(3) Берж К. Теория графов и ее применения. - М.: ИЛ,1962. - 320 с.
(4) Зыков А.А. Основы теории графов. М.: Наука, 1987. - 384 с.
(5) Кристофидес Н. Теория графов. Алгоритмический подход. - М.: Мир, 1978. - 432 с.
(6) Березина Л.Ю. Графы и их применение. - М.: Просвещение, 1979. - 143 с.

Со следующего шага мы начнем рассматривать алгоритмы на графах.

        1.23. Алгоритмы на графах. Кратчайшие пути между всеми парами вершин. Алгоритм Уоршалла
На этом шаге мы рассмотрим алгоритм Уоршалла.
Метод определения матрицы достижимости P графа сначала путем вычисления A, A2, ..., An, а затем Bn является очень громоздким.
Опишем более эффективный метод, основанный на аналогичных идеях. Заметим, что нас не интересует число путей любой конкретной длины из вершины vi в вершину vj. Эта информация, получаемая в процессе вычисления степеней A, далее игнорируется. Для того, чтобы сократить объем вычислений, можно отказаться от получения указанной информации и использовать в вычислениях просто реализуемые булевские матричные операции, которые мы определим согласно [1, с.440].
Обозначим булевскую сумму C двух матриц A и B размера n*n как , а булевское произведение D - .
Элементы матриц C и D задаются соотношениями

Заметим, что элемент dij легко получается путем просмотра i-й строки матрицы A слева направо и одновременно j-го столбца матрицы B сверху вниз. Если k-й элемент в строке матрицы A и k-й элемент в столбце матрицы B равны 1 для какого-нибудь k, то dij=1. В противном случае dij=0.
Булевы матрицы более экономичны в вычислительном отношении, чем целочисленные. Действительно, запоминание булевой матрицы требует меньшего объема оперативной памяти ЭВМ по сравнению с целочисленной матрицей той же размерности. Кроме того, выполнение на компьютере логических операций над булевыми матрицами требует меньшего объема вычислений, чем над целочисленными матрицами тех же размерностей.
Матрица смежностей, так же как и путевая матрица, является булевской матрицей. Заметим, что .
Единственная разница между A2 и A(2) заключается в том, что A(2) является булевской матрицей и элемент на пересечении i-й строки и j-го столбца A(2) равен 1 в том случае, когда существует по крайней мере один путь длины 2 из vi в vj. Аналогичное положение имеет место для A3 и A(3) и в общем случае для Ar и A(r) при любом целом положительном r. Из этих рассуждений ясно, что матрица достижимости P задается выражением

Например, если

то

Данный метод получения матрицы достижимости ориентированного графа называется алгоритмом Уоршалла(Warshall S.A. A Theorem on Boolean Matrices. - J.ACM, 1962, 9, pp.11-12). Он может быть легко реализован на языке C++.

Программа 1 [2, с.329]. Вычисление матрицы достижимости по заданной матрице смежностей с помощью алгоритма Уоршалла.
#include <iostream.h>
#define MaxNodes 4

class Warshall
{
  private:
    unsigned Adj[MaxNodes][MaxNodes];  //Матрица смежностей.
    unsigned Path[MaxNodes][MaxNodes]; //Матрица достижимости.
  public:
    void Vvod();
    void TransClose();
    void Vyvod();
};

void Warshall::Vvod()
{
  //Ввод матрицы смежностей заданного графа.
  cout <<"Вводите элементы матрицы смежностей по строкам:\n";
  for (int i=0;i<MaxNodes;i++)
    for (int j=0;j<MaxNodes;j++)
     {
       cout <<"Введите Adj["<< (i+1) << "]["<< (j+1) << "]: ";
       cin >> Adj[i][j];
     }
}

void Warshall::TransClose()
//Вычисление матрицы достижимости.
{
  //Инициализация матрицы Path матрицей смежностей Adj.
  for (int i=0;i<MaxNodes;i++)
    for (int j=0;j<MaxNodes;j++)
      Path[i][j] = Adj[i][j];
  //Нахождение следующих значений матрицы Path.
  for (int k=0;k<MaxNodes;k++)
    for (i=0;i<MaxNodes;i++)
      if (Path[i][k]==1)
         for (int j=0;j<MaxNodes;j++)
               Path[i][j] = (Path[i][j] || Path[k][j]);
}

void Warshall::Vyvod()
//Вывод матрицы достижимости.
{
  cout << "Матрица достижимости:\n";
  for (int i=0;i<MaxNodes;i++)
  {
    for (int j=0;j<MaxNodes;j++)
      cout << Path[i][j] << " ";
    cout << endl;
  }
}

void main()
{
  Warshall A;
  A.Vvod();
  A.TransClose();
  A.Vyvod();
}
Текст этой программы можно взять здесь.
Заметим, что описанный алгоритм обрабатывает матрицу Adj по столбцам. Уоррен [3, с.320] предложил изящный двухпроходной строкоориентированный алгоритм. В этом алгоритме при обработке вершины, например i, в первом проходе обрабатываются только ребра, связанные с вершинами, меньшими i, а во втором проходе - только ребра, связанные с вершинами, большими i. Другими словами, алгоритм преобразует матрицу смежности Adj графа G в матрицу достижимости, обрабатывая в первом проходе только элементы матрицы, расположенные ниже ее главной диагонали, а во втором проходе - только элементы матрицы, расположенные выше ее главной диагонали. Таким образом, при каждом проходе обрабатывается не более n*(n-1)/2 ребер.

Программа 2. Приведем реализацию алгоритма Уоррена на языке C++.
#include <iostream.h>
#define MaxNodes 4

class Warren
{
  private:
    unsigned Adj[MaxNodes][MaxNodes];  //Матрица смежностей.
    unsigned Path[MaxNodes][MaxNodes]; //Матрица достижимости.
  public:
    void Vvod();
    void TransClose();
    void Vyvod();
};

void Warren::Vvod()
{
  //Ввод матрицы смежностей заданного графа.
  cout <<"Вводите элементы матрицы смежностей по строкам:\n";
  for (int i=0;i<MaxNodes;i++)
    for (int j=0;j<MaxNodes;j++)
     {
       cout <<"Введите Adj["<< (i+1) << "]["<< (j+1) << "]: ";
       cin >> Adj[i][j];
     }
}

void Warren::TransClose()
//Вычисление матрицы достижимости.
{
  //Инициализация матрицы Path матрицей смежностей Adj.
  for (int i=0;i<MaxNodes;i++)
    for (int j=0;j<MaxNodes;j++)
      Path[i][j] = Adj[i][j];
  //Нахождение следующих значений матрицы Path.
  for (i=1;i<MaxNodes;i++)
    for (int j=0;j<i;j++)
      if (Path[i][j]==1)
         for (int k=0;k<MaxNodes;k++)
               Path[i][k] = (Path[i][k] || Path[j][k]);
  for (i=0;i<MaxNodes-1;i++)
    for (int j=i+1;j<MaxNodes;j++)
      if (Path[i][j]==1)
         for (int k=0;k<MaxNodes;k++)
               Path[i][k] = (Path[i][k] || Path[j][k]);
}

void Warren::Vyvod()
//Вывод матрицы достижимости.
{
  cout << "Матрица достижимости:\n";
  for (int i=0;i<MaxNodes;i++)
  {
    for (int j=0;j<MaxNodes;j++)
      cout << Path[i][j] << " ";
    cout << endl;
  }
}

void main()
{
  Warren A;
  A.Vvod();
  A.TransClose();
  A.Vyvod();
}
Текст этой программы можно взять здесь.


(1) Трамбле Ж., Соренсон П. Введение в структуры данных. - М.: Машиностроение, 1982. - 784 с.
(2) Tenenbaum A., Augenstein M. Data Structures Using Pascal. Englewood Cliffs. - N.Y.: Prentice-Hall, Inc. 1981.
(3) Свами М., Тхуласираман К. Графы, сети и алгоритмы. - М.: Мир, 1984. - 454 с.

На следующем шаге мы рассмотрим применение алгоритма Уоршалла.

        1.24. Применение алгоритма Уоршалла. Вычисление длин кратчайших путей между вершинами
На этом шаге мы рассмотрим алгоритм нахождения кратчайших путей между вершинами графа.
Алгоритм Уоршалла может быть модифицирован с целью получения матрицы, содержащей длины кратчайших путей между вершинами [1, с.441].
Идея этого алгоритма следующая [2,с.131]. Обозначим через d(m)ij длину кратчайшего из путей из vi в vj с промежуточными вершинами в множестве {v1, ..., vm}.
Тогда имеем следующие уравнения, объединенные в систему:
    d(0)ij = aij
    d(m)ij = min(d(m)ij, d(m)im + d(m)mj)
Обоснование второго уравнения достаточно простое. Рассмотрим кратчайший путь из vi в vj c промежуточными вершинами из множества {v1, ..., vm,vm+1}. Если этот путь не содержит vm+1, то деля путь на отрезки от vi до vm+1 и от vm+1 до vj, получаем равенство
    d(m+1)ij = d(m)im + d(m)mj).
Вышеприведенные уравнения дают возможность легко вычислить расстояния
    d(vi,vj) = d(n)ij, 1 <= i, j <= n.
Для машинной реализации алгоритма предположим, что A - матрица смежности графа. Заменим все нулевые элементы A на "бесконечность" или на некоторое "очень большое число", которое в данной матрице обозначим через B. Требуемая матрица длин минимальных путей формируется следующим алгоритмом, записанным на языке C++.

Программа. Вычисление матрицы минимальных длин путей.
#include <iostream.h>
#define MaxNodes 4
#define B 1000

class Warshall
{
  private:
    unsigned Adj[MaxNodes][MaxNodes]; //Матрица смежностей.
    unsigned C[MaxNodes][MaxNodes];   //Матрица достижимости.
  public:
    void Vvod();
    void MinDlin();
    void Vyvod();
};

void Warshall::Vvod()
//Ввод матрицы смежностей заданного графа и ее "исправление".
{
  //Ввод матрицы смежностей заданного графа.
  cout <<"Вводите элементы матрицы смежностей по строкам:\n";
  for (int i=0;i<MaxNodes;i++)
    for (int j=0;j<MaxNodes;j++)
     {
       cout <<"Введите Adj["<< (i+1) << "]["<< (j+1) << "]: ";
       cin >> Adj[i][j];
       if (Adj[i][j]==0) C[i][j] = B;
       else  C[i][j] = Adj[i][j];
     }
}

void Warshall::MinDlin()
//Вычисление матрицы минимальных длин путей.
{
  for (int k=0;k<MaxNodes;k++)
   for (int i=0;i<MaxNodes;i++)
    for (int j=0;j<MaxNodes;j++)
       if ( C[i][j]>C[i][k]+C[k][j] )
              C[i][j] = C[i][k]+C[k][j];
}

void Warshall::Vyvod()
//Вывод матрицы минимальных длин путей.
{
  cout << "Матрица минимальных длин путей:\n";
  for (int i=0;i<MaxNodes;i++)
  {
    for (int j=0;j<MaxNodes;j++)
      cout << C[i][j] << " ";
    cout << endl;
  }
}

void main()
{
  Warshall A;
  A.Vvod();
  A.MinDlin();
  A.Vyvod();
}
Текст этой программы можно взять здесь.
Очевидно, что сложность алгоритма есть O(n3). В монографии [2, с.132] отмечено, что "для общего случая (т.е. без предположения о неотрицательности весов или о бесконтурности графа) не известен ни один алгоритм нахождения расстояния между одной фиксированной парой вершин, который был бы значительно эффективнее алгоритма нахождения расстояний между всеми парами вершин."

Замечание. Авторами приведенного алгоритма являются Уоршалл и Флойд (Floyd R.W.).



(1) Трамбле Ж., Соренсон П. Введение в структуры данных. - М.: Машиностроение, 1982. - 784 с.
(2) Липский В. Комбинаторика для программистов: Пер. с польск. - М.: Мир, 1988. - 213 с.

На следующем шаге мы рассмотрим алгоритм отыскания компонент сильной связности.

        1.25. Применение алгоритма Уоршалла. Отыскание компонент сильной связности
На этом шаге мы рассмотрим еще одну область применимости алгоритма Уоршалла.
Рассмотрим матричный алгоритм отыскания компонент сильной связности (бикомпонент) ориентированного графа, следуя монографии [1, с.54-55].

Определение.
Ориентированный граф называется сильно связным, если для любой пары вершин каждая из них достижима из другой [1, с.11].
Сильно связный подграф ориентированного графа называется зоной.
Зона, максимальная относительно включения вершин, называется компонентой сильной связности (бикомпонентой).
Знание матрицы достижимости позволяет выявить все компоненты сильной связности в ориентированном графе.
Определим поэлементное (адамарово) произведение матриц B=(bij) и C=(cij) по правилу: B *C=(bij * cij).
Тогда вершины бикомпоненты ориентированного графа, содержащей вершину xi, определяются единичными элементами i-й строки матрицы R * RT, где RT - транспонированная матрица достижимости.
Отсюда следует, что, вычислив поэлементное произведение матриц R и RT и разбив все ненулевые строки этого произведения на группы одинаковых строк, мы можем определить множество вершин каждой бикомпоненты, поскольку номера строк однозначно определяют номера вершин, входящих в бикомпоненту.

Пример. Нахождение бикомпонент ориентированного графа.
#include <iostream.h>
#define MaxNodes 4

class Warshall
{
  private:
    unsigned Adj[MaxNodes][MaxNodes];  //Матрица смежностей.
    unsigned Path[MaxNodes][MaxNodes]; //Матрица достижимости.
    unsigned PathT[MaxNodes][MaxNodes];//Транспонированная матрица достижимости.
    unsigned Adam[MaxNodes][MaxNodes]; //Результат адамарова
                                       //произведения Path*PathT.
  public:
    void Vvod();
    void TransClose();
    void Vyvod_D();
    void Trans();
    void Adamar();
    void Vyvod_A();
};

void Warshall::Vvod()
{
  //Ввод матрицы смежностей заданного графа.
  cout <<"Вводите элементы матрицы смежностей по строкам:\n";
  for (int i=0;i<MaxNodes;i++)
    for (int j=0;j<MaxNodes;j++)
     {
       cout <<"Введите Adj["<< (i+1) << "]["<< (j+1) << "]: ";
       cin >> Adj[i][j];
     }
}

void Warshall::TransClose()
//Вычисление матрицы достижимости.
{
  //Инициализация матрицы Path матрицей смежностей Adj.
  for (int i=0;i<MaxNodes;i++)
    for (int j=0;j<MaxNodes;j++)
      Path[i][j] = Adj[i][j];
  //Нахождение следующих значений матрицы Path.
  for (int k=0;k<MaxNodes;k++)
    for (i=0;i<MaxNodes;i++)
      if (Path[i][k]==1)
         for (int j=0;j<MaxNodes;j++)
               Path[i][j] = (Path[i][j] || Path[k][j]);
}

void Warshall::Vyvod_D()
//Вывод матрицы достижимости.
{
  cout << "Матрица достижимости:\n";
  for (int i=0;i<MaxNodes;i++)
  {
    for (int j=0;j<MaxNodes;j++)
      cout << Path[i][j] << " ";
    cout << endl;
  }
}

void Warshall::Trans()
//Транспонирование матрицы Path и помещение результата в
//матрицу PathT.
{
  unsigned k,r;
  for (int i=0;i<MaxNodes;i++)
    for (int j=0;j<MaxNodes;j++)
    {
      k = Path[i][j]; r = Path[j][i];
      PathT[j][i] = k; PathT[i][j] = r;
    }
}

void Warshall::Adamar()
//Нахождение адамарова произведения PathхPathT.
{
  for (int i=0;i<MaxNodes;i++)
    for (int j=0;j<MaxNodes;j++)
        Adam[i][j] = Path[i][j]*PathT[i][j];
}

void Warshall::Vyvod_A()
//Вывод адамарова произведения.
{
  cout << "Адамарово произведение:\n";
  for (int i=0;i<MaxNodes;i++)
  {
    for (int j=0;j<MaxNodes;j++)
      cout << Adam[i][j] << " ";
    cout << endl;
  }
}

void main()
{
  Warshall A;
  A.Vvod();
  A.TransClose();
  A.Vyvod_D();
  A.Trans();
  A.Adamar();
  A.Vyvod_A();
}
Текст этой программы можно взять здесь.

Замечания.
    1. Приведенный простейший матричный алгоритм отыскания бикомпонент принадлежит, по-видимому, С.Рамамурти [1, с.119].
    2. [1, с.55]. Более эффективные алгоритмы отыскания бикомпонент основаны на обходе графа в глубину.



(1) Евстигнеев В.А. Применение теории графов в программировании. -М.: Hаука, 1985. - 352 с.

На следующем шаге мы рассмотрим вопросы, связанные с определением рекурсивности процедуры.

        1.26. Применение алгоритма Уоршалла. Определение рекурсивности подпрограммы
На этом шаге мы рассмотрим способ определения рекурсивности подпрограммы.
Сейчас мы покажем, как путевая матрица ориентированного графа может быть использована для решения вопроса о том, являются ли определенные процедуры в программе рекурсивными.
В некоторых языках программирования программист может задать рекурсивность процедуры в явной форме. В других языках для того, чтобы определить, какие из процедур являются рекурсивными, можно использовать идеи, вытекающие из теории графов.
Вначале необходимо заметить, что рекурсивная процедура необязательно вызывает себя непосредственно. Если процедура P1 вызывает P2, процедура P2 вызывает P3, ..., процедура Pn-1 вызывает Pn и процедура Pn вызывает P1, то процедура P1 является рекурсивной. Подобная форма рекурсии называется косвенной.
Пусть P={P1, P2, P3, ..., Pn} - набор процедур в программе. Построим ориентированный граф, состоящий из вершин, соответствующих элементам P. Ребро из Pi в Pj проведем в графе в том случае, когда процедура Pi вызывает процедуру Pj.
Например, пусть матрица смежностей, соответствующая вызовам, проводимым некоторым набором процедур, имеет вид:

Процедура Pi является рекурсивной, если в графе имеется цикл, содержащий Pi. Такие циклы могут быть обнаружены путем анализа диагональных элементов матрицы достижимости Q графа. Так, Pi является рекурсивной процедурой, если Qii=1. Матрица Q может быть построена с помощью программы 1 из шага 100. В приведенном выше примере она имеет вид:

откуда следует, что процедуры P1, P2 и P4 являются рекурсивными.

Замечание [1, с.132-133].
С задачей определения кратчайших путей в графе тесно связана задача транзитивного замыкания бинарного отношения.
Вспомним, что под бинарным отношением на множестве V мы понимаем множество E, являющееся подмножеством V*V.
Отношение является транзитивным, если удовлетворяется условие: если (x,y) принадлежит E и (y,z) принадлежит E, то (x,z) принадлежит E для произвольных x,y,z, принадлежащих E.
Для произвольного такого отношения мы определяем
   E* = {(x,y): в (V,E) существует путь ненулевой длины из x в y}.
Нетрудно заметить, что E* - транзитивное отношение на множестве V и E принадлежит E*. Более того, E*является наименьшим транзитивным отношением, содержащим E, т.е. для произвольного транзитивного отношения F, такого, что E принадлежит F выполняется включение E* принадлежит F.
Отношение E* называется транзитивным замыканием отношения E.
Отметим, что бинарное отношение E, принадлежащее V*V, можно однозначно представить ориентированным графом G=(V,E).
Ориентированный граф называется транзитивным, если из существования дуг (xi,xj) и (xj,xk) следует существование дуги (xi,xk).
Транзитивным замыканием графа G=(X,A) является граф Gtc=(X,AUA'), где A' является минимально возможным множеством дуг, необходимых для того, чтобы граф Gtc был транзитивным. Так как путь от xi к xj в графе Gдолжен соответствовать дуге (xi,xj) в Gtc, то совершенно очевидно, что матрица достижимости R графа G почти полностью совпадает с матрицей смежностей A графа Gtc - надо только в матрице A поставить на главной диагонали единицы.



(1) Липский В. Комбинаторика для программистов: Пер. с польск. - М.: Мир, 1988. - 213 с.

На следующем шаге мы рассмотрим контуры в ориентированных графах.

        1.27. Кратчайшие пути между всеми парами вершин. Контуры в ориентированных графах
На этом шаге мы рассмотрим отыскание контуров в ориентированных графах.
Одной из важнейших задач, связанных с контурами является задача нахождения множества всех контуров [1, с.105]. Трудность ее состоит прежде всего в том, что число контуров ориентированного графа может быть экспоненциально большим относительно числа вершин. Поэтому при разработке алгоритмов внимание обращается не на полную трудоемкость алгоритма, а на относительную, т.е. на трудоемкость, приходящуюся на один контур.

Алгоритм отыскания множества вершин, принадлежащих контуру заданной длины

Алгоритм использует матрицу смежности A(G) и матрицу Ak, если длина контура равна k. Выберем некоторое i, такое, что aii(k)=1. Это означает, что вершина vi принадлежит контуру длины k.
Тогда вершина vj принадлежит тому же контуру, если выполняются следующие три условия:
    • ajj(k)=1;
    • для любого n aij(n)=1, т.е. существует путь длины n из vi в vj;
    • aji(k-n)=1, т.е. существует путь длины k-n из vj в vi.
Таким образом, для каждой вершины i графа мы легко можем построить множество вершин, каждый элемент которого принадлежит некоторому контуру длины k.

Пример.
#include <iostream.h>
#define MaxNodes 4
#define Stepen 10

class Warshall
{
  private:
	 unsigned Adj[MaxNodes][MaxNodes];  //Матрица смежностей.
	  //Массив степеней матрицы смежностей.
	 unsigned AdjN[Stepen][MaxNodes][MaxNodes];
	 void Power(int);
  public:
	 void Vvod();
	 void Step();
	 void Kontur();
};

void Warshall::Vvod()
{
  //Ввод матрицы смежностей заданного графа.
  cout <<"Вводите элементы матрицы смежностей по строкам:\n";
  for (int i=0;i<MaxNodes;i++)
	 for (int j=0;j<MaxNodes;j++)
	  {
		 cout <<"Введите Adj["<< (i+1) << "]["<< (j+1) << "]: ";
		 cin >> Adj[i][j];
	  }
}

void Warshall::Step()
//Вычисление степеней матрицы смежностей.
{
  for (int l=0;l<Stepen;l++)
  {
    Power(l);
   }
}

void Warshall::Power(int n)
//Возвращает значение n-й степени матрицы A.
{
  unsigned Z[MaxNodes][MaxNodes];
  unsigned C[MaxNodes][MaxNodes];
  unsigned Val;

  for (int i=0;i<MaxNodes;i++)
	 for (int j=0;j<MaxNodes;j++) C[i][j]=Adj[i][j];

  for (int m=0;m<n-1;m++)
  {
	  for (int i=0;i<MaxNodes;i++)
		for (int j=0;j<MaxNodes;j++)
		{
			Val = 0;
			for (int k=0;k<MaxNodes;k++)
				Val = Val || (Adj[i][k] && C[k][j]);
			Z[i][j] = Val;
		}
	  for (i=0;i<MaxNodes;i++)
		for (int j=0;j<MaxNodes;j++) C[i][j]=Z[i][j];
  }

  for (i=0;i<MaxNodes;i++)
	for (int j=0;j<MaxNodes;j++)
			 AdjN [n][i][j] = C[i][j];

}

void Warshall::Kontur()
//Отыскание контуров заданной длины.
{
  unsigned n;

  cout << "Вводите длину контура: ";
  cin >> n;
  for (int m=1;m<n;m++)
  {
    for (int i=0;i<MaxNodes;i++)
	 if ( AdjN [m][i][i]==1 )
	 //Вершина i+1 принадлежит контуру длины n.
	 {
		cout << "Вершина " << (i+1) <<
		 " образует контуры длины " << (m+1) << " с вершинами
                                      из множества: {";
		for (int j=0;j<MaxNodes;j++)
		{
			if ( AdjN[m][j][j]==1 )
			//Вершина j принадлежит контуру длины m.
			  for (int l=0;l<m;l++)
				 if  ( AdjN[l][i][j]==1  && m-l>0
						 && AdjN[m-l][j][i]==1 )
				 {
					cout << (j+1) << ' ';
					goto Metka;
				  }
	Metka:;
		}
		cout << '}' << endl;
	 }
  cout << endl;
  }
}

void main()
{
  Warshall A;
  A.Vvod();
  A.Step();
  A.Kontur();
}
Текст этой программы можно взять здесь.


(1) Евстигнеев В.А. Применение теории графов в программировании. - М.: Hаука, 1985. - 352 с.

На следующем шаге мы начнем рассматривать вопросы связности графа.

        1.28. Связность. Вычисление компонент связности
На этом шаге мы изменим алгоритм обхода графа в ширину для вычисления конпонент связности.
С помощью изложенных в шагах 96 и 97 алгоритмов обхода графа можно ответить на некоторые вопросы относительно структуры графа. Мы рассмотрим здесь две задачи, связанные с обходом графа:
    • вычисление компонент связности графа и
    • построение остовного дерева связного графа.

Определение.
Рассмотрим некоторое семейство подграфов графа G.
Граф Hmax из этого семейства называется максимальным, если он не содержится ни в каком другом графе из рассматриваемого семейства.
Максимальный связный подграф графа G называется связной компонентой G (компонентой связности G). В связном графе имеется единственная связная компонента, совпадающая с самим графом.

Вычисление компонент связности

Отметим, что алгоритм обхода графа в глубину можно легко модифицировать так, чтобы он вычислял связные компоненты этого графа.

Пример 1. Иллюстрация использования обхода графа в глубину для нахождения всех его связных компонент. Граф представлен структурой Вирта.
#include <iostream.h>
#define TRUE 1
#define FALSE 0
typedef int Boolean;
typedef struct L *Lref; // Тип: указатель на заголовочный узел.
typedef struct T *Tref; // Тип: указатель на дуговой узел.

//Описание типа заголовочного узла.
typedef struct L
{
  int Key; //Имя заголовочного узла.
  int Count; //Количество предшественников.
  Boolean Flag; //Флаг посещения узла при обходе.
  Tref Trail; //Указатель на список смежности.
  Lref Next; //Указатель на следующий узел в списке заголовочных узлов.
} Leader;

//Описание типа дугового узла.
typedef struct T
{
  Lref Id;
  Tref Next;
} Trailer;

//Описание типа узла стека.
typedef Tref TipElement;
typedef struct Zveno *svqz;
typedef struct Zveno
{
  TipElement Element; //Указатель на список смежности.
  svqz Sled;
} St;

class Spisok
{
  private:
    Lref Head; //Указатель на голову списка заголовочных узлов.
    Lref Tail; //Указатель на фиктивный элемент
               // в конце списка заголовочных узлов.
    void SearchGraph (int, Lref *);
  public:
    Spisok() {//Инициализация списка заголовочных узлов.
              Head = Tail =  new (Leader); }
    Lref GetHead() { return Head; }
    Lref GetTail() { return Tail; }
    void MakeGraph ();
    void PrintGraph ();
    void Depth_First_Search (Lref);
    void LinkComp();
};

void main ()
{
  Spisok A;
  Lref t; //Рабочий указатель для перемещения
          // по списку заголовочных звеньев.
  //Построение графа и вывод его структуры Вирта.
  A.MakeGraph ();
  A.PrintGraph (); cout<<endl;
  //Рекурсивный обход графа в глубину.
  cout<<"Результат рекурсивного обхода...\n";
  t = A.GetHead();
  while (t!=A.GetTail())
    { (*t).Flag = TRUE; t = (*t).Next; }
  A.Depth_First_Search (A.GetHead()); cout<<endl;
  //Вывод компонент связности.
  cout<<"Компоненты связности:\n";
  A.LinkComp();
}

void Spisok::SearchGraph (int w, Lref *h)
//Функция возвращает указатель на заголовочный узел
//с ключом w в графе, заданном структурой Вирта с указателем Head.
{
  *h = Head; (*Tail).Key = w;
  while ((**h).Key!=w) *h = (**h).Next;
  if (*h==Tail)
  //В списке заголовочных узлов нет узла с ключом w.
  //Поместим его в конец списка Head.
  { Tail = new (Leader); (**h).Count = 0;
    (**h).Trail = NULL; (**h).Next = Tail; }
}

void Spisok::MakeGraph ()
//Функция возвращает указатель Head на структуру
//Вирта, соответствующую ориентированному графу.
{
  int x,y;
  Lref p,q; //Рабочие указатели.
  Tref t,r; //Рабочие указатели.
  Boolean Res; //Флаг наличия дуги.
  cout<<"Вводите начальную вершину дуги: ";
  cin>>x;
  while (x!=0)
  {
     cout<<"Вводите конечную вершину дуги: "; cin>>y;
     //Определим, существует ли в графе дуга (x,y)?
     SearchGraph (x, &p); SearchGraph (y,&q);
     r = (*p).Trail; Res = FALSE;
     while ((r!=NULL)&&(!Res))
       if ((*r).Id==q) Res = TRUE;
       else r = (*r).Next;
     if (!Res) //Если дуга отсутствует, то поместим её в граф.
      { t = new (Trailer); (*t).Id = q;
        (*t).Next = (*p).Trail; (*p).Trail = t; (*q).Count++; }
     cout<<"Вводите начальную вершину дуги: "; cin>>x;
  }
}

void Spisok::PrintGraph ()
//Вывод структуры Вирта, заданной указателем
//Head и соответствующей ориентированному графу.
{
  Lref p; //Рабочий указатель.
  Tref q; //Рабочий указатель.

  p = Head;
  while (p!=Tail)
  {
     cout<<"("<<(*p).Key; q = (*p).Trail;
     while (q!=NULL)
      { cout<<(*(*q).Id).Key; q = (*q).Next; }
     cout<<")"; p = (*p).Next; cout<<" ";
  }
}

void Spisok::Depth_First_Search (Lref r)
//Рекурсивный обход графа в глубину. r - указатель
//на структуру Вирта.
{
  Tref t;

  t = (*r).Trail; cout<<(*r).Key; (*r).Flag = FALSE;
  while (t!=NULL)
  { if ((*(*t).Id).Flag) Depth_First_Search ((*t).Id); t = (*t).Next; }
}

void Spisok::LinkComp()
//Определение компонент связности в графе, заданном
//структурой Вирта с указателем Head.
{
  Lref t = Head;
  while  (t !=Tail)
   { t->Flag = TRUE; t = t->Next; }
  t = Head;
  while ( t!=Tail )
  {
    if ( t->Flag )
    { Depth_First_Search (t); cout << endl; }
    t = t->Next;
  }
}
Текст этой программы можно взять здесь.
Результат работы приложения изображен на рисунке 1:

Рис.1. Результат работы приложения
Для вычисления компонент связности графа на языке LISP воспользуемся уже написанной ранее функциейDEPTHFIRST [1].
Рассмотрим еще раз работу функции DEFI. Заметим, что когда к списку просмотренных вершин VISITEDдобавляется новая вершина, список PATH представляет собой путь из этой вершины в начальную. Поэтому по окончанию работы в списке VISITED содержатся только те вершины, которые можно соединить с начальной. Можно показать [2], что в этом списке содержатся все вершины, обладающие этим свойством.
Таким образом, можно сказать, что функция DEPTHFIRST вычисляет список вершин связной компоненты вершины ROOT, и теперь мы готовы решить задачу о построении всех компонент связности данного графа.
Проще всего это сделать в два этапа.
1. Сначала построим списки вершин компонент связности.
Программа [3, с.129-130].
   (DEFUN CONNLISTS (LAMBDA (GRAPH)
   ; Построение списка списков вершин компонент связности
   ; GRAPH    - граф, представленный структурой смежности в
   ;            виде ассоциативного списка
      (CONNLSTS GRAPH NIL)
   ))
   ; -----------------------------------
   (DEFUN CONNLSTS (LAMBDA (GRAPH LISTS)
      (COND ( (NULL GRAPH) LISTS )
            ( T (COND ( (NULL (LMEMBER (CAAR GRAPH) LISTS))
                           (CONNLSTS
                               (CDR GRAPH)
                               (CONS (DEPTHFIRST GRAPH (CAAR GRAPH))
                                     LISTS)) )
                      (  T  (CONNLSTS (CDR GRAPH) LISTS) )) )
      )
   ))
   ; -----------------------------------
   (DEFUN LMEMBER (LAMBDA (VERTEX LISTS)
   ; Функция проверяет, содержится ли вершина VERTEX в
   ;    каком-либо из списков, составляющих LISTS
      (AND LISTS
           (OR (MEMBER  VERTEX (CAR LISTS))
               (LMEMBER VERTEX (CDR LISTS))))
   ))
   ; ------------------------------------
   (DEFUN DEPTHFIRST (LAMBDA (GRAPH ROOT)
   ; Обход графа в глубину:
   ; GRAPH - граф, представленный структурой смежности в
   ;         виде ассоциативного списка,
   ; ROOT  - вершина, с которой начинается обход графа,
   ; Результат: список вершин графа в порядке посещения в глубину
      (COND ( (NULL GRAPH) NIL )
            (  T  (DEFI GRAPH (LIST ROOT) (LIST ROOT)) ))
   ))
   ; --------------------------------------
   (DEFUN DEFI (LAMBDA (GRAPH VISITED PATH)
   ; GRAPH   - граф, представленный структурой смежности в
   ;           виде ассоциативного списка,
   ; VISITED - список уже посещенных вершин,
   ; PATH    - список вершин, определяющий путь посещения
      (COND ( (NULL PATH) (REVERSE VISITED) )
            ( T  (COND ( (NULL (EXPND GRAPH VISITED (CAR PATH)))
                            (DEFI GRAPH VISITED (CDR PATH)) )
                       (  T  (DEFI GRAPH
                                   (CONS (EXPND GRAPH VISITED (CAR PATH))
                                         VISITED)
                                   (CONS (EXPND GRAPH VISITED (CAR PATH))
                                         PATH)) )) )
      )
   ))
   ; -----------------------------------------
   (DEFUN EXPND (LAMBDA (GRAPH VISITED VERTEX)
   ; Выбор в графе GRAPH следующей еще не просмотренной
   ;        вершины, смежной с вершиной VERTEX
      (COND ( (NULL (NEIGHBOUR3 VERTEX GRAPH)) NIL )
            (  T  (FIRSTNOTVISITED VISITED (NEIGHBOUR3 VERTEX GRAPH)) )
      )
   ))
   ; --------------------------------------------
   (DEFUN FIRSTNOTVISITED (LAMBDA (VISITED VLIST)
   ; Поиск первой непосещенной вершины в списке VLIST
   ; VISITED - список уже посещенных вершин
      (COND ( (NULL VLIST) NIL )
            (  T  (COND ( (NULL (MEMBER (CAR VLIST) VISITED))
                             (CAR VLIST) )
                        (  T  (FIRSTNOTVISITED VISITED (CDR VLIST)) )) )
      )
   ))
   ; ---------------------------------
   (DEFUN NEIGHBOUR3 (LAMBDA (X GRAPH)
   ; Функция возвращает список вершин графа GRAPH, смежных с
   ;                 вершиной X
      (COND ( (NULL (ASSOC X GRAPH)) NIL )
            (  T  (CDR (ASSOC X GRAPH)) ))
   ))
Текст этой библиотеки можно взять здесь.
Тестовые примеры:
   $ (CONNLISTS '((1 . (2 3)) (2 . (3)) (5 . ())))
   ((5) (1 2 3))
   $ (CONNLISTS '((1 . (2 3)) (2 . (3)) (5 . ()) (6 . ())))
   ((6) (5) (1 2 3))
   $ (CONNLISTS '((1 . (2 3)) (2 . (3)) (5 . (6))))
   ((5 6) (1 2 3))
   $ (CONNLISTS '((1 . (2 3 5)) (2 . (3)) (5 . (6))))
   ((1 2 3 5 6))
2. Теперь не составляет труда написать функцию, возвращающую структуры смежности, соответствующие компонентам связности. Для этого мы воспользуемся следующими вспомогательными функциями:
   (DEFUN F2 (LAMBDA (GRAPH LST)
   ; Построение структур смежности всех компонент связности
   ; GRAPH - граф, представленный структурой смежности в
   ;         виде ассоциативного списка,
   ; LST   - список списков компонент связности
      (COND ( (NULL LST) NIL )
            (  T  (CONS (F1 GRAPH (CAR LST))
                        (F2 GRAPH (CDR LST))) ))
   ))
   ; ---------------------------
   (DEFUN F1 (LAMBDA (GRAPH LST)
      (COND ( (NULL GRAPH) NIL )
            ( (MEMBER (CAAR GRAPH) LST)
                 (CONS (CAR GRAPH) (F1 (CDR GRAPH) LST)) )
            (  T  (F1 (CDR GRAPH) LST) ))
   ))
Текст этой библиотеки можно взять здесь.
Тестовый пример:
   $ (F2 '((1 . (2 3)) (4 . (5 6)) (5 . (4)) (3 . (2 1)))
   '((1 2 3) (4 5 6)))
   (((1 2 3) (3 2 1)) ((4 5 6) (5 4)))


(1) Крюков А.П., Радионов А.Я., Таранов А.Ю., Шаблыгин Е.М. Программирование на языке R-Лисп. - М.: Радио и связь, 1991. - 192 с.
(2) Баррон Д. Рекурсивные методы в программировании. - М.: Мир, 1974. - 80 с.
(3) Turbo Pascal Version 3.0 Reference Manual. Borland International, 1985.

На следующем шаге мы рассмотрим нахождение компонент двусвязности.

        1.29. Связность. Нахождение компонент двусвязности
На этом шаге мы рассмотрим алгоритм нахождения компонент двусвязности.

Определение [1, с.101].
Вершину a неориентированного графа G=(V,E) будем называть точкой сочленения, если удаление этой вершины и всех инцидентных ей ребер ведет к увеличению числа компонент связности графа.
Неориентированный граф называется двусвязным, если он связный и не содержит точек сочленения.
Произвольный максимальный двусвязный подграф графа G называется компонентой двусвязности илиблоком этого графа.
Двусвязность графа - очень желательный признак для некоторых приложений. Представим себе, что вершины графа изображают узлы некоторой информационной сети, а ребра соответствуют линиям передачи. Если наш граф двусвязный, то выход из строя отдельного узла w никогда не приведет к потере соединения между любыми двумя узлами, отличными от w. Знание блоков графа также очень важно, если принять во внимание то, что многие графовые задачи, такие как нахождение всех элементарных циклов или установление факта планарности графа (граф называется планарным, если его можно так начертить на плоскости, чтобы никакие два ребра не пересекались), приводят естественным путем к аналогичным задачам для блоков данного графа.
Нахождение точек сочленения и блоков графа является классической задачей, которую можно эффективно решить "погружением" в процедуру обхода графа в глубину.

Пример.
#include <iostream.h>
#define TRUE 1
#define FALSE 0
typedef int Boolean;
typedef struct L *Lref; // Тип: указатель на заголовочный узел.
typedef struct T *Tref; // Тип: указатель на дуговой узел.

//Описание типа заголовочного узла.
typedef struct L
{
  int Key; //Имя заголовочного узла.
  int Count; //Количество предшественников.
  int WGN; //Характеристика узла.
  Tref Trail; //Указатель на список смежности.
  Lref Next; //Указатель на следующий узел в списке заголовочных узлов.
} Leader;

//Описание типа дугового узла.
typedef struct T
{
  Lref Id;
  Tref Next;
} Trailer;

//Описание типа узла стека.
typedef Lref TipElement;
typedef struct Zveno *svqz;
typedef struct Zveno
{
  TipElement Element1;
  TipElement Element2;
  svqz Sled;
} St;

int L[30]; //Количество  элементов  в  массиве L
           //совпадает с количеством вершин графа.
int num=0;

class Spisok
{
  private:
	 Lref Head; //Указатель на голову списка заголовочных узлов.
	 Lref Tail; //Указатель на фиктивный элемент
                    //в конце списка заголовочных узлов.
	 svqz Stack; //Указатель на рабочий стек.
	 void SearchGraph (int, Lref *);
	 void W_S (svqz *, TipElement, TipElement);
	 void UDALENIE (svqz *, TipElement *, TipElement *);
  public:
	 Spisok() {//Инициализация списка заголовочных узлов.
                   Head = Tail =  new (Leader); Stack = NULL;}
	 Lref GetHead() { return Head; }
	 Lref &GetHead1() { return Head; }
	 Lref GetTail() { return Tail; }
	 void MakeGraph ();
	 void PrintGraph ();
	 void TwoLink (Lref, Lref);
};

void main ()
{
  Spisok A;
  Lref SuperHead;//Заглавное звено списка заголовочных узлов.
  Lref t; //Рабочий указатель для перемещения
          //по списку заголовочных звеньев.

  //Построение графа и вывод его структуры Вирта.
  A.MakeGraph ();
  A.PrintGraph (); cout<<endl;
  //Нахождение компонент двусвязности графа.
  cout << "Множество ребер всех компонент двусвязности:\n";
  t = A.GetHead();
  while (t!=A.GetTail())
	{ (*t).WGN = 0; t = (*t).Next;}
  //Построение заглавного звена списка заголовочных звеньев.
  SuperHead = new (Leader);
  SuperHead->Key = 0; SuperHead->Next = A.GetHead();
  A.GetHead1() = SuperHead;
  t = A.GetHead()->Next;
  while (t!=A.GetTail())
  {
	 if ( t->WGN==0 ) A.TwoLink (t,A.GetHead());
	 t = t->Next;
  }
}

void Spisok::SearchGraph (int w, Lref *h)
//Функция возвращает указатель на заголовочный узел
//с ключом w в графе, заданном структурой Вирта с указателем Head.
{
  *h = Head; (*Tail).Key = w;
  while ((**h).Key!=w) *h = (**h).Next;
  if (*h==Tail)
  //В списке заголовочных узлов нет узла с ключом w.
  //Поместим его в конец списка Head.
  { Tail = new (Leader); (**h).Count = 0;
    (**h).Trail = NULL; (**h).Next = Tail; }
}

void Spisok::MakeGraph ()
//Функция возвращает указатель Head на структуру
//Вирта, соответствующую ориентированному графу.
{
  int x,y;
  Lref p,q; //Рабочие указатели.
  Tref t,r; //Рабочие указатели.
  Boolean Res; //Флаг наличия дуги.
  cout<<"Вводите начальную вершину дуги: ";
  cin>>x;
  while (x!=0)
  {
	  cout<<"Вводите конечную вершину дуги: "; cin>>y;
	  //Определим, существует ли в графе дуга (x,y)?
	  SearchGraph (x, &p); SearchGraph (y,&q);
	  r = (*p).Trail; Res = FALSE;
	  while ((r!=NULL)&&(!Res))
		 if ((*r).Id==q) Res = TRUE;
		 else r = (*r).Next;
	  if (!Res) //Если дуга отсутствует, то поместим её в граф.
		{ t = new (Trailer); (*t).Id = q;
		  (*t).Next = (*p).Trail; (*p).Trail = t; (*q).Count++; }
	  cout<<"Вводите начальную вершину дуги: "; cin>>x;
  }
}

void Spisok::PrintGraph ()
//Вывод структуры Вирта, заданной указателем
//Head и соответствующей ориентированному графу.
{
  Lref p; //Рабочий указатель.
  Tref q; //Рабочий указатель.

  p = Head;
  while (p!=Tail)
  {
	  cout<<"("<<(*p).Key; q = (*p).Trail;
	  while (q!=NULL)
		{ cout<<(*(*q).Id).Key; q = (*q).Next; }
	  cout<<")"; p = (*p).Next; cout<<" ";
  }
}

void Spisok::W_S (svqz *stk, TipElement el1, TipElement el2)
//Помещение el1 и el2 в стек stk.
{
  svqz q=new (St);
  (*q).Element1 = el1; (*q).Element2 = el2;
  (*q).Sled = *stk; *stk = q;
}

void Spisok::UDALENIE (svqz *stk, TipElement *klad1, TipElement *klad2)
//Удаление звена из стека, заданного указателем *stk.
//Значение информационного поля удаляемого звена сохраня-
//ется в параметрах klad1 и klad2.
{
  svqz q;

  if (*stk==NULL) cout<<"Попытка выбора из пустого стека!\n";
  else
	{ *klad1 = (**stk).Element1;
	  *klad2 = (**stk).Element2;
	  q = *stk; *stk = (**stk).Sled; delete q; }
}


void Spisok::TwoLink (Lref r, Lref p)
//Поиск в глубину, начиная с вершины r->Key и полагая,
//что p является указателем на отца вершины r->Key.
{
  Tref t;
  Lref e1,e2;

  num++; r->WGN = num; L[r->Key] = r->WGN;
  t = r->Trail;
  while ( t != NULL )
  {
    if ( t->Id->WGN==0 )
    {
      W_S (&Stack,r,t->Id);
      TwoLink (t->Id,r);
      if ( L[r->Key] > L[t->Id->Key] )
			L[r->Key] = L[t->Id->Key];
      if ( L[t->Id->Key] >= r->WGN )
      {
	//Выписать ребра компоненты двусвязности.
	do {
		  UDALENIE (&Stack,&e1,&e2);
		  cout << "(" << e1->Key << " " << e2->Key << ") ";
           }
	while (!((e1->Key==r->Key && e2->Key==t->Id->Key) ||
		(e1->Key==t->Id->Key && e2->Key==r->Key)));
	cout << ";\n";
      }	
    }
    else
      if  (t->Id->Key != p->Key &&  r->WGN > t->Id->WGN)
      {
          W_S (&Stack,r,t->Id);
	  if ( L[r->Key] > t->Id->WGN )
		 L[r->Key] = t->Id->WGN;
      }
      t = t->Next;
  }
}
Текст этой программы можно взять здесь.
Результат работы приложения изображен на рисунке 1:

Рис.1. Результат работы приложения

(1) Липский В. Комбинаторика для программистов: Пер. с польск. - М.: Мир, 1988. - 213 с.

Со следующего шага мы начнем знакомиться с остовами.

        1.30. Остовы. Построение остова
На этом шаге мы рассмотрим алгоритм построения остова.

Определение.
Для произвольного связного неориентированного графа G=(V,E) каждое дерево (V,T), где T - подмножество E, будем называть стягивающим деревом (остовом, остовным деревом) графа G. Ребра такого дерева будем называть ветвями, а все остальные ребра графа будем называть хордами.
Максимальный подграф без циклов произвольного графа G называется стягивающим лесом графа G.
Задачу нахождения стягивающих деревьев можно понимать как поиск экономных путей, обеспечивающих связь между точками заданного множества без ненужного дублирования. Поэтому она применима во многих областях, например, при исследовании электрических цепей или при анализе схем программ.


Построение остова

Процедуры обхода графа в глубину и в ширину можно простым способом использовать для нахождения остовов. В обоих случаях достижение новой вершины графа u из вершины v вызывает "включение" в остовное дерево ребра {u,v}.
Сравните две процедуры:
void Spisok::Depth_First_Search (Lref r)
//Рекурсивный обход графа в глубину. r - указатель
//на структуру Вирта.
{
  Tref t;

  t = (*r).Trail; cout<<(*r).Key; (*r).Flag = FALSE;
  while (t!=NULL)
  { if ((*(*t).Id).Flag) Depth_First_Search ((*t).Id); t = (*t).Next; }
}
void Spisok::Ostov_Depth (Lref r)
//Рекурсивный обход графа в глубину, соединенный с
//нахождением ребра остовного дерева.
//r - указатель на структуру Вирта.
{
  Tref t;
  Lref s;

  s = r;
  t = (*r).Trail; (*r).Flag = FALSE;
  while ( t != NULL )
  { if ((*(*t).Id).Flag)
    { cout << "(" << s->Key << "," << t->Id->Key << ") ";
      Ostov_Depth ((*t).Id);
    }
    t = (*t).Next;
  }
}
Для доказательства того, что функция Ostov_Depth корректно строит остов связного графа, достаточно отметить следующие три факта [1, с.95]:
1) в момент выдачи на экран новой ветви {s->Key,t->Id->Key} оператором
    cout << "(" << s->Key << "," << t->Id->Key << ") ";
в дереве уже существует путь из вершины Head->Key в s->Key, что легко доказывается по индукции. Таким образом, процедура строит связный граф;
2) каждая новая ветвь, добавляемая к множеству T (конечно, в процедуре множества нет: его роль играет экран дисплея!), соединяет уже рассмотренную вершину s->Key c новой вершиной t->Id->Key. Отсюда следует, что построенный граф не содержит циклов: действительно, последняя ветвь, "замыкающая" цикл, должна была бы соединить две уже рассмотренные вершины;
3) из свойства функции Depth_First_Search поиска в глубину следует, что функция Ostov_Depth просматривает все вершины связного графа.
Следовательно, граф (V,T), построенный процедурой Ostov_Depth, есть стягивающее дерево графа G.
Вычислительная сложность алгоритма есть, очевидно, O(n+m), т.е. того же порядка, что и поиск в глубину. Здесь: n - число вершин, а m - число ребер графа.
Приведем демонстрационный пример.

Пример 1. Нахождение стягивающего дерева связного графа, используя рекурсивный обход графа в глубину. Граф задан структурой Вирта.
#include <iostream.h>
#define TRUE 1
#define FALSE 0
typedef int Boolean;
typedef struct L *Lref; // Тип: указатель на заголовочный узел.
typedef struct T *Tref; // Тип: указатель на дуговой узел.

//Описание типа заголовочного узла.
typedef struct L
{
  int Key; //Имя заголовочного узла.
  int Count; //Количество предшественников.
  Boolean Flag; //Флаг посещения узла при обходе.
  Tref Trail; //Указатель на список смежности.
  Lref Next; //Указатель на следующий узел в списке заголовочных узлов.
} Leader;

//Описание типа дугового узла.
typedef struct T
{
  Lref Id;
  Tref Next;
} Trailer;

//Описание типа узла стека.
typedef Tref TipElement;
typedef struct Zveno *svqz;
typedef struct Zveno
{
  TipElement Element; //Указатель на список смежности.
  svqz Sled;
} St;

class Spisok
{
  private:
    Lref Head; //Указатель на голову списка заголовочных узлов.
    Lref Tail; //Указатель на фиктивный элемент
               // в конце списка заголовочных узлов.
    void SearchGraph (int, Lref *);
  public:
    Spisok() {//Инициализация списка заголовочных узлов.
              Head = Tail =  new (Leader); }
    Lref GetHead() { return Head; }
    Lref GetTail() { return Tail; }
    void MakeGraph ();
    void Ostov_Depth (Lref);
    void PrintGraph ();
};

void main ()
{
  Spisok A;
  Lref t; //Рабочий указатель для перемещения
          // по списку заголовочных звеньев.
  //Построение графа и вывод его структуры Вирта.
  A.MakeGraph ();
  A.PrintGraph (); cout<<endl;
  //Построение стягивающего дерева (остова).
  cout<<"Остов: ";
  t = A.GetHead();
  while (t!=A.GetTail())
    { (*t).Flag = TRUE; t = (*t).Next; }
  A.Ostov_Depth (A.GetHead()); cout<<endl;
}

void Spisok::SearchGraph (int w, Lref *h)
//Функция возвращает указатель на заголовочный узел
//с ключом w в графе, заданном структурой Вирта с указателем Head.
{
  *h = Head; (*Tail).Key = w;
  while ((**h).Key!=w) *h = (**h).Next;
  if (*h==Tail)
  //В списке заголовочных узлов нет узла с ключом w.
  //Поместим его в конец списка Head.
  { Tail = new (Leader); (**h).Count = 0;
    (**h).Trail = NULL; (**h).Next = Tail; }
}

void Spisok::MakeGraph ()
//Функция возвращает указатель Head на структуру
//Вирта, соответствующую ориентированному графу.
{
  int x,y;
  Lref p,q; //Рабочие указатели.
  Tref t,r; //Рабочие указатели.
  Boolean Res; //Флаг наличия дуги.
  cout<<"Вводите начальную вершину дуги: ";
  cin>>x;
  while (x!=0)
  {
     cout<<"Вводите конечную вершину дуги: "; cin>>y;
     //Определим, существует ли в графе дуга (x,y)?
     SearchGraph (x, &p); SearchGraph (y,&q);
     r = (*p).Trail; Res = FALSE;
     while (( r != NULL )&&(!Res))
       if ((*r).Id==q) Res = TRUE;
       else r = (*r).Next;
     if (!Res) //Если дуга отсутствует, то поместим её в граф.
      { t = new (Trailer); (*t).Id = q;
        (*t).Next = (*p).Trail; (*p).Trail = t; (*q).Count++; }
     cout<<"Вводите начальную вершину дуги: "; cin>>x;
  }
}

void Spisok::PrintGraph ()
//Вывод структуры Вирта, заданной указателем
//Head и соответствующей ориентированному графу.
{
  Lref p; //Рабочий указатель.
  Tref q; //Рабочий указатель.

  p = Head;
  while (p!=Tail)
  {
     cout<<"("<<(*p).Key; q = (*p).Trail;
     while (q!=NULL)
      { cout<<(*(*q).Id).Key; q = (*q).Next; }
     cout<<")"; p = (*p).Next; cout<<" ";
  }
}

void Spisok::Ostov_Depth (Lref r)
//Рекурсивный обход графа в глубину, соединенный с
//нахождением ребра остовного дерева.
//r - указатель на структуру Вирта.
{
  Tref t;
  Lref s;

  s = r;
  t = (*r).Trail; (*r).Flag = FALSE;
  while ( t != NULL )
  { if ((*(*t).Id).Flag)
    { cout << "(" << s->Key << "," << t->Id->Key << ") ";
      Ostov_Depth ((*t).Id);
    }
    t = (*t).Next;
  }
}
Текст этой программы можно взять здесь.
Результат работы приложения изображен на рисунке 1:

Рис.1. Результат работы приложения
Ясно, что далеко не всякий ориентированный граф имеет остов. Например, граф, заданный следующим списком дуг: (1,2), (1,6), (1,7), (6,7), (7,2), (5,7), (2,5), (3,2), (3,5) остова не имеет.
Подобным же способом можно построить остов, используя обход графа в ширину. В функции Ostov_Breadthиспользуются две очереди.
Пример 2. Нахождение стягивающего дерева связного графа с использованием нерекурсивного обхода графа в ширину. Граф задан структурой Вирта.
#include <iostream.h>
#define TRUE 1
#define FALSE 0
typedef int Boolean;
typedef struct Leader *Lref; // Тип: указатель на заголовочный узел.
typedef struct Trailer *Tref; // Тип: указатель на дуговой узел.

//Описание типа заголовочного узла.
typedef struct Leader
{
  int Key; //Имя заголовочного узла.
  int Count; //Количество предшественников.
  Boolean Flag; //Флаг посещения узла при обходе.
  Tref Trail; //Указатель на список смежности.
  Lref Next; //Указатель на следующий узел в списке заголовочных узлов.
};

//Описание типа дугового узла.
typedef struct Trailer
{
  Lref Id;
  Tref Next;
};

//Описание типа узла очереди.
typedef Tref TipElement; //Указатель на звено заголовочного списка.
typedef struct Zveno *svqz;
typedef struct Zveno
{
  TipElement Element; //Указатель на список смежности.
  svqz Sled;
};

//Описание типа узла очереди указателей на
//узлы списков смежности.
typedef Lref TipElement1;
typedef struct Zveno1 *svqz1;
typedef struct Zveno1
{
  TipElement1 Element; //Указатель на заголовочный узел.
  svqz1 Sled;
};

class Spisok
{
  private:
     Lref Head; //Указатель на голову списка заголовочных узлов.
     Lref Tail; //Указатель на фиктивный элемент
                // в конце списка заголовочных узлов.
     void Udalenie_A (svqz *, svqz *, TipElement *);
     void Udalenie_A1 (svqz1 *, svqz1 *, Lref *);
     void Dobavlenie (svqz *, svqz *, TipElement);
     void Dobavlenie1 (svqz1 *, svqz1 *, Lref);
     void SearchGraph (int, Lref *);
  public:
     Spisok() {//Инициализация списка заголовочных узлов.
                Head = Tail =  new (Leader); }
     Lref GetHead() { return Head; }
     Lref GetTail() { return Tail; }
     void MakeGraph ();
     void PrintGraph ();
     void Ostov_Breadth ();
};

void main ()
{
  Spisok A;
  Lref t; //Рабочий указатель для перемещения
          //по списку заголовочных звеньев.

  //Построение графа и вывод его структуры Вирта.
  A.MakeGraph ();
  A.PrintGraph (); cout<<endl;
  //Построение стягивающего дерева (остова).
  cout<<"Остов: ";
  t = A.GetHead();
  while (t!=A.GetTail())
	 { (*t).Flag = TRUE; t = (*t).Next; }
  A.Ostov_Breadth (); cout<<endl;
}

void Spisok::SearchGraph (int w, Lref *h)
//Функция возвращает указатель на заголовочный узел
//с ключом w в графе, заданном структурой Вирта с указателем Head.
{
  *h = Head; (*Tail).Key = w;
  while ((**h).Key!=w) *h = (**h).Next;
  if (*h==Tail)
  //В списке заголовочных узлов нет узла с ключом w.
  //Поместим его в конец списка Head.
  { Tail = new (Leader); (**h).Count = 0;
	 (**h).Trail = NULL; (**h).Next = Tail; }
}

void Spisok::MakeGraph ()
//Функция возвращает указатель Head на структуру
//Вирта, соответствующую ориентированному графу.
{
  int x,y;
  Lref p,q; //Рабочие указатели.
  Tref t,r; //Рабочие указатели.
  Boolean Res; //Флаг наличия дуги.
  cout<<"Вводите начальную вершину дуги: ";
  cin>>x;
  while (x!=0)
  {
	  cout<<"Вводите конечную вершину дуги: "; cin>>y;
	  //Определим, существует ли в графе дуга (x,y)?
	  SearchGraph (x, &p); SearchGraph (y,&q);
	  r = (*p).Trail; Res = FALSE;
	  while ((r!=NULL)&&(!Res))
		 if ((*r).Id==q) Res = TRUE;
		 else r = (*r).Next;
	  if (!Res) //Если дуга отсутствует, то поместим её в граф.
		{ t = new (Trailer); (*t).Id = q;
		  (*t).Next = (*p).Trail; (*p).Trail = t; (*q).Count++; }
	  cout<<"Вводите начальную вершину дуги: "; cin>>x;
  }
}

void Spisok::PrintGraph ()
//Вывод структуры Вирта, заданной указателем
//Head и соответствующей ориентированному графу.
{
  Lref p; //Рабочий указатель.
  Tref q; //Рабочий указатель.

  p = Head;
  while (p!=Tail)
  {
	  cout<<(*p).Key<<"("; q = (*p).Trail;
	  while (q!=NULL)
		{ cout<<(*(*q).Id).Key; q = (*q).Next; }
	  cout<<")"; p = (*p).Next; cout<<" ";
  }
}

void Spisok::Dobavlenie (svqz *L, svqz *R, TipElement elem)
//Добавление элемента elem в очередь, заданную указателями L и R.
{
  svqz K = new (Zveno);

  K->Element = elem; K->Sled = NULL;
  if (*L==NULL)
	 { (*L) = K; (*R) = K; }
  else { (*R)->Sled = K; (*R) = K; }
}

void Spisok::Dobavlenie1 (svqz1 *L, svqz1 *R, Lref elem)
//Добавление элемента elem в очередь, заданную указателями L и R.
{
  svqz1 K = new (Zveno1);

  K->Element = elem; K->Sled = NULL;
  if (*L==NULL)
	 { (*L) = K; (*R) = K; }
  else { (*R)->Sled = K; (*R) = K; }
}

void Spisok::Udalenie_A (svqz *L, svqz *R, TipElement *A)
//Удаление элемента из очереди, заданной указателями L и R и
//помещение удаленного элемента в переменную A.
{
  svqz q;

  if ((*L)!=NULL)
   if ((*L)->Sled!=NULL)
   {
     (*A) = (*L)->Element; q = (*L);
     (*L) = (*L)->Sled; delete q;
   }
   else {
         (*A) = (*L)->Element; delete *L;
         (*L) = (*R) = NULL;
        }
}

void Spisok::Udalenie_A1 (svqz1 *L, svqz1 *R, Lref *A)
//Удаление элемента из очереди, заданной указателями L и R и
//помещение удаленного элемента в переменную A.
{
  svqz1 q;

  if ((*L)!=NULL)
   if ((*L)->Sled!=NULL)
   {
     (*A) = (*L)->Element; q = (*L);
     (*L) = (*L)->Sled; delete q;
   }
   else {
         (*A) = (*L)->Element; delete *L;
         (*L) = (*R) = NULL;
        }
}

void Spisok::Ostov_Breadth ()
//Обход графа, заданного указателем r в ширину (нерекурсивный
//обход), соединенный с построением стягивающего дерева.
{
  svqz L;    //Указатель на начало очереди.
  svqz R;    //Указатель на конец  очереди.
  svqz1 L1;  //Указатель на начало очереди заглавных узлов.
  svqz1 R1;  //Указатель на конец  очереди заглавных узлов.
  Tref s;    //Рабочий указатель.
  Tref t;    //Рабочий указатель.
  Tref Tail1;//Указатель на фиктивный элемент в очереди L,R;
  Lref v;    //Рабочий указатель.

  Tail1 = new (Trailer); //Построили фиктивный элемент.
  //Создали пустые очеpеди.
  L = R = NULL;
  L1 = R1 = NULL;
  //Посетим первую непосещенную вершину графа.
  Head->Flag = FALSE;
  t = Head->Trail;
  while ( t != NULL )
   {  Dobavlenie (&L,&R,t); t = t->Next; }
  Dobavlenie (&L,&R,Tail1);
  v = Head;
  while ( L!=NULL )
	//Пока очередь не пуста...
	{
	  Udalenie_A (&L,&R,&t);
          if ( t != Tail1 )
          {
             if (t->Id->Flag)
             {
               cout << "(" << v->Key << "," << t->Id->Key << ") ";
               t->Id->Flag = FALSE;
             }
             s = t->Id->Trail;
             Dobavlenie1 (&L1,&R1,t->Id);
             while  (s != NULL )
             {
               if (s->Id->Flag)
               {
                 Dobavlenie (&L,&R,s);
                 t->Id->Flag = FALSE;
               }
               s = s->Next;
             }
             Dobavlenie (&L,&R,Tail1);
          }
          else  Udalenie_A1 (&L1,&R1,&v);
        }
}
Текст этой программы можно взять здесь.
Результат работы приложения изображен на рисунке 2:

Рис.2. Результат работы приложения

Замечание. Приведенные программы легко модифицируются для произвольных графов, не обязательно связных.

Обратимся теперь к реализации алгоритма построения остовного дерева связного графа на языке LISP. Для этого вспомним, что при поиске в глубину новая вершина добавляется к списку уже пройденных вершин только в том случае, когда она в этом списке отсутствует. Поэтому последовательность вершин, соответствующая удлинению списка PATH при работе функции DEFI, представляет собой простой0(т.е. без самопересечений) путьв просматриваемом графе.
После этих замечаний можно написать функцию, значением которой является список ребер, представляющий остовное дерево графа:

Программа 1 [2, с.130-131].
   (DEFUN SPANDF (LAMBDA (GRAPH ROOT)
   ; Построение остовного дерева графа GRAPH с корнем ROOT:
   ; GRAPH   - граф, представленный структурой смежности в
   ;           виде ассоциативного списка,
   ; ROOT    - корень остовного дерева,
   ; Результат: список ребер остовного дерева, полученного
   ;            с помощью поиска в глубину
      (COND ( (NULL GRAPH) NIL )
            (  T  (SPDF GRAPH (LIST ROOT) (LIST ROOT)) )
      )
   ))
   ; --------------------------------------
   (DEFUN SPDF (LAMBDA (GRAPH VISITED PATH)
   ; GRAPH   - граф, представленный структурой смежности в
   ;           виде ассоциативного списка,
   ; VISITED - список уже посещенных вершин,
   ; PATH    - список вершин, определяющий путь посещения
      (COND ( (NULL PATH) NIL )
            (  T  (COND ( (NULL (EXPND GRAPH VISITED (CAR PATH)))
                             (SPDF GRAPH VISITED (CDR PATH)) )
                        (  T  (CONS
                                  (CONS (CAR PATH)
                                        (EXPND GRAPH VISITED
                                               (CAR PATH)))
                                  (SPDF
                                      GRAPH
                                      (CONS (EXPND GRAPH
                                                   VISITED
                                                   (CAR PATH))
                                            VISITED)
                                      (CONS (EXPND GRAPH
                                                   VISITED
                                                   (CAR PATH))
                                            PATH))) )) )
      )
   ))
   ; -----------------------------------------
   (DEFUN EXPND (LAMBDA (GRAPH VISITED VERTEX)
   ; Выбор в графе GRAPH следующей еще не просмотренной
   ;        вершины, смежной с вершиной VERTEX
      (COND ( (NULL (NEIGHBOUR3 VERTEX GRAPH)) NIL )
            (  T  (FIRSTNOTVISITED
                                VISITED
                                (NEIGHBOUR3 VERTEX GRAPH)) ))
   ))
   ; --------------------------------------------
   (DEFUN FIRSTNOTVISITED (LAMBDA (VISITED VLIST)
   ; Поиск первой непосещенной вершины в списке VLIST
   ; VISITED - список уже посещенных вершин
      (COND ( (NULL VLIST) NIL )
            (  T  (COND ( (NULL (MEMBER (CAR VLIST) VISITED))
                             (CAR VLIST) )
                        (  T  (FIRSTNOTVISITED
                                            VISITED
                                            (CDR VLIST)) )) ))
   ))
   ; ---------------------------------
   (DEFUN NEIGHBOUR3 (LAMBDA (X GRAPH)
   ; Функция возвращает список вершин графа GRAPH, смежных с
   ;                 вершиной X
      (COND ( (NULL (ASSOC X GRAPH)) NIL )
            (  T  (CDR (ASSOC X GRAPH)) ))
   ))
Текст этой библиотеки можно взять здесь.
Тестовые примеры:
   1) $ (SPANDF '((1 . (2 3)) (2 . (4 5)) (3 . (6 7))) 1)
      ((1 . 2) (2 . 4) (2 . 5) (1 . 3) (3 . 6) (3 . 7))
   2) $ (SETQ A1 '((1 .  (2 4)) (2 .  (1 3 5)) (3 . (2 4 6))
                   (4 . (1 3 6 7)) (5 . (2 6 8 9)))
      ((1 2 4) (2 1 3 5) (3 2 4 6) (4 1 3 6 7) (5 2 6 8 9))
      $ (SETQ A2 '((6 . (3 4 5 7 9)) (7 . (4 6)) (8 . (5)) (9 . (5 6)))
      ((6 3 4 5 7 9) (7 4 6) (8 5) (9 5 6))
      $ (SPANDF (APPEND A1 A2) 1)
      ((1 . 2) (2 . 3) (3 . 4) (4 . 6) (6 . 5) (5 . 8) (5 . 9) (6 . 7))

Теперь мы зададимся вопросом, какими свойствами будет обладать остовное дерево, построенное с помощью процедуры обхода графа в ширину? Мы уже упоминали о том, что при обходе в ширину просмотренные вершины располагаются в порядке неубывания их расстояния от начальной вершины. Поэтому в остовном дереве, построенном с помощью обхода в ширину, единственный путь, соединяющий какую-либо вершину с начальной, совпадает с кратчайшим путем в исходном графе между этими двумя вершинами.
Необходимые для построения остовного дерева с помощью обхода в ширину изменения в функции BRFI более существенны по сравнению с аналогичными изменениями в функции DEFI. Дело в том, что при поиске в ширину нам не нужна была информация о предшественнике рассматриваемой вершины - в этом смысле поиск в ширину нелокален. Поэтому вместо очереди вершин, предназначенных для просмотра, мы введем очередь, состоящую непосредственно из элементов структуры смежности.

Программа 2 [3, с.132-133].
   (DEFUN SPANBF (LAMBDA (GRAPH ROOT)
   ; Построение остовного дерева графа GRAPH с корнем
   ; в вершине ROOT при помощи обхода графа в ширину:
   ; GRAPH   - граф, представленный структурой смежности в
   ;           виде ассоциативного списка,
   ; ROOT  - корень остовного дерева
      (SPBF GRAPH (LIST ROOT) (CDR (ASSOC ROOT GRAPH))
            NIL (CAR (ASSOC ROOT GRAPH)))
   ))
   ; ---------------------------------------------------
   (DEFUN SPBF (LAMBDA (GRAPH VISITED HEAD QUEUE FATHER)
   ; GRAPH   - граф, представленный структурой смежности в
   ;           виде ассоциативного списка,
   ; VISITED - список уже посещенных вершин,
   ; HEAD    - список вершин для просмотра,
   ; QUEUE   - очередь списка вершин для просмотра,
   ; FATHER  - предок просматриваемых вершин
      (COND ( (NULL HEAD)
                 (COND ( (NULL QUEUE) NIL )
                       (  T  (SPBF GRAPH VISITED
                                   (CDAR QUEUE) (CDR QUEUE)
                                   (CAAR QUEUE)) )) )
            ( T  (COND ( (MEMBER (CAR HEAD) VISITED)
                            (SPBF GRAPH VISITED (CDR HEAD) QUEUE
                                  FATHER) )
                       (  T  (CONS
                                 (CONS FATHER (CAR HEAD))
                                 (SPBF
                                    GRAPH
                                    (CONS (CAR HEAD) VISITED)
                                    (CDR HEAD)
                                    (APPEND QUEUE
                                            (LIST (ASSOC (CAR HEAD)
                                                  GRAPH)))
                                    FATHER)) )) )
      )
   ))
Текст этой библиотеки можно взять здесь.
Тестовые примеры:
   1) $ (SPANBF '((1 . (2 4)) (2 . (1 3)) (4 . (1 3)) (3 . (1 4))) 1)
      ((1 . 2) (1 . 4) (2 . 3))
      $ (SPANBF '((1 . (2 4)) (2 . (1 3)) (4 . (1 3)) (3 . (1 4))) 2)
      ((2 . 1) (2 . 3) (1 . 4))
      $ (SPANBF '((1 . (2 4)) (2 . (1 3)) (4 . (1 3)) (3 . (1 4))) 3)
      ((3 . 1) (3 . 4) (1 . 2))
      $ (SPANBF '((1 . (2 4)) (2 . (1 3)) (4 . (1 3)) (3 . (1 4))) 4)
      ((4 . 1) (4 . 3) (1 . 2))
   2) $ (SPANBF '((1 . (2 3)) (2 . (4 5)) (3 . (6 7))) 1)
      ((1 . 2) (1 . 3) (2 . 4) (2 . 5) (3 . 6) (3 . 7))
   3) $ (SETQ A1 '((1 .  (2 4)) (2 .  (1 3 5)) (3 . (2 4 6))
                   (4 . (1 3 6 7)) (5 . (2 6 8 9)))
      ((1 2 4) (2 1 3 5) (3 2 4 6) (4 1 3 6 7) (5 2 6 8 9))
      $ (SETQ A2 '((6 . (3 4 5 7 9)) (7 . (4 6)) (8 . (5)) (9 . (5 6)))
      ((6 3 4 5 7 9) (7 4 6) (8 5) (9 5 6))
      $ (SPANBF (APPEND A1 A2) 1)
      ((1 . 2) (1 . 4) (2 . 3) (2 . 5) (4 . 6) (4 . 7) (5 . 8) (5 . 9))

Обратите внимание, что при работе функции SPBF параметр HEAD всегда есть список соседей вершины, определяемой параметром FATHER, что позволяет знать предшественника текущей вершины.


(1) Липский В. Комбинаторика для программистов. - М.: Мир, 1988. - 213 с.
(2) Turbo Pascal Version 3.0 Reference Manual. Borland International, 1985.
(3) Крюков А.П., Радионов А.Я., Таранов А.Ю., Шаблыгин Е.М. Программирование на языке R-Лисп. - М.: Радио и связь, 1991. - 192 с.

На следующем шаге мы рассмотрим алгоритм построения остова наименьшей стоимости.

        1.31. Остовы. Построение остова наименьшей стоимости
На этом шаге мы рассмотрим алгоритм построения остова наименьшей стоимости.
Пусть G=(V,E) - связный неориентированный граф, для которого задана функция стоимости, отображающая ребра в вещественные (целые) числа. Напомним, что остовным деревом для данного графа называется неориентированное дерево, содержащее все вершины графа. Стоимость остовного дерева определяется как сумма стоимостей его ребер.
Наша цель - найти для G остовное дерево наименьшей стоимости.
Эта задача возникает при проектировании линий электропередачи, трубопроводов, дорог и т.п., когда требуется заданные центры соединить некоторой системой каналов связи так, чтобы любые два центра были связаны либо непосредственно соединяющим их каналом, либо через другие центры и каналы, и чтобы общая длина (или, например, стоимость) каналов связи была минимальной. В этой ситуации заданные центры можно считать вершинами графа с весами ребер, равными длинам (стоимости) соединяющих эти центры каналов. Тогда искомая сеть будет остовным деревом наименьшей длины (стоимости). Поскольку граф с n вершинами содержит nn-2 различных остовных дерева, то решение этой задачи "слепым" перебором" вариантов потребовало бы чрезвычайно больших вычислений даже при относительно малых n. Однако для ее решения имеются эффективные алгоритмы.
Первый алгоритм нахождения такого дерева - алгоритм Дж.Краскала, опубликованный в 1956 г. Развитием этого алгоритма является алгоритм Р.Прима (1957 г.) (см. Прим Р.К. Кратчайшие связывающие сети и их обощения. - Киберн.сб., вып.2 (ст.серия), 1961, с.95-107).
Приведем теорему, позволяющую получить алгоритм Краскала.
Теорема [1, с.69].
Пусть G - связный граф с n вершинами, и пусть каждому его ребру приписано неотрицательное действительное число m(e), называемое его мерой.
Тогда следующая процедура приводит к решению задачи о минимальном остовном графе:
    • выберем ребро e1, обладающее в G наименьшей мерой;
    • определим по индукции последовательность ребер e2,e3, ...,en-1, выбирая на каждом шаге ребро (отличное от предыдущих) с наименьшей мерой, обладающее тем свойством, что оно не образует циклов с предыдущими ребрами ei. Полученный подграф T графа G, ребрами которого являются e2,e3, ...,en-1 и есть требуемое остовное дерево.
Алгоритм Краскала [2, с.199] работает с набором VS непересекающихся множеств узлов. Каждое множество W из VS представляет связное множество узлов, образующее остовное дерево в остовном лесу, представленном набором VS.
Ребра выбираются из E в порядке возрастания стоимости. Ребра (v,w) рассматриваются по очереди. Если v и wпринадлежат одному и тому же множеству из VS, то ребро (v,w) исключается из рассмотрения. Если v и wпринадлежат разным множествам W1 и W2 (это означает, что W1 и W2 еще не соединены), то сливаем их в одно множество и добавляем (v,w) к множеству ребер, входящих в окончательное остовное дерево.
В [2, с.199] приведено описание алгоритма Краскала на псевдокоде:
      T <- пустое множкство;
      VS <- пустое множество;
      Построить очередь с приоритетами Q, содержащую все ребра из E;
      for (v принадлежащего V)  Добавить {v} к VS
      while |VS|>1
         {
            Выбрать в Q ребро (v,w) наименьшей стоимости;
            Удалить (v,w) из Q;
            if  v и w принадлежат различным множествам W1 и W2 из VS
            {
                        Заменить W1 и W2 на объединение W1 и W2 в VS;
                        Добавить (v,w) к T;
             }
         }
Реализуем алгоритм на языке C++. Для хранения ребер и их стоимостей воспользуемся бинарным деревом поиска, описание которого имеет вид:
typedef unsigned int SubInt;
typedef struct Uzel *Ref;

typedef struct Uzel
{
  SubInt X; //Начало дуги.
  SubInt Y; //Конец дуги
  int Pay;  //Стоимость дуги.
  Ref Left; //Указатель на левого сына.
  Ref Right;//Указатель на правого сына.
};
Ясно, что в "самой левой" вершине дерева будет храниться дуга, обладающая наименьшей стоимостью, и поиск этой вершины может выглядеть, например, так:
   UkUzel = Root;  //Установили текущий указатель на корень дерева.
   while  (UkUzel->Left != NULL)
      UkUzel = UkUzel->Left;
   T1 = UkUzel->X; T2 = UkUzel->Y;  //Получили ребро!
Множество VS будем хранить в линейном однонаправленном списке с заглавным звеном, описание которого выглядит так:
typedef struct zveno *svqz;
typedef struct zveno
{
  unsigned int Element[256]; // Множество из VS.
  svqz Sled; // Указатель на узел.
  zveno(); // Конструктор.
};

zveno::zveno()
//Обнуление элементов.
{
  for(int k=0;k<256;Element[k++]=0);
}
Тогда, например, фрагмент алгоритма:
    if  v и w принадлежат различным множествам W1 и W2 из VS
    {
                Заменить W1 и W2 на объединение W1 и W2 в VS;
                Добавить (v,w) к T;
     }
запишется на языке С++ так:
 Res1 = Res2 = NULL;
 Poisk (UkStr,T1,&Res1);
 Poisk (UkStr,T2,&Res2);
 if ( Res1!=Res2 )
 {
   for (int k=0;k<256;k++)
     if ( Res1->Element[k]==1 || Res2->Element[k]==1 ) Res1->Element[k]=1;
   Udalenie (&Res2,UkStr);
   cout << "(" << T1 << " " << T2 << ")  ";
 }

Пример. Построение остовного дерева наименьшей стоимости (алгоритм Краскала).
#include <iostream.h>
#define TRUE 1
#define FALSE 0
typedef int Boolean;
typedef unsigned int SubInt;
typedef struct Uzel *Ref;

typedef struct Uzel
{
  SubInt X; //Начало дуги.
  SubInt Y; //Конец дуги
  int Pay;  //Стоимость дуги.
  Ref Left; //Указатель на левого сына.
  Ref Right;//Указатель на правого сына.
};

typedef struct zveno *svqz;
typedef struct zveno
{
  unsigned int Element[256];
  svqz Sled;
  zveno();
};

zveno::zveno()
{
  for(int k=0;k<256;Element[k++]=0);
}

class Spisok
{
  private:
	 Ref Root;
	 void Search (int, int, int, Ref *);
	 void Poisk (svqz, SubInt, svqz *);
	 void Postroenie (svqz *);
	 void Udalenie (svqz *, svqz);
  public:
	 Spisok() { Root = NULL;} //Вначале дерево пусто.
	 void Reshenie();
	 void Postr();
};

void Spisok::Search (int A, int B, int C, Ref *p)
//Добавление вершины, содержащей поля A,B,C, в дерево *p.
{
  if ( (*p) == NULL )
  {
	  (*p) = new (Uzel); (**p).X = A; (**p).Y = B; (**p).Pay = C;
	  (**p).Left = (**p).Right = NULL;
  }
  else
	  if ( C<=(**p).Pay ) Search (A,B,C,&((**p).Left));
	  else
		 if ( C>(**p).Pay ) Search (A,B,C,&((**p).Right));
}

void Spisok::Postroenie (svqz *UkStr)
//Постpоение линейного однонапpавленного списка
//с заглавным звеном, содержащего вершины графа.
{
  svqz UkZv;
  int el;

  (*UkStr) = new (zveno);
  UkZv = (*UkStr); UkZv->Sled = NULL;
  cout << "Вводите вершины графа: \n";
  cin >> el;
  while ( el!=0 )
  {
	 UkZv->Sled = new (zveno); UkZv = UkZv->Sled;
	 UkZv->Element[el] = 1; UkZv->Sled = NULL;
	 cin >> el;
  }
}

void Spisok::Postr()
//Постpоение деpева, содержащего все ребра графа.
{
  int A,B,C;

  cout << "Для каждого ребра вводите начальную, затем конечную\n";
  cout << "вершины и стоимость ребра, их соединяющего:\n";
  cin >> A >> B >> C;
  while ( A!=0 )
  { Search (A,B,C,&Root);
    cin >> A >> B >> C;
  }
}

void Spisok::Poisk (svqz st, SubInt MENT, svqz *Res)
{
  svqz q;

  (*Res) = NULL; q = st->Sled;
  while  ( q != NULL  &&  (*Res) == NULL )
  {
	 if ( q->Element[MENT]==1 ) (*Res) = q;
	 else  q = q->Sled;
  }
}

void Spisok::Udalenie (svqz *zv, svqz UkStr)
//Удаление из однонапpавленного списка с заглавным звеном
//элемента, на который указывает указатель zv.
{
	svqz Z;     //"Стаpый" указатель.
	svqz UkZv1; //"Hовый" указатель.

	if ( (*zv)->Sled != NULL ) (**zv) = *((**zv).Sled);
	else
	{  Z = UkStr; UkZv1 = UkStr->Sled;
		while  (UkZv1 != (*zv))
		{ Z = UkZv1; UkZv1 = UkZv1->Sled; }
		Z->Sled = NULL; delete UkZv1;
	}
}

void Spisok::Reshenie()
{
  svqz UkStr;  //Указатель на список.
  Ref UkUzel;  //Рабочий указатель на узел дерева.
  Ref UkUzel1; //Рабочий указатель на узел дерева.
  SubInt T1,T2;
  svqz Res1,Res2;

  //Построение первоначальных множеств вершин графа.
  Postroenie (&UkStr);
  cout <<"Ребра остовного дерева наименьшей стоимости: ";
  while ( UkStr->Sled->Sled != NULL )
  {
	 UkUzel1 = Root;       //"Отстающий" указатель.
	 UkUzel  = Root->Left; //"Опережающий" указатель.
	 if ( UkUzel== NULL )
	 { //Выбор в дереве ребра наименьшей стоимости и ...
		T1 = Root->X; T2 = Root->Y;
		//... удаление этого ребра из дерева.
		Root = Root->Right; delete UkUzel1;
	 }
	 else
	 { //Выбор в дереве ребра наименьшей стоимости и ...
		while ( UkUzel->Left != NULL )
		{
		  UkUzel1 = UkUzel1->Left;
		  UkUzel  = UkUzel->Left;
		}
		T1 = UkUzel->X; T2 = UkUzel->Y;
		//... удаление этого ребра из дерева.
		UkUzel1->Left = UkUzel->Right;
		delete UkUzel;
	 }
	 //Если v и w принадлежат различным
	 //множествам W1 и W2 из VS ...
	 Res1 = Res2 = NULL;
	 Poisk (UkStr,T1,&Res1);
	 Poisk (UkStr,T2,&Res2);
	 if ( Res1!=Res2 )
	 {
           for (int k=0;k<256;k++)
	     if ( Res1->Element[k]==1 || Res2->Element[k]==1 )
                     Res1->Element[k]=1;
             Udalenie (&Res2,UkStr);
             cout << "(" << T1 << " " << T2 << ")  ";
	 }
  }
}

void main ()
{
  Spisok Tree;
  Tree.Postr();
  Tree.Reshenie();
}
Текст этой программы можно взять здесь.
Тестовые примеры:
   пример (A) заимствован из [2, с.200-201];
   пример (B) заимствован из [3, с.198];
   пример (C) заимствован из [4, с.341].
   Для каждого ребра вводите начальную, затем конечную
   вершины и стоимость ребра, их соединяющего:
   (A) 1 7 1         (B) 1 2 9         (C) 1 3 2
       3 4 3             2 3 10            2 4 4
       2 7 4             2 7 8             2 5 8
       3 7 9             1 3 6             1 2 1
       2 3 15            1 7 1             3 4 9
       4 7 16            1 6 4             3 6 7
       4 5 17            6 4 5             8 10 5
       1 2 20            7 4 7             4 8 6
       1 6 23            3 4 2             5 8 4
       5 7 25            4 5 11            4 7 3
       5 6 28            7 6 3             1 4 6
       6 7 36            0 0 0             6 7 7
       0 0 0                               6 9 2
                                           7 9 8
                                           7 10 9
                                           9 10 3
                                           0 0 0
   Вводите вершины графа:
   (A) 1 2 3 4 5 6 7 0
   (B) 1 2 3 4 5 6 7 0
   (С) 1 2 3 4 5 6 7 8 9 10 0
   Ребра остовного дерева наименьшей стоимости:
   (A)  (1 7)  (3 4)  (2 7)  (3 7)  (4 5)  (1 6)
   (B)  (1 7)  (3 4)  (7 6)  (6 4)  (2 7)  (4 5)
   (C)  (1 2)  (6 9)  (1 3)  (9 10)  (4 7)  (5 8)  (2 4)  (8 10)  (4 8)

Замечания.
    1. В монографии [2, с.201-202] показано, что остовное дерево наименьшей стоимости для графа с |E| ребрами можно найти за время O( |E|*log |E|) в общем случае и O(|E|), если  |E| достаточно велико по сравнению с числом узлов.

    2. В некоторых ситуациях требуется построить остов не минимального, а максимального веса. К этой задаче также применим алгоритм Краскала. Следует только всюду минимальный вес заменить максимальным.

    3. [5, с.424]. Напомним Вам, что под стягиванием ребра мы подразумеваем операцию удаления ребра e и отождествление его концевых вершин.
Алгоритм Прима для определения минимального взвешенного остова в связном взвешенном графе G=(V,E)формулируется так: выбрать произвольную вершину v в графе G. Среди всех ребер, входящих в v, выбрать ребро e1 с минимальным весом. Стянем e1, и пусть G' - полученный граф. Повторить эти действия для G' и продолжить до тех пор, пока не будет определено ребро en-1. Ребра e1, e2, ..., en-1 образуют минимальный взвешенный остов графа G.

    4. С задачей об остове минимального веса тесно связана задача Штейнера [4, с.62-63]. Мы отметим лишь, что какие-либо эффективные алгоритмы, решающие задачу Штейнера неизвестны!



(1) Уилсон Р. Введение в теорию графов. - М.: Мир, 1977. - 207 с.
(2) Ахо А., Хопкрофт Дж., Ульман Дж. Построение и анализ вычислительных алгоритмов. - М.: Мир, 1979. - 536 с.
(3) Липский В. Комбинаторика для программистов: Пер. с польск. - М.: Мир, 1988. - 213 с.
(4) Лекции по теории графов / Емеличев В.А., Мельников О.И., Сарванов В.И., Тышкевич Р.И. - М.: Наука, 1990. - 384 с.
(5) Свами М., Тхуласираман К. Графы, сети и алгоритмы. - М.: Мир, 1984. - 454 с.

На следующем шаге мы рассмотрим алгоритм построения фундаментального множества циклов.

        1.32. Остовы. Построение фундаментального множества циклов
На этом шаге мы рассмотрим алгоритм построения фундаментального множества циклов.
Тесно связана с задачей нахождения стягивающего дерева задача построения фундаментального множества циклов.
Если к стягивающему дереву (V,T) графа G=(V,E) мы добавим произвольное ребро e, принадлежащее E\T, то нетрудно отметить, что возникший при этом подграф (V, T в объединении с {e}) содержит в точности один цикл, который мы будем обозначать через Ce. Очевидно, что Ce содержит ребро e.
Определение 1 [1, с.98].
Множество J={Ce: e принадлежит E\T} будем называть фундаментальным множеством циклов графа G(относительно стягивающего дерева (V,T)).
Название "фундаментальный" связано с тем фактом, что каждый цикл графа G можно некоторым естественным способом получить из циклов множества J.
Введем для произвольных множеств A и B операцию A+B = (объединение A и B)\(пересечение A и B).
Определение 2.
Множество A+B будем называть симметрической разностью множеств A и B.
Определение 3 [1, с.98].
Множество C ребер графа называется псевдоциклом, если каждая вершина графа (V,C) имеет четную степень.
Примером псевдоцикла является пустое множество и произвольный цикл графа.
В монографии [1, c.99] доказана теорема о фундаментальном множестве циклов.
Теорема.
Пусть G=(V,E) - связный неориентированный граф, а (V,T) - его стягивающее дерево. Произвольный цикл графаG можно однозначно представить как симметрическую разность некоторого числа фундаментальных циклов. В общем случае произвольный псевдоцикл C графа G можно однозначно представить в виде симметрической разности вида:

Реализуем теперь алгоритм, описанный в [1, с.100-101]. Этот алгоритм основывается на поиске в глубину и имеет структуру, аналогичную рекурсивному алгоритму нахождения стягивающего дерева. Каждая новая вершина, встречающаяся в процессе поиска, помещается в стек, представленный массивом Stack, и удаляется из стека после использования. Очевидно, что стек всегда содержит последовательность вершин с рассматриваемой в данный момент вершины v до корня. Поэтому если анализируемое нами ребро {v,u} замыкает цикл (WGN[v]>WGN[u]>0 и u не находится непосредственно под верхним элементом стека), то вершина u находится в стеке и цикл, замыкаемый ребром {v,u} представлен верхней группой элементов стека, начиная с v и кончая вершиной u.

Пример.
#include <iostream.h>
#define TRUE 1
#define FALSE 0
typedef int Boolean;
typedef struct Leader *Lref; // Тип: указатель на заголовочный узел.
typedef struct Trailer *Tref; // Тип: указатель на дуговой узел.

//Описание типа заголовочного узла.
typedef struct Leader
{
  int Key;   //Имя заголовочного узла.
  int Count; //Количество предшественников.
  int WGN;   //Характеристика узла.
  Tref Trail;//Указатель на список смежности.
  Lref Next; //Указатель на следующий узел в списке заголовочных узлов.
};

//Описание типа дугового узла.
typedef struct Trailer
{
  Lref Id;
  Tref Next;
};

class Spisok
{
  private:
    Lref Head; //Указатель на голову списка заголовочных узлов.
    Lref Tail; //Указатель на фиктивный элемент
               // в конце списка заголовочных узлов.
    Lref Stack[30]; //Рабочий стек.
    void SearchGraph (int, Lref *);
    void Cycle (Lref, int *, int *);
  public:
    Spisok() {//Инициализация списка заголовочных узлов.
              Head = Tail =  new (Leader); }
    void MakeGraph ();
    void PrintGraph ();
    void Mn_Cycle();
};

void main ()
{
  Spisok A;

  //Построение графа и вывод его структуры Вирта.
  A.MakeGraph ();
  A.PrintGraph (); cout<<endl;
  //Построение множества фундаментальных циклов графа.
  A.Mn_Cycle();
}

void Spisok::Mn_Cycle()
//Построение множества фундаментальных циклов графа G.
{
  cout << "Фундаментальные циклы:\n ";
  int num = 0, d = 0; //Количество элементов в стеке.
  Stack[0] = NULL;
  Lref t = Head;
  while ( t!=Tail )
  {  t->WGN = 0; t = t->Next; }
  t = Head;
  while ( t!=Tail )
  {
     if ( t->WGN==0 ) Cycle(t,&d,&num);
     t = t->Next;
  }
}

void Spisok::Cycle (Lref r, int *d, int *num)
//Нахождение фундаментального множества циклов для
//компоненты связности, содержащей вершину r->Key.
{
  Tref t;
  int i;

  (*d)++; Stack[(*d)] = r;
  (*num)++; r->WGN = *num;
  t = r->Trail;
  while ( t != NULL )
  {
    if ( t->Id->WGN==0 ) Cycle (t->Id,d,num);
    else
       if  (t->Id->Key != Stack[(*d)-1]->Key &&
            r->WGN > t->Id->WGN)
       {
          i = *d;
          while ( Stack[i]->Key != t->Id->Key )
          {
             cout << Stack[i]->Key << " ";
             i--;
          }
          cout << t->Id->Key << endl;
       }
    t = t->Next;
  }
  // Использованная вершина r->Key удаляется из стека.
  (*d)--;
}

void Spisok::SearchGraph (int w, Lref *h)
//Функция возвращает указатель на заголовочный узел
//с ключом w в графе, заданном структурой Вирта с указателем Head.
{
  *h = Head; (*Tail).Key = w;
  while ((**h).Key!=w) *h = (**h).Next;
  if (*h==Tail)
  //В списке заголовочных узлов нет узла с ключом w.
  //Поместим его в конец списка Head.
  { Tail = new (Leader); (**h).Count = 0;
    (**h).Trail = NULL; (**h).Next = Tail; }
}

void Spisok::MakeGraph ()
//Функция возвращает указатель Head на структуру
//Вирта, соответствующую ориентированному графу.
{
  int x,y;
  Lref p,q; //Рабочие указатели.
  Tref t,r; //Рабочие указатели.
  Boolean Res; //Флаг наличия дуги.
  cout<<"Вводите начальную вершину дуги: ";
  cin>>x;
  while (x!=0)
  {
     cout<<"Вводите конечную вершину дуги: "; cin>>y;
     //Определим, существует ли в графе дуга (x,y)?
     SearchGraph (x, &p); SearchGraph (y,&q);
     r = (*p).Trail; Res = FALSE;
     while ((r!=NULL)&&(!Res))
       if ((*r).Id==q) Res = TRUE;
       else r = (*r).Next;
     if (!Res) //Если дуга отсутствует, то поместим её в граф.
      { t = new (Trailer); (*t).Id = q;
        (*t).Next = (*p).Trail; (*p).Trail = t; (*q).Count++; }
     cout<<"Вводите начальную вершину дуги: "; cin>>x;
  }
}

void Spisok::PrintGraph ()
//Вывод структуры Вирта, заданной указателем
//Head и соответствующей ориентированному графу.
{
  Lref p; //Рабочий указатель.
  Tref q; //Рабочий указатель.

  p = Head;
  while (p!=Tail)
  {
     cout<<"("<<(*p).Key; q = (*p).Trail;
     while (q!=NULL)
      { cout<<(*(*q).Id).Key; q = (*q).Next; }
     cout<<")"; p = (*p).Next; cout<<" ";
  }
}
Текст этой программы можно взять здесь.
Результат работы приложения изображен на рисунке 1:

Рис.1. Результат работы приложения
Оценим теперь вычислительную сложность этого алгоритма [1, с.101].
Отметим сначала, что общее число шагов, как и во всех алгоритмах, основанных на поиске в глубину, имеет порядок O(m+n). К этому следует прибавить суммарную длину всех циклов. Эта длина не превосходит (m-n+1)n, что дает общую сложность алгоритма O(nm+n).


(1) Липский В. Комбинаторика для программистов: Пер. с польск. - М.: Мир, 1988. - 213 с.

Со следующего шага мы начнем знакомиться с алгоритмами с возвратом.

        1.33. Алгоритмы с возвратом (общие сведения)
На этом шаге мы приведем общие сведения об алгоритмах с возвратом.
До сих пор мы рассматривали только такие алгоритмы на графах, в процессе работы которых нам никогда не приходилось возвращаться назад. Если, например, при обходе графа вершина была просмотрена, то она и оставалась в списке просмотренных вершин до окончания работы алгоритма. Однако существует большой класс задач, для которых неизвестны такие алгоритмы.
Пожалуй, наиболее известной такой задачей является задача коммивояжера (см., например, [1]) - задача о поиске кратчайшего маршрута между N городами, при этом лишь некоторые из городов непосредственно соединены дорогами.
Ниже мы рассмотрим задачу о поиске такого марщрута, который начинается и заканчивается в одном и том же городе и, кроме того, не заходит в один и тот же город дважды. Эта задача известна как задача поиска гамильтонова цикла в графе.
В отличие от эйлеровых путей не известно ни одного простого необходимого и достаточного условия для существования гамильтоновых путей и это несмотря на то, что эта задача - одна из центральных в теории графов. Не известен также алгоритм, который проверял бы существование гамильтонова пути в произвольном графе, используя число шагов, ограниченное многочленом от переменной n (число вершин в графе). Имеются некоторые основания, но нет математического довазательства того, чтобы предполагать, что такое положение вещей вызвано не столько нашим незнанием, а скорее тем фактом, что такого алгоритма не существует.
Проблема существования гамильтонова пути принадлежит к классу так называемых  2NP-полных задач [2, с.109]. Это широкий класс задач, включающий фундаментальные задачи из теории графов, логики, теории чисел, дискретной оптимизации и других дисциплин, ни для одной из которых неизвестен полиномиальный алгоритм (т.е. с числом шагов, ограниченным полиномом от размерности задачи), причем существование полиномиального алгоритма для хотя бы одной из них автоматически влекло бы за собой существование полиномиальных алгоритмов для всех этих задач. Именно факт фундаментальности многих NP-полных задач в различных областях и то, что, несмотря на независимые друг от друга усилия специалистов в этих областях, не удалось найти полиномиального алгоритма ни для одной из этих задач, склоняет к предположению, что такого алгоритма не существует.


(1) Рейнгольд Э., Hивергельт Ю., Део H. Комбинаторные алгоритмы. Теория и практика. - М.: Мир, 1980. - 476 с.
(2) Липский В. Комбинаторика для программистов: Пер. с польск. - М.: Мир, 1988. - 213 с.

На следующем шаге мы рассмотрим построение алгоритма с возвратом.

        1.34. Построение алгоритмов с возвратом
На этом шаге мы рассмотрим построение алгоритма с возвратом.
Опишем, следуя монографии [1], общий метод, позволяющий значительно сократить число шагов в алгоритмах типа полного перебора всех возможностей. Чтобы применить этот метод, искомое решение должно иметь вид последовательности (x1, x2, ...,xn).
Основная идея метода состоит в том, что мы строим решение последовательно, начиная с пустой последовательности e (длины 0). Вообще, имея данное частичное решение (x1, x2, ...,xi), мы стараемся найти такое допустимое значение xi+1, относительно которого мы не можем сразу заключить, что (x1, x2, ...,xi+1) можно расширить до некоторого решения (либо (x1, x2, ...,xi+1) уже является решением). Если такое предполагаемое, но еще не использованное решение xi+1 существует, то мы добавляем его к нашему частичному решению и продолжаем процесс для последовательности (x1, x2, ...,xi+1). Если его не существует, то мы возвращаемся к нашему частичному решению (x1, x2, ...,xi-1) и продолжаем наш процесс, отыскивая новое, еще не использованное допустимое значение xi' - отсюда название "алгоритм с возвратом" (англ. Backtracking) [1, с.110].
Точнее говоря, мы предполагаем, что для каждого k>0 существует некоторое множество Ak, из которого мы будем выбирать кандидатов для k-й координаты частичного решения. Очевидно, что множества Ak должны быть определены таким образом, что для каждого k<=n множество Ak содержало элемент xk (на практике мы не можем вообще исключить ситуацию, когда множество Ak содержит некоторые "лишние" элементы, не появляющиеся в k-й координате ни одного целочисленного решения).
Мы предполагаем также, что существует некоторая простая функция, которая произвольному частичному решению (x1, x2, ...,xi) ставит в соответствие значение P(x1, x2, ...,xi) (истина либо ложь) таким образом, что если P(x1, x2, ...,xi) = ложь, то последовательность (x1, x2, ...,xi) несомненно нельзя расширить до решения.
Если P(x1, x2, ...,xi) = истина, то мы говорим, что значение xi  допустимо (для частичного решения (x1, x2, ...,xi-1), но это отнюдь не означает, что (x1, x2, ...,xi-1) обязательно расширяется до полного решения. Этот процесс можно записать в виде следующей схемы [1, с.111]:
   {
      k = 1;
      while ( k>0 )
         if ( существует еще неиспользованный элемент yпринадлежащий Ak, такой что
             P(X[1],X[2],...,X[k-1],y)
         {
             X[k] = y; //Элемент y использован.
              if  ((X[1],X[2],...,X[k]) является целочисленным решением)
              {
                  cout << (X[1],X[2],...,X[k]);
                   k++;
               }
         }
         else
            //Возврат на более короткое частичное решение; все эле-
            //менты множества Ak вновь становятся неиспользованными.
            k -= 1;
   }
Этот алгоритм находит все решения в предположении, что множества Ak конечные и что существует n такое, что P(x1, x2, ...,xn) = ложь для всех x1, принадлежащем A1, x2, принадлежащем A2, ...,xn, принадлежащем An (последнее условие означает, что все решения имеют длину меньше n).
Приведем рекурсивный вариант схемы алгоритма с возвратом [1, с.112]:
   AP (k);
   //Генерирование всех решений, являющихся расширением
   //последовательности X[1],X[2],...,X[k-1].
   //Массив X - глобальный.
   {
      for (y, принадлежащего Ak, такого, что P(X[1],X[2],...,X[k-1]))
      {
         X[k] = y;
         if (X[1],X[2],...,X[k] есть целочисленное решение)
         {
             cout << X[1],X[2],...,X[k];
             AP(k+1);
          }
   }
Генерирование всех целочисленных решений можно вызвать вызовом AP(1). Представление алгоритма с возвратом мы начали с несколько более сложного нерекурсивного варианта только потому, что в рекурсивном варианте "возврат" не появляется в явном виде, будучи частью реализации механизма рекурсии.

Пример [1,c.118]. Для данных целых чисел a1, a2, ...,an нахождение множества индексов J, принадлежащего {1, 2, ..., n}, такого, что сумма aj равна b при j, принадлежащих J, если такое множество существует.
#include <iostream.h>
#define TRUE 1
#define FALSE 0
#define Node 20 //Максимальное количество вершин в графе.
typedef int Boolean;
typedef struct L *Lref; // Тип: указатель на заголовочный узел.
typedef struct T *Tref; // Тип: указатель на дуговой узел.

//Описание типа заголовочного узла.
typedef struct L
{
  int Key; //Имя заголовочного узла.
  int Count; //Количество предшественников.
  Boolean Flag; //Флаг посещения узла при обходе.
  Tref Trail; //Указатель на список смежности.
  Lref Next; //Указатель на следующий узел в списке заголовочных узлов.
};

//Описание типа дугового узла.
typedef struct T
{
  Lref Id;
  Tref Next;
};

class Spisok
{
  private:
    Lref Head; //Указатель на голову списка заголовочных узлов.
    Lref Tail; //Указатель на фиктивный элемент
               // в конце списка заголовочных узлов.
    int  X[Node+1];
    void SearchGraph (int, Lref *);
  public:
    Spisok() {//Инициализация списка заголовочных узлов.
              Head = Tail =  new (L); }
    Lref GetHead() { return Head; }
    Lref GetTail() { return Tail; }
    void MakeGraph ();
    void PrintGraph ();
    void Summa (int, int, int);
    void X1 (Lref t) {X[1] = t->Key;};
};

void main ()
{
  Spisok A;
  Lref t; //Рабочий указатель для перемещения
          // по списку заголовочных звеньев.
  Lref t1;
  int n=0,B;
  //Построение графа и вывод его структуры Вирта.
  A.MakeGraph ();
  A.PrintGraph (); cout<<endl;
  //Подсчет n - количества вершин в графе Head.
  t = A.GetHead();
  while (t!=A.GetTail())
    { n++; t = (*t).Next; }
  // ------------------------------------
  //Обнаружение множества индексов.
  cout << "Введите число B: "; cin >> B;
  t = A.GetHead();
  while (t!=A.GetTail())
  {
    //Инициализация.
    t1 = A.GetHead();
    while (t1!=A.GetTail())
    { t1->Flag = TRUE; t1 = t1->Next; }
      A.X1(t); t->Flag = FALSE;
      A.Summa (2,B,n);
      t = t->Next;
  }
}

void Spisok::SearchGraph (int w, Lref *h)
//Функция возвращает указатель на заголовочный узел
//с ключом w в графе, заданном структурой Вирта с указателем Head.
{
  *h = Head; (*Tail).Key = w;
  while ((**h).Key!=w) *h = (**h).Next;
  if (*h==Tail)
  //В списке заголовочных узлов нет узла с ключом w.
  //Поместим его в конец списка Head.
  { Tail = new (L); (**h).Count = 0;
    (**h).Trail = NULL; (**h).Next = Tail; }
}

void Spisok::MakeGraph ()
//Функция возвращает указатель Head на структуру
//Вирта, соответствующую ориентированному графу.
{
  int x,y;
  Lref p,q; //Рабочие указатели.
  Tref t,r; //Рабочие указатели.
  Boolean Res; //Флаг наличия дуги.
  cout<<"Вводите начальную вершину дуги: ";
  cin>>x;
  while (x!=0)
  {
     cout<<"Вводите конечную вершину дуги: "; cin>>y;
     //Определим, существует ли в графе дуга (x,y)?
     SearchGraph (x, &p); SearchGraph (y,&q);
     r = (*p).Trail; Res = FALSE;
     while ((r!=NULL)&&(!Res))
       if ((*r).Id==q) Res = TRUE;
       else r = (*r).Next;
     if (!Res) //Если дуга отсутствует, то поместим её в граф.
      { t = new (T); (*t).Id = q;
        (*t).Next = (*p).Trail; (*p).Trail = t; (*q).Count++; }
     cout<<"Вводите начальную вершину дуги: "; cin>>x;
  }
}

void Spisok::PrintGraph ()
//Вывод структуры Вирта, заданной указателем
//Head и соответствующей ориентированному графу.
{
  Lref p; //Рабочий указатель.
  Tref q; //Рабочий указатель.

  p = Head;
  while (p!=Tail)
  {
     cout<< (*p).Key << "("; q = (*p).Trail;
     while (q!=NULL)
      { cout<<(*(*q).Id).Key; q = (*q).Next; }
     cout<<")"; p = (*p).Next; cout<<" ";
  }
}

void Spisok::Summa (int k, int B, int n)
//Нахождение множества вершин в графе, заданном
//структурой Вирта с указателем Head.
{
  int i;  //Параметр цикла.
  Lref t; //Указатель на k-ю вершину частичного решения.
  Tref r;
  int S;
  int Set1[256]; //Вспомогательное множество.
  int m; //Количество элементов в Set1.

  SearchGraph (X[k-1], &t);
  r = t->Trail;
  while ( r != NULL )
  {
    X[k] = r->Id->Key;
    //Построение вспомогательного множества Set1 для
    //проверки, все ли элементы массива X различны.
    for (int j=0;j<256;Set1[j++]=0);
    for (i=1;i<=k;i++) Set1[X[i]]=1;
    //Подсчет m - количества элементов в множестве Set1.
    m = 0;
    for(i=1;i<=Node;i++)
     if (Set1[i]==1) m++;
    // -------------------------------
    S = 0;
    for (i=1;i<=k;i++)  S += X[i];
    // ----------------------------
    if  (k<n+1 && S==B && m==k)
    {
      //Вывод множества индексов на экран дисплея.
      for (i=1;i<=k;i++) cout << X[i] << " ";
      cout << endl;
    }
    else
      if  (r->Id->Flag)
      {
         X[k] = r->Id->Key;
         r->Id->Flag = FALSE;
         Summa (k+1,B,n);
         r->Id->Flag = TRUE;
      }
    r = r->Next;
  }
}
Текст этой программы можно взять здесь.


(1) Липский В. Комбинаторика для программистов: Пер. с польск. - М.: Мир, 1988. - 213 с.

На следующем шаге мы познакомимся с гамильтоновыми циклами.

        1.35. Гамильтоновы циклы
На этом шаге мы рассмотрим гамильтоновы циклы.
Отметим, что начало исследований так называемых гамильтоновых графов относится к графам многогранников [1, с.70].
В 1857 г. ирландский математик Гамильтон предложил игру, названную "путешествие по додекаэдру". Игра сводилась к обходу по ребрам всех вершин правильного додекаэдра при условии, что ни в одну из вершин нельзя заходить более одного раза. Додекаэдр - это многогранник, гранями которого служат 12 правильных пятиугольников. У него 20 вершин и 30 ребер. Вершины и ребра додекаэдра составляют некоторый плоский граф.
Определение.
Простой цикл в графе - это замкнутый путь, все вершины которого, кроме v0 и vn, попарно различны.
Гамильтонов цикл - это простой цикл, содержащий все вершины графа. Заметим, что гамильтонов цикл есть далеко не в каждом графе. Граф называется гамильтоновым, если в нем имеется гамильтонов цикл.
Граф, который содержит простой путь, проходящий через каждую его вершину, называется полугамильтоновым [2, с.48-49]. Ясно, что всякий гамильтонов граф является полугамильтоновым.
Применим теперь алгоритм с возвратом для нахождения гамильтонова цикла в графе.
Алгоритм, с помощью которого мы будем искать гамильтоновы циклы, называется поиск с возвращением. В основе его лежит понятие частичного решения. Пусть решение задачи представляется в виде некоторой последовательности. В нашем случае это просто последовательность всех вершин графа, удовлетворяющая очевидным ограничениям. Начальный отрезок последовательности, который удовлетворяет ограничениям, определяющим полное решение, называется частичным решением.
Частичным решением для гамильтонова цикла является любая последовательность вершин, определяющая простой путь.
Если в последовательность, представляющую частичное решение, добавить новый элемент так, что расширенная последовательность снова будет частичным решением, то новая последовательность называется продолжением частичного решения. Продолжение, как правило, неоднозначно.
Идея поиска с возвращением состоит в том, чтобы, начав с тривиального частичного решения, последовательно продолжать его до тех пор, пока не будет получено полное решение, либо продолжение станет невозможным. В последнем случае мы возвращаемся на шаг назад и пробуем построить другое продолжение. Если пространство поиска конечно, то либо мы получим полное решение, либо убедимся в невозможности его построения, поскольку осуществлен полный перебор возможных продолжений.
После этих замечаний приведем реализацию алгоритма поиска гамильтонова пути в связном неориентированном графе:

Программа 1.
//Нахождение всех гамильтоновых циклов в графе,
//заданном структурой Вирта.
#include <iostream.h>
#define TRUE 1
#define FALSE 0
#define Node 20 //Максимальное количество вершин в графе.
typedef int Boolean;
typedef struct L *Lref; // Тип: указатель на заголовочный узел.
typedef struct T *Tref; // Тип: указатель на дуговой узел.

//Описание типа заголовочного узла.
typedef struct L
{
  int Key; //Имя заголовочного узла.
  int Count; //Количество предшественников.
  Boolean Flag; //Флаг посещения узла при обходе.
  Tref Trail; //Указатель на список смежности.
  Lref Next; //Указатель на следующий узел в списке заголовочных узлов.
};

//Описание типа дугового узла.
typedef struct T
{
  Lref Id;
  Tref Next;
};

//Описание типа узла стека.
typedef Lref TipElement;
typedef struct Zveno *svqz;
typedef struct Zveno
{
  TipElement Element; //Указатель на список смежности.
  svqz Sled;
};

class Spisok
{
  private:
    Lref Head; //Указатель на голову списка заголовочных узлов.
    Lref Tail; //Указатель на фиктивный элемент
               // в конце списка заголовочных узлов.
    int  X[Node+1]; //Результат работы программы.
    void SearchGraph (int, Lref *);
  public:
    Spisok() {//Инициализация списка заголовочных узлов.
              Head = Tail =  new (L); }
    Lref GetHead() { return Head; }
    Lref GetTail() { return Tail; }
    void MakeGraph ();
    void PrintGraph ();
    void Hamilton (int, int);
    void X1 (Lref t) {X[1] = t->Key;};
};

void main ()
{
  Spisok A;
  Lref t; //Рабочий указатель для перемещения
          // по списку заголовочных звеньев.
  int n=0;

  //Построение графа и вывод его структуры Вирта.
  A.MakeGraph ();
  A.PrintGraph (); cout<<endl;
  //Инициализация и подсчет количества вершин графа.
  t = A.GetHead();
  while (t!=A.GetTail())
    { t->Flag = TRUE; n++; t = (*t).Next; }
  // ------------------------------------
  //Нахождение всех гамильтоновых циклов.
  t = A.GetHead();
  A.X1(t);
  t->Flag = FALSE;
  A.Hamilton (2,n);
}

void Spisok::SearchGraph (int w, Lref *h)
//Функция возвращает указатель на заголовочный узел
//с ключом w в графе, заданном структурой Вирта с указателем Head.
{
  *h = Head; (*Tail).Key = w;
  while ((**h).Key!=w) *h = (**h).Next;
  if (*h==Tail)
  //В списке заголовочных узлов нет узла с ключом w.
  //Поместим его в конец списка Head.
  { Tail = new (L); (**h).Count = 0;
    (**h).Trail = NULL; (**h).Next = Tail; }
}

void Spisok::MakeGraph ()
//Функция возвращает указатель Head на структуру
//Вирта, соответствующую ориентированному графу.
{
  int x,y;
  Lref p,q; //Рабочие указатели.
  Tref t,r; //Рабочие указатели.
  Boolean Res; //Флаг наличия дуги.
  cout<<"Вводите начальную вершину дуги: ";
  cin>>x;
  while (x!=0)
  {
     cout<<"Вводите конечную вершину дуги: "; cin>>y;
     //Определим, существует ли в графе дуга (x,y)?
     SearchGraph (x, &p); SearchGraph (y,&q);
     r = (*p).Trail; Res = FALSE;
     while ((r!=NULL)&&(!Res))
       if ((*r).Id==q) Res = TRUE;
       else r = (*r).Next;
     if (!Res) //Если дуга отсутствует, то поместим её в граф.
      { t = new (T); (*t).Id = q;
        (*t).Next = (*p).Trail; (*p).Trail = t; (*q).Count++; }
     cout<<"Вводите начальную вершину дуги: "; cin>>x;
  }
}

void Spisok::PrintGraph ()
//Вывод структуры Вирта, заданной указателем
//Head и соответствующей ориентированному графу.
{
  Lref p; //Рабочий указатель.
  Tref q; //Рабочий указатель.

  p = Head;
  while (p!=Tail)
  {
     cout<< (*p).Key << "("; q = (*p).Trail;
     while (q!=NULL)
      { cout<<(*(*q).Id).Key; q = (*q).Next; }
     cout<<")"; p = (*p).Next; cout<<" ";
  }
}

void Spisok::Hamilton (int k, int n)
//Нахождение всех гамильтоновых циклов в графе, структура
//смежности которого заданна указателем t.
{
  int i;  //Параметр цикла.
  Lref t; //Указатель на k-ю вершину частичного решения.
  Tref r;

  SearchGraph (X[k-1], &t);
  r = t->Trail;
  while ( r != NULL )
  {
    X[k] = r->Id->Key;
    if  (k==n+1 && X[k]==X[1])
    {
      for (i=1;i<=n;i++) cout << X[i] << " ";
      cout << X[1] << endl;
    }
    else
      if (r->Id->Flag)
      {
        r->Id->Flag = FALSE;
        Hamilton (k+1,n);
        r->Id->Flag = TRUE;
      }
    r = r->Next;
  }
}
Текст этой программы можно взять здесь.
Результат работы приложения изображен на рисунке 1:

Рис.1. Результат работы приложения

Программа [3, с.134-135].
   (DEFUN HAMILTCYCLE (LAMBDA (GRAPH)
   ; Построение гамильтонова цикла:
   ; GRAPH   - граф, представленный структурой смежности в
   ;           виде ассоциативного списка,
   ; Результат: гамильтонов цикл в виде списка вершин,
   ;            NIL, если гамильтонова цикла не существует
      (COND ( (NULL GRAPH) NIL )
            (  T  (COND ( (NULL (CDR GRAPH))
                              (LIST (CAAR GRAPH)))
                        (  T  (HC GRAPH (CAAR GRAPH)
                                  (LIST (CAAR GRAPH))
                                  (CDAR GRAPH)) )) ))
   ))
   ; ------------------------------------------
   (DEFUN HC (LAMBDA (GRAPH START VISITED SONS)
   ; GRAPH   - граф, представленный структурой смежности в
   ;           виде ассоциативного списка,
   ; START   - вершина графа - начало гамильтонова цикла,
   ; VISITED - список посещенных вершин графа,
   ; SONS    - список вершин, смежных первой вершине в списке VISITED
      (COND ( (NULL SONS) NIL )
            (  T  (COND ( (AND (MEMBER START SONS)
                               (EQ (LENGTH GRAPH)
                                   (LENGTH VISITED)))
                             (REVERSE VISITED) )
                        ( T (COND
                              ( (MEMBER (CAR SONS) VISITED)
                                  (HC GRAPH START VISITED
                                             (CDR SONS)) )
                              (  T  (OR (HC GRAPH START
                                            (CONS
                                              (CAR SONS) VISITED)
                                            (NEIGHBOUR3 (CAR SONS) GRAPH)
                                        )
                                        (HC
                                           GRAPH START VISITED
                                           (CDR SONS))) )) )) ))
   ))
   ; ---------------------------------
   (DEFUN NEIGHBOUR3 (LAMBDA (X GRAPH)
   ; Функция возвращает список вершин графа GRAPH,
   ;            смежных с вершиной X
      (COND ( (NULL (ASSOC X GRAPH)) NIL )
            (  T  (CDR (ASSOC X GRAPH)) ))
   ))
Текст этой библиотеки можно взять здесь.
Тестовые примеры:
   $ (HAMILTCYCLE '((1 . (2 6)) (2 . (1 3 4)) (3 . (2 4))
   (4 . (2 3 5)) (5 . (4 6)) (6 . (1 5))))
   (1 2 3 4 5 6)
   $ (HAMILTCYCLE '((A . (F D C)) (F . (E D A B))
   (E . (D F B)) (D . (E F A)) (C . (A B)) (B . (F E C))))
   (A F D E B C)
Разберем работу функции HAMILTCYCLE.
Для пустого графа она возвращает пустой список, а для графа, состоящего из единственной вершины - список, содержащий эту вершину.
Если граф состоит более чем из двух вершин, то вызывается функция HC. Именно эта функция осуществляет продолжение частичного решения.
Частичное решение представлено в виде списка VISITED - это список просмотренных вершин в порядке, обратном порядку их просмотра.
Список SONS - это список соседей первой вершины в списке VISITED. С точки зрения частичного решения эта вершина является как раз последней. Поэтому вершины из списка SONS могут входить в продолжения частичного решения.
Если этот список пуст, то продолжение частичного решения невозможно и функция HC возвращает значение NIL.
В противном случае проверяется, нельзя ли на следующем шаге замкнуть гамильтонов цикл. Это возможно, если,
    • во-первых, начальная вершина содержится в списке SONS и,
    • во-вторых, если пройдены все вершины графа. Поскольку каждая вершина по условию посещается не более одного раза (это следует из определения частичного решения), то достаточно проверить, что длины списков GRAPH и VISITED равны.
Если оба вышеупомянутых условия выполнены, то список VISITED представляет собой искомый цикл.
Перейдем теперь к случаю, когда продолжение возможно, но не приводит немедленно к построению полного решения. Наша цель продолжить частичное решение. Для этого мы просматриваем список SONS до тех пор, пока не встретим вершину, которой нет в списке VISITED. Если такая вершина не найдена, то продолжение невозможно.
В противном случае вычисляется выражение
   (OR  (HC GRAPH START (CONS (CAR SONS) VISITED)
            (NEIGHBOUR3 (CAR SONS) GRAPH))
        (HC GRAPH START VISITED (CDR SONS)))
Это ключевой момент поиска с возвращением. Если при первом вызове функции HC вычисляется значение, отличное от NIL, то это означает, что продолжение (CONS (CAR SONS) VISITED) достроено до полного решения. Это решение и возвращается на верхний уровень. В противном случае с помощью второго вызова функции HCделается попытка найти продолжение, отличное от (CONS (CAR SONS) VISITED).
Обратите внимание на то, что весь механизм возврата оказался "спрятанным" в рекурсию. Это позволило сделать программу ясной и компактной.
Функция HAMILTCYCLE прекратит работу, как только найдет первый гамильтонов цикл или просмотрит все возможности.
Заметим, что алгоритм поиска с возвращением можно интерпретировать как поиск в графе. Вершинами этого графа являются частичные решения, а ребрами - те пары частичных решений, одно из которых является непосредственным продолжением другого. Выбор того или иного алгоритма поиска на графе определяет стратегию поиска с возвращением.

Замечания.
    1. Следующие четыре неориентированных графа демонстрируют отсутствие тесной взаимосвязи между существованием эйлеровых и гамильтоновых циклов:
    2.    1) эйлеров и гамильтонов:
    3.       {1,2},{2,3},{3,4},{4,1};
    4.    2) неэйлеровы и гамильтоновы:
    5.       a) {1,2},{2,3},{3,4},{2,4},{4,5},{5,1};
    6.       b) {1,2},{2,3},{3,4},{2,4},{4,6},{1,6},{4,5},{5,6};
    7.    3) эйлеровы и негамильтоновы:
    8.       a) {1,2},{2,3},{3,4},{4,1},{4,5},{5,2},{2,6},{6,4};
    9.       b) {1,2},{2,3},{3,5},{5,6},{6,4},{1,4},{2,7},{7,4},{2,8},
    10.          {8,5},{4,5};
    11.    4) неэйлеров и негамильтонов:
    12.       {1,2},{2,3},{3,4},{4,1},{4,5},{5,2}.
Однако, двойственность между эйлеровыми и гамильтоновыми циклами (замена вершины на ребро и наоборот) приводит к тесной связи между этими двумя понятиями в применении к неориентированному графу G и соответствующему ему реберному графу, определяемому ниже.
Определение [4, с.237].
Реберный граф Gl графа G имеет столько же вершин, сколько ребер у графа G. Ребро между двумя вершинами графа Gl существует тогда и только тогда, когда ребра графа G, соответствующие этим двум вершинам, смежны (т.е. инцидентны одной и той же вершине графа G).
Верны два следующих утверждения о взаимоотношении между эйлеровыми и гамильтоновыми циклами, принадлежащие Ф.Харари [4, с.237].
1. Если граф G имеет эйлеров цикл, то граф Gl имеет как эйлеров, так и гамильтонов циклы.
2. Если граф G имеет гамильтонов цикл, то граф Gl также имеет гамильтонов цикл.
Обращение этих утверждений неверно!

    13. Пусть G - граф с n вершинами v1, v2, ...,vn, степени di которых удовлетворяют неравенствам d1<=d2<= ... <=dn-1<=dn.
Граф G имеет гамильтонов цикл, если выполняется одно из следующих условий:
        ◦ условие Дирака: d1>=n/2;
        ◦ условие Поша: dk >= k+1 для k<n/2;
        ◦ условие Бонди: из dl<=l и dk<=k следует, что dl+dk>=n (k<>l);
        ◦ условие Хватала: из dk<=k<=n/2 следует, что dn-k>=n-k.
Обратим также Ваше внимание на условие Дирака в другой формулировке.
Теорема Дирака.
Обозначим R(v) - степень вершины v в графе. Если в простом графе с n>=3 вершинами R(v)>=n/2 для любой вершины v, то граф является гамильтоновым.

    14. Каждый гамильтонов цикл можно характеризовать с помощью матрицы смежностей (xij) размера n*n, имея в виду, что xij=1, если ребро (i,j) принадлежит C, и xij=0 в противном случае.

    15. Толщиной графа G (обозначается  l(G)) называется число вершин в самой длинной простой цепи графа. Если граф G гамильтонов, то толщина l(G) равна числу вершин графа.

    16. [5, с.48]. Простейший пример негамильтонова графа - это тэта-граф, графическое изображение которого похоже на греческую букву "тэта":
    17.                             o --------- o
    18.                             ¦           ¦
    19.                             o --- o --- o
    20.                             ¦           ¦
    21.                             o --------- o



(1) Емеличев В.А., Ковалев М.М., Кравцов М.К. Многогранники, графы, опитимизация. - М.: Наука, 1981. - 341 с.
(2) Уилсон И.Р., Эддиман А.М. Практическое введение в ПАСКАЛЬ. - М.: Радио и связь, 1983. - 143 с.
(3) Крюков А.П., Радионов А.Я., Таранов А.Ю., Шаблыгин Е.М. Программирование на языке R-Лисп. - М.: Радио и связь, 1991. - 192 с.
(4) Кристофидес Н. Теория графов. Алгоритмический подход. - М.: Мир, 1978. - 432 с.
(5) Березина Л.Ю. Графы и их применение. - М.: Просвещение, 1979. - 143 с.

На следующем шаге мы познакомимся с кликами.

        1.36. Клики
На этом шаге мы рассмотрим понятие и реализацию кликов.
Понятие клики используется в различных социологических теориях (вопросы, связанные с голосованием, альянсами и т.п.), а также в теории игр.
Вначале напомним Вам, что:
    • часть графа G=(V,E) - это такой граф G'=(V',E'), что V' принадлежит V и E' принадлежит E;
    • подграфом графа G называется такая его часть G', которая вместе со всякой парой вершин u,v содержит и ребро{u,v}, если только оно есть в G;
    • граф называется полным, если любые две его различные вершины соединены ребром.
Определение [1, с.34]
Клика графа - это любой максимальный полный подграф.
Не требует никакой изобретательности следующий процесс нахождения клики.
Пусть вершины графа L=(X,U) пронумерованы: X={x1, x2, ..., xn}. Выберем вершину x1, затем первую смежную с ней xi, потом вторую xj, смежную с обеими (1<i<j) и т.д. пока возможно, и пусть p - число вершин выявленной таким образом максимальной (по включению) клики. Попытаемся увеличить это число, рассматривая другой вариант процесса: вместо вершины xk, добавленной к некоторой клике на последнем шаге, добавляем другую вершину xl, l>k, тоже смежную со всеми вершинами этой клики (если такая xl есть), в надежде, что продолжение процесса по новой ветви окажется более успешным и даст хотя бы (p+1)-клику; если ни одна замена вершины xk не приводит к цели, возвращаемся еще на один шаг и т.д.

Пример.
//Нахождение всех клик в графе, заданном структурой Вирта.
#include <iostream.h>
#define TRUE 1
#define FALSE 0
#define Node 20 //Максимальное количество вершин в графе.
typedef int Boolean;
typedef struct L *Lref; // Тип: указатель на заголовочный узел.
typedef struct T *Tref; // Тип: указатель на дуговой узел.

//Описание типа заголовочного узла.
typedef struct L
{
  int Key; //Имя заголовочного узла.
  int Count; //Количество предшественников.
  Boolean Flag; //Флаг посещения узла при обходе.
  Tref Trail; //Указатель на список смежности.
  Lref Next; //Указатель на следующий узел в списке заголовочных узлов.
};

//Описание типа дугового узла.
typedef struct T
{
  Lref Id;
  Tref Next;
};

class Spisok
{
  private:
    Lref Head; //Указатель на голову списка заголовочных узлов.
    Lref Tail; //Указатель на фиктивный элемент
               // в конце списка заголовочных узлов.
    int  X[20]; //Результат работы программы.
    void SearchGraph (int, Lref *);
  public:
    Spisok() {//Инициализация списка заголовочных узлов.
              Head = Tail =  new (L); }
    Lref GetHead() { return Head; }
    Lref GetTail() { return Tail; }
    void MakeGraph ();
    void PrintGraph ();
    void Clique (int, int);
    void X1 (Lref t) {X[1] = t->Key;};
};

void main ()
{
  Spisok A;
  Lref t; //Рабочий указатель для перемещения
          // по списку заголовочных звеньев.
  Lref t1;
  int n=0;

  //Построение графа и вывод его структуры Вирта.
  A.MakeGraph ();
  A.PrintGraph (); cout<<endl;
  //Инициализация и подсчет количества вершин графа.
  t = A.GetHead();
  while (t!=A.GetTail())
    { n++; t = (*t).Next; }
  // ------------------------------------
  //Нахождение всех клик в графе Head.
  for (int i=3;i<=n;i++)
  {
    //i - количество вершин в клике (i<=3).
    cout << "Перечислим все клики длины " << i << endl;
    t = A.GetHead();
    while (t!=A.GetTail())
    {
       //Инициализация.
       t1 = A.GetHead();
       while (t1!=A.GetTail())
       { t1->Flag = TRUE; t1 = t1->Next;  }
       A.X1(t); t->Flag = FALSE;
       //Отыскание клики с i вершинами, "начинающейся" в вершине t.
       A.Clique (2,i); t = t->Next;
    }
  }
}

void Spisok::SearchGraph (int w, Lref *h)
//Функция возвращает указатель на заголовочный узел
//с ключом w в графе, заданном структурой Вирта с указателем Head.
{
  *h = Head; (*Tail).Key = w;
  while ((**h).Key!=w) *h = (**h).Next;
  if (*h==Tail)
  //В списке заголовочных узлов нет узла с ключом w.
  //Поместим его в конец списка Head.
  { Tail = new (L); (**h).Count = 0;
    (**h).Trail = NULL; (**h).Next = Tail; }
}

void Spisok::MakeGraph ()
//Функция возвращает указатель Head на структуру
//Вирта, соответствующую ориентированному графу.
{
  int x,y;
  Lref p,q; //Рабочие указатели.
  Tref t,r; //Рабочие указатели.
  Boolean Res; //Флаг наличия дуги.
  cout<<"Вводите начальную вершину дуги: ";
  cin>>x;
  while (x!=0)
  {
     cout<<"Вводите конечную вершину дуги: "; cin>>y;
     //Определим, существует ли в графе дуга (x,y)?
     SearchGraph (x, &p); SearchGraph (y,&q);
     r = (*p).Trail; Res = FALSE;
     while ((r!=NULL)&&(!Res))
       if ((*r).Id==q) Res = TRUE;
       else r = (*r).Next;
     if (!Res) //Если дуга отсутствует, то поместим её в граф.
      { t = new (T); (*t).Id = q;
        (*t).Next = (*p).Trail; (*p).Trail = t; (*q).Count++; }
     cout<<"Вводите начальную вершину дуги: "; cin>>x;
  }
}

void Spisok::PrintGraph ()
//Вывод структуры Вирта, заданной указателем
//Head и соответствующей ориентированному графу.
{
  Lref p; //Рабочий указатель.
  Tref q; //Рабочий указатель.

  p = Head;
  while (p!=Tail)
  {
     cout<< (*p).Key << "("; q = (*p).Trail;
     while (q!=NULL)
      { cout<<(*(*q).Id).Key; q = (*q).Next; }
     cout<<")"; p = (*p).Next; cout<<" ";
  }
}

void Spisok::Clique (int k, int m)
//Нахождение всех клик, содержащих m вершин, в графе,
//заданном структурой Вирта с указателем Head,
//k - количество вершин в частичном решении.
{
  Tref r,r1;   //Рабочие указатели.
  Lref p,q;    //Рабочие указатели.
  Lref t;      //Указатель на k-ю вершину частичного решения.
  int v;       //Вершина - кандидат на дополнение к частичному решению.
  Boolean Res; //Флаг клики.
  Boolean Res1;//Флаг существования ребра.
  int i;       //Параметр цикла.

  SearchGraph (X[k-1], &t);
  r = t->Trail;
  while ( r != NULL )
  {
    v = r->Id->Key;
    //Проверим, смежна ли вершина v с вершинами X[1],X[2],...,X[k-1].
    Res = TRUE;
    for (i=1;i<=k-1;i++)
    {
      //Cуществует ли в графе ребро (X[i],v)?
      SearchGraph (v, &p);
      SearchGraph (X[i], &q);
      r1 = p->Trail;
      Res1 = FALSE;
      while  (r1 != NULL && !Res1)
       if ( r1->Id==q ) Res1 = TRUE;
       else  r1 = r1->Next;
      Res = (Res && Res1);
    }
    if (!Res) r->Id->Flag = FALSE;
    // --------------------------
    if  (k==m && Res)
      //Количество вершин в графе равно m, и
      //вершины X[1],X[2],...,X[k] образуют клику.
      {
        //Вывод клики на экран дисплея.
        for (i=1;i<=k-1;i++) cout << X[i] << " ";
        cout << v << endl;
      }
    else
      if ( r->Id->Flag )
      {
        X[k] = r->Id->Key;
        r->Id->Flag = FALSE;
        Clique (k+1,m);
        r->Id->Flag = TRUE;
      }
    r = r->Next;
  }
}
Текст этой программы можно взять здесь.
Мы рассмотрели лишь естественный поиск клик с возвращением, т.е. поиск, в котором не делается никаких попыток упростить дерево поиска. Каждый узел в дереве поиска соответствует полному подграфу графа, и каждое ребро соответствует вершине графа. Заметим, что каждая клика порождается много раз: в общем случае клика размера kпорождается k! раз.
От общего числа шагов порядка n! могут спасти (не всегда, но часто) следующие два обстоятельства [2, с.56].
    1. Если когда-то уже была найдена p-клика, а затем на некоторой ветви процесса образовалась q-клика от присоединения (к какой-то другой, вообще говоря, клике) вершины xj с номером j>=0n-p+q, то развивать эту ветвь не имеет смысла, ибо ни одной клики с числом вершин более p она все равно дать не может.
    2. Пусть из некоторой сформированной клики F мы удаляем последнюю присоединенную вершину xk и вместо нее собираемся добавить xl с l>k; это заведомо не имеет смысла делать, если все вершины клики F\xk, смежные с xl, смежны также с xk.
Весь процесс с учетом этих двух обстоятельств представляет собой частный случай хорошо известного метода ветвей и границ, предлагался в разное время (устно и письменно) многими авторами, и установить приоритет здесь затруднительно.
Ссылка на вариант технического воплощения этого процесса, называемый одесским алгоритмом есть в монографии [2, с.56].

Замечания.
    1. В монографии [3, с.118] кликой называется произвольное подмножество вершин, в котором каждая пара различных вершин соединена ребром графа.
    2. Кликовое число графа (густота или плотность) - это максимальное число вершин в кликах данного графа [4, с.46]. Тогда, образно говоря, чем более "плотен" граф, тем будет больше кликовое число.
    3. Матрицей клик графа называется матрица инциденций вершин графа его кликам, т.е. aij=1, если вершина jпринадлежит некоторой клике Ki, и aij=0 в противном случае.
    4. В монографии [5, с.389-396] приведен очень сложный алгоритм порождения всех клик графа.
    5. Мун и Мозер (1965 г.) доказали (см. ссылку в [4, с.70]), что наибольшее число клик, которые могут встретиться в графе с n вершинами, дается соотношениями:
    6.     3n/3      , если n=0(mod 3)
    7.     4*3(n-4)/3, если n=1(mod 3)
    8.     2*3(n-2)/3, если n=2(mod 3)
Этот результат впервые был получен в 1960 г. Р.Миллером и Д.Малером, но не был опубликован.



(1) Харари Ф. Теория графов. - М.: Мир, 1973. - 300 с.
(2) Зыков А.А. Основы теории графов. М.: Наука, 1987. - 384 с.
(3) Липский В. Комбинаторика для программистов: Пер. с польск. - М.: Мир, 1988. - 213 с.
(4) Кристофидес Н. Теория графов. Алгоритмический подход. - М.: Мир, 1978. - 432 с.
(5) Рейнгольд Э., Hивергельт Ю., Део H. Комбинаторные алгоритмы. Теория и практика. - М.: Мир, 1980. - 476 с.

На следующем шаге мы рассмотрим независимые множества вершин графа.

        1.37. Независимые множества вершин графа
На этом шаге мы рассмотрим понятие числа независимости графа и алгоритм нахождения наибольшего независимого множества.

Определение 1 [1, с.44].
Рассмотрим неориентированный граф G=(V,E).
Независимое множество вершин (известное также как внутренне устойчивое множество) есть множество вершин графа G, такое, что любые две вершины в нем не смежны (никакая пара вершин не соединена ребром).
Независимое множество называется максимальным, когда нет другого независимого множества, в которое оно бы входило.
Например, рассмотрим граф:

Рис.1. Пример графа
Для данного графа множества вершин
   - {7,8,2}, {1,3}, {7,8,2,5} - независимые;
   - {1,3,7}, {4,6}, {7,8,2,5} - максимальные.
Следовательно, в рассмотренном графе больше одного независимого множества.
Определение 2 [1, с.45]
Если Q является семейством всех независимых множеств графа G, то число
     a(G) = max |S|
          S принадлежит Q
называется числом независимости графа G, а множество S*, на котором этот максимум достигается, называется наибольшим независимым множеством.
Например, для изображенного выше графа семейство максимальных независимых множеств таково: {8,7,2,5}, {1,3,7}, {2,4,8}, {6,4}, {6,3}, {1,4}, {7,5,1}, {3,7,8}.
Наибольшее из этих множеств имеет 4 элемента и, следовательно, a(G)=4.
Множество {8,7,2,5} является наибольшим независимым множеством.
Ясно, что понятие, противоположное максимальному независимому множеству, есть максимальный полный подграф (клика).
Совершенно очевидно, что максимальное независимое множество графа G соответствует клике графа G~ и наоборот, где G~ - дополнение графа G.
Это утверждение лежит в основе работы алгоритма, реализованного ниже на языке C++.

Пример.
//Нахождение всех независимых множеств в графе, заданном
//структурой Вирта, с использованием клики.
#include <iostream.h>
#define TRUE 1
#define FALSE 0
#define Node 20 //Максимальное количество вершин в графе.
typedef int Boolean;
typedef struct L *Lref; // Тип: указатель на заголовочный узел.
typedef struct T *Tref; // Тип: указатель на дуговой узел.

//Описание типа заголовочного узла.
typedef struct L
{
  int Key; //Имя заголовочного узла.
  int Count; //Количество предшественников.
  Boolean Flag; //Флаг посещения узла при обходе.
  Tref Trail; //Указатель на список смежности.
  Lref Next; //Указатель на следующий узел в списке заголовочных узлов.
};

//Описание типа дугового узла.
typedef struct T
{
  Lref Id;
  Tref Next;
};

class Spisok
{
  private:
    Lref Head; //Указатель на голову списка заголовочных узлов.
    Lref Tail; //Указатель на фиктивный элемент
               // в конце списка заголовочных узлов.
    int  X[20]; //Результат работы программы.
    void SearchGraph (int, Lref *);
    Lref Search(int);
  public:
    Spisok() {//Инициализация списка заголовочных узлов.
              Head = Tail =  new (L); }
    Lref GetHead() { return Head; }
    Lref GetTail() { return Tail; }
    void MakeGraph ();
    void PrintGraph ();
    void AddGraph(int, int);
    void DeleteGraph(int, int);
    void Clique (int, int);
    void X1 (Lref t) {X[1] = t->Key;};
};

void main ()
{
  Spisok A;
  Lref t; //Рабочий указатель для перемещения
          // по списку заголовочных звеньев.
  Lref t1;
  int n=0;

  //Построение графа и вывод его структуры Вирта.
  A.MakeGraph ();
  A.PrintGraph (); cout<<endl;
  //Инициализация и подсчет количества вершин графа.
  t = A.GetHead();
  while (t!=A.GetTail())
    { n++; t = (*t).Next; }
  // ------------------------------------
  //Нахождение всех клик в графе Head.
  for (int i=3;i<=n;i++)
  {
    //i - количество вершин в клике (i<=3).
    cout << "Перечислим все клики длины " << i << endl;
    t = A.GetHead();
    while (t!=A.GetTail())
    {
       //Инициализация.
       t1 = A.GetHead();
       while (t1!=A.GetTail())
       { t1->Flag = TRUE; t1 = t1->Next;  }
       A.X1(t); t->Flag = FALSE;
       //Отыскание клики с i вершинами, "начинающейся" в вершине t.
       A.Clique (2,i); t = t->Next;
    }
  }
}

Lref Spisok::Search (int w)
//Функция возвращает указатель на заголовочный узел
//ключом w. Если узел отсутствует, то функция возвращает NULL .
{
  Lref h = Head;
  (*Tail).Key = w; //Поиск "с барьером".
  while ((*h).Key!=w) h = (*h).Next;
  if (h==Tail) //В списке заголовочных узлов нет узла с ключом w.
    h = NULL;
  return h;
}

void Spisok::AddGraph (int x,int y)
//Добавление дуги (x,y) (если ее не было!) к структуре
//Вирта, соответствующей ориентированному графу Head.
{
  Lref p,q;    //Рабочие указатели.
  Tref t,r;    //Рабочие указатели.
  Boolean Res; //Флаг наличия в графе данной дуги.

  //Определим, существует ли в графе дуга (x,y)?
  SearchGraph (x,&p); SearchGraph (y,&q);
  r = (*p).Trail; Res = FALSE;
  while ((r!=NULL)&&(!Res))
    if ((*r).Id==q) Res = TRUE; else r = (*r).Next;
  if (!Res)
  { //Если дуга отсутствует, то поместим её в граф.
    t = new (T); (*t).Id = q; (*t).Next = (*p).Trail;
    (*p).Trail = t; (*q).Count++;
  }
}

void Spisok::DeleteGraph (int x,int y)
//Функция возвращает указатель Head на структуру
//Вирта, соответствующую ориентированному графу
//и полученную удалением дуги (x,y).
{
  Lref p,q;    //Рабочие указатели.
  Tref t,r;    //Рабочие указатели.
  Boolean Res; //Флаг наличия в графе данной дуги.

  //Определим, существует ли в графе дуга (x,y)?
  p=Search (x); q= Search (y);
  if ((p!=NULL)&&(q!=NULL))
  { //Вершины x и y в графе есть.
    r = (*p).Trail; Res = FALSE;
    while ((r!=NULL)&&(!Res))
      if ((*r).Id==q) Res = TRUE;
      else r = (*r).Next;
   if (Res) //Если дуга существует, то удалим её.
   if (r==(*p).Trail)
     { (*p).Trail = (*(*p).Trail).Next; delete r; (*q).Count--; }
   else
    {
      t = (*p).Trail;
      while ((*t).Next!=r) t = (*t).Next;
      (*t).Next = (*(*t).Next).Next; delete r; (*q).Count--; }
    }
}

void Spisok::SearchGraph (int w, Lref *h)
//Функция возвращает указатель на заголовочный узел
//с ключом w в графе, заданном структурой Вирта с указателем Head.
{
  *h = Head; (*Tail).Key = w;
  while ((**h).Key!=w) *h = (**h).Next;
  if (*h==Tail)
  //В списке заголовочных узлов нет узла с ключом w.
  //Поместим его в конец списка Head.
  { Tail = new (L); (**h).Count = 0;
    (**h).Trail = NULL; (**h).Next = Tail; }
}

void Spisok::MakeGraph ()
//Функция возвращает указатель Head на структуру
//Вирта, соответствующую ориентированному графу.
{
  int x,y;
  Lref p,q; //Рабочие указатели.
  Tref t,r; //Рабочие указатели.
  Boolean Res; //Флаг наличия дуги.
  cout<<"Вводите начальную вершину дуги: ";
  cin>>x;
  while (x!=0)
  {
     cout<<"Вводите конечную вершину дуги: "; cin>>y;
     //Определим, существует ли в графе дуга (x,y)?
     SearchGraph (x, &p); SearchGraph (y,&q);
     r = (*p).Trail; Res = FALSE;
     while ((r!=NULL)&&(!Res))
       if ((*r).Id==q) Res = TRUE;
       else r = (*r).Next;
     if (!Res) //Если дуга отсутствует, то поместим её в граф.
      { t = new (T); (*t).Id = q;
        (*t).Next = (*p).Trail; (*p).Trail = t; (*q).Count++; }
     cout<<"Вводите начальную вершину дуги: "; cin>>x;
  }
}

void Spisok::PrintGraph ()
//Вывод структуры Вирта, заданной указателем
//Head и соответствующей ориентированному графу.
{
  Lref p; //Рабочий указатель.
  Tref q; //Рабочий указатель.

  p = Head;
  while (p!=Tail)
  {
     cout<< (*p).Key << "("; q = (*p).Trail;
     while (q!=NULL)
      { cout<<(*(*q).Id).Key; q = (*q).Next; }
     cout<<")"; p = (*p).Next; cout<<" ";
  }
}

void Spisok::Clique (int k, int m)
//Нахождение всех клик, содержащих m вершин, в графе,
//заданном структурой Вирта с указателем Head,
//k - количество вершин в частичном решении.
{
  Tref r,r1;   //Рабочие указатели.
  Lref p,q;    //Рабочие указатели.
  Lref t;      //Указатель на k-ю вершину частичного решения.
  int v;       //Вершина - кандидат на дополнение к частичному решению.
  Boolean Res; //Флаг клики.
  Boolean Res1;//Флаг существования ребра.
  int i;       //Параметр цикла.

  SearchGraph (X[k-1], &t);
  r = t->Trail;
  while ( r != NULL )
  {
    v = r->Id->Key;
    //Проверим, смежна ли вершина v с вершинами X[1],X[2],...,X[k-1].
    Res = TRUE;
    for (i=1;i<=k-1;i++)
    {
      //Cуществует ли в графе ребро (X[i],v)?
      SearchGraph (v, &p);
      SearchGraph (X[i], &q);
      r1 = p->Trail;
      Res1 = FALSE;
      while  (r1 != NULL && !Res1)
       if ( r1->Id==q ) Res1 = TRUE;
       else  r1 = r1->Next;
      Res = (Res && Res1);
    }
    if (!Res) r->Id->Flag = FALSE;
    // --------------------------
    if  (k==m && Res)
      //Количество вершин в графе равно m, и
      //вершины X[1],X[2],...,X[k] образуют клику.
      {
        //Вывод клики на экран дисплея.
        for (i=1;i<=k-1;i++) cout << X[i] << " ";
        cout << v << endl;
      }
    else
      if ( r->Id->Flag )
      {
        X[k] = r->Id->Key;
        r->Id->Flag = FALSE;
        Clique (k+1,m);
        r->Id->Flag = TRUE;
      }
    r = r->Next;
  }
}
Текст этой программы можно взять здесь.

Замечания.
    1. Пусть нам необходимо отыскать "специальное" множество M ребер графа G такое, что в M не должно быть смежных ребер. Множество M называют паросочетанием, а множество M* - с наибольшей мощностью - является наибольшим паросочетанием, его можно называть также наибольшим независимым множеством ребер [1, с.66].
Связь между наибольшими независимыми множествами вершин и наибольшими паросочетаниями устанавливается с помощью реберных графов.
    2. [2, с.73]. Одна из чисто житейских интерпретаций понятия независимости состоит в следующем. Определенный человек желает устроить юбилей с максимальным числом гостей из своих знакомых. Стремясь сделать юбилейный вечер приятным, он должен организовать все так, чтобы на этом вечере присутствовали люди, симпатизирующие друг другу. Так как отношение "симпатии" не является транзитивным, то ему для достижения цели придется находить число независимости графа своих знакомых.
Этот граф устроен следующим образом. Вершины его - знакомые юбиляра. Две вершины смежны, если соответствующие знакомые друг другу не симпатизируют. Нетрудно понять, что число независимости этого графа и представляет тот самый максимальный контингент приглашенных, который может себе позволить юбиляр.
    3. Рассмотрим следующую шахматную задачу. Сколько ферзей можно установить на шахматной жоске, чтобы они не "били" друг друга? Нетрудно убедиться, что искомое число равно 8, что соответствует утверждению о числе независимости графа шахматной доски G. Ясно, что аналогичные задачи могут быть сформулированы и для других шахматных фигур.
    4. [2, с.74]. Пусть Gn - граф "делимости" натуральных чисел. Вершины Gn - это числа 1,2,...,n, и две вершины i, jсмежны только в том случае, когда их наибольший общий делитель больше единицы. На рисунке изображен граф G8:

Рис.2. Граф G8
Нетрудно показать, что справедливо следущее равенство:
    a(Gn)=p(n),
где функция p(n) - число простых чисел, не превосходящих n. Полученное соотношение показывает, что нахождение числа независимости в общем случае не является простой задачей, уже хотя бы потому, что для частного вида графа она эквивалентна традиционно трудной задаче вычисления значения функции p(n).
    5. В работе [3] показано, что "почти все" n-вершинные графы имеют число независимости, лежащее в следующих границах:
    6.      [2(log2n-log2log2n)]<=a(G)<=[2(log2n-log2log2n)]+3



(1) Кристофидес Н. Теория графов. Алгоритмический подход. - М.: Мир, 1978. - 432 с.
(2) Компьютер и задачи выбора. - М.: Наука, 1989. - 208 с.
(3) Коршунов А.Д. Основные свойства случайных графов с большим числом вершин и ребер // УМН, 1985, т.40, вып.1 (241), с.107-173.

Со следующего шага мы начнем знакомиться с раскрасками.


        1.38. Раскраски
На этом шаге мы приведем общие сведения о раскрасках.
Разнообразные задачи, возникающие при планировании производства, составлении графиков осмотра, хранении и транспортировке товаров и т.д. могут быть представлены часто как задачи теории графов, тесно связанные с так называемой "задачей раскраски".
Пусть рассматриваемые графы являются неориентированными и не имеют петель.
Определение [1, с.73].
Граф G называют r-хроматическим, если его вершины могут быть раскрашены с использованием r цветов (красок) так, что не найдется двух смежных вершин одного цвета.
Наименьшее число r, такое, что граф G является r-хроматическим, называется хроматическим числом графа G и обозначается g(G).
Например, полный n-вершинный граф G имеет хроматическое число, равное n, а всякое дерево имеет хроматическое число равное двум.
Задача нахождения хроматического числа графа называется задачей о раскраске (задачей раскраски) графа.
Соответствующая хроматическому числу раскраска вершин разбивает множество вершин графа на r подмножеств, каждое из которых содержит вершины одного цвета. Эти множества являются независимыми, поскольку в пределах одного множества нет двух смежных вершин.
Вообще говоря, хроматическое число графа нельзя найти, зная только число вершин и число ребер графа. При известных величинах n (число вершин), m (число ребер) и d1, d2, ..., dn (степени вершин графа) можно получить верхнюю и нижнюю оценки для хроматического числа графа.
Вначале отметим, что поскольку между кликами графа G и максимальными независимыми множествами дополнительного графа G~ существует взаимно однозначное соответствие, то справедливы равенства
    r(G)= a(G~) и r(G~0)=a(G),
где a(G) - число независимости графа, r(G) - кликовое число графа G.
Теперь, поскольку по крайней мере r(G) цветов требуется для раскраски соответствующей клики графа G (той самой клики, которая "определяет" кликовое число графа G), что r(G) является нижней оценкой хроматического числа, т.е. g(G)>=r(G).
У.Татт в 1954 г. показал, что можно построить граф G с кликовым числом равным 2, который будет иметь произвольно большое заданное значение хроматического числа (граф Татта).
Поскольку a(G) равно мощности наибольшего множества попарно несмежных вершин графа G, то оно совпадает также с мощностью наибольшего множества вершин в G, которые могут быть окрашены в один цвет, и, следовательно,
    g(G) >= [n/a(G)]
где n - число вершин графа G, а [x] - целая часть числа x.
Нижние оценки хроматического числа безусловно более интересны, чем верхние, поскольку (если они достаточно близки к истинному значению) они могут быть использованы в процедуре вычисления g(G), включающей дерево поиска. В то же время верхние оценки хроматического числа подобного применения не находят.
Тем не менее в литературе приводятся формулы для вычисления верхних оценок хроматического числа; так Р.Бруксом предложена следующая легко вычисляемая оценка:
    g(G) <= 1 + max [d(vi)+1]
                vi принадлежит V
где d(vi) - степень вершины vi.
Приведем важную для построения алгоритма раскраски теорему.
Теорема [1, с.80].
Если граф является r-хроматическим, то он может быть раскрашен с использованием r (или меньшего числа) красок с помощью следующей процедуры: сначала в один цвет окрашивается некоторое максимальное независимое множество S1[G], затем окрашивается в следующий цвет множество S1[X-S1[G]] и т.д. до тех пор, пока не будут раскрашены все вершины.
Раскраску указанного в теореме вида будем называть оптимальной независимой раскраской.
Приведенный ниже пример показывает шаги алгоритма, описанного в теореме.
Максимальным независимым множеством вершин для графа

Рис.1. Пример графа
является {8,7,2,5}. Удаляем данные вершины из графа, предварительно присвоив им цвет 1:

Рис.2. Результат удаления
Максимальными независимыми множествами вершин для полученного графа будут {1,3}, {1,4}, {6,3}, {6,4}. Удалим из графа, например, вершины 1 и 4, присвоив им цвет 2. Оставшиеся в графе вершины 3 и 6 получают цвет 3.
Изобразим результат раскраски:

Рис.3. Результат раскраски


(1) Кристофидес Н. Теория графов. Алгоритмический подход. - М.: Мир, 1978. - 432 с.

На следующем шаге мы рассмотрим алгоритмы раскраски.


        1.39. Алгоритмы раскраски графа
На этом шаге мы рассмотрим алгоритмы закраски графа.
Задачи определения хроматического числа и построения минимальной раскраски произвольного графа являются очень сложными. С одной стороны, не известны алгоритмы их решения, сложность которых есть некоторая фиксированная степень от длины записи условий задачи (так называемые полиномиальные алгоритмы). С другой стороны, нигде явно не выражены те потери, которые мы несем от отсутствия таких алгоритмов [1, с.70].
Разумеется, есть лишь конечное число ситуаций, которые надо рассмотреть, чтобы найти хроматическое число n-вершинного графа. Действительно, всего имеется kn различных способов раскраски графа G в k цветов. Перебрав их, мы либо найдем правильную раскраску G в k цветов, либо убедимся, что таковой не существует. Ясно, что это самый примитивный способ решения задачи. Имеется целый ряд значительно более совершенных методов, использующих как оценки, так и другие соображения, призванные сократить перебор.
Рассмотрим простой алгоритм построения правильной раскраски [2, с.237], в ряде случаев приводящий к раскраскам, близким к минимальным.


Алгоритм последовательной раскраски
    1. Произвольной вершине v1 графа G припишем цвет 1.
    2. Если вершины v1, v2, ...,vi раскрашены l цветами 1, 2, ..., l, l<=i, то новой произвольно взятой вершине vi+1припишем минимальный цвет, не использованный при раскраске смежных вершин.
Приведем реализацию алгоритма, осуществляющего последовательную раскраску вершин графа при помощи обхода графа в глубину.

Пример 1.
//Последовательная раскраска вершин графа при помощи
//обхода графа в глубину.
//Граф представлен структурой Вирта.
#include <iostream.h>
#define TRUE 1
#define FALSE 0
typedef int Boolean;
typedef struct L *Lref; // Тип: указатель на заголовочный узел.
typedef struct T *Tref; // Тип: указатель на дуговой узел.

//Описание типа заголовочного узла.
typedef struct L
{
  int Key; //Имя заголовочного узла.
  int Color; //Цвет раскраски.
  int Count; //Количество предшественников.
  Boolean Flag; //Флаг посещения узла при обходе.
  Tref Trail; //Указатель на список смежности.
  Lref Next; //Указатель на следующий узел в списке заголовочных узлов.
};

//Описание типа дугового узла.
typedef struct T
{
  Lref Id;
  Tref Next;
};

class Spisok
{
  private:
    Lref Head; //Указатель на голову списка заголовочных узлов.
    Lref Tail; //Указатель на фиктивный элемент
               // в конце списка заголовочных узлов.
    int MSet[256]; //Вспомогательное множество, содер-
                   //жащее 0,1,2...,n.
    void SearchGraph (int, Lref *);
  public:
    Spisok() {//Инициализация списка заголовочных узлов.
              Head = Tail =  new (L); }
    Lref GetHead() { return Head; }
    Lref GetTail() { return Tail; }
    void MakeGraph ();
    void PrintGraph ();
    void Color (Lref, int);
    void Postr (int);
};

void main ()
{
  Spisok A;
  Lref t; //Рабочий указатель для перемещения
          // по списку заголовочных звеньев.
  int n=0; //Количество вершин в графе.

  //Построение графа и вывод его структуры Вирта.
  A.MakeGraph ();
  A.PrintGraph (); cout<<endl;
  //Раскраска с помощью рекурсивного обхода графа в глубину.
  //Инициализация.
  t = A.GetHead(); //Установлен рабочий указатель.
  while (t!=A.GetTail())
    { t->Flag = TRUE; t->Color = 0;
      n++; t = (*t).Next; }
  // ------------------------------------
  //Построение вспомогательного множества MSet.
  A.Postr(n);
  cout << "Результат раскраски: ";
  A.Color (A.GetHead(),n);
  cout << endl;
}

void Spisok::Postr (int n)
//Построение вспомогательного множества MSet.
{
  for (int i=0;i<256;i++)
    MSet[i] = (i<=n)?1:0;
}

void Spisok::SearchGraph (int w, Lref *h)
//Функция возвращает указатель на заголовочный узел
//с ключом w в графе, заданном структурой Вирта с указателем Head.
{
  *h = Head; (*Tail).Key = w;
  while ((**h).Key!=w) *h = (**h).Next;
  if (*h==Tail)
  //В списке заголовочных узлов нет узла с ключом w.
  //Поместим его в конец списка Head.
  { Tail = new (L); (**h).Count = 0;
    (**h).Trail = NULL; (**h).Next = Tail; }
}

void Spisok::MakeGraph ()
//Функция возвращает указатель Head на структуру
//Вирта, соответствующую ориентированному графу.
{
  int x,y;
  Lref p,q; //Рабочие указатели.
  Tref t,r; //Рабочие указатели.
  Boolean Res; //Флаг наличия дуги.
  cout<<"Вводите начальную вершину дуги: ";
  cin>>x;
  while (x!=0)
  {
     cout<<"Вводите конечную вершину дуги: "; cin>>y;
     //Определим, существует ли в графе дуга (x,y)?
     SearchGraph (x, &p); SearchGraph (y,&q);
     r = (*p).Trail; Res = FALSE;
     while ((r!=NULL)&&(!Res))
       if ((*r).Id==q) Res = TRUE;
       else r = (*r).Next;
     if (!Res) //Если дуга отсутствует, то поместим её в граф.
      { t = new (T); (*t).Id = q;
        (*t).Next = (*p).Trail; (*p).Trail = t; (*q).Count++; }
     cout<<"Вводите начальную вершину дуги: "; cin>>x;
  }
}

void Spisok::PrintGraph ()
//Вывод структуры Вирта, заданной указателем
//Head и соответствующей ориентированному графу.
{
  Lref p; //Рабочий указатель.
  Tref q; //Рабочий указатель.

  p = Head;
  while (p!=Tail)
  {
     cout<< (*p).Key << "("; q = (*p).Trail;
     while (q!=NULL)
      { cout<<(*(*q).Id).Key; q = (*q).Next; }
     cout<<")"; p = (*p).Next; cout<<" ";
  }
}

void Spisok::Color (Lref r, int n)
//Последовательная раскраска графа при помощи
//рекурсивного обхода графа в глубину.
//r - указатель на структуру Вирта.
//MSet - глобальное множество.
//n    - количество вершин в графе.
{
  Tref t,t1;
  int i;         //Параметр цикла.
  Boolean Fl;

  t = r->Trail; r->Flag = FALSE;
  //Сейчас мы находимся в вершине r->Key.
  //Исключим цвета всех вершин, смежных вершине
  //r->Key, из множества MSet.
  t1 = t;
  while ( t1 != NULL )
  {  MSet[t1->Id->Color] = 0; t1 = t1->Next; }
  //Выбор цвета вершины: это "первый" элемент множества MSet.
  Fl = TRUE; i = 1;
  while ( Fl )
   if ( MSet[i] ) Fl = FALSE; else  i++;
  r->Color = i;   //Цвет присвоен!
  cout << "(" << r->Key << "," << r->Color << ") ";
  //Восстановление вспомогательного множества MSet.
  for (i=0;i<256;MSet[i++]=0);
  for (i=0;i<=n;MSet[i++]=1);
  // -------------
  while ( t != NULL )
  {
    if ( t->Id->Flag ) Color (t->Id,n);
    t = t->Next;
  }
}
Текст этой программы можно взять здесь.
Приведем реализацию алгоритма, осуществляющего последовательную раскраску вершин графа при помощи обхода графа в ширину.
//Последовательная раскраска графа при помощи
//обхода графа в ширину.
//Граф представлен структурой Вирта.
#include <iostream.h>
#define TRUE 1
#define FALSE 0
typedef int Boolean;
typedef struct Leader *Lref; // Тип: указатель на заголовочный узел.
typedef struct Trailer *Tref; // Тип: указатель на дуговой узел.

//Описание типа заголовочного узла.
typedef struct Leader
{
  int Key; //Имя заголовочного узла.
  int Count; //Количество предшественников.
  int Color; //Цвет раскраски.
  Boolean Flag; //Флаг посещения узла при обходе.
  Tref Trail; //Указатель на список смежности.
  Lref Next; //Указатель на следующий узел в списке заголовочных узлов.
};

//Описание типа дугового узла.
typedef struct Trailer
{
  Lref Id;
  Tref Next;
};

//Описание типа узла очереди.
typedef Lref TipElement; //Указатель на звено заголовочного списка.
typedef struct Zveno *svqz;
typedef struct Zveno
{
  TipElement Element; //Указатель на список смежности.
  svqz Sled;
};

class Spisok
{
  private:
     Lref Head; //Указатель на голову списка заголовочных узлов.
     Lref Tail; //Указатель на фиктивный элемент
                // в конце списка заголовочных узлов.
     int MSet[256]; //Вспомогательное множество, содер-
                    //жащее 0,1,2...,n.
     void Udalenie_A (svqz *, svqz *, TipElement *);
     void Dobavlenie (svqz *, svqz *, TipElement);
     void SearchGraph (int, Lref *);
  public:
     Spisok() {//Инициализация списка заголовочных узлов.
                Head = Tail =  new (Leader); }
     Lref GetHead() { return Head; }
     Lref GetTail() { return Tail; }
     void MakeGraph ();
     void PrintGraph ();
     void Color (Lref, int);
     void Postr (int);
};

void main ()
{
  Spisok A;
  Lref t; //Рабочий указатель для перемещения
          // по списку заголовочных звеньев.
  int n=0; //Количество вершин в графе.

  //Построение графа и вывод его структуры Вирта.
  A.MakeGraph ();
  A.PrintGraph (); cout<<endl;
  //Раскраска с помощью рекурсивного обхода графа в ширину.
  //Инициализация.
  t = A.GetHead(); //Установлен рабочий указатель.
  while (t!=A.GetTail())
    { t->Flag = TRUE; t->Color = 0;
      n++; t = (*t).Next; }
  // ------------------------------------
  //Построение вспомогательного множества MSet.
  A.Postr(n);
  cout << "Результат раскраски: ";
  A.Color (A.GetHead(),n);
  cout << endl;
}

void Spisok::Postr (int n)
//Построение вспомогательного множества MSet.
{
  for (int i=0;i<256;i++)
    MSet[i] = (i<=n)?1:0;
}

void Spisok::SearchGraph (int w, Lref *h)
//Функция возвращает указатель на заголовочный узел
//с ключом w в графе, заданном структурой Вирта с указателем Head.
{
  *h = Head; (*Tail).Key = w;
  while ((**h).Key!=w) *h = (**h).Next;
  if (*h==Tail)
  //В списке заголовочных узлов нет узла с ключом w.
  //Поместим его в конец списка Head.
  { Tail = new (Leader); (**h).Count = 0;
	 (**h).Trail = NULL; (**h).Next = Tail; }
}

void Spisok::MakeGraph ()
//Функция возвращает указатель Head на структуру
//Вирта, соответствующую ориентированному графу.
{
  int x,y;
  Lref p,q; //Рабочие указатели.
  Tref t,r; //Рабочие указатели.
  Boolean Res; //Флаг наличия дуги.
  cout<<"Вводите начальную вершину дуги: ";
  cin>>x;
  while (x!=0)
  {
	  cout<<"Вводите конечную вершину дуги: "; cin>>y;
	  //Определим, существует ли в графе дуга (x,y)?
	  SearchGraph (x, &p); SearchGraph (y,&q);
	  r = (*p).Trail; Res = FALSE;
	  while ((r!=NULL)&&(!Res))
		 if ((*r).Id==q) Res = TRUE;
		 else r = (*r).Next;
	  if (!Res) //Если дуга отсутствует, то поместим её в граф.
		{ t = new (Trailer); (*t).Id = q;
		  (*t).Next = (*p).Trail; (*p).Trail = t; (*q).Count++; }
	  cout<<"Вводите начальную вершину дуги: "; cin>>x;
  }
}

void Spisok::PrintGraph ()
//Вывод структуры Вирта, заданной указателем
//Head и соответствующей ориентированному графу.
{
  Lref p; //Рабочий указатель.
  Tref q; //Рабочий указатель.

  p = Head;
  while (p!=Tail)
  {
	  cout<<(*p).Key<<"("; q = (*p).Trail;
	  while (q!=NULL)
		{ cout<<(*(*q).Id).Key; q = (*q).Next; }
	  cout<<")"; p = (*p).Next; cout<<" ";
  }
}

void Spisok::Dobavlenie (svqz *L, svqz *R, TipElement elem)
//Добавление элемента elem в очередь, заданную указателями L и R.
{
  svqz K = new (Zveno);

  K->Element = elem; K->Sled = NULL;
  if (*L==NULL)
	 { (*L) = K; (*R) = K; }
  else { (*R)->Sled = K; (*R) = K; }
}

void Spisok::Udalenie_A (svqz *L, svqz *R, TipElement *A)
//Удаление элемента из очереди, заданной указателями L и R и
//помещение удаленного элемента в переменную A.
{
  svqz q;

  if ((*L)!=NULL)
   if ((*L)->Sled!=NULL)
   {
     (*A) = (*L)->Element; q = (*L);
     (*L) = (*L)->Sled; delete q;
   }
   else {
         (*A) = (*L)->Element; delete *L;
         (*L) = (*R) = NULL;
        }
}

void Spisok::Color (Lref H, int n)
//Последовательная раскраска графа при помощи обхода графа
//в ширину, начиная с вершины, заданной указателем H
//(нерекурсивный обход).
{
  svqz L;   // Указатель на начало очереди.
  svqz R;   // Указатель на конец  очереди.
  Lref p;   // Рабочий указатель.
  Tref t;   // Рабочий указатель.
  Tref t1;
  int i;    // Параметр цикла.
  Boolean Fl;

  L = R = NULL; // Создание пустой очереди.
  Dobavlenie (&L,&R,H); H->Flag = FALSE;
  while ( L != NULL )
  {  //Пока очередь не пуста...
     Udalenie_A (&L,&R,&p);
     t = p->Trail;
     //Сейчас мы находимся в вершине r->Key.
     //Исключим цвета всех вершин, смежных вершине
     //r->Key, из множества MSet.
     t1 = t;
     while ( t1 != NULL )
     {  MSet[t1->Id->Color] = 0; t1 = t1->Next; }
     //Выбор цвета вершины - "первого" элемента множества MSet.
     Fl = TRUE; i = 1;
     while ( Fl )
      if ( MSet[i] ) Fl = FALSE; else  i++;
     p->Color = i;   //Цвет присвоен!
     cout << "(" << p->Key << "," << p->Color << ") ";
     //Восстановление вспомогательного множества MSet.
     for (i=0;i<256;MSet[i++]=0);
     for (i=0;i<=n;MSet[i++]=1);
     while ( t != NULL )
     {
       if ( t->Id->Flag )
       {
          Dobavlenie (&L,&R,t->Id);
          t->Id->Flag = FALSE;
       }
       t = t->Next;
     }
  }
}
Текст этой программы можно взять здесь.

Пример 3.
//Последовательная раскраска графа, представленного с помощью
//модифицированных списков смежности.
#include <iostream.h>
#include <conio.h>
#define TRUE 1
#define FALSE 0
#define XRY 8  //Количество вершин графа.
typedef int Boolean;
typedef struct zveno *svqz;
typedef struct zveno
{
  int Key;  // Вершина графа.
  svqz Up;  // Указатель на смежную вершину.
  svqz Sled;// Указатель на следующую смежную вершину.
};

class Spisok
{
  private:
     svqz Beg[XRY+1]; //Массив указателей на вершины.
     void Add_Ver (int);
     int Find (int, int, svqz *);
     void Add_duga (int, int);
     void Make (int, int);
     void Delinenok (int, int);
     void Del_Duga (int, int);
     void Del_Ver (int);
     int Find_Color (int, int, svqz *);
  public:
     Spisok();
     void Init_Graph ();
     void Make_Graph ();
     void Print_Graph ();
     void Color ();
     void Print_Color ();
};

void main ()
{
  Spisok A;

  //Инициализация графа.
  A.Init_Graph ();
  //Построение графа.
  A.Make_Graph ();
  //Вывод графа.
  A.Print_Graph ();
  getch();
  //Последовательная раскраска графа, представленного
  //модифицированными списками смежности.
  A.Color ();
  A.Print_Color ();
  getch();
}

Spisok::Spisok()
{
  for ( int i=0; i<=XRY;Beg[i++] = NULL );
}

void Spisok::Add_Ver (int x)
//Функция создания вершины x.
{
  svqz Ukaz = new (zveno);

  Ukaz->Sled = NULL;
  Beg[x] = Ukaz;
}

void Spisok::Init_Graph ()
//Функция инициализации модифицированных списков смежности.
{
  for (int i=1;i<=XRY;i++) Add_Ver (i);
}

int Spisok::Find (int x, int y, svqz *UkZv)
//Функция проверки смежности вершин y и x. Функция возвращает
//TRUE, если  вершина x смежна с вершиной y. Указатель *UkZv,
//возвращает указатель на место y в списке  смежности x. Если
//вершина x не смежна с вершиной y, то UkZv есть NULL.
{
  svqz Ukaz;

  Ukaz = Beg[x]->Sled;
  while  (Ukaz != NULL && Ukaz->Key != y)
     Ukaz = Ukaz->Sled;
  *UkZv = Ukaz;
  return  ( Ukaz != NULL );
}

void Spisok::Add_duga (int x, int y)
//Функция создания дуги (x,y).
{
  svqz Ukaz = new (zveno);

   Ukaz->Sled = Beg[x]->Sled; Ukaz->Key = y;
   Beg[x]->Sled = Ukaz;
}

void Spisok::Make (int x, int y)
//Функция создания ребра {x,y}.
{
  svqz Ukaz;

  if  ( !Find(x,y,&Ukaz) )
  {
     Add_duga (x,y);
     if ( x != y ) Add_duga (y,x);
     Beg[x]->Sled->Up = Beg[y];
     Beg[y]->Sled->Up = Beg[x];
  }
}

void Spisok::Make_Graph ()
//Функция построения модифицированных списков смежности.
{
  int f;

  for (int i=1;i<=XRY;i++)
  {
    cout << "Введите вершины, смежные с " << i << "-й вершиной: ";
    cin >> f;
    while (f!=0)
    {
      Make (i,f);
      cout << " ";
      cin >> f;
    }
    cout << endl;
  }
}

void Spisok::Delinenok (int x, int y)
//Функция удаления дуги (x,y).
{
  svqz Ukaz;
  svqz Ukazlenok;

  Ukazlenok = Beg[x]; Ukaz = Beg[x]->Sled;
  while (Ukaz != NULL && Ukaz->Key != y)
  {  Ukazlenok = Ukaz; Ukaz = Ukaz->Sled; }
  if ( Ukaz != NULL )
  {
     Ukazlenok->Sled = Ukaz->Sled;
     delete Ukaz;
  }
}

void Spisok::Del_Duga (int x, int y)
//Функция удаления ребра {x,y}.
{
  Delinenok (x,y); Delinenok (y,x);
}

void Spisok::Del_Ver (int x)
//Функция удаления вершины x.
{
  svqz Ukaz;
  svqz Ukazlenok;

  for (int i=1;i<=XRY;i++) Delinenok (i,x);
  Ukaz = Beg[x]; Beg[x] = NULL;
  while ( Ukaz != NULL )
  {
     Ukazlenok = Ukaz->Sled;
     delete Ukaz; Ukaz = Ukazlenok;
  }
}

void Spisok::Print_Graph ()
//Функция вывода содеpжимого модифицированных
//списков смежности.
{
  svqz UkZv;

  for (int i=1;i<=XRY;i++)
  {
    if ( Beg[i] != NULL )
    {
      UkZv = Beg[i]->Sled;
      cout << i << " - ";
      while ( UkZv != NULL )
      {
        cout << " " << UkZv->Key;
        UkZv = UkZv->Sled;
      }
    }
    cout << endl;
  }
}

int Spisok::Find_Color (int x, int c, svqz *UkZv)
//Функция  выявления возможности раскраски вершины  x цветом c.
//Функция  возвращает TRUE, если вершину  x  можно  раскрасить.
//Указатель *UkZv, возвращает указатель на вершину, смежную с x
//и раскрашенную цветом c. Если вершину x можно раскрасить, то
//*UkZv есть NULL.
{
   int i = 1;

   while (!(Find(x,i,&(*UkZv)) &&
          Beg[i]->Key==c)   &&
          i != x) i++;
   return (i==x);
}

void Spisok::Color ()
//Функция последовательной раскраски графа, заданного
//модифицированными списками смежности Beg.
{
  int i = 1;
  int c = 1;
  svqz UkZv;

  while  (Beg[i] == NULL && i<=XRY) i++;
  if ( i != XRY )
  {
    Beg[i]->Key = c;
    i++;
    while  (i<=XRY)
     if ( Beg[i] != NULL )
     {
       c = 1;
       while  (!Find_Color(i,c,&UkZv)) c++;
       Beg[i]->Key = c; i++;
     }
     else  i++;
  }
  else  cout << "Граф отсутствует!";
}

void Spisok::Print_Color ()
//Функция вывода раскраски графа, заданного
//модифицированными списками смежности Beg.
{
  for (int i=1;i<=XRY;i++)
    if ( Beg[i] != NULL )
       cout << " Color " << i << " - " << Beg[i]->Key << endl;
}
Текст этой программы можно взять здесь.
Результат работы приложения изображен на рисунке 1:

Рис.1. Результат работы приложения
Отметим, что для некоторых классов графов (например, полных k-дольных) последовательная раскраска является минимальной [2, с.238].
В общем случае это не так!


Алгоритм прямого неявного перебора
Приведем теперь алгоритм прямого неявного перебора для определения хроматического числа графа, использующий дерево поиска [3, с.89-90].
Предположим, что множество вершин каким-то образом упорядочено и vi - i-я вершина этого множества.
Вначале построим первоначальную допустимую раскраску по следующему алгоритму:
1) окрасить v1 в цвет 1;
2) каждую из оставшихся вершин окрашивать последовательно в соответствии с заданным упорядочением: вершина vi окрашивается в цвет с наименьшим возможным "номером" (т.е. выбираемый цвет должен быть первым в данном упорядочении цветом, не использованным при окраске какой-либо вершины, смежной с vi).
Опишем последующие шаги алгоритма согласно монографии [3, с.89].
Пусть q - число цветов, требуемое для вышеупомянутой раскраски. Если существует раскраска, использующая только q-1 цветов, то все вершины, окрашенные в цвет q, должны быть перекрашены в цвет j<q. Пусть vi* - первая вершина при заданном упорядочении, которая была окрашена в цвет q. Поскольку она была так окрашена потому, что не могла быть окрашена в цвет j<q, то ее можно перекрасить в цвет j
Итак, шаг возвращения из вершины vi* можно осуществить следующим образом. Из смежных с vi* вершин в множестве {x1, x2, ..., xi*-1} найти последнюю (при заданном упорядочении), т.е. вершину с наибольшим индексом. Пусть это будет вершина xk. Если xk окрашена в цветjk, то xk перекрашивается в другой допустимый цвет с наименьшим возможным "номером" jk', таким, что jk' >= jk+1.
Если jk'<q, то надо продолжать последовательно перекрашивать все вершины с xk+1 до xn, применяя указанное выше правило 2 и помня о том, что цвет q использовать нельзя.
Если такая процедура осуществима, то будет найдена новая лучшая раскраска, использующая меньше, чем q цветов. В противном случае, т.е. если встретится вершина, "требующая" цвет q, то можно снова сделать шаг возвращения - из такой вершины.
Если jk'=q или нет другого допустимого цвета jk', то можно сразу же делать шаг возвращения из вершины xk.
Алгоритм заканчивает работу, когда на шаге возвращения достигается вершина x1.
Хотя описанная процедура неявного перебора является примитивным древовидным поиском, тем не менее она ничуть не хуже других известных методов раскраски графов [3, с.90].

Замечание [1, с.70]. Мы не привели пока ни одного интересного примера, в котором хроматическое число выступает в роли объекта, практическая важность изучения которого несомненна. Попытаемся восполнить этот пробел.
Задача об обслуживании авиалиний.
Имеется некоторый город M, который связан маршрутами с городами A1, A2, ..., Am. Пусть, согласно расписанию, маршрут MAiM обслуживается в интервале времени [ai, bi]. Другими словами, ai - это тот момент, начиная с которого самолет связан с маршрутом MAiM, а bi - тот момент, когда эта связь прекращается. Таким образом, задано m временных интервалов [a1, b1], ..., [am, bm]. Требуется указать, каково минимальное число самолетов, достаточное для обслуживания всех рейсов?
Соответствующему расписанию сопоставим граф G, вершинами которого будут заданные временные интервалы, а две вершины будут смежны тогда и только тогда, когда соответствующие интервалы имеют непустое пересечение. Этот граф и служит моделью для нашей задачи.
Утверждение.
Искомое число самолетов равно хроматическому числу графа G.
Действительно, все рейсы, имеющие одинаковый цвет, могут быть обслужены одним самолетом. С другой стороны, если имеется некоторое число самолетов для обслуживания всех рейсов, то, окрасив одним цветом все рейсы, обслуживаемые одним самолетом, мы получим некоторую правильную раскраску графа G. Эти соображения и обосновывают сформулированное утверждение.



(1) Компьютер и задачи выбора. - М.: Наука, 1989. - 208 с.
(2) Лекции по теории графов / Емеличев В.А., Мельников О.И., Сарванов В.И., Тышкевич Р.И. - М.: Наука, 1990. - 384 с.
(3) Кристофидес Н. Теория графов. Алгоритмический подход. - М.: Мир, 1978. - 432 с.

На следующем шаге мы рассмотрим изоморфизм графов.

        1.40. Изоморфизм
На этом шаге мы рассмотрим алгоритмы, определяющие изоморфизм графов.
Напомним сначала Вам несколько определений.
Определение 1.
Пусть G и H - графы, f - взаимно однозначное отображение множества V(G) на множество V(H) и g - взаимно однозначное отображение E(G) на E(H). Обозначим Q упорядоченную пару (f,g). Будем говорить, что Q естьизоморфное отображение (изоморфизм) графа G на граф H, если выполняется следующее условие: вершина xинцидентна ребру A в графе G тогда и только тогда, когда вершина fx инцидентна ребру gA в графе H.
Если такой изоморфизм Q существует, то будем говорить, что графы G и H изоморфны. Ясно, что в этом случае
    |V(G)| = |V(H)| и |E(G)| = |E(H)|.
Мы можем рассматривать Q как операцию, преобразующую граф G в граф H, и в соответствии с этим писать QG=H. Удобно также писать Qv=fv и QA=gA (для каждой вершины v и каждого ребра A графа G).
Автоморфизмом графа G называется изоморфизм графа G на себя.
Всякий граф G имеет тождественный (или тривиальный) автоморфизм I, такой, что Ix=x для каждого ребра x и каждой вершины x из G.
Можно показать [1, с.21], что отношение изоморфизма между графами является отношением эквивалентности, т.е. оно симметрично, транзитивно и рефлексивно. Следовательно, оно разбивает класс всех графов на непустые и попарно непересекающиеся подклассы, называемые классами изоморфизма или классами изоморфных графов. Два произвольных графа принадлежат одному и тому же классу изоморфизма тогда и только тогда, когда они изоморфны друг другу.
Изоморфные графы естественно отождествлять, т.е. считать совпадающими (их можно изобразить одним рисунком). Они могли бы различаться конкретной природой своих элементов, но именно это игнорируется при введении понятия "граф".
Математическая теория графов интересуется такими свойствами графов, которые инвариантны относительно изоморфизма (например, числом вершин в графе, числом петель или числом вершин данной валентности и т.д.). Для специалиста по теории графов естественно отождествлять изоморфные графы. Поэтому обычно речь идет о классах изоморфизма (называемых также абстрактными графами).
Вопрос о том, изоморфны ли два данных графа, в общем случае оказывается сложным (см., например, [2]).
Для изоморфизма двух n-вершинных графов само определение этого отношения дает теоретически безукоризненный способ проверки: надо просмотреть все n! взаимно однозначных соответствий между множествами вершин и установить, совмещаются ли полностью ребра графа хотя бы при одном соответствии. Однако даже весьма грубая оценка показывает, что такое решение задачи "в лоб" практически непригодно: уже при n=20 перебор всех n!вариантов потребовал бы около 40 лет машинного времени.
Подобная ситуация, естественно, толкнула многих математиков на классический путь: попытаться найти такой инвариант (число или систему чисел), который бы, с одной стороны, легко вычислялся по заданному графу (и по возможности имел наглядный смысл), а с другой - обладал свойством полноты, т.е. определял граф однозначно с точностью до изоморфизма.
Вначале естественно поставить вопрос: какие характеристики графов инвариантны относительно изоморфизма [3,с.21]?
Примеры таких инвариантов графа G известны: это число вершин n(G), число ребер m(G) и вектор степеней s(G)=(s1, s2, ...,sn), который, в частности, дает числовые инварианты
     min  si      и        max  si
  i принадлежит {1,2,...,n}      i принадлежит {1,2,...,n}
Второй из них часто называется степенью графа.

Определение 2.
Пусть f - функция, относящая каждому графу G некоторый элемент f(G) из множества M произвольной природы. Эту функцию мы будем называть инвариантом, если на изоморфных графах ее значения совпадают, т.е. для любых G и G' из изоморфности графов G и G' следует f(G)=f(G').
Введем несколько наиболее важных инвариантов графа [3, с.21-25]:
    • плотность f(G) - число вершин клики графа G. Инвариантность этой характеристики следует из того, что при изоморфном соответствии двух графов каждому подмножеству вершин одного графа, порождающему клику, соответствует в другом графе подмножество с тем же числом вершин и тоже порождающее клику;
    • неплотность e(G) - это наибольшее количество попарно несмежных вершин графа;
    • xроматическое число g(G);
    • число компонент связности K(G);
    • число Хадвигера h(G).
Заметим, что матрица смежностей не является инвариантом графа: при переходе от одной нумерации его вершин к другой она претерпевает перестановку рядов, состоящую из некоторой перестановки строк и точно такой же перестановки столбцов. Любая функция от элементов aij матрицы, не меняющаяся ни при каких перестановках рядов матрицы смежности, является инвариантом графа G. К числу таких функций относятся сумма всех элементов, неупорядоченный набор сумм элементов каждой строки или сумм элементов каждого столбца, определитель матрицы, ее характеристический многочлен и корни последнего и др.

Определение 3 [3, с.41-42].
Инвариант f называется полным, если для любых графов G и G' из равенства f(G)=f(G') следует изоморфизм графов G и G'.
Из рассмотренных инвариантов, которые отнесены к "легко вычислимым", даже наиболее "богатый" - вектор степеней s(G) - не является полным. В процессе развития теории графов не было нехватки в гипотезах полноты или иного "трудно вычислимого" инварианта, но все эти гипотезы рано или поздно опровергались конкретными примерами.

Определение 4.
Степенью s вершины v графа (V,E) называется число его вершин, смежных с v, или, что то же, число ребер, инцидентных этой вершине.
Ясно, что при всяком изоморфизме графов L и L' соответствующие друг другу вершины должны иметь одинаковую степень.

Определение 5 [3,с.17].
Пусть G=(V,E) - n-вершинный граф, а s1, s2, ...,sn - степени его вершин, выписанные в порядке неубывания: s1<= s2 <= ... <= sn.
Упорядоченную систему (s1, s2, ...,sn) будем называть вектором степеней графа G и кратко обозначать s(G).
Вместо самого вектора степеней часто пользуются его обращением t(G)=(t1, t2, ...,tn), где ti=sn-i (i=1,2,...,n) - те же степени вершин, но расположенные в порядке невозрастания: t1 >= t2 >= ... >= tn.
Из сказанного выше следует, что для изоморфизма графов G и G' необходимо совпадение векторов их степеней: s(G)=s(G').
Однако достаточным это условие не является: на рисунке 1 мы видим две пары неизоморфных графов с одинаковыми векторами: s = (1,2,2,2,2,3):

Рис.1. Пара неизоморфных графов
Не будучи идеальным средством распознавания изоморфизма, вектор степеней может тем не менее во многих случаях оказать существенную помощь.
Во-первых, если s(G) не равно s(G'), то отсюда сразу следует неизоморфность графов G и G'.
Во-вторых, если s(G)=s(G'), то для проверки графов G и G' на изоморфизм требуется перебор не всех n!соответствий между вершинами, а лишь тех, при которых сопоставляются вершины одинаковой степени. Так в примере надо перебрать лишь 4!=24 соответствия вместо 720 [3,с.17].

Пример. Распознавание изоморфизма неориентированных графов с помощью анализа вектора степеней. Результатом работы программы являются все взаимно-однозначные отоб 1ражения множества вершин первого графа на множество вершин второго графа, определяющие изоморфизм.
В программе существенным образом использован модификация алгоритма Джонсона и Троттера генерирования всех перестановок с минимальным числом транспозиций соседних элементов.
#include <iostream.h>
#define TRUE 1
#define FALSE 0
#define M 10 //Максимальное количество вершин в графе.
typedef int Boolean;
typedef struct L *Lref; // Тип: указатель на заголовочный узел.
typedef struct T *Tref; // Тип: указатель на дуговой узел.

//Описание типа заголовочного узла.
typedef struct L
{
  int Key; //Имя заголовочного узла.
  int Count; //Количество предшественников.
  Tref Trail; //Указатель на список смежности.
  Lref Next; //Указатель на следующий узел в списке заголовочных узлов.
};

//Описание типа дугового узла.
typedef struct T
{
  Lref Id;
  Tref Next;
};

class Spisok
{
  private:
    Lref Head; //Указатель на голову списка заголовочных узлов.
    Lref Tail; //Указатель на фиктивный элемент
               // в конце списка заголовочных узлов.
    int Fun[M+1]; //Массив вершин графа.
    int NewFun[M+1]; //Массив перестановок элементов массива Fun.
    void SearchGraph (int, Lref *);
    Lref Search(int);
    Boolean Find_Arc (int, int);
    Boolean Isomorph (Spisok, int);
  public:
    Spisok() {//Инициализация списка заголовочных узлов.
              Head = Tail =  new (L); }
    Lref GetHead() { return Head; }
    Lref GetTail() { return Tail; }
    void MakeGraph ();
    void PrintGraph ();
    void Sorting ();
    friend void Reshenie(Spisok,Spisok);
};

void main ()
{
  Spisok A,B;

  //Построение графов и вывод их структур смежности.
  A.MakeGraph ();
  A.PrintGraph (); cout<<endl;
  B.MakeGraph ();
  B.PrintGraph (); cout<<endl;
  A.Sorting ();
  A.PrintGraph (); cout<<endl;
  B.Sorting ();
  B.PrintGraph (); cout<<endl;
  //Решение.
  Reshenie(A,B);
}

void Reshenie(Spisok A, Spisok B)
//Решение задачи.
{
   Lref Ukaz;      //Рабочий указатель для перемещения
                   // по списку заголовочных звеньев.
   int P[M+1];     //Массив для перестановок.
   int Ves[M+1];   //Массив "весов" элементов массива P
                   //(в нем хранятся степени вершин).
   int Ves1[M+1];  //Вначале - копия массива Ves,
                   //затем - рабочий массив.
   Boolean Fl;     //Флаг совпадения массивов Ves и Ves1.
   Boolean PR[M+1];
   int C[M+1];
   int x,k,t;

  //Определение количества вершин и функций.
  int N=0;
  Ukaz = A.GetHead();
  while (Ukaz!=A.GetTail())
    { N++;
      A.Fun[N] = A.NewFun[N] = Ukaz->Key; Ves[N] = Ukaz->Count;
      Ves1[N] = Ves[N]; Ukaz = Ukaz->Next;
    }
  N=0;
  Ukaz = B.GetHead();
  while (Ukaz!=B.GetTail())
    { N++;
      B.Fun[N] = Ukaz->Key; Ukaz = Ukaz->Next;
    }
  for (int i=1;i<=N;i++) cout << Ves[i] << " "; cout << endl;
  for (i=1;i<=N;i++) cout << A.Fun[i] << " "; cout << endl;
  for (i=1;i<=N;i++) cout << B.Fun[i] << " "; cout << endl;
  //Инициализация.
  for (i=1;i<=N;i++)
    { P[i] = i; C[i] = 1; PR[i] = TRUE; }
  //Нахождение перестановок.
  C[N] = 0;
  cout << "Отображение вершин, определяющее изоморфизм: \n";
  if ( A.Isomorph (B,N) )
  {
    for(int j=1;j<=N;j++) A.NewFun[j] = A.Fun[P[j]];
    for(j=1;j<=N;j++) cout << A.NewFun[j] << " ";
    cout << endl;
    for(j=1;j<=N;j++) cout << B.Fun[j] << " ";
    cout << endl;
  }
  cout << " --------------------------- \n";
  i = 1;
  while ( i<N )
  {
    i = 1; x = 0;
    while ( C[i]==N-i+1 )
    {
       PR[i] = (!PR[i]); C[i] = 1;
       if ( PR[i]) x++;
       i++;
    }
    if ( i<N )
    //Выполнение транспозиции.
    {
       if ( PR[i] )  k = C[i] + x;
       else  k = N - i + 1 - C[i] + x;
       t = P[k]; P[k] = P[k+1]; P[k+1] = t;
       t = Ves1[k]; Ves1[k] = Ves1[k+1];
       Ves1[k+1] = t; C[i] += 1;
       //Отбор нужной перестановки.
       Fl = TRUE;
       for (int j=1;j<=N;j++) Fl = (Fl && (Ves[j]==Ves1[j]));
       if ( Fl )
       {
          for (j=1;j<=N;j++) A.NewFun[j] = A.Fun[P[j]];
          if (A.Isomorph (B,N))
          {
             for (j=1;j<=N;j++) cout << A.NewFun[j] << " ";
             cout << endl;
             for (j=1;j<=N;j++) cout << B.Fun[j] << " ";
             cout << endl;
             cout << " --------------------------- \n";
           }
       }
    }
  }
}

Lref Spisok::Search (int w)
//Функция возвращает указатель на заголовочный узел
//ключом w. Если узел отсутствует, то функция возвращает NULL .
{
  Lref h = Head;
  (*Tail).Key = w; //Поиск "с барьером".
  while ((*h).Key!=w) h = (*h).Next;
  if (h==Tail) //В списке заголовочных узлов нет узла с ключом w.
    h = NULL;
  return h;
}

void Spisok::SearchGraph (int w, Lref *h)
//Функция возвращает указатель на заголовочный узел
//с ключом w в графе, заданном структурой Вирта с указателем Head.
{
  *h = Head; (*Tail).Key = w;
  while ((**h).Key!=w) *h = (**h).Next;
  if (*h==Tail)
  //В списке заголовочных узлов нет узла с ключом w.
  //Поместим его в конец списка Head.
  { Tail = new (L); (**h).Count = 0;
    (**h).Trail = NULL; (**h).Next = Tail; }
}

void Spisok::MakeGraph ()
//Функция возвращает указатель Head на структуру
//Вирта, соответствующую ориентированному графу.
{
  int x,y;
  Lref p,q; //Рабочие указатели.
  Tref t,r; //Рабочие указатели.
  Boolean Res; //Флаг наличия дуги.
  cout<<"Вводите начальную вершину дуги: ";
  cin>>x;
  while (x!=0)
  {
     cout<<"Вводите конечную вершину дуги: "; cin>>y;
     //Определим, существует ли в графе дуга (x,y)?
     SearchGraph (x, &p); SearchGraph (y,&q);
     r = (*p).Trail; Res = FALSE;
     while ((r!=NULL)&&(!Res))
       if ((*r).Id==q) Res = TRUE;
       else r = (*r).Next;
     if (!Res) //Если дуга отсутствует, то поместим её в граф.
      { t = new (T); (*t).Id = q;
        (*t).Next = (*p).Trail; (*p).Trail = t; (*q).Count++; }
     cout<<"Вводите начальную вершину дуги: "; cin>>x;
  }
}

void Spisok::PrintGraph ()
//Вывод структуры Вирта, заданной указателем
//Head и соответствующей ориентированному графу.
{
  Lref p; //Рабочий указатель.
  Tref q; //Рабочий указатель.

  p = Head;
  while (p!=Tail)
  {
     cout<< "(" << (*p).Count << ")" << (*p).Key << "("; q = (*p).Trail;
     while (q!=NULL)
      { cout<<(*(*q).Id).Key; q = (*q).Next; }
     cout<<")"; p = (*p).Next; cout<<" ";
  }
}

Boolean Spisok::Find_Arc (int x, int y)
//Функция возвращает TRUE, если в графе, представленном
//структурой Вирта (Head,Tail), существует дуга (x,y).
{

  Lref p,q;    //Рабочие указатели.
  Tref r;      //Рабочие указатели.
  Boolean Res; //Флаг наличия дуги.

  //Определим, существует ли в графе дуга (x,y)?
  p = Search (x);
  q = Search (y);
  r = p->Trail; Res = FALSE;
  while  ( r != NULL && !Res )
    if  (r->Id==q) Res = TRUE;
    else  r = r->Next;
  return Res;
}

void Spisok::Sorting ()
//Сортировка узлов в заголовочном списке
//по полю Count в порядке убывания.
{
  Lref UkZv_1,UkZv_2;
  Lref UkZv_3;
  Tref UkZv_4;
  int  A, B;
  Tref D;

  UkZv_1 = Head;
  while ( UkZv_1 != Tail )
  {
    UkZv_2 = UkZv_1->Next;
    while  ( UkZv_2!=Tail )
    {
      if ( UkZv_1->Count < UkZv_2->Count )
      {
        A              = UkZv_1->Key;
        B              = UkZv_1->Count;
        D              = UkZv_1->Trail;
        UkZv_1->Key    = UkZv_2->Key;
        UkZv_1->Count  = UkZv_2->Count;
        UkZv_1->Trail  = UkZv_2->Trail;
        UkZv_2->Key    = A;
        UkZv_2->Count  = B;
        UkZv_2->Trail  = D;
        UkZv_3 = Head;
        while ( UkZv_3!=Tail )
        {
          UkZv_4 = UkZv_3->Trail;
          while ( UkZv_4 != NULL )
          {
            if ( UkZv_4->Id==UkZv_1 ) UkZv_4->Id = UkZv_2;
            else
               if ( UkZv_4->Id==UkZv_2 ) UkZv_4->Id=UkZv_1;
            UkZv_4 = UkZv_4->Next;
          }
          UkZv_3 = UkZv_3->Next;
        }
      }
      UkZv_2 = UkZv_2->Next;
    }
    UkZv_1 = UkZv_1->Next;
  }
}

Boolean Spisok::Isomorph (Spisok B, int N)
//Функция, возвращающая TRUE, если  графы, представленные
//структурами Вирта (A.Head,A.Tail) и (B.Head,B.Tail), изоморфны.
//Отображение  вершин  при  изоморфизме  задано  векторами
//NewFun и Fun.
{

  Boolean Flag = TRUE;
  int k1,k2;

  for (int i=1;i<=N;i++)
  {
    k1 = 1;
    while ( i != this->NewFun[k1] ) k1++;
    for (int j=1;j<=N;j++)
    {
      k2 = 1;
      while ( j != this->NewFun[k2] )  k2++;
       if  ( i>j && this->Find_Arc(i,j) )
          Flag = (Flag && B.Find_Arc (B.Fun[k1],B.Fun[k2]));
    }
  }
  return Flag;
}
Текст этой программы можно взять здесь.
Для графов, изображенных на рисунке 2,

Рис.2. Пример графов
результат работы приложения будет следующим:

Рис.3. Результат работы приложения
Нетривиальный тестовый пример Вы можете обнаружить в монографии [4, с.207].
Однако есть случаи, когда при выяснении изоморфизма графов их векторы степеней практически бесполезны: речь идет об однородных графах, в которых степень всех вершин одна и та же.
Например, взгляните на граф, степени всех вершин которого равны 3:

Рис.4. пример однородного графа
Противоположный случай представляют графы, определяемые однозначно с точностью до изоморфизма своим вектором степеней (или, что равносильно, его обращением) и называемые униграфами.


Алгоритм, распознавания изоморфизма графов, описанный в [5]
Этот подход используется при построении алгоритма установления изоморфизма ориентированных графов в монографии [5,с.398].
Предположим, что нам даны два ориентированных графа GX=(VX,EX) и GY=(VY, EY) и требуется выяснить, изоморфны ли они. Мы полагаем, что VX=VY={1,2,...,n}, ибо если  |VX| не равно |VY|, то ориентированные графы не могут быть изоморфными.
Пусть один из ориентированных графов, скажем GX, выбран в качестве эталона. Пусть GX(k) - подграф графа GX, индуцируемый вершинами {1,2,...,k}, 0<=k<=n. Ясно, что GX(0) - пустой подграф и GX(1) - подграф, состоящий из единственной вершины 1 и не содержащий ребер.
При определении того, изоморфны ли графы GX и GY, используем технику поиска с возвращением.
Очевидно, GX(0) изоморфен пустому подграфу GY. Предположим, что на некотором шаге найден подграф GY, состоящий из вершин S, принадлежащих VY, который изоморфен GX(k).
Попытаемся продолжить изоморфизм на GX(k+1), выбирая вершину v, принадлежащую VY-S, соответствующую k+1 из VX.
Если такая вершина v найдена, то зафиксируем соответствие fk+1<-v и попытаемся продолжить изоморфизм на GX(k+2).
Если такой вершины не существует, то возвращаемся в GX(k-1) и пытаемся выбрать другую вершину, соответствующую k из VX.
Этот процесс продолжается до тех пор, пока не будет найден изоморфизм между GX(n)=GX и GY, в противном случае возвращаемся к GX(0), заключив, что графы GX и GY неизоморфны.
С.Гудман и С.Хидетниеми [6,с.62] предложили называть эвристическим алгоритм, который обладает следующими двумя свойствами:
    1. Он находит, как правило, хорошие, хотя и не обязательно оптимальные решения.
    2. Его легче и быстрее реализовать, чем любой из известных точных алгоритмов (т.е. алгоритмов, гарантирующих оптимальное решение).
Эвристики для решения задач изоморфизма обычно состоят в попытках показать, что рассматриваемые графы не изоморфны. Для этого составляется список различных инвариантов в порядке, определяемом сложностью вычисления инварианта. Затем последовательно сравниваются значения параметров данных графов. Как только обнаруживаются два различных значения одного и того же параметра, приходят к заключению, что данные графы неизоморфны.
Рассмотрим пример достаточно сложной эвристики, работающей с матрицей смежности A(G) [6, с.63-64].


Алгоритм сравнения порядков смежности
Вычисляется A2(Gi) для i=1, 2. Затем переставляются строки и столбцы A2(G1) и A2(G2) так, чтобы элементы на главной диагонали оказались в нисходящем порядке.
Если G1 и G2 изоморфны и все диагональные элементы различны, то при этой перестановке должны получиться идентичные матрицы.
Если нет, то данные два графа не могут быть изоморфными.
Если матрицы идентичны, то можно продолжить проверку с A3(Gi), A4(Gi), ..., Ak(Gi) для i=1, 2. Значение kопределяется имеющимся бюджетом машинных ресурсов. Если все из проверенных матриц совпадают, то весьма правдоподобно, но не обязательно истинно, что G1 и G2 изоморфны.

Замечания.
    1. Графы изоморфны тогда и только тогда, когда их матрицы смежностей получаются друг из друга одинаковыми перестановками строк и столбцов [7,с.28].
Графы (ориентированные графы) изоморфны тогда и только тогда, когда их матрицы инцидентностиполучаются друг из друга произвольными перестановками строк и столбцов [7, с.28].

    2. Существует немало глубоких и трудных проблем, связанных с изоморфизмом графов, и наиболее известная из них - проблема восстановления.
Пусть вершины графа G занумерованы следующим образом: v1, v2, ...,vk. Через Gj обозначим граф, получающийся из G после удаления вершины vj и инцидентных ей ребер. Все k подграфов Gj 0 графа G будем называть примарными [1, с.154].
C1 (гипотеза о восстановлении).
Если заданы классы изоморфизма всех k примарных подграфов графа G, то при k>=3 класс изоморфизма графа G определяется однозначно.
К моменту написания книги У.Татта [1] гипотеза о восстановлении оставалась недоказанной.
Ограничение на k (k>=3) обосновывается легко.
Если k=1, то единственным примарным подграфом графа G будет пустой граф, который не несет никакой информации о числе петель в графе G. Если k=2, то в каждом из двух примарных подграфов графа Gсодержится только по одной вершине, а потому нам ничего не известно о числе ребер в графе G. Таким образом, действительно нужно предположить, что |V(G)|>=3.
Если некоторое свойство или характеристику графа G можно выявить, рассматривая классы изоморфизма всех его примарных подграфов Gj, то оно (она) называется восстанавливаемым (восстанавливаемой), а графы, обладающие этим свойством или характеристикой, называются распознаваемыми. Примером восстанавливаемой характеристики является число вершин в графе. Это число на единицу больше числа вершин в каждом примарном подграфе данного графа и совпадает с числом заданных классов изоморфизма.
Пусть G - граф с занумерованными ребрами A1, A2, ...,Ak. Через Gj обозначим подграф графа G, получающийся после удаления из G ребра Aj.
C2 (гипотеза о реберном восстановлении).
Если заданы классы изоморфизма всех k подграфов Gj, то при k>=4 класс изоморфизма графа Gопределяется однозначно.
Причина, по которой введено ограничение на k (k>=4) ясна из следующего рисунка [1, с.164], на котором изображены два графа G и H, такие, что, удаляя из них произвольное ребро, мы получаем, с точностью до изоморфизма, один и тот же подграф.

Рис.5. Пример графов

    3. [7, с.14]. В некоторых ситуациях все же приходится различать изоморфные графы, и тогда полезно понятие "помеченный граф". Граф порядка n называется помеченным, если его вершинам присвоены некоторые метки, например, номера 1, 2, ..., n.
Отождествив каждую из вершин графа с ее номером (и, следовательно, множество вершин - с множеством чисел {1, 2, ..., n}), определим равенство помеченных графов G и H одного и того же порядка: G=H тогда, когда множество ребер графа G совпадает с множеством ребер графа H.



(1) Татт У. Теория графов. - М.: Мир, 1988. - 424 с.
(2) Земляченко В.Н., Корнеенко Н.М., Тышкевич Р.И. Проблема изоморфизма графов // Теория сложности вычислений, I. Записки научных семинаров ЛОМИ. - 1982. - Т.118. - С.83-158.
(3) Зыков А.А. Основы теории графов. М.: Наука, 1987. - 384 с.
(4) Белов В.В., Воробьев Е.М., Шаталов В.Е. Теория графов. - М.: Высш.шк., 1976. - 392 с.
(5) Рейнгольд Э., Hивергельт Ю., Део H. Комбинаторные алгоритмы. Теория и практика. - М.: Мир, 1980. - 476 с.
(6) Гудман С., Хидетниеми С. Введение в разработку и анализ алгоритмов. - М.: Мир, 1981. - 368 с.
(7) Лекции по теории графов / Емеличев В.А., Мельников О.И., Сарванов В.И., Тышкевич Р.И. - М.: Наука, 1990. - 384 с.

Со следующего шага мы начнем краткий обзор сетей.












    2. Эволюция и революция
        1.41. Второй уровень
            2.1.1. Третий уровень
    3. Четвертый уровень
                    3.1.1.1.1. Пятый уровень





Основной текст.

    • Список

    1. Первый элемент списка.
    2. Второй элемент списка

Рис. 1

	p	p	p	p	p	p	p	p	p	p	p	p	p	p	p	p	p	p

1. Сеть
1.1. Сети (общие сведения)
1.2. Кратчайшие пути в сети. Алгоритм Форда-Беллмана
1.3. Кратчайшие пути в сети. Алгоритм Дейкстры
1.4. Пути в бесконтурной сети
1.5. Потоки в сетях. Система дорог
1.6. Описание алгоритма Дейкстры
1.7. Алгоритм Флойда
1.8. Задача о максимальном потоке
1.9. Алгоритм нахождения максимального потока
1.10. Нахождение потока наименьшей стоимости (общие замечания)
1.11. Нахождение потока наименьшей стоимости. Сетевая модель
1.12. Нахождение потока наименьшей стоимости. Сетевая модель как задача линейного программирования
1.13. Нахождение потока наименьшей стоимости. Симплексный алгоритм для сетей с ограниченной пропускной способностью
1.14. Методы сетевого планирования (общие сведения)
1.15. Методы сетевого планирования. Построение сети проекта
1.16. Методы сетевого планирования. Метод критического пути
1.17. Методы сетевого планирования. Построение временного графика
1.18. Приложение "Сетевые модели"





    1. Сеть

        1.1. Сети (общие сведения)
На этом шаге мы приведем общие сведения о сетях.
Наиболее общий вид многосвязной структуры - многосвязная структура, которая характеризуется следующими свойствами [1, с.95].
    1. Каждый элемент структуры содержит произвольное число направленных связей с другими элементами (или ссылок на другие элементы).
    2. С каждым элементом может связываться произвольное число других элементов (т.е. каждый элемент может быть объектом ссылки произвольного числа других элементов).
    3. Каждая связь в структуре имеет не только направление, но и вес.
Такую многосвязную структуру называют сетевой структурой или сетью [2].
Логически сеть эквивалентна взвешенному ориентированному графу общего вида [2, 3], и поэтому вместо термина "сеть" часто употребляются термин "графовая структура", или просто "граф".
Сетевые структуры широко применяются при организации банков данных, систем управления базами данных, в системах программного имитационного моделирования сложных комплексов и т.д. Особое значение сетевые структуры приобрели в системах искусственного интеллекта, в которых они адекватно отражают логику организации данных и сложные отношения, возникающие в таких системах между различными элементами данных. В этих системах сетевые структуры применяются для построения семантических сетей, фреймов и других логических конструкций, необходимых для представления знаний, образования понятий и осуществления логических выводов.


(1) Костин А.Е., Шаньгин В.Ф. Организация и обработка структур данных в вычислительных системах. - М.: Высш.шк., 1987. - 248 с.
(2) Трамбле Ж., Соренсон П. Введение в структуры данных. - М.: Машиностроение, 1982. - 784 с.
(3) Харари Ф. Теория графов. - М.: Мир, 1973. - 300 с.

Со следующего шага мы начнем приводить алгоритмы нахождения кратчайшего пути в сетях.

        1.2. Кратчайшие пути в сети. Алгоритм Форда-Беллмана
На этом шаге мы приведем реализацию алгоритма Форда-Беллмана.
Приведем текст программы, реализующей алгоритм Форда-Беллмана.
//Нахождение расстояния от источника до всех вершин
//(метод Форда-Беллмана).
//Нахождение кратчайшего пути из S в T.
#include <iostream.h>
#define MaxNodes 7
#define B 1000  //Машинный эквивалент бесконечности.

//Описание типа узла стека.
typedef struct Zveno *svqz;
typedef struct Zveno
{
  int Element;
  svqz Sled;
};

class Spisok
{
  private:
         int A[MaxNodes][MaxNodes];  //Матрица весов дуг.
         int D[MaxNodes]; //Матрица расстояний от источника до 
                          //всех вершин графа.
         svqz Stack; //Указатель на рабочий стек.
         void UDALENIE (svqz *, int *);
         void W_S (svqz *, int);
  public:
         Spisok() {Stack = NULL;}
         void Vvod_Ves();
         void Reshenie ();
};

void main ()
{
  Spisok A;
  A.Vvod_Ves();
  A.Reshenie();
}

void Spisok::Reshenie ()
{
  int S; // Начальная вершина пути (источник).
  int T; // Конечная вершина пути.
  int u,v;
  int i,j,k;
  svqz UkZv;

  cout << "Введите источник: "; 
  cin >> S; S--;
  //Инициализация.
  for (i=0;i<MaxNodes;i++) D[i] = A[S][i];
  D[S] = 0;
  //Вычисление матрицы расстояний от 
  //источника до всех вершин графа.
  for (k=0;k<MaxNodes-2;k++)
   for (i=0;i<MaxNodes;i++)
     if ( i!=S )
        for (j=0;j<MaxNodes;j++)
           if ( D[i] > D[j]+A[j][i] ) D[i] = D[j]+A[j][i];
  //Вывод матрицы расстояний от источника
  //до всех вершин графа.
  cout << "Матрица расстояний: \n";
  for (i=0;i<MaxNodes;i++) cout << D[i] << " ";
  cout << endl;
  // -----------------------------------------------------
  // Нахождение кратчайшего пути из S в T с использованием
  //            построенной матрицы расстояний.
  // ----------------------------------------------------- 
  cout << "Введите конечную вершину пути: "; 
  cin >> T; T--;
  W_S (&Stack,T); v = T;
  while ( v!=S )
  {
    for (i=0;i<MaxNodes;i++) 
      if ( D[v]==D[i]+A[i][v] ) u = i;
    W_S (&Stack,u);
    v = u;
  }
  //Вывод кратчайшего пути на экран дисплея.
  cout << "Кратчайший путь: ";
  UkZv = Stack;
  while ( UkZv != NULL )
  {  cout << UkZv->Element << " "; 
     UkZv = UkZv->Sled;  }
  cout << endl;
}

void Spisok::Vvod_Ves()
//Ввод матрицы весов дуг заданного графа.
{
  cout << "Вводите элементы матрицы весов дуг по строкам:\n";
  for (int i=0;i<MaxNodes;i++)
   for (int j=0;j<MaxNodes;j++)
     {
       cout << "Введите A[" << (i+1) << "," << (j+1) << "]: "; 
       cin >> A[i][j];
       if ( A[i][j]==0 ) A[i][j] = B;
     }
}

void Spisok::W_S (svqz *stk, int Elem)
//Помещение Elem в стек stk.
{
  svqz q=new (Zveno);
  (*q).Element = Elem; 
  (*q).Sled = *stk; *stk = q;
}

void Spisok::UDALENIE (svqz *stk, int *Klad)
//Удаление звена из стека, заданного указателем *stk.
//Значение информационного поля удаляемого звена сохраня-
//ется в параметре Klad.
{
  svqz q;

  if (*stk==NULL) cout<<"Попытка выбора из пустого стека!\n";
  else
	{ *Klad = (**stk).Element;
	  q = *stk; *stk = (**stk).Sled; delete q; }
}
Текст этой программы можно взять здесь.
Рассмотрим тестовый пример [1].
  Вычислить кратчайшее растояние между вершинами s и t в сети:
   (s,a,4), (s,d,6), (a,d,-3), (a,b,8),  (b,t,2), (a,e,5),
   (d,e,2), (e,c,3), (d,c,11), (c,b,-4), (c,t,7), (b,d,-6).
Перенумеруем вершины:
   (s,1), (a,2), (d,3), (b,4), (c,5), (e,6), (t,7),
выпишем матрицу весов дуг
    0  4  6  0  0  0  0
    0  0 -3  8  0  5  0
    0  0  0  0 11  2  0
    0  0 -6  0  0  0  2
    0  0  0 -4  0  0  7
    0  0  0  0  3  0  0
    0  0  0  0  0  0  0
и применим алгоритм Форда-Беллмана к этой матрице. В результате получим:
   Введите источник: 1
   Матрица расстояний 0: 0 4 -4 2 1 -2 4
   Введите конечную вершину пути: 7
   Кратчайший путь: ...
Компьютер "зависает", ибо в графе имеется контур отрицательной длины 3-6-5-4 (его длина -6+2+3-4=-5), что приводит к появлению бесконечного множества путей, каждый из которых "короче" предыдущего, например:
   путь 1-2-3-6-5-4-7                 с длиной 4,
   путь 1-2-3-6-5-4-3-6-5-4-7         с длиной -1,
   путь 1-2-3-6-5-4-3-6-5-4-3-6-5-4-7 с длиной -6 и т.д.
Поэтому кратчайший путь алгоритмом Форда-Беллмана определить нельзя.

Замечание [2, с.47-48]. Приведенный алгоритм отыскания кратчайших путей в графах с отрицательными длинами дуг, принадлежащий Форду, Муру и Беллману, может служить одним из возможных способов обнаружения контуров отрицательной длины (или циклов в неориентированном графе).



(1) Евстигнеев В.А., Мельников Л.С. Задачи и упражнения по теории графов и комбинаторике. - Новосибирск: НГУ, 1981. - 88 с.
(2) Евстигнеев В.А., Касьянов В.Н. Деревья: основные понятия, свойства и алгоритмы. - Новосибирск: НГУ, 1992. - 80 с.

На следующем шаге мы рассмотрим алгоритм Дейкстры.


        1.3. Кратчайшие пути в сети. Алгоритм Дейкстры
На этом шаге мы рассмотрим алгоритм Дейкстры.
Описание алгоритма Дейкстры дано на 123 шаге. Здесь мы приведем текст программы, реализующей алгоритм Дейкстры.
//Нахождение расстояния от источника до всех вершин в графе
//с неотрицательными весами (метод Дейкстры).
//Нахождение кратчайшего пути из S в T.
#include <iostream.h>
#define MaxNodes 7
#define B 1000  //Машинный эквивалент бесконечности.

//Описание типа узла стека.
typedef struct Zveno *svqz;
typedef struct Zveno
{
  int Element;
  svqz Sled;
};

class Spisok
{
  private:
         int A[MaxNodes][MaxNodes];  //Матрица весов дуг.
         int D[MaxNodes]; //Матрица расстояний от источника до 
                          //всех вершин графа.
         svqz Stack; //Указатель на рабочий стек.
         void UDALENIE (svqz *, int *);
         void W_S (svqz *, int);
         int Pusto_Q (int *);
  public:
         Spisok() {Stack = NULL;}
         void Vvod_Ves();
         void Reshenie ();
};

void main ()
{
  Spisok A;
  A.Vvod_Ves();
  A.Reshenie();
}

int Spisok::Pusto_Q (int *Q)
{
  for (int i=0;i<MaxNodes;i++)
    if ( *(Q+i)!=0 ) return 0; //Ложь - не пусто!
  return 1; //Истина - пусто!
}

void Spisok::Reshenie ()
{
  int S; // Начальная вершина пути (источник).
  int T; // Конечная вершина пути.
  int u,v,Min;
  int i,j,k;
  svqz UkZv;
  int Q[MaxNodes];

  cout << "Введите источник: "; 
  cin >> S; S--;
  //Инициализация.
  for (i=0;i<MaxNodes;i++) { D[i] = A[S][i]; Q[i] = 0; }
  D[S] = 0;
  for (i=0;i<MaxNodes;i++)  Q[i] = 1;
  Q[S] = 0;
  //Вычисление матрицы расстояний от 
  //источника до всех вершин графа.
  while (!Pusto_Q(&Q[0])) //Пока Q не пусто.
  { 
    Min = B;
    for (i=0;i<MaxNodes;i++)
     if (Q[i]==1 && D[i]<Min) { Min = D[i]; u = i; }
    Q[u] = 0;
    for (i=0;i<MaxNodes;i++)
     if (Q[i] == 1)
       if ( D[i] > D[u]+A[u][i] ) D[i] = D[u] + A[u][i];
  }
  //Вывод матрицы расстояний от источника
  //до всех вершин графа.
  cout << "Матрица расстояний: \n";
  for (i=0;i<MaxNodes;i++) cout << D[i] << " ";
  cout << endl;
  // -----------------------------------------------------
  // Нахождение кратчайшего пути из S в T с использованием
  //            построенной матрицы расстояний.
  // ----------------------------------------------------- 
  cout << "Введите конечную вершину пути: "; 
  cin >> T; T--;
  W_S (&Stack,T); v = T;
  while ( v!=S )
  {
    for (i=0;i<MaxNodes;i++) 
      if ( D[v]==D[i]+A[i][v] ) u = i;
    W_S (&Stack,u);
    v = u;
  }
  //Вывод кратчайшего пути на экран дисплея.
  cout << "Кратчайший путь: ";
  UkZv = Stack;
  while ( UkZv != NULL )
  {  cout << (UkZv->Element+1) << " "; 
     UkZv = UkZv->Sled;  }
  cout << endl;
}

void Spisok::Vvod_Ves()
//Ввод матрицы весов дуг заданного графа.
{
  cout << "Вводите элементы матрицы весов дуг по строкам:\n";
  for (int i=0;i<MaxNodes;i++)
   for (int j=0;j<MaxNodes;j++)
     {
       cout << "Введите A[" << (i+1) << "," << (j+1) << "]: "; 
       cin >> A[i][j];
       if ( A[i][j]==0 ) A[i][j] = B;
     }
}

void Spisok::W_S (svqz *stk, int Elem)
//Помещение Elem в стек stk.
{
  svqz q=new (Zveno);
  (*q).Element = Elem; 
  (*q).Sled = *stk; *stk = q;
}

void Spisok::UDALENIE (svqz *stk, int *Klad)
//Удаление звена из стека, заданного указателем *stk.
//Значение информационного поля удаляемого звена сохраня-
//ется в параметре Klad.
{
  svqz q;

  if ( *stk == NULL ) cout<<"Попытка выбора из пустого стека!\n";
  else
	{ *Klad = (**stk).Element;
	  q = *stk; *stk = (**stk).Sled; delete q; }
}
Текст этой программы можно взять здесь.
Приведем контрпример к алгоритму Дейкстры.
  Вычислить кратчайшее растояние между вершинами s и t в сети[1]:
   (s,a,4), (s,d,6), (a,d,-3), (a,b,8),  (b,t,2), (a,e,5),
   (d,e,2), (e,c,3), (d,c,11), (c,b,-4), (c,t,7), (b,d,-6).
Заметим, что мы допустили существование отрицательных весов!
Перенумеруем вершины:
   (s,1), (a,2), (d,3), (b,4), (c,5), (e,6), (t,7),
выпишем матрицу весов дуг
    0  4  6  0  0  0  0
    0  0 -3  8  0  5  0
    0  0  0  0 11  2  0
    0  0 -6  0  0  0  2
    0  0  0 -4  0  0  7
    0  0  0  0  3  0  0
    0  0  0  0  0  0  0
и применим алгоритм Дейкстры к этой матрице. В результате получим:
   Введите источник: 1
   Матрица расстояний:
   0 4 1 2 6 3 4
   Введите конечную вершину пути: 7
   Кратчайший путь: 1 2 3 6 5 4 7
Однако, как уже было отмесено ранее, в графе имеется контур отрицательной длины 3-6-5-4 (его длина -6+2+3-4=-5), что приводит к появлению бесконечного множества путей, каждый из которых "короче" предыдущего, например:
   путь 1-2-3-6-5-4-7                 с длиной 4,
   путь 1-2-3-6-5-4-3-6-5-4-7         с длиной -1,
   путь 1-2-3-6-5-4-3-6-5-4-3-6-5-4-7 с длиной -6 и т.д.
Таким образом, кратчайший путь алгоритмом Дейкстры определить нельзя, так как в графе имеется контур отрицательной длины.


(1) Евстигнеев В.А., Мельников Л.С. Задачи и упражнения по теории графов и комбинаторике. - Новосибирск: НГУ, 1981. - 88 с.

На следующем шаге мы рассмотрим пути в бесконтурной сети.

        1.4. Пути в бесконтурной сети
На этом шаге мы рассмотрим вычисление путей в бесконтурных сетях.
Займемся теперь вторым случаем, для которого известен алгоритм нахождения расстояний от фиксированной вершины за время O(n2), а именно случаем, когда граф является бесконтурным (веса дуг могут быть произвольными).
При описании алгоритма нахождения путей в бесконтурном графе мы можем предположить, что каждая дуга идет из вершины с меньшим номером в вершину с большим номером.

Пример. Нахождение расстояний от источника до всех вершин в бесконтурном графе.
#include <iostream.h>
#define MaxNodes 9
#define B 1000  //Машинный эквивалент бесконечности.

class Spisok
{
  private:
	int A[MaxNodes][MaxNodes];  //Матрица весов дуг.
	int D[MaxNodes]; //Матрица расстояний от источника до
                         //всех вершин графа.
  public:
	void Vvod_Ves();
	void Reshenie ();
};

void main ()
{
  Spisok A;
  A.Vvod_Ves();
  A.Reshenie();
}

void Spisok::Reshenie ()
{
  int S; // Начальная вершина пути (источник).
  int i,j;

  S = 0;
  //Инициализация.
  for (j=1;j<MaxNodes;j++) D[j] = B;
  D[S] = 0;
  //Вычисление матрицы расстояний от источника до
  //всех вершин графа.
  for (j=1;j<MaxNodes;j++)
   for (i=0;i<MaxNodes;i++)
     if  (A[i][j]!=0 && D[j]>D[i]+A[i][j])  D[j] = D[i]+A[i][j];
  cout << "Матрица расстояний: \n";
  for (i=0;i<MaxNodes;i++) cout << D[i] << " ";
  cout << endl;
}

void Spisok::Vvod_Ves()
//Ввод матрицы весов дуг заданного графа.
{
  cout << "Вводите элементы матрицы весов дуг по строкам:\n";
  for (int i=0;i<MaxNodes;i++)
   for (int j=0;j<MaxNodes;j++)
     {
       cout << "Введите A[" << (i+1) << "," << (j+1) << "]: "; 
       cin >> A[i][j];
       if ( A[i][j]==0 ) A[i][j] = B;
     }
}
Текст этой программы можно взять здесь.
Проверьте работу программы для следующей путевой матрицы:
    0  1  0  2  0  0  1  0  0 
    0  0  2  0  7  0  0  0  0 
    0  0  0  0  0 10  0  0  5 
    0  0  0  0  5  0  0  0  0 
    0  0  0  0  0  6  0  1  0 
    0  0  0  0  0  0  0  0  4 
    0  0  0  0  0  0  0  3  0 
    0  0  0  0  0  0  0  0  5 
    0  0  0  0  0  0  0  0  0 
При выполнении приложения будет получен следующий результат:
    Матрица расстояний:
    0 1 3 2 7 13 1 4 8 
Приведенный алгоритм может найти применение в методах управления выполнением проекта, называемых PERT (Project Evaluation and Review Technique) или CPM (Critical Path Method). Эти методы основываются на построении графа (сети PERT или сети CPM), дуги которого соответствуют некоторым элементарным задачам, составляющим проект, а их веса указывают на время, необходимое для решения отдельных задач. Кроме этого, мы предполагаем, что для произвольных дуг этого графа (u,v) и (v,t) задача, изображаемая дугой (u,v), должна быть закончена перед началом решения задачи, изображаемой дугой (v,t). Легко заметить, что такой граф должен быть бесконтурным.
Нашей задачей является нахождение самого длинного пути из вершины s, соответствующей началу проекта, до вершины t, соответствующей его окончанию. Такой путь называется критическим. Его длина определяет время, необходимое для реализации всего проекта.
Эта задача сводится к задаче о кратчайшем пути путем изменения знака каждого веса A(u,v), где u->v, на обратный.
Так, например, выполните предыдущую программу для следующей путевой матрицы:
    0 -1  0 -2  0  0  1  0  0 
    0  0 -2  0 -7  0  0  0  0 
    0  0  0  0  0-10  0  0 -5
    0  0  0  0 -5  0  0  0  0 
    0  0  0  0  0 -6  0 -1  0 
    0  0  0  0  0  0  0  0  4 
    0  0  0  0  0  0  0 -3  0 
    0  0  0  0  0  0  0  0 -5 
    0  0  0  0  0  0  0  0  0 
Результат будет следующим:
    Матрица расстояний:
    0 -1 -3 -2 -8 -14 1 -9 -14 

Пример [1, с.100-104].
//Планирование критического пути (анализ сети ПЕРТ)
//Автор алгоритма: Leavenworth B. (CACM, 1961, 3).
#include <iostream.h>

void Critical_Path (int n, int i[], int j[], int dij[],
               int *s1, int *s2, int *f1, int *f2, int *tf, int *ff)
{
  int k,index,max,min;
  int ti[20],te[20];

  index = 0;
  for (k=0;k<n;k++)
  {
    if ( i[k]==index+1 )  index = i[k];
    ti[k] = 0; te[k] = 9999;
  }
  for (k=0;k<n;k++)
  {
    max = ti[i[k]] + dij[k];
    if ( ti[j[k]]<max ) ti[j[k]] = max;
  }
  te[j[n-1]] = ti[j[n-1]];
  for (k=n-1;k>=0;k--)
  {
    min = te[j[k]] - dij[k];
    if ( te[i[k]]>min ) te[i[k]] = min;
  }
  for (k=0;k<n;k++)
  {
    s1[k] = ti[i[k]]; f1[k] = s1[k] + dij[k];
    f2[k] = te[j[k]]; s2[k] = f2[k] - dij[k];
    tf[k] = f2[k] - f1[k]; ff[k] = ti[j[k]] - f1[k];
  }
}

void main()
{
  int n;      // Общее количество работ по проекту          
              // (количество ребер ориентированного графа).
  int i[20];  // Вектор-пара, представляющая k-ю работу,    
  int j[20];  // которая понимается как стрелка, связыва-   
              // ющая событие i[k] с событием j[k]          
              // Граф задан массивом ребер:                 
              // (i[0],j[0]),(i[1],j[1]),...,(i[n-1],j[n-1])    
              // Должно быть выполнено: 
              // i[0]=1, i[k]<i[k+1], i[k]<j[k].
  int dij[20];// dij[k] - продолжительность k-й операции.
  int s1[20]; // s1[k] - самый ранний срок начала k-й операции.
  int s2[20]; // s2[k] - самый поздний срок начала k-й.
  int f1[20]; // f1[k] - самый ранний срок завершения k-й.
  int f2[20]; // f2[k] - самый поздний срок завершения k-й операции.
  int tf[20]; // tf[k] - полный резерв времени k-й операции.
  int ff[20]; // ff[k] - свободный резерв времени k-й операции.
  int k;      // Параметр цикла.

  cout << "Введите общее количество работ по проекту: ";
  cin >> n;
  for (k=0;k<n;k++)
  {
     cout << "Вводите начало, конец дуги и продолжительность: ";
     cin >> i[k] >> j[k] >> dij[k];
  }
  Critical_Path (n,&i[0],&j[0],&dij[0],&s1[0],&s2[0],&f1[0],&f2[0],&tf[0],&ff[0]);
  //Вывод результатов.
  cout << "Самый ранний срок начала     : ";
  for (k=0;k<n;k++) cout << s1[k] << " "; cout << endl;
  cout << "Самый поздний срок начала    : ";
  for (k=0;k<n;k++) cout << s2[k] << " "; cout << endl;
  cout << "Самый ранний срок завершения : ";
  for (k=0;k<n;k++) cout << f1[k] << " "; cout << endl;
  cout << "Самый поздний срок завершения : ";
  for (k=0;k<n;k++) cout << f2[k] << " "; cout << endl;
  cout << "Свободный резерв времени     : ";
  for (k=0;k<n;k++) cout << ff[k] << " "; cout << endl;
  cout << "Полный резерв времени        : ";
  for (k=0;k<n;k++) cout << tf[k] << " "; cout << endl;
  // Определение  критического  пути. Критический путь задается 
  // стрелками, соединяющими события, для которых полный резерв
  // времени равен нулю.
  cout << "Критический путь: " << 1 << " ";
  for (k=0;k<n;k++)
   if ( tf[k]==0 ) cout << j[k] << " ";
}
Текст этой программы можно взять здесь.


(1) Библиотека алгоритмов 1б-50б. (Справочное пособие.) - М.: Сов.радио, 1975. - 176 с.

На следующем шаге мы приведем программу вычисления потока в сети.

        1.5. Потоки в сетях. Система дорог
На этом шаге мы приведем программу вычисления потока в сети и дадим несколько определений, связанных с системой дорог.

Пример [1, 2].
#include <iostream.h>
#define TRUE 1
#define FALSE 0
typedef int Boolean;
#define MaxNodes 8
#define MaxInt 1000  //Машинный эквивалент бесконечности.
class Spisok
{
  private:
    int cap[MaxNodes][MaxNodes];  //Функция пропускной способности.
    int flow[MaxNodes][MaxNodes]; //Максимальная функция потока.
    Boolean Any (Boolean *);
  public:
    void Vvod();
    void Maxflow (int, int, int *);
    void Vyvod (int);
};

void main()
{
  Spisok A;
  int s;  //Источник.
  int t;  //Сток.
  int totflow; //Значение потока от узла s к узлу t.

  //Задайте пропускную способность.
  A.Vvod();
  cout << "Укажите источник... "; cin >> s;
  cout << "Укажите сток... "; cin >> t;
  //Вывод результатов.
  A.Maxflow (s,t,&totflow);
  A.Vyvod(totflow);
}

void Spisok::Vvod()
{
  for (int i=0;i<MaxNodes;i++)
   for (int j=0;j<MaxNodes;j++)
   {
     cout << "Введите элемент " << i << " " << j<< " ";
     cin >> cap[i][j];
   }
}

void Spisok::Vyvod(int totflow)
{
  for (int i=0;i<MaxNodes;i++)
  {
    for (int j=0;i<MaxNodes;i++)
      cout << flow[i][j] << " ";
    cout << endl;
  }
  cout << "Значение потока: " << totflow << endl;
}

Boolean Spisok::Any (Boolean *Q)
{
  Boolean A = FALSE;

  for (int i=0;i<MaxNodes;i++) A = (A || Q[i]);
  return A;
}

void Spisok::Maxflow (int s, int t, int *totflow)
{
  int nd,i,x,pred;
  Boolean endpath[MaxNodes];
  Boolean onpath[MaxNodes];
  Boolean forward[MaxNodes];
  int     improve[MaxNodes];
  int     precede[MaxNodes];

  for (nd=0;nd<MaxNodes;nd++)
   for (i=0;i<MaxNodes;i++)
            flow[nd][i] = 0;
  *totflow = 0;
  do {
    //Попытка найти полупуть из s в t.
    for (nd=0;nd<MaxNodes;nd++)
    {
      endpath[nd] = FALSE;
      onpath [nd] = FALSE;
    }
    endpath[s] = TRUE;
    onpath [s] = TRUE;
    improve[s] = MaxInt;
    // Мы допускаем, что s обеспечивает неопределенный поток.
    while  (!onpath[t] && Any (&endpath[0])) 
    {
      // Попытка расширить существующий путь.
      nd = 0;
      while (!endpath[nd]) nd++;
      endpath[nd] = FALSE;
      for (i=0;i<MaxNodes;i++)
      {
        if (flow[nd][i]<cap[nd][i] && !onpath[i])
        {
           endpath[i]  = TRUE;
           onpath [i]  = TRUE;
           precede[i]  = nd;
           forward[nd] = TRUE;
           x = cap[nd][i] - flow[nd][i];
           if  ( improve[nd]<x ) improve[i] = improve[nd];
           else  improve[i] = x;
        }
        if (flow[i][nd]>0 && !onpath[i])
        {
           onpath [i]  = TRUE;
           endpath[i]  = TRUE;
           precede[i]  = nd;
           forward[nd] = FALSE;
           if ( improve[nd]<flow[i][nd] )
                 improve[i] = improve[nd];
           else  improve[i] = flow[i][nd];
        }
      }
    }
    if ( onpath[t] )
    // Поток на полупути к t может быть увеличен.
    {
       x = improve[t];
       *totflow += x;
       nd = t;
       while ( nd!=s )
       // Возвращение обратно вдоль пути.
       {
          pred = precede [nd];
          if ( forward[pred] )
          // Увеличение потока от pred.
                flow[pred][nd] += x;
          else // Уменьшение потока от pred.
                flow[pred][nd] -= x;
          nd = pred;
       }
    }            
  } while ( onpath[t] );
}
Текст этой программы можно взять здесь.
Система дорог - это размеченный мультиграф (без петель), который отличается от графа тем, что в нем одна и та же пара (различных) вершин может быть связана более чем одним ребром [3, с.97-98]. При этом вершины соответствуют городам, а ребра - дорогам. Односторонним дорогам соответствуют дуги, а двусторонним дорогам - ребра.
Каждая дорога имеет некоторую длину - положительное вещественное число. Понятие пути, достижимости и замкнутого пути определяются для системы дорог аналогично подобным понятиям для графа и ориентированного графа.
Длина пути в системе дорог - это сумма длин дорог этого пути.
Расстояние между двумя городами - это длина минимального пути между этими городами.


(1) Tenenbaum A., Augenstein M. Data Structures Using Pascal. Englewood Cliffs. - N.Y.: Prentice-Hall, Inc. 1981.
(2) Лэнгсам Й., Огенстейн М., Тененбаум А. Структуры данных для персональных ЭВМ: Пер. с англ. - М.: Мир, 1989. - 568 с.
(3) Касьянов В.H., Сабельфельд В.К. Сборник заданий по практикуму на ЭВМ. - М.: Hаука, 1986. - 272 с.

На этом шаге мы намеревались закончить изложение материала, связанного со структурами данных. Однако определенная недосказанность последних шагов вынудила нас отыскать дополнительный материал по сетям. Мы не будем менять ранее опубликованные шаги, а в следующих шагах вернемся к ранее изложенному материалу и рассмотрим его более подробно.
Таким образом, на следующем шаге мы подробно рассмотрим алгоритм Дейкстры.


        1.6. Описание алгоритма Дейкстры
На этом шаге мы приведем описание алгоритма Дейкстры.
Напомним, что алгоритм Дейкстры разработан для нахождения кратчайшего пути между заданным исходным узлом и любым другим узлом сети.
В процессе выполнения этого алгоритма при переходе от узла i к следующему узлу j используется специальная процедура пометки ребер. Обозначим через ui кратчайшее расстояние от исходного узла 1 до узла i, через dij - длину ребра (i, j). Тогда для узла j определим метку [uj, i] следующим образом:
    [uj, i] = [ui + dij, i], dij >= 0 
Метки узлов в алгоритме Дейкстры могут быть двух типов: временные и постоянные. Временная метка впоследствии может быть заменена на другую временную, если будет найден более короткий путь к данному узлу. Когда же станет очевидным, что не существует более короткого пути от исходного узла к данному, статус временной метки изменяется на постоянный.
Вычислительная схема алгоритма состоит из следующих шагов.
Шаг 0. Исходному узлу (узел 1) присваивается метка [0, -]. Полагаем i = 1.
Шаг i. а) Вычисляются временные метки [ui + dij, i] для всех узлов j, которые можно достичь непосредственно из узла i и которые не имеют постоянных меток. Если узел j уже имеет метку [uj, k], полученную от другого узла k, и если ui + dij < uj, тогда метка [uj, k] заменяется на [ui + dij, i].
b) Если все узлы имеют постоянные метки, процесс вычислений заканчивается. В противном случае выбирается метка [ur, s] с наименьшим значением расстояния ur среди всех временных меток (если таких меток несколько, то выбор произволен). Полагаем i = r и повторяем шаг i.

Пример. На рисунке 1 показана транспортная сеть, состоящая из пяти городов (расстояния между городами (в километрах) приведены возле соответствующих дуг сети). Необходимо найти кратчайшие расстояния от города 1 (узел 1) до всех остальных четырех городов.

Рис.1. Транспортная сеть
Шаг 0. Назначаем узлу 1 постоянную метку [0, -].
Шаг 1. Из узла 1 можно достичь узлов 2 и 3. Вычисляем метки для этих узлов, в результате получаем следующую таблицу меток:
Узел	Метка		          Статус метки
  1	[0, -]                   Постоянная
  2	[0 + 100, 1] = [100, 1]  Временная
  3	[0 + 30, 1] = [30, 1]  <-Временная
Среди узлов 2 и 3 узел 3 имеет наименьшее значение расстояния (u3 = 30). Поэтому статус метки этого узла изменяется на "постоянная".
Шаг 2. Из узла 3 (последнего узла с постоянной меткой) можно попасть в узлы 4 и 5. Получаем следующий список узлов:
Узел	Метка                     Статус метки
  1	[0, -]                     Постоянная
  2	[100, 1]                   Временная
  3	[30, 1]                    Постоянная
  4	[30 + 10, 3] = [40, 3]   <-Временная
  5	[30 + 60, 3] = [90, 3]     Временная
Временный статус метки [40, 3] узла 4 заменяется на постоянный (u4 = 40).
Шаг 3. Из узла 4 можно достичь узлов 2 и 5. После вычисления меток получим следующий их список:
Узел	Метка	                                  Статус метки
  1	[0, -]                                    Постоянная
  2	[40 + 15, 4] = [55, 4]                  <-Временная
  3	[30, 1]                                   Постоянная
  4	[40, 3]                                   Постоянная
  5	[90, 3] или [40 + 50, 4] = [90, 4]        Временная
Временная метка [100, 1], полученная узлом 2 на втором шаге, изменена на [55, 4]. Это указывает на то, что найден более короткий путь к этому узлу (проходящий через узел 4). На третьем шаге узел 5 получает две метки с одинаковым значением расстояния u5 = 90.
Шаг 4. Из узла 2 можно перейти только в узел 3, но он уже имеет постоянную метку, которую нельзя изменить. Поэтому на данном шаге получаем такой же список меток, как и на предыдущем шаге, но с единственным изменением: метка узла 2 получает статус постоянной. С временной меткой остается только узел 5, но так как из этого узла нельзя попасть ни в какой другой, процесс вычислений заканчивается.
Алгоритм позволяет проводить вычисления непосредственно по схеме сети, как показано на рисунке 2.

Рис.2. Вычисления по схеме (в скобках указан номер шага)
Кратчайший маршрут между узлом 1 и любым другим узлом определяется начиная с узла назначения путем прохождения их в обратном направлении с помощью информации, представленной в постоянных метках. Например, для определения кратчайшего маршрута между узлами 1 и 2 получаем такую обратную последовательность узлов:
    (2) -> [55, 4] -> (4) -> [40, 3] -> (3) -> [30, 1] -> (1).
Таким образом, получаем путь 1->3->4->2 общей длиной 55 километров.
Проиллюстрируем описанный алгоритм программой, приведенной на 120 шаге. Для разобранного примера результат работы этой программы будет следующим:

Рис.3. Результат работы приложения
На следующем шаге мы рассмотрим алгоритм Флойда.

        1.7. Алгоритм Флойда
На этом шаге мы рассмотрим алгоритм Флойда.
Этот алгоритм более общий по сравнению с алгоритмом Дейкстры, так как он находит кратчайшие пути между любыми двумя узлами сети. В этом алгоритме сеть представлена в виде квадратной матрицы с n строками и nстолбцами. Элемент (i, j) равен расстоянию dij от узла i к узлу j, которое имеет конечное значение, если существует дуга (i, j), и равен бесконечности в противном случае.
Покажем сначала основную идею метода Флойда. Пусть есть три узла i, j и k и заданы расстояния между ними (рис. 1). Если выполняется неравенство dij + djk < dik, то целесообразно заменить путь i -> k путем i -> j -> k. Такая замена (далее ее будем условно называть треугольным оператором) выполняется систематически в процессе выполнения алгоритма Флойда.

Рис.1. Треугольный оператор
Алгоритм Флойда требует выполнения следующих действий.
Шаг 0. Определяем начальную матрицу расстояния D0 и матрицу последовательности узлов S0. Диагональные элементы обеих матриц помечаются знаком "-", показывающим, что эти элементы в вычислениях не участвуют. Полагаем k = 1:

Рис.2. Начальная ситуация
Основной шаг k. Задаем строку k и столбец k как ведущую строку и ведущий столбец. Рассматриваем возможность применения треугольного оператора ко всем элементам dij матрицы Dk-1. Если выполняется неравенство dik + dkj < dij, (i <> k, j <> k, i <> j), тогда выполняем следующие действия:
    • создаем матрицу Dk путем замены в матрице Dk-1 элемента dij на сумму dik + dkj,
    • создаем матрицу Sk путем замены в матрице Sk-1 элемента sij на k. Полагаем k = k + 1 и повторяем шаг k.
Поясним действия, выполняемые на k-м шаге алгоритма, представив матрицу Dk-1 так, как она показана на рисунке 3. На этом рисунке строка k и столбец k являются ведущими. Строка i - любая строка с номером от 1 до k - 1, а строка p - произвольная строка с номером от k + 1 до n. Аналогично столбец j представляет любой столбец с номером от 1 до k - 1, столбец q - произвольный столбец с номером от k + 1 до n. Треугольный оператор выполняется следующим образом. Если сумма элементов ведущих строки и столбца (показанных в квадратах) меньше элементов, находящихся в пересечении столбца и строки (показанных в кружках), соответствующих рассматриваемым ведущим элементам, то расстояние (элемент в кружке) заменяется на сумму расстояний, представленных ведущими элементами:

Рис.3. Иллюстрация алгоритма Флойда
После реализации n шагов алгоритма определение по матрицам Dn и Sn кратчайшего пути между узлами i и jвыполняется по следующим правилам.
    1. Расстояние между узлами i и j равно элементу dij в матрице Dn.
    2. Промежуточные узлы пути от узла i к узлу j определяем по матрице Sn. Пусть sij = k, тогда имеем путь i -> k -> j. Если далее sik = k и skj = j, тогда считаем, что весь путь определен, так как найдены все промежуточные узлы. В противном случае повторяем описанную процедуру для путей от узла i к узлу k и от узла k к узлу j.

Пример. Найдем для сети, показанной на рисунке 4, кратчайшие пути между любыми двумя узлами. Расстояние между узлами этой сети проставлены на рисунке возле соответствующих ребер. Ребро (3, 5) ориентированно, поэтому не допускается движение от узла 5 к узлу 3. Все остальные ребра допускают движение в обе стороны:

Рис.4. Пример сети
Шаг 0. Начальные матрицы D0 и S0 строятся непосредственно по заданной схеме сети. Матрица D0 симметрична, за исключением пары элементов d35 и d53, где d53 равно бесконечности, поскольку невозможен переход от узла 5 к узлу 3:

Рис.5. Начальное состояние
Шаг 1. В матрице D0 выделены ведущие строка и столбец (k = 1). Двойной рамкой представлены элементы d23 и d32, единственные среди элементов матрицы D0, значения которых можно улучшить с помощью треугольного оператора. Таким образом, чтобы на основе матриц D0 и S0 получить матрицы D1 и S1, выполняем следующие действия.
    1. Заменяем d23 на d21 + d13 = 3 + 10 = 13 и устанавливаем s23 = 1.
    2. Заменяем d32 на d31 + d12 = 10 + 3 = 13 и устанавливаем s32 = 1.
Матрицы D1 и S1 имеют следующий вид:

Рис.6. Матрицы D1 и S1
Шаг 2. Полагаем k = 2; в матрице D1 выделены ведущие строка и столбец. Треугольный оператор применяется к элементам матрицы D1 и S1, выделенным двойной рамкой. В результате получаем матрицы D2 и S2:

Рис.7. Матрицы D2 и S2
Шаг 3. Полагаем k = 3; в матрице D2 выделены ведущие строка и столбец. Треугольный оператор применяется к элементам матрицы D2 и S2, выделенным двойной рамкой. В результате получаем матрицы D3 и S3:

Рис.8. Матрицы D3 и S3
Шаг 4. Полагаем k = 4, ведущие строка и столбец в матрице D3 выделены. Получаем новые матрицы D4 и S4:

Рис.9. Матрицы D4 и S4
Шаг 5. Полагаем k = 5, ведущие строка и столбец в матрице D4 выделены. Никаких действий на этом шаге не выполняем; вычисления закончены.
Конечные матрицы D4 и S4 содержат всю информацию, необходимую для определения кратчайших путей между любыми двумя узлами сети. Например, кратчайшее расстояние между узлами 1 и 5 равно d15 = 12.
Для нахождения соответствующих маршрутов напомним, что сегмент маршрута (i, j) состоит из ребра (i, j) только в том случае, когда sij = j. В противном случае узлы i и j связаны, по крайней мере, через один промежуточный узел. Например, поскольку s15 = 4 и s45 = 5, сначала кратчайший маршрут между узлами 1 и 5 будет иметь вид 1->4->5. Но так как s14 не равно 4, узлы 1 и 4 в определенном пути не связаны одним ребром (но в исходной сети они могут быть связаны непосредственно). Далее следует определить промежуточный узел (узлы) между первым и четвертым узлами. Имеем s14 = 2 и s24 = 4, поэтому маршрут 1->4 заменяем 1->2->4. Поскольку s12 = 2 и s24 = 4, других промежуточных узлов нет. Комбинируя определенные сегменты маршрута, окончательно получаем следующий кратчайший путь от узла 1 до узла 5: 1->2->4->5. Длина этого пути равна 12 километрам.
Приведем текст программы, реализующей алгоритм Флойда.
#include <iostream.h>
#define TRUE 1
#define FALSE 0
#define MaxNodes 5  //Количество вершин.
//Описание типа узла стека.
typedef struct Zveno *svqz;
typedef struct Zveno
{
  int Element;
  svqz Sled;
};

class Spisok
{
  private:
         int Mas[MaxNodes][MaxNodes];  //Матрица весов дуг.
         int DD[MaxNodes][MaxNodes];   //Матрица расстояний.
         int SS[MaxNodes][MaxNodes];   //Матрица последовательных узлов.
         svqz Stack; //Указатель на рабочий стек.
         void UDALENIE (svqz *, int *);
         void W_S (svqz *, int);
         void Small_Put (int,int);
  public:
         Spisok() {Stack = NULL;}
         void Vvod_Ves();
         void Reshenie ();
};

void main()
{
  Spisok A;

  A.Vvod_Ves();
  A.Reshenie();
}

void Spisok::Small_Put (int one, int two)
//Нахождение кратчайшего пути.
{
  svqz St=NULL; //Указатель на вспомогательный стек.
  svqz UkZv;
  int Flag=FALSE; //Флаг построения кратчайшего пути.
  int elem1,elem2,k;
  //Помещение в стек конечной и начальной вершин.
  W_S (&Stack,two);
  W_S (&Stack,one);
  while (!Flag)
  {
    //Извлекли верхних два элемента.
    UDALENIE(&Stack,&elem1);
    UDALENIE(&Stack,&elem2);
    if (SS[elem1][elem2]==elem2) //Если есть путь...
      if (elem2==two) //и это конечный узел...
      {
       Flag = TRUE;   //то кратчайший путь найден.
       W_S (&St,elem1);
       W_S (&St,elem2);
      }
      else //и это не конечный узел...
      {
       W_S (&St,elem1); //В вспомогательный стек.
       W_S (&Stack,elem2); //Обратно в рабочий стек.
      }
    else //Если пути нет.
    {
      W_S (&Stack,elem2); //Обратно в рабочий стек.
      k = SS[elem1][elem2];
      W_S (&Stack,k);     //Запомнить промежуточную вершину.
      W_S (&Stack,elem1); //Обратно в рабочий стек.
    }
  }
  UkZv = St;
  while ( UkZv != NULL )
  {  cout << (UkZv->Element+1) << " "; 
     UkZv = UkZv->Sled;  }
  cout << endl;
}

void Spisok::W_S (svqz *stk, int Elem)
//Помещение Elem в стек stk.
{
  svqz q=new (Zveno);
  (*q).Element = Elem; 
  (*q).Sled = *stk; *stk = q;
}

void Spisok::UDALENIE (svqz *stk, int *Klad)
//Удаление звена из стека, заданного указателем *stk.
//Значение информационного поля удаляемого звена сохраня-
//ется в параметре Klad.
{
  svqz q;

  if (*stk==NULL) cout<<"Попытка выбора из пустого стека!\n";
  else
	{ *Klad = (**stk).Element;
	  q = *stk; *stk = (**stk).Sled; delete q; }
}


void Spisok::Vvod_Ves()
//Ввод матрицы весов дуг заданного графа.
{
  cout << "Вводите элементы матрицы весов дуг по строкам:\n";
  for (int i=0;i<MaxNodes;i++)
   for (int j=0;j<MaxNodes;j++)
     {
       cout << "Введите Mas[" << (i+1) << "," << (j+1) << "]: "; 
       cin >> Mas[i][j];
     }
}

void Spisok::Reshenie()
{
  int one,two;
  int i,j;

  //Инициализация.
  for (i=0;i<MaxNodes;i++)
   for (j=0;j<MaxNodes;j++)
   {
     if (Mas[i][j]>0)  SS[i][j]=j;
     else SS[i][j]=0;
     DD[i][j]=Mas[i][j];
   }
   cout << "\nНачальная вершина: ";
   cin >> one; one--;
   cout << "Конечная вершина: ";
   cin >> two; two--;

   int ved=0;
   while (ved<MaxNodes)
   {
     for (i=0;i<MaxNodes;i++)
      for (j=0;j<MaxNodes;j++)
        if (i!=j && i!=ved && j!=ved &&
            DD[i][ved]>0 && DD[ved][j]>0) 
          if (DD[i][ved]+DD[ved][j]<DD[i][j] || DD[i][j]==0) 
          {
             DD[i][j]=DD[i][ved]+DD[ved][j];
             SS[i][j]=ved;
          }
          ved++;
   }
   i=one;
   if (SS[i][two]!=two && SS[i][two]!=0) 
     while (SS[i][two]!=two) 
     {
        j=SS[i][two];
        while (SS[i][j]!=j)  j=SS[i][j];
        i=j;
     }
     cout << "\nКратчайший путь (в обратном порядке): ";
     Small_Put (one, two);
     cout << "Длина минимального пути между этими вершинами: " << DD[one][two];
}
Текст этой программы можно взять здесь.
Результат работы этой программы для сети, изображенной на рисунке 4, будет следующим:

Рис.10. Результат работы приложения
На следующем шаге мы рассмотрим задачу о максимальном потоке.


        1.8. Задача о максимальном потоке
На этом шаге мы сформулируем задачу о максимальном потоке.
Рассмотрим сеть трубопроводов для транспортировки сырой нефти от буровых скважин до нефтеперегонных заводов. Для перекачки нефти предусмотрены магистральные насосные станции. Каждый сегмент трубопровода имеет свою пропускную способность. Сегменты трубопровода могут быть как однонаправленные (осуществляют перекачку нефти только в одном направлении), так и в двунаправленные. В однонаправленных сегментах положительная пропускная способность предполагается в одном направлении и нулевая - в другом. На рис. 1 показана типовая сеть нефтепроводов. Как определить оптимальную пропускную способность (т.е. максимальный поток) между нефтяными скважинами и нефтеперегонными заводами?

Рис.1. Типовая сеть нефтепроводов
При решении данной задачи исходную сеть необходимо свести к сети с одним источником и одним стоком. Этого можно достигнуть путем введения дополнительных дуг с бесконечной пропускной способностью от источника к скважинам и от нефтеперегонных заводов к стоку (на рис. 1 эти дуги показаны пунктирными линиями).
Для ребра (i, j), где i < j, используем запись (Cij,Cji) для представления пропускных способностей в направлениях i->j и j->i соответственно. Во избежании недоразумений на схеме сети Cij будем располагать на ребре (i, j) ближе к узлу i, а Cji ближе к узлу j, как показано на рис. 2.

Рис.2. Иллюстрация пропускной способности

Перебор разрезов

Разрез определяет множество ребер, при удалении которых из сети полностью прекращается поток от источника к столу. Пропускная способность разреза равна сумме пропускных способностей "разрезанных" ребер. Среди всехразрезов сети разрез с минимальной пропускной способностью определяет максимальный поток в сети.

Пример. Рассмотрим сеть, показанную на рис. 3. На этом рисунке при обозначении пропускных способностей двунаправленных ребер придерживались соглашения, принятого ранее (рис. 2). Например, для ребра (3, 4) пропускная способность в направлении 3 -> 4 равна 10, а в направлении 4 -> 3 равна 5.

Рис.3. Пример сети
Разрезы, представленные на рис. 3, имеют следующие пропускные способности:
Разрез   "Разрезанные" ребра	           Пропускная способность
   1     (1, 2), (1, 3), (1, 4)             10 + 30 + 20 = 60
   2     (1, 3), (1, 4), (2, 3), (2, 5)     30 + 10 + 40 + 30 = 110
   3     (2, 5), (3, 5), (4, 5)             30 + 20 + 20 = 70
Вывод, который можно сделать из этих трех разрезов, заключается в том, что максимальный поток не может превышать 60 единиц. Но мы не можем сказать, какой максимальный поток на самом деле, так как не перебрали все возможные разрезы сети. К сожалению, перебор всех разрезов является непростой задачей. Поэтому для определения максимального потока в сети не используются алгоритмы, основанные на полном переборе разрезов.
На следующем шаге мы рассмотрим алгоритм нахождения максимального потока.

        1.9. Алгоритм нахождения максимального потока
На этом шаге мы реализуем алгоритм нахождения максимального потока.
Идея данного алгоритма состоит в нахождении сквозных путей с положительными потоками от источника к стоку.
Рассмотрим ребро (i, j) с (начальной) пропускной способностью (Cij,Cji). В процессе выполнения алгоритма части этих пропускных способностей "забираются" потоками, проходящими через данное ребро, в результате каждое ребро будет иметь остаточную пропускную способность. Будем использовать запись (cij, cji) для представления остаточных пропускных способностей. Сеть, где все ребра имеют остаточную пропускную способность, назовем остаточной.
Для произвольного узла j, получающего поток от узла i, определим метку [aj, i], где aj - величина потока, протекающего от узла j к узлу i. Алгоритм нахождения максимального потока предполагает выполнение следующих действий.
Шаг 1. Для всех ребер (i, j) положим остаточную пропускную способность равной первоначальной пропускной способности, т.е. приравняем (cij, cji) = (Cij, Cji). Назначим a1 = бесконечности и пометим узел 1 меткой [бесконечность, -]. Полагаем i = 1 и переходим ко второму шагу.
Шаг 2. Определяем множество Si как множество узлов j, в которые можно перейти из узла i по ребру с положительной остаточной пропускной способностью (т.е. cij > 0 для всех j, принадлежащих Si). Если Si не пустое множество, выполняем третий шаг, в противном случае переходим к шагу 4.
Шаг 3. В множестве Si находим узел k, такой, что cik = max {cij} для всех j, принадлежащих Si. Положим ak = cik и пометим узел k меткой [ak, i]. Если последней меткой помечен узел стока (т.е. если k = n), сквозной путь найден, и мы переходим к пятому шагу.
Шаг 4 (Откат назад). Если i = 1, сквозной путь невозможен, и мы переходим к шагу 6. Если i не равно 1, находим помеченный узел r, непосредственно предшествующий узлу i, и удаляем узел i из множества узлов, смежных с узлом r. Полагаем i = r и возвращаемся ко второму шагу.
Шаг 5 (Определение остаточной сети). Обозначим через Np = {1, k1, k2, …, n} множество узлов, через которые проходит p-й найденный сквозной путь от узла источника (узел 1) до узла стока (узел n). Тогда максимальный поток, проходящий по этому пути, вычисляется как fp = min {a1, ak1, ak2, ..., an}.
Остальные пропускные способности ребер, составляющих сквозной путь, уменьшается на величину fp в направлении движения потока и увеличиваются на эту же величину в противоположном направлении. Таким образом, для ребра (i, j), входящего в сквозной путь, текущие остаточные стоимости (cij, cji) изменятся следующим образом:
    • (cij - fp, cji + fp), если поток идет от узла i к узлу j,
    • (cij + fp, cji - fp), если поток идет от узла j к узлу i.
Далее восстанавливаем все узлы, удаленные на шаге 4. полагаем i = 1 и возвращаемся ко второму шагу для поиска нового сквозного пути.
Шаг 5 (Решение).
    • При m найденных сквозных путях максимальный поток вычисляется по формуле F = f1 + f2 + ... + fm.
    • Имея значения начальных (Cij, Cji) и конечных (cij, cji) пропускных способностей ребра (i, j), можно вычислить оптимальный поток через это ребро следующим образом. Положим (a,b) = (Cij - cij, Cji - cji). Если a > 0, поток, проходящий через ребро (i, j), равен a. Если же b > 0, тогда поток равен b. (Случай, когда одновременно a > 0 иb > 0, невозможен.)
Процесс отката назад на четвертом шаге выполняется тогда, когда алгоритм должен "убить" промежуточный узел до момента реализации сквозного пути. Коррекцию пропускных способностей, выполняемых на шаге 5, можно пояснить на примере простой сети, показанной на рис. 1. На рис. 1а найден первый сквозной путь N1 = {1, 2, 3, 4} с максимальным потоком f1 = 5. После этого остаточные пропускные способности ребер (1, 2), (2, 3) и (3, 4) изменятся соответственно с (5, 0) на (0, 5). На рис. 1б показан второй сквозной путь N2 = {1, 3, 2, 4} с максимальным потоком f2 = 5. После коррекции пропускных способностей получаем сеть, показанную на рис. 1в, где уже невозможно построить сквозной путь. Почему так получилось? При вычислении остаточных пропускных способностей на шаге 5 при переходе от сети (б) к сети (в) невозможна организация потока в направлении 2 -> 3. Получается, что алгоритм как бы "помнит", что поток в направлении 2 -> 3 уже был в предыдущих сквозных путях, и поэтому снова (на пятом шаге) изменяет пропускную способность с 0 до 5 в направлении от узла 3 к узлу 2.

Рис.1. Иллюстрация сквозных путей

Пример. Найдем максимальный поток в сети из примера предыдущего шага. На рисунке 2 предлагается графическая иллюстрация выполнения алгоритма. Считаем полезным сравнить описание выполняемых алгоритмом вычислительных итераций с их графическим представлением.

Рис.2. Графическая иллюстрация выполнения алгоритма
Итерация 1.
Положим остаточные пропускные способности (cij, cji) всех ребер равными первоначальным пропускным способностям (Cij, Cji).
Шаг 1. Назначаем a1 = бесконечности и помечаем узел 1 меткой [бесконечность,-]. Полагаем i = 1.
Шаг 2. S1 = [2, 3, 4] (множество не пустое).
Шаг 3. k = 3, поскольку c13 = max {c12, c13, c14} = max {20, 30, 10} = 30. Назначаем a3 = c13 = 30 и помечаем узел 3 меткой [30, 1]. Полагаем i = 3 и возвращаемся к шагу 2.
Шаг 2. S2 = [4, 5].
Шаг 3. k = 5 и a5 = c35 = max {10, 20} = 20. Помечаем узел 5 меткой [20,3]. Получен сквозной путь. Переходим к шагу 5.
Шаг 5. Сквозной путь определяем по меткам, начиная с узла 5 и заканчивая узлом 1: (5) -> [20, 3] -> (3) -> [30, 1] -> (1). Таким образом, N1 = {1, 3, 5} и f1 = min {a1, a3, a5} = {бесконечность, 30, 20} = 20. Вычисляем остаточные пропускные способности вдоль пути N1:
  (c13, c31) = (30 - 20, 0 + 20) = (10, 20),
  (c35, c53) = (20 - 20, 0 + 20) = (0, 20).
Итерация 2.
Шаг 1. Назначаем a1 = бесконечности и помечаем узел 1 меткой [бесконечность,-]. Полагаем i = 1.
Шаг 2. S1 = [2, 3, 4].
Шаг 3. k = 2, назначаем a2 = c12 = max {20, 10, 10} = 20 и помечаем узел 2 меткой [20, 1]. Полагаем i =2 и возвращаемся к шагу 2.
Шаг 2. S3 = [4] (отметим, что c35 = 0, поэтому узел 5 не включается в S3).
Шаг 3. k = 4, назначаем a4 = c34 = 10 и помечаем узел 4 меткой [10, 3]. Полагаем i = 4 и возвращаемся к шагу 2.
Шаг 2. S4 = [5] (поскольку узлы 1 и 3 уже помечены, они не включаются в S4).
Шаг 3. k = 5 и a5 = c45 = 20. Помечаем узел 5 меткой [20, 4]. Получаем сквозной путь. Переходим к шагу 5.
Шаг 5. N2 = {1, 2, 3, 4, 5} и f2 = min {бесконечность, 20, 40, 10, 20} = 10. Вычисляем остаточные пропускные способности вдоль пути N2:
  (c12, c21) = (20 - 10, 0 + 10) = (10, 10),
  (c23, c32) = (40 - 10, 0 + 10) = (30, 10),
  (c34, c43) = (10 - 10, 5 + 10) = (0, 15),
  (c45, c54) = (20 - 10, 0 + 10) = (10, 10).
Итерация 3.
Шаг 1. Назначаем a1 = бесконечности и помечаем узел 1 меткой [бесконечность,-]. Полагаем i = 1.
Шаг 2. S1 = [2, 3, 4].
Шаг 3. k = 2, назначаем a2 = c12 = max {10, 10, 10} = 10 и помечаем узел 2 меткой [10, 1]. Полагаем i = 2 и возвращаемся к шагу 2.
Шаг 2. S2 = [3, 5].
Шаг 3. k = 3 и a3 = c23 = 30. Помечаем узел 3 меткой [30, 2]. Полагаем i = 3 и возвращаемся к шагу 2.
Шаг 2. S3 пусто, поскольку c34 = c35 = 0. Переходим к шагу 4.
Шаг 4. Метка [30, 2] узла 3 показывает номер предшествующего узла r = 2. На этой итерации узел 3 в дальнейшем во внимание не принимается, его метку вычеркиваем. Полагаем i = r = 2 и возвращаемся к шагу 2.
Шаг 2. S4 = [5] (поскольку узел 3 удален из возможного сквозного пути).
Шаг 3. k = 5 и a5 = c25 = 30. помечаем узел меткой [30, 2]. Получаем сквозной путь. Переходим к шагу 5.
Шаг 5. N3 = {1, 2, 5} и f3 = min {бесконечность, 10, 30} = 10. Вычисляем остаточные пропускные способности вдоль пути N3:
  (c12, c21) = (10 - 10, 10 + 10) = (0, 20),
  (c2, c52) = (30 - 10, 0 + 10) = (20, 10).
Итерация 4. На этой итерации получен путь N4 = {1, 3, 2, 5} с f4 = 10.
Итерация 5. На этой итерации получен путь N5 = {1, 4, 5} с f5 = 10.
Итерация 6. Новые сквозные пути невозможны, поскольку все ребра, исходящие из узла 1, имеют нулевые остаточные пропускные способности. Переходим к шагу 6 для определения решения.
Шаг 6. Максимальный объем потока в сети равен F = f1 + f2 + … +f5 = 20 + 10 + 10 + 10 + 10 = 60 единиц. Значения потоков по различным ребрам вычисляются путем вычитания последних значений остаточных пропускных способностей (т.е. (cij, cji)6) из первоначальных значений пропускных способностей (Cij, Cji). Результаты вычислений приведены ниже:
Ребро  (Cij, Cji)-(cij, cji)6        Величина потока  Направление
(1, 2)	(20, 0) - (0, 20) = (20, -20)	20	     1->2
(1, 3)	(30, 0) - (0, 30) = (30, -30)	30	     1->3
(1, 4)	(10, 0) - (0, 10) = (10, -10)	10	     1->4
(2, 3)	(40, 0) - (40, 0) = (0, 0)	0	             -
(2, 5)	(30, 0) - (10, 20) = (20, -20)	20	     2->5
(3, 4)	(10, 5) - (0, 15) = (10, -10)	10	     3->4
(3, 5)	(20, 0) - (0, 20) = (20, -20)	20	     3->5
(4, 5)	(20, 0) - (0, 20) = (20, -20)	20	     4->5
Приведем текст программы, решающей данную задачу:
#include <iostream.h>
#include <stdlib.h>  //Для функции abs().
#define TRUE 1
#define FALSE 0
#define MaxNodes 5   //Количество вершин.
#define MaxInt 1000  //Машинный эквивалент бесконечности.


//Описание типа узла.
struct Uzel
{
  int Element; //Заданный номер вершины.
  int Propusk; //Пропускная способность.
  int Metka;   //Помечена вершина или нет.
};


class Spisok
{
  private:
      int C[MaxNodes][MaxNodes];    //Матрица начальных пропускных способностей.
      int c[MaxNodes][MaxNodes];    //Матрица конечных пропускных способностей.
      int Put[MaxNodes][MaxNodes];  //Матрица сквозных путей.
      int Potok [MaxNodes];         //Потоки.
      int Est (Uzel*,int,int);
      int Tpk (int*,int,int);
  public:
      void Vvod_Ves();
      int Reshenie ();
      void Vyvod(int);

};

void main()
{
  Spisok A;

  A.Vvod_Ves();
  A.Vyvod(A.Reshenie());
}

void Spisok::Vvod_Ves()
//Ввод матрицы пропускных способностей.
{
  cout << "Вводите пропускные способности ребер:\n";
  for (int i=0;i<MaxNodes;i++)
   for (int j=0;j<MaxNodes;j++)
     {
       cout << "Введите C[" << (i+1) << "," << (j+1) << "]: "; 
       cin >> C[i][j];
       c[i][j] = C[i][j];
     }
}

void Spisok::Vyvod(int n)
//Вывод результатов.
{
  //Вычисление максимального объема потока.
  for (int i=0,sum=0;i<=n;sum+=Potok[i++]);
  cout << "\nМаксимальный объем потока в сети: " << sum;
  cout << "\nЗначения потоков по различным ребрам:\n";
  for (i=0;i<MaxNodes;i++)
   for (int j=i;j<MaxNodes;j++)
     if (C[i][j])
     {
         cout << "Ребро (" << (i+1) << "," << (j+1) <<"): ";
         cout << "(" << C[i][j]  << "," << C[j][i] << ")-(";
         cout << c[i][j]  << "," << c[j][i] << ")=(";
         cout << (C[i][j]-c[i][j]) << "," << (C[j][i]-c[j][i]) << ") ";
         cout << "Поток: " << abs(C[i][j]-c[i][j]) << " ";
         if (C[i][j]-c[i][j]!=0)
         {
           cout << "Направление: ";
           if (C[i][j]-c[i][j]>0)
              cout << (i+1) << "->" << (j+1);
           else
              cout << (j+1) << "->" << (i+1);
         }
         cout << endl;
     }
}

int Spisok::Reshenie()
{
  Uzel SS[MaxNodes]; //Множество узлов, в которые можно перейти.
  Uzel S[MaxNodes]; //Путь.
  int i,j=0,k,el,mx,mn;
  int m; //Текущее количество вершин в пути.
  int nomer=-1; //Текущее количество сквозных потоков.
  int Tupik[MaxNodes]; //Перечень "тупиковых" вершин.
  int N_Tupik; //Количество элементов в массиве.

  while (j!=-1)
  {
    i=m=0;
    S[i].Element=0;
    S[i].Propusk=MaxInt;
    S[i].Metka=TRUE;
    el=0;
    N_Tupik=-1;
    while (el!=MaxNodes-1)
    {
      j=-1;
      for (k=0;k<MaxNodes;k++)
       if (c[i][k]!=0) //Если есть ненулевой поток...
        if (i>0)   //и в путь уже включены вершины...
        {
          if (!Est(&S[0],m,k) && !Tpk(&Tupik[0],N_Tupik,k)) 
                            //то включаем текущую вершину,
                           //если ее нет в пути и если она не "тупиковая".
          {  
             SS[++j].Element=k;
             SS[j].Propusk=c[i][k];
             SS[j].Metka=FALSE;
          }
        }
        else 
          if (!Tpk(&Tupik[0],N_Tupik,k)) //Не вернулись ли назад?
               //Поток не нулевой, и это первая вершина.
          {    //Включаем эту вершину в путь.
               SS[++j].Element=k;
               SS[j].Propusk=c[i][k];
               SS[j].Metka=FALSE;
          }
      if (j!=-1) //Есть продолжение.
      {
         mx=SS[0].Propusk;
         el=0;
         for (k=1;k<=j;k++)
          if (SS[k].Propusk>mx)
            { el=k; mx=SS[k].Propusk; }
         S[++m].Element=SS[el].Element;
         S[m].Propusk=mx;
         S[m].Metka=TRUE;
         if (SS[el].Element==MaxNodes-1) //Найден сквозной путь.
         {
           nomer++;
           //Запоминаем сквозной путь.
           for (k=0;k<=m;k++)
              Put[nomer][k]=S[k].Element;
           //Ищем минимальный поток.
           mn=S[0].Propusk;
           el=0;
           for (k=1;k<=m;k++)
            if (S[k].Propusk<mn)
              { el=k; mn=S[k].Propusk; }
           Potok[nomer]=mn; //Запоминаем его.
           //Вычисляем остаточные пропускные способности.
           for (k=0;k<m;k++)
           { 
             c[S[k].Element][S[k+1].Element] -= Potok[nomer];
             c[S[k+1].Element][S[k].Element] += Potok[nomer];
           }
           el=MaxNodes-1; //Переход к следующей итерации.
           j=0;
         }
         else i=S[m].Element;
      }
      else //Продолжения нет. Это возможно тогда, когда:
      {
         if (i==0)  //а) все пропускные способности нулевые.
                    //   В этом случае - выход
              el=MaxNodes-1;
         else       //б) мы попали в тупик. Запомним тупиковую вершину
                    //   в массиве и отступим назад на одну вершину.
         {
           Tupik[++N_Tupik]=S[m].Element;
           m--;
           i=S[m].Element;
         }
      }
    }
  }
  return nomer; //Возвращает количество сквозных потоков.
}

int Spisok::Est(Uzel S[], int m, int k)
//Функция проверяет, есть ли вершина k в пути S.
//m - текущее количество элементов в пути.
//Возвращает 1, если вершина есть, и 0 - в противном случае.
{
  for (int l=0;l<=m;l++)
    if (S[l].Element==k) return 1;
  return 0;
}

int Spisok::Tpk(int Tupik[],int N_Tupik, int k) 
//Функция проверяет, есть ли вершина k в массиве "тупиковых" вершин.
//N_Tupik - текущее количество вершин в массиве.
//Возвращает 1, если вершина есть, и 0 - в противном случае.
{
  if (N_Tupik==-1) return 0;
  for (int l=0;l<=N_Tupik;l++)
    if (Tupik[l]==k) return 1;
  return 0;
}
Текст этой программы можно взять здесь.
Результат работы этой программы для сети, изображенной на рисунке 2, будет следующим:

Рис.3. Результат работы приложения
Со следующего шага мы начнем рассматривать задачу о нахождении потока наименьшей стоимости.

        1.10. Нахождение потока наименьшей стоимости (общие замечания)
На этом шаге мы рассмотрим (общих чертах) задачу нахождения потока наименьшей стоимости.
Задача нахождения потока наименьшей стоимости в сети с ограниченной пропускной способностью обобщает задачу определения максимального потока по следующим направлениям.
    1. Все ребра допускают только одностороннее направление потока, т.е. являются (ориентированными) дугами.
    2. Каждой дуге поставлена в соответствие (неотрицательная) стоимость прохождения единицы потока по данной дуге.
    3. Дуги могут иметь положительную нижнюю границу пропускной способности.
    4. Любой узел сети может выступать как в качестве источника, так и стока.
В рассматриваемой задаче необходимо найти потоки по дугам, минимизирующие общую стоимость прохождения потока по сети; при этом должны удовлетворятся ограничения на пропускные способности дуг и на величины предложений и спроса отдельных (или всех) узлов. Сначала опишем сетевую модель с заданными стоимостями прохождения потока по дугам и сформулируем соответствующую задачу линейного программирования. Эта задача далее будет использована как основа для построения специального симплексного алгоритма, предназначенного для решения данной сетевой задачи.
Прежде чем приступить к рассмотрению поставленной задачи коротко изложим основные положения линейного программирования и симплекс-метода, упомянутые выше.
Линейное программирование - это метод математического моделирования, разработанный для оптимизации использования ограниченных ресурсов. Задачи линейного программирования являются задачами на нахождение наиболее выгодного варианта: наилучшего плана перевозок, наиболее экономного рациона и т.д. С математической точки зрения в каждой задаче ищутся значения нескольких неизвестных, причем требуется, чтобы:
    • эти значения были неотрицательны;
    • эти значения удовлетворяли некоторой системе линейных уравнений или линейных неравенств;
    • при этих значениях некоторая линейная функция обращалась в минимум (или максимум).
Число переменных и число условий могут быть какими угодно. В реальных задачах эти числа весьма велики. Общая математическая формулировка задачи линейного программирования выглядит следующим образом.
Дана система линейных уравнений
  a11x1 + a12x2 + … + a1nxn = b1
  a21x1 + a22x2 + … + a2nxn = b2    (*)
  .   .   .   .   .   .   .   .
  am1x1 + am2x2 + … + amnxn = bm
и линейная функция
  f = c1x1 + c2x2 + ... + cnxn.
Требуется найти такое неотрицательное решение
  x1>=0, x2>=0, ... , xn>= 0
системы, при котором функция f принимает наименьшее значение (минимизируется).
Естественно, что решение таких задач связано с большим объемом вычислений. Однако существуют методы, позволяющие найти решение любой задачи линейного программирования за конечное число шагов. К их числу относится прежде всего так называемый симплекс-метод.
Для начала работы по симплекс-методу требуется, чтобы заданная система уравнений была приведена к такому виду, в котором какие-либо r неизвестных (r<=m) выражены через остальные, причем свободные члены этих выражений неотрицательны. Предположим, для определенности, что неизвестные, которые выражены через остальные, - это x1, ..., xr. Следовательно, система приведена к виду: приведена к виду:
  x1 =  a'1,r+1xr+1 + ... +  a'1,nxn +  b'1
  x2 =  a'2,r+1xr+1 + ... +  a'2,nxn +  b'2
  .   .   .   .   .   .   .   .
  xr =  a'r,r+1xr+1 + ... +  a'r,nxn +  b'r
где
b'1 >=0, b'2 >=0, ..., b'n >=0  (**)
Неизвестные x1, …, xr, находящиеся в левой части этой системы, называются базисными, а весь набор { x1, …, xr}, который мы обозначим для краткости одной буквой Б, - базисом, остальные неизвестные называются небазиснымиили свободными. Подставляя в форму f вместо базисных неизвестных их выражения через небазисные из последней системы, мы можем и саму форму f также записать через небазисные неизвестные xr+1, …, xn:
  f = c0 +  с'r+1xr+1 + ... + с'nxn.
Положим все небазисные неизвестные равными нулю: xr+1 = ... = xn = 0 и и найдем из последней системы значения базисных неизвестных: x1 = b'1, …, xr = b'n. Полученное таким путем решение системы:
  (b'1, …, b'r, 0, …, 0)
будет, вследствие (**), допустимым. Оно называется базисным решением, отвечающим базису x1, …, xr. Для базисного решения значение формы f равно
  fБ = с0.
Решение задачи при помощи симплекс-метода распадается на ряд шагов. Каждый из шагов заключается в том, что от данного базиса Б мы переходим к другому базису Б' с таким расчетом, чтобы значение fБ уменьшилось или, по крайней мере, не увеличилось: fБ' <= fБ. Новый базис Б' получается из старого Б весьма просто: из Б удаляется одна из неизвестных и взамен нее вводится другая (из числа прежних небазисных). Изменение базиса влечет за собой соответствующую перестройку системы (*). После некоторого числа таких шагов мы или приходим к базису Б(k), для которого fБ(k) есть искомый минимум формы f, а соответствующее базисное решение является оптимальным, или же выясняем, что задача решения не имеет.
При рассмотрении поставленной задачи необходимо знать термин двойственная задача. Исходную задачу линейного программирования будем называть прямой. Двойственная задача - это задача, формулируемая с помощью определенных правил непосредственно из прямой задачи. Переменные и ограничения двойственной задачи формируются путем преобразований прямой задачи по следующим правилам:
    1. Каждому из m ограничений прямой задачи соответствует переменная двойственной задачи.
    2. Каждой из n переменных прямой задачи соответствует ограничение двойственной задачи.
    3. Коэффициенты при какой-либо переменной в ограничениях прямой задачи становятся коэффициентами ограничения двойственной задачи, соответствующей этой переменной, а правая часть формируемого ограничения равна коэффициенту при этой переменной в выражении целевой функции.
    4. Коэффициенты целевой функции двойственной задачи равны правым частям ограниченной прямой задачи.
На следующем шаге мы рассмотрим пример построения сетевой модели.


        1.11. Нахождение потока наименьшей стоимости. Сетевая модель
На этом шаге мы рассмотрим пример сетевой модели.
Рассмотрим сеть G = (N, A) с ограниченной пропускной способностью, где N - множество узлов, A - множество дуг. Обозначим:
    • xij - величина потока, протекающего от узла i к узлу j,
    • uij (lij) - верхняя (нижняя) граница пропускной способности дуги (i, j),
    • cij - стоимость прохождения единицы потока по дуге (i, j),
    • fi - величина "чистого" результирующего потока, протекающего через узел i.
На рисунке 1 показано, как на схемах сетей будем отображать определенные параметры дуг. Метка [fi] указывает положительное (отрицательное) значение предложения (спроса), соответствующего узлу i:

Рис.1. Отображение параметров дуг
Рассмотрим пример построения сетевой модели.

Пример. Компания GrainCo снабжает зерном из трех зернохранилищ три птицеводческие фермы. Предложение зернохранилищ составляет 100, 200 и 50 тысяч тонн зерна, а спрос ферм - 150, 80 и 120 тысяч тонн соответственно. Компания может транспортировать зерно по железной дороге, за исключением трех маршрутов, где используется автомобильный транспорт.

Рис.2. Схема маршрутов
На рисунке 2 показаны возможные маршруты между зернохранилищами и птицеводческими фермами. Зернохранилища представлены узлами 1, 2 и 3; их предложения указаны метками [100], [200] и [50] соответственно. Фермы обозначены узлами 4, 5 и 6 с величинами спроса [-150], [-80] и [-120]. Маршруты транспортировки зерна показаны на рисунке 2 дугами, соединяющими узлы сети. Дуги (1, 4), (3, 4) и (4, 6) соответствуют автомобильным маршрутам. Эти маршруты имеют верхние и нижние границы пропускных способностей. Например, по маршруту (1, 4) можно провести от 50 до 80 тысяч тонн зерна. Другие маршруты соответствуют железнодорожному транспорту, пропускная способность которого практически не ограничена. Стоимость транспортировки одной тонны зерна показана возле каждой дуги.
На следующем шаге мы рассмотрим сетевую модель как задачу линейного программирования.

        1.12. Нахождение потока наименьшей стоимости. Сетевая модель как задача линейного программирования
На этом шаге мы рассмотрим преобразование сетевой модели в задачу линейного программирования.
Определение модели сети с ограниченной пропускной способностью как задачи линейного программирования необходимо для разработки симплексного алгоритма решения задач данного типа. Используя определения, данные в шаге 127, мы можем записать задачу линейного программирования для сети с ограниченной пропускной способностью следующим образом.
Минимизировать:

при ограничениях:

Результирующий "чистый" поток fj, протекающий через узел j, вычисляется по формуле
    fj = (Величина потока, выходящего из узла j) - 
                      (Величина потока, входящего в узел j).
Узел j выступает в качестве источника, если fj > 0, и как исток при fj < 0.
Нижнюю границу пропускной способности lij можно удалить из ограничений с помощью подстановки xij = x'ij - lij. Для нового потока верхней границей пропускной способности будет величина uij - lij. В этом случае результирующий поток через узел i будет равен [fi] - lij, а через узел j - [fj] + lij. На рисунке 1 показаны преобразования характеристик дуги (i, j) после исключения ее нижней границы пропускной способности.

Рис.1. Преобразования характеристик

Пример 1. Запишем задачи линейного программирования для сети из рисунка 2 до и после исключения нижних границ пропускных способностей.
Основные ограничения формулируемой задачи линейного программирования связаны с определением входных и выходных потоков, протекающих через каждый узел, что порождает следующую задачу линейного программирования:
              x12    x13    x14    x23    x25    x34    x35    x46    x56
Миними-       3      4      1      5      6      1      2      2      4	
зировать
Узел 1        1      1      1                                               = 100
Узел 2       -1                    1      1                                 = 200
Узел 3              -1            -1             1      1                   =  50
Узел 4                     -1                   -1             1            =-150
Узел 5                                   -1            -1             1     = -80
Узел 6                                                        -1     -1     =-120
Нижние        0      0     50      0      0     70      0    100      0	
границы										
Верхние       Б      Б     80      Б      Б    120      Б    120      Б 	
границы										

Примечание. Б - бесконечность.
Сделаем замечание о структуре коэффициентов, формирующих ограничения. В столбце, соответствующем переменной xij, всегда в строке i стоит +1, а в строке j находится -1. Остальные коэффициенты равны нулю. Такая структура коэффициентов типична для сетевых моделей.
Для переменных, представляющих потоки через дуги, имеющие ненулевые нижние границы пропускных способностей, выполняем замену:
  x14 = x'14 + 50,
  x34 = x'34 + 70,
  x46 = x'46 + 100.
В результате получаем следующую задачу линейного программирования:
              x12    x13    x14    x23    x25    x34    x35    x46    x56
Миними-       3      4      1      5      6      1      2      2      4	
зировать
Узел 1        1      1      1                                               =  50
Узел 2       -1                    1      1                                 = 200
Узел 3              -1            -1             1      1                   = -20
Узел 4                     -1                   -1             1            =-130
Узел 5                                   -1            -1             1     = -80
Узел 6                                                        -1     -1     = -20
Верхние       Б      Б     30      Б      Б     50      Б     20      Б 	
границы										

Примечание. Б - бесконечность.
Соответствующая сеть после исключения нижних границ пропускных способностей дуг показана на рисунке 2.

Рис.2. Сеть после исключения нижних границ
Отметим, что данную сеть можно получить непосредственно из сети, представленной на рисунке 3, с помощью преобразований, показанных на рисунке 1, причем без необходимости записи в виде задачи линейного программирования.

Рис.3. Схема маршрутов
В следующем примере представлена сетевая модель, которая исходно не удовлетворяет условию узлового потока(т.е. условию, что результирующий поток, проходящий через узел, равен разности выходного и входного потоков), но которую можно преобразовать в модель, удовлетворяющую этому условию, путем изменения ограничений соответствующей задачи линейного программирования.

Пример 2. Агентство по найму рабочей силы имеет заказ на рабочих на 4 месяца вперед (с января по апрель) согласно следующему графику:
    Месяц             Январь   Февраль   Март     Апрель
К-во рабочих           100       120      80       170
Поскольку спрос на рабочих различен в разные месяцы, возможно, экономически целесообразно нанять больше рабочих, чем требуется, в текущем месяце. Стоимость найма рабочих и удержания их в "ждущем режиме" зависит от времени трудоустройства, как показано в следующей таблице:
Время трудоустройства (месяцы)           1    2    3    4
Стоимость на одного рабочего (рубли)    100  130  180  220
Обозначим через xij количество рабочих, нанятых на начало i-го месяца и освобожденных на начало j-го. Например, x12 - это количество рабочих, нанятых в январе только на один месяц.
Чтобы сформулировать задачу линейного программирования, нужно добавить еще пятый месяц (май). Тогда, например, переменная x45 будет обозначать количество рабочих, нанятых в апреле на один месяц. Естественно, на май нет заказа на рабочих.
Ограничения строятся так, чтобы спрос на рабочих в месяц k можно было бы удовлетворить за счет всех рабочих xij, где i<=k<=j. Обозначив через Si (Si>=0) количество рабочих, "лишних" в месяце i, получим следующую задачу линейного программирования:
      x12  x13  x14  x15  x23  x24  x25  x34  x35  x45  S1  S2  S3  S4	
      100  130  180 220  100  130 180  100  130  100                  Min
Янв.   1    1    1   1                                -1              100
Фев.        1    1   1    1    1   1                      -1          120
Март             1   1         1   1    1    1                -1       80
Апр.                 1             1         1    1              -1   170
В данной задаче линейного программирования нет той специальной структуры коэффициентов ограничений, что была в модели из примера 1. Тем не менее, эта задача имеет свою специфику, которая позволит преобразовать ее в сетевую модель. Выполним следующие действия.
    1. Из n-го уравнения (ограничения) задачи создадим новое (n + 1)-е уравнение, умножив n-е уравнение на -1.
    2. Оставляем первое уравнение без изменений.
    3. Для i = 2, 3, …, n последовательно заменяем i-е уравнение разностью i-го и (i - 1)-го уравнений.
Применение описанной процедуры к задаче данного примера приводит к следующей задаче линейного программирования, которая уже имеет структуру сетевой модели.
Таким образом, задачу распределения рабочих можно представить в виде эквивалентной задачи нахождения потока минимальной стоимости в сети с ограниченной пропускной способностью (рисунок 4):
      x12  x13  x14  x15  x23  x24  x25  x34  x35  x45  S1  S2  S3  S4	
      100  130  180 220  100  130 180  100  130  100                   Min
Янв.   1    1    1   1                                -1               100
Фев.  -1                  1    1   1                   1  -1            20
Март       -1            -1             1    1             1  -1       -40
Апр.            -1            -1       -1         1            1 -1     90
Май                 -1            -1   -1   -1   -1              -1   -170

Рис.4. Сеть с ограниченной пропускной способностью
Задачу линейного программирования можно решить с помощью специализированных программных средств, например Microsoft Excel.
На следующем шаге мы рассмотрим симплексный алгоритм для сетей с ограниченной пропускной способностью.

        1.13. Нахождение потока наименьшей стоимости. Симплексный алгоритм для сетей с ограниченной пропускной способностью
На этом шаге мы приведем пример использования симплексного метода при решении сетевых задач.
Предлагаемый алгоритм повторяет в точности те же шаги, что и обычный симплексный метод. Вместе с тем здесь учитывается специальная структура сетевой модели.
Используя определения из предыдущего шага, fi - результирующий поток через узел i, строим симплексный алгоритм на основе условия равенства нулю суммы fi при i, изменяющимся от 1 до n. Это условие означает, что в сети суммарный объем предложений равен суммарному объему спроса. Мы всегда можем удовлетворить данное условие путем введения фиктивного источника или стока, которые можно связать с остальными узлами сети дугами с нулевой стоимостью и бесконечной пропускной способностью. Однако сбалансированность сети не гарантирует существования допустимого решения, поскольку этому может воспрепятствовать ограниченность пропускных способностей дуг.
Опишем шаги алгоритма нахождения потока минимальной стоимости для сетей с ограниченной пропускной способностью.
Шаг 0. Определяем для данной сети начальное базисное допустимое решение (множество дуг). Переходим к шагу 1.
Шаг 1. С помощью условия оптимальности симплекс-метода определяем вводимую в базис переменную (дугу). Если на основе условия оптимальности определяем, что последнее решение оптимально, вычисления заканчиваются. В противном случае переходим к шагу 2.
Шаг 2. На основе условия допустимости симплекс-метода определяем исключаемую из базиса переменную (дугу). Изменив базис, возвращаемся к шагу 1.
Сети с n узлами и нулевым результирующим потоком (т.е. при выполнении равенства f1 + f2 +…+ fn = 0) соответствуют n - 1 независимым ограничениям в виде равенств. Поэтому базисное решение должно содержать n - 1переменных. Можно показать, что базисное решение соответствует остовному дереву данной сети.
Вводимая переменная (дуга) на шаге 1 определяется путем вычисления разностей zij - cij для всех текущих небазисных дуг (i, j). Если для всех разностей zij - cij <= 0, тогда текущее базисное решение оптимально. Иначе в качестве вводимой в базис переменной выбираем дугу, которой соответствует наибольшее положительное значение разности zij - cij.
Вычисление разностей zij - cij основано на соотношениях двойственности, точно так же как в транспортной модели. Обозначим через wi переменную задачи, двойственной к задаче линейного программирования, которая (переменная) соответствует ограничению узла i. Тогда данная двойственная задача формулируется следующим образом.
Максимизировать

при выполнении условий

переменные wi произвольного знака (i = 1, 2, …, n).
Из теории линейного программирования следует, что wi - wj = cij для любой базисной дуги (i, j). Поскольку исходная задача линейного программирования по определению имеет одно избыточное ограничение, мы можем присвоить произвольное значение одной из переменной двойственной задачи. Для определенности положим w1 = 0. Затем следует решить (базисную) систему уравнений wi - wj = cij для нахождения остальных переменных двойственной задачи. Далее вычисляем разности zij - cij для небазисных переменных согласно формуле
    zij - cij = wi - wj - сij.
Теперь осталось показать, как определяется исключаемая из базиса переменная. Для этого рассмотрим следующий числовой пример.

Пример. Сеть трубопроводов связывает две станции опреснения воды с двумя городами. Ежедневное предложение опреснительных станций составляет 40 и 50 миллионов литров воды, города ежедневно потребляют 30 и 60 миллион литров воды. Каждая станция трубопроводами соединена с каждым городом непосредственно, однако они могут также перекачивать воду в города через специальную насосную станцию. Кроме того, станция 1 может транспортировать воду на станцию 2, а город 1 - в город 2. Данная сеть сбалансирована, так как в ней суммарный спрос равен суммарному предложению. Описанная сеть показана на рисунке 1.

Рис.1. Пример сети
Итерация 0.
Шаг 0. Определение начального допустимого базисного решения. Нетрудно построить остовное дерево (на рис. 2 показано сплошными дугами) для рассматриваемой сети. Отсюда получаем начальное допустимое базисное решение. Обычно для нахождения такого решения используется метод введения искусственных переменных.

Рис.2. Остовное дерево
На рис. 2 показано, что базисному решению соответствуют дуги (1, 3), (1,4) и (3, 5) с потоками 30, 10, 50 и 60 единиц соответственно. Оставшиеся дуги (показаны пунктиром) представляют небазисные переменные. Запись x(c)показывает, что через соответствующую дугу с пропускной способностью c проходит поток x.
Итерация 1.
Шаг 1. Определение вводимой в базис переменной. При решении системы уравнений
    w1 = 0,
    wi - wj = cij для базисных дуг (i, j)
получим значения переменных двойственной задачи.
    Дуга (1, 3): w1 - w3 = 7 ==> w3 = -7.
    Дуга (1, 4): w1 - w4 = 5 ==> w4 = -5.
    Дуга (2, 3): w2 - w3 = 2 ==> w2 = -5.
    Дуга (3, 5): w3 - w5 = 8 ==> w5 = -15.
Теперь вычисляем разности zij - cij для небазисных переменных.
    Дуга (1, 2): w1 - w2 - c12 = 0 - (-5) - 3 = 2.
    Дуга (2, 5): w2 - w5 - c25 = (-5) - (-15) - 1 = 9.
    Дуга (4, 5): w4 - w5 - c45 = (-5) - (-15) - 4 = 6.
Таким образом, дуга (2, 5) будет введена в базисное решение.
Шаг 2. Определение исключаемой из базиса переменной. На рис. 2 видно, что дуга (2, 5) совместно с базисными дугами (2, 3) и (3, 5) образуют цикл. По определению остовное дерево не может содержать циклов. Поскольку поток через дугу (2, 5) должен возрасти, необходимо выровнять потоки через дуги, составляющие цикл таким образом, чтобы новое решение осталось допустимым. Для этого поток через дугу (2, 5) пометим знаком "+", потоки через другие дуги цикла - знаком "+" или "-", в зависимости от того, будут ли совпадать направления потоков в этих дугах с направлением потока в дуге (2, 5) при обходе цикла против часовой стрелки. Пометки дуг цикла показаны на рис. 2.
При определении максимального потока, протекающего через дугу (2, 5), необходимо придерживаться следующих правил.
    1. Новый поток в текущей базисной дуге не может быть отрицательным.
    2. Поток через вводимую в базис дугу не может превышать ее пропускную способность.
Применение правила 1 показывает, что потоки через дуги (2, 3) и (3, 5) нельзя уменьшить более, чем на min {50, 60} = 50 единиц. Из правила 2 следует, что поток через дугу (2, 5) не может превышать 30 единиц (пропускная способность этой дуги равна 30). Поэтому поток через дуги цикла изменится не более, чем на min {30, 50} = 30единиц. Таким образом, поток через дугу (2, 5) равен 30 единицам, через дугу (2, 3) - 50 - 30 = 20 единицам, а через дугу (3, 5) - 60 - 30 =30 единицам.
Поскольку никакая из текущих базисных переменных не приняла нулевого значения, дуга (2, 5) должна остаться небазисной, но с ненулевым значением в 30 единиц. Чтобы выполнить требование равенства нулю небазисных переменных, сделаем подстановку
    x25 = 30 - x52, 0 <= x52 <=  30.
Эта подстановка изменит уравнения для потоков, протекающих через узлы 2 и 5.
    Текущее уравнение для потоков узла 2: 50 + x12 = x23 + x25.
    Текущее уравнение для потоков узла 5: x25 + x35 + x45 = 60.
После подстановки x25 = 30 - x52 получим
    Новое уравнение для потоков узла 2: 20 + x12 + x52 = x23.
    Новое уравнение для потоков узла 5:  x35 + x45 = x52 + 30.
Результаты этих изменений показаны на рисунке 3. Направление потока через дугу (2, 5) изменилось на обратное (от узла 5 к узлу 2), причем, как и ожидалось, x52 = 0. Описанная подстановка также требует изменения стоимости прохождения потока по дуге (2, 5) до -$1. Те дуги, направления потоков которых изменены на противоположные, помечены в сети звездочкой.

Рис.3. Результаты изменения сети
Итерация 2.
На рисунке 3 представлены новые значения разностей zij - cij. Очевидно, что в базис следует ввести дугу (4, 5). Введение в базис этой дуги также приводит к образованию цикла.
Величину потока через дугу (4, 5) можно увеличить до наименьшей из следующих величин.
    1. Максимальный поток через дугу (4, 5), определяемый пропускной способностью, равен бесконечности.
    2. Максимальное увеличение потока через дугу (1, 4) равно 35 - 30 = 5 единиц.
    3. Максимальное уменьшение потока через дугу (1, 3) равно 10 единиц.
    4. Максимальное уменьшение потока через дугу (3, 5) равно 30 единиц.
Таким образом, поток через дугу (4, 5) можно увеличить до 5 единиц; эта дуга входит в базис, а дуга (1, 4) с потоком в 35 единиц исключается из базиса.
Выполнив подстановку x14 = 35 - x41, получим сеть, показанную на рис. 4, где дуги (1, 3), (2, 3), (3, 5) и (4, 5) формируют остовное дерево сети (базисное решение). Для дуги (1, 4) с обратным направлением потока изменена стоимость прохождения потока до -$5.

Рис.4. Результирующая сеть
Итерация 3.
Вычисленные новые значения разностей zij - cij для небазисных дуг (1, 2), (4, 1) и (5, 2) показаны на рис. 4. Из этих значений вытекает, что в базис следует ввести дугу (1, 2) с потоком в 5 единиц, тогда как дуга (1, 3) исключается из базиса с нулевым значением потока. Новое решение представлено на рисунке 5.

Рис.5. Новое решение
Итерация 4.
Из новых значений разностей zij - cij (рис. 5) видно, что последнее решение оптимально. Значения исходных переменных получаем путем обратной подстановки, как показано на рисунке 5.
Со следующего шага мы начнем знакомиться с методами сетевого планирования.

        1.14. Методы сетевого планирования (общие сведения)
На этом шаге мы приведем общие сведения о методах сетевого планироваия.
На основе сетевых моделей разработано множество методов планирования, составление временных расписаний и управления проектами. Наиболее известные - метод критического пути (Critical Path Method, сокращенно CPM), а также система планирования и руководства программами разработок (Program Evaluation and Review Technique, сокращенно PERT). В этих методах проекты рассматриваются как совокупность некоторых взаимосвязанных процессов (видов деятельности, этапов или фаз выполнения проекта), каждый из которых требует определенных временных и других ресурсов. В методах CPM и PERT проводится анализ проектов для составления временных графиков распределения фаз проектов. На рисунке 1 в обобщенной форме показаны основные этапы выполнения этих методов. На первом этапе определяются отдельные процессы, составляющие проект, их отношения предшествования (т.е. какой процесс должен предшествовать другому) и их длительность. Далее проект представляется в виде сети, показывающей отношения предшествования среди процессов, составляющих проект. На третьем этапе на основе построенной сети выполняются вычисления, в результате которых составляется временной график реализации проекта.

Рис.1. Основные этапы выполнения проектирования
Методы CPM и PERT, которые разрабатывались независимо друг от друга, отличаются тем, что в методе критического пути длительность каждого этапа проекта является детерминированной, тогда как в системе планирования PERT - стохастической.
На следующем шаге мы рассмотрим построение сети проекта.

        1.15. Методы сетевого планирования. Построение сети проекта
На этом шаге мы рассмотрим пример построения сети проекта.
Каждый процесс проекта обозначается в сети дугой, ориентированной по направлению выполнения проекта. Узлы сети (также называемые событиями) устанавливают отношения предшествования среди процессов проекта.
Построение сети проекта основано на следующих правилах.
Правило 1. Каждый процесс в проекте представим одной и только одной дугой.
Правило 2. Каждый процесс идентифицируется двумя концевыми узлами.
На рисунке 1 показано, как с помощью фиктивного процесса можно представить два параллельных (конкурирующих) процесса А и В. По определению фиктивный процесс (который на схеме сети обычно обозначается пунктирной дугой) не поглощает временных или других ресурсов. Вставив фиктивный процесс одним из четырех способов, показанных на рисунке 1, мы получаем возможность идентифицировать процессы А и В, по крайней мере, одним уникальным концевым узлом (как требует правило 2).

Рис.1. Представление конкурирующих процессов
Правило 3. Для поддержания правильных отношений предшествования при включении в сеть любого процесса необходимо ответить на следующие вопросы.
    • Какой процесс непосредственно предшествует текущему?
    • Какой процесс должен выполняться после завершения текущего процесса?
    • Какой процесс конкурирует (выполняется параллельно) с текущим?
Ответы на эти вопросы, возможно, потребует включения в сеть фиктивных процессов, чтобы правильно отобразить последовательность выполнения процессов. Предположим, например, что четыре процесса должны удовлетворять следующим условиям.
    1. Процесс С должен начаться после завершения процессов А и В.
    2. Процесс Е должен начаться непосредственно после завершения процесса В.
На рисунке 2а показано неправильное представление наших процессов, так как из него следует, что процесс Едолжен начаться после завершения как процесса В, так и А. На рисунке 2б показано, как с помощью фиктивного процесса D разрешить эту коллизию.

Рис.2. Представление процессов

Пример. Издатель имеет контракт с автором на издание его книги. Ниже представлена последовательность (упрощенная) процессов, приводящая к реализации проекта издания книги. Необходимо разработать сеть для этого проекта.
                 Процесс              Предшествующий процесс  Длительность (недели)
A:  Прочтение рукописи редактором                   -               3
B:  Пробная верстка отдельных страниц книги         -               2
C:  Разработка обложки книги                        -               4
D:  Подготовка иллюстраций                          -               3
E:  Просмотр автором редакторских правок и 
         сверстанных страниц                       А,В              2
F:  Верстка книги (создание макета книги)           Е               4
G:  Проверка автором макета книги                   F               2
H:  Проверка автором иллюстраций                    D               1
I:  Подготовка печатных форм                       G,H              2
J:  Печать и брошюровка книги                      C,I              4
На рисунке 3 показана сеть, представляющая взаимосвязь процессов данного проекта. Фиктивный процесс (2, 3) введен для того, чтобы "развести" конкурирующие процессы А и В. Номера узлов сети возрастают в направлении выполнения проектов.

Рис.3. Взаимосвязь процессов
На следующем шаге мы рассмотрим метод критического пути.

        1.16. Методы сетевого планирования. Метод критического пути
На этом шаге мы рассмотрим алгоритм определения критического пути.
Конечным результатом применения метода критического пути будет построение временного графика выполнения проекта (см. рис. 1 шага 131). Для этого проводятся специальные вычисления, в результате чего получаем следующую информацию.
    1. Общая длительность выполнения проекта.
    2. Разделение множества процессов, составляющих проект, на критически и некритические.
Процесс является критическим, если он не имеет "зазора" для времени своего начала и завершения. Таким образом, чтобы весь проект завершился без задержек, необходимо, чтобы все критические процессы начинались и заканчивались в строго определенное время. Для некритического процесса возможен некоторый "дрейф" времени его начала, но в определенных границах, когда время его начала не влияет на длительность выполнения всего проекта.
Для проведения необходимых вычислений определим событие как точку на временной оси, где завершается один процесс и начинается другой. В терминах сети, событие - это сетевой узел. Нам понадобятся также следующие определения и обозначения:
    • Aj - самое раннее возможное время наступления события j,
    • Bj - самое позднее возможное время наступления события j,
    • Dij - длительность процесса (i, j).
Вычисления критического пути включает два этапа (прохода). При проходе вперед вычисляются самые ранние времена наступления событий, а при проходе назад - самые поздние времена наступления тех же событий.
Проход вперед. Здесь вычисления начинаются в узле 1 и заканчиваются в последнем узле n.
Начальный шаг. Полагаем A1=0; это указывает на то, что проект начинается в нулевой момент времени. Основной шаг j. Для узла j определяем узлы p, q, …, v, непосредственно связанные с узлом j процессами (p, j), (q, j), …, (v, j), для которых уже вычислены самые ранние времена наступления соответствующих событий. Самое раннее время наступления события j вычисляется по формуле
    Aj = max { Ap + Dpj,  Aq + Dqj, …,  Av + Dvj}.
Проход вперед завершается, когда будет вычислена величина An для узла n. По определению величина j равна самому длинному пути (длительности) от начала проекта до узла (события) j.
Проход назад. В этом проходе вычисления начинаются в последнем узле n и заканчивается в узле 1.
Начальный шаг. Полагаем Bn = An; это указывает, что самое раннее и самое позднее времена для завершения проекта совпадают.
Основной шаг j. Для узла j определяем узлы p, q, …, v, непосредственно связанные с узлом j процессами (j, p), (j, q), …, (j, v), для которых уже вычислены самые поздние времена наступления соответствующих событий. Самое позднее время наступления события j вычисляется по формуле
    Bj = min {Bp - Djp, Bq - Djq, …, Bv - Djv}.
Проход назад завершается при вычислении величины B1 для узла 1.
Процесс (i, j) будет критическим, если выполняются три условия.
    1. Bi = Ai.
    2. Bj = Aj.
    3. Bj - Bi = Aj - Ai = Dij.
Эти условия не выполняются, то процесс некритический.
Критические процессы должны образовывать непрерывный путь через всю сеть от начального события до конечного.

Пример. Найдем критический путь для сети проекта, показанной на рисунке 1. Длительность всех процессов дана в днях.
Проход вперед.
Узел 1. Полагаем A1 = 0.
Узел 2. A2 = A1 + D12 = 0 + 5 = 5.
Узел 3. A3 = max { A1 + D13, A2 + D23} = max {0 + 6, 5 + 3} = 8.
Узел 4. A4 = A2 + D24 = 5 + 8 = 13.
Узел 5. A5 = max { A3 + D35, A4 + D45} = max {8 + 2, 13 + 0} = 13.
Узел 6. A6 = max { A3 + D36, A4 + D46, A5 + D56} = max {8 + 11, 13 + 1, 13 + 12} = 25.

Рис.1. Пример проекта
Таким образом, расчеты показывают, что проект можно выполнить за 25 дней.
Проход назад.
Узел 6. Полагаем A6 = B6 = 25.
Узел 5. B5 = B6 - D56 = 25 - 12 = 13.
Узел 4. B4 = min {B6 - D46, B5 - D45} = min {25 - 1, 13 - 0} = 13.
Узел 3. B3 = min {B6 - D36, B5 - D35} = min {25 - 11, 13 - 2} = 11.
Узел 2. B2 = min {B4 - D24, B3 - D23} = min {13 - 8, 11 - 3} = 5.
Узел 1. B1 = min {B3 - D13, B2 - D12} = min {11 - 6, 5 - 5} = 0.
Вычисления без ошибок всегда приводят к результату B = 0.
Результаты вычислений, выполняемых при проходах вперед и назад, показаны на рисунке 1. Правила определения критических процессов показывают, что критический путь составляют процессы 1->2->4->5->6, т.е. этот путь проходит от начального узла 1 до конечного узла 6. Сумма длительности критических процессов (1, 2), (2, 4), (4, 5) и (5, 6) равна длительности всего проекта (т.е. 25 дней). Отметим, что процесс (4, 6) удовлетворяет первым двум условиям критического пути (B4 = A4 = 13 и B6 = A6 = 25), но не удовлетворяет третьему условию ( A6 - B4 не равно D46). Поэтому данный процесс не является критическим.
Для проверки полученных результатов воспользуемся программой, приведенной на 121 шаге, которая позволяет спланировать критический путь. Для заданных исходных данных результат вычислений по этой программе будет следующим:

Рис.2. Результат работы приложения
На следующем шаге мы рассмотрим построение временного графика.

        1.17. Методы сетевого планирования. Построение временного графика
На этом шаге мы рассмотрим правила построения временного графика.
На этом шаге мы покажем, как на основе данных, полученных расчетным путем на предыдущем шаге, строится временной график последовательного выполнения проекта. Мы уже знаем, что Ai для процесса (i, j) указывает на самое раннее время начала этого процесса, а Bj - на самое позднее время завершения процесса. Таким образом, пара величин (Ai, Bj) ограничивает максимальный интервал времени, в течение которого может выполняться процесс (i, j).

Построение предварительного графика

Метод построения предварительного временного графика выполнения проекта покажем на следующем примере.

Пример. Построим временной график проекта на примере из предыдущего шага.
Предварительный временной график проекта можно начертить, используя максимальные интервалы выполнения каждого процесса. В результате получим график, представленный на рисунке 1:

Рис.1. Время выполнения процессов
Сделаем два замечания.
    1. Критические процессы (показаны на графике сплошными линиями) располагаются последовательно друг за другом без временных зазоров и перекрытий. Таким образом, их суммарная длительность равна длительности выполнения всего проекта (в данном случае, 25 дней).
    2. Некритические процессы (показаны на графике пунктирными линиями) представлены максимальными интервалами выполнения, которые превышают реальную длительность выполнения этих процессов. Поэтому необходимо каким-то образом определиться с началом выполнения этих процессов.
Как выбрать время начала выполнения некритического процесса? Обычно предпочитают начинать некритические процессы (по возможности) в самый ранний срок. В этом случае остается запас времени (остаток максимального интервала выполнения), который можно использовать для решения неожиданно возникших во время выполнения процесса проблем. Вместе с тем при необходимости можно перенести начало выполнения какого-либо процесса. Допустим, если в нашем примере во время выполнения процессов E и F (рис. 1) используется одно и то же оборудование, причем в каждый момент времени его можно задействовать только для одного процесса, тогда можно исключить временное наложение этих процессов, начав процесс F после завершения Е.
Если на некритические процессы не накладываются какие-либо дополнительные ограничения и все они начинаются в самый ранний момент времени, то временной график проекта строится автоматически. Однако в этом случае могут нарушаться некоторые отношения предшествования. В частности, в нашем примере (см. рис. 1 предыдущего шага) процесс С должен быть завершен до начала процесса Е. Но максимальные интервалы времени выполнения этих процессов перекрываются, поэтому и реальные интервалы времени их выполнения также могут перекрываться. Поэтому необходимо предусмотреть какие-нибудь "красные флажки", которые автоматически указывали бы, когда тот или иной процесс может начинаться без нарушения отношений предшествования с другими процессами. Далее мы покажем, как для этого использовать запасы времени отдельных процессов.

Определение запасов времени

Запас времени некритического процесса - это часть максимального интервала времени выполнения этого процесса (который, напомним, больше реальной длительности процесса). Различают общий запас времени и свободный запас времени процесса.
На рисунке 2 показана разность между этими запасами времени процесса (i, j) - общим (TFij) и свободным (FFij). Общий запас времени процесса (i, j) определяется как превышение над длительностью выполнения этого процесса интервала времени от самого раннего момента осуществления события i до самого позднего осуществления события j, т.е.
    TFij = Bj -  Ai - Dij.
Свободный запас времени процесса (i, j) определяется как превышение над длительностью выполнения этого процесса интервала времени - от самого раннего момента осуществления события i до самого раннего времени осуществления события j, т.е.
    FFij =  Aj -  Bi - Dij.
По определению FFij <= TFij.

Рис.2. Разность между общим и свободным запасами времени

Правило "красного флажка"

Для некритического процесса (i, j)
    • если FFij = TFij, тогда данный процесс может выполняться в любое время внутри максимального интервала (Ai, Bj) без нарушения отношений следования;
    • если FFij < TFij, тогда без нарушения отношений следования данный процесс может начаться со сдвигом, не превышающим FFij, относительно самого раннего момента начала процесса i. Сдвиг начала процесса на величину времени, превышающую FFij (но не более TFij), должен сопровождаться равным сдвигом относительно j всех процессов, начинающихся с события j.
Это правило означает, что некритический процесс (i, j) помечается "красным флажком" только тогда, когда FFij < TFij. Этот флажок принимается во внимание при сдвиге начала процесса относительно самого раннего времени i на такую величину, при которой следует рассчитывать сдвиг процессов, следующих из узла j.

Пример. Вычислим запасы времени для некритических процессов в сети проекта из примера шага 133 и на основе этих расчетов построим окончательный временной график проекта.
Общие и свободные запасы времени некритических процессов представлены ниже. Такие расчеты можно проводить непосредственно на сети проекта, как показано на рисунке 2.
Некритический  Длительность    Общий запас        Свободный запас 
процесс        процесса        времени (TF)       времени (FF)
B (1, 3)          6           11 -  0 -  6 =  5    8 -  0 -  6 =  2
C (2, 3)          3           11 -  5 -  3 =  3    8 -  5 -  3 =  0
E (3, 5)          2           13 -  8 -  2 =  3   13 -  8 -  2 =  3
F (3, 6)         11           25 -  8 - 11 =  6   25 -  8 - 11 =  6
H (4, 6)          1           25 - 13 -  1 = 11   25 - 13 -  1 = 11
Правило "красного флажка" следует применять только к процессам В и С, поскольку для них FF < TF. Оставшиеся процессы (E, F и H) имеют FF = TF, поэтому они могут выполняться в любое время внутри своих максимальных интервалов времени выполнения.
Рассмотрим процесс В, помеченный "красным флажком". Поскольку для этого процесса TF = 5 дней, он может начаться в любой день из интервала 0 - 5 дней от начала выполнения всего проекта (рис. 1). Но если FF = 2 дня, то, поскольку процесс В начнется в 0-й, 1-й или 2-й день от начала выполнения проекта, это не окажет никакого эффекта на последующие процессы E и F. Однако если процесс В начнется в (2 + B)-й день (2 + B < 5), начало выполнения процессов E и F необходимо сдвинуть от самого раннего срока их начала (8-й день от начала выполнения проекта) на величину, не меньшую B; только при таком условии не нарушатся отношения следования между процессами В, E и F.
Для помеченного "красным флажком" процесса С имеем FF = 0. Это означает, что любой сдвиг начала выполнения этого процесса должен сопровождаться таким же (не меньшим) сдвигом начала выполнения процессов Eи F.
На следующем шаге мы приведем программу, позволяющую визуально строить сетевые модели.

        1.18. Приложение "Сетевые модели"
На этом шаге мы рассмотрим приложение, иллюстрирующее некоторые из рассмотренных ранее алгоритмов.
Описанное на этом шаге приложение было выполнено в среде программирования Delphi 6.0 студенткой факультета математики и информационных технологий Курганского государственного университета Н.Л.Скутиной в 2004 г.
Разработанная программа "Сетевые модели" позволяет изобразить сеть с помощью узлов и ребер (неориентированных и ориентированных), а также найти минимальное остовное дерево построенной сети и минимальный путь между любыми двумя узлами с помощью двух алгоритмов: алгоритма Дейкстры и алгоритма Флойда.

Рис.1. Внешний вид окна программы
Работу программы можно разделить на две части: построение сети и применение указанных алгоритмов к этой сети.

Построение сети

Для того чтобы добавлять новые узлы должна быть нажата кнопка панели инструментов "Новый узел" . Для ввода узла необходимо щелкнуть левой кнопкой мыши на рабочем поле.
Для того чтобы добавлять новые ребра должна быть нажата кнопка "Добавить путь"  или "Добавить направленный путь" . Для ввода ребра необходимо щелкнуть левой кнопкой мыши на одном узле, затем на другом, при этом появляется диалоговое окно для ввода длины ребра (пока не введут длину перейти в окно программы нельзя).
При перемещении узла нажмите кнопку "Перемещение узла"  на панели инструментов, щелкните левой кнопкой мыши на перемещаемый узел, затем, не отпуская кнопки мыши, на свободное место, куда вы хотите переместить узел.
Для удаления узла нажмите кнопку "Удаление узла"  на панели инструментов, затем щелкните левой кнопкой мыши на узел, который хотите удалить.

Замечание. Пункт меню "Сеть" также содержит все перечисленные выше команды.

Для сохранения сети в файле нажмите кнопку "Сохранить" . В появившемся окне диалога введите имя файла и выберите директорию, затем нажмите кнопку ОK.
Для загрузки сети из файла нажмите кнопку "Открыть"  и в появившемся окне выберите нужный файл.

Замечание. Эти команды также можно выполнить с помощью соответствующих команд меню "Файл".

Чтобы очистить поле и ввести новую сеть нажмите кнопку "Новый"  или выберите соответствующую команду в меню "Файл". Для получения помощи нажмите кнопку "Справка"  или выберите соответствующую команду меню "Справка". Для очистки результатов действий алгоритмов нажмите кнопку "Обновить"  или выберите соответствующую команду пункта меню "Вид".

Выполнение алгоритмов

Для нахождения минимального остовного дерева сети щелкните по кнопке "Построить остовное дерево" .
Если выбрать две различные вершины (для этого необходимо щелкнуть по кнопке "Выделить узлы"  или выбрать соответствующую команду меню "Сеть", а затем щелкнуть на те узлы, которые надо выделить) и нажать на кнопку "Выполнить алгоритм Дейкстры"  или "Выполнить алгоритм Флойда" , то программа найдет кратчайший путь между выделенными узлами. Если сеть является ориентированной, то очень важен порядок выделения узлов.

Замечание. Эти команды также можно выполнить с помощью соответствующих команд меню "Алгоритмы".

Для всех кнопок панели инструментов и команд главного меню в строке состояния отображается подсказка. При наведении мыши на кнопку панели инструментов появляется всплывающая подсказка. К некоторым командам есть горячие клавиши, которые отображаются справа от команды в главном меню или во всплывающей подсказке.
Текст этого приложения можно взять здесь.
Мы закончили изложение материала, связанного с динамическими структурами данных. Конечно, мы не охватили всего многообразия динамических структур. Может быть, в дальнейшем, мы к нему вернемся.





1. Структуры данных: двоичная куча (binary heap)
1.1. Введение
1.2. Реализация двоичной кучи (binary heap)
1.2.1. Реализация класса кучи
1.2.2. Конструктор кучи
1.2.3. Добавление элемента кучи
1.2.4. Вывод элементов кучи
1.2.5. Упорядочение кучи
1.2.6. Удаление вершины кучи (максимального элемента)
1.3. Примеры бинарной кучи
1.3.1. Бинарная куча #01. Реализация на C (arry)
1.3.2. Бинарная куча #02. Реализация на C++ (class)
1.3.3. Бинарная куча #03. Реализация на C++ (class)
1.3.4. Бинарная куча #04. Реализация на C (struct)
1.3.5. Бинарная куча #05. Реализация на C (struct) (#04=#05)
1.3.6. Бинарная куча #06. Реализация на C++ (class) (#03=#06)
1.3.7. Бинарная куча #07. Лабораторная работа № 12



https://prog-cpp.ru/data-heap/
    1. Структуры данных: двоичная куча (binary heap)

Двоичная куча (binary heap) –структура данных, позволяющая быстро (за логарифмическое время) добавлять элементы и извлекать элемент с максимальным приоритетом (например, максимальный по значению).

        1.1. Введение
Бинарная куча (пирамида, сортирующее дерево, binary heap) – это двоичное дерево, удовлетворяющее следующим условиям:
    • Приоритет любой вершины не меньше ( ≥ ), приоритета ее потомков
    • Дерево является полным двоичным деревом (complete binary tree) – все уровни заполнены слева направо (возможно за исключением последнего)



Двоичная куча представляет собой полное бинарное дерево, для которого выполняется основное свойство кучи: приоритет каждой вершины больше приоритетов её потомков. В простейшем случае приоритет каждой вершины можно считать равным её значению. В таком случае структура называется max-heap, поскольку корень поддерева является максимумом из значений элементов поддерева. Здесь для простоты используется именно такое представление. Напомним также, что дерево называется полным бинарным, если у каждой вершины есть не более двух потомков, а заполнение уровней вершин идет сверху вниз (в пределах одного уровня – слева направо).



Двоичную кучу удобно хранить в виде одномерного массива, причем левый потомок вершины с индексом i имеет индекс 2*i+1, а правый 2*i+2. Корень дерева – элемент с индексом 0. Высота двоичной кучи равна высоте дерева, то есть log2 N, где N – количество элементов массива.

        1.2. Реализация двоичной кучи (binary heap)

Полный код примера приведен в разделе «Бинарная куча #02. Реализация на C++ (class)»

Двоичная куча представляет собой полное бинарное дерево, для которого выполняется основное свойство кучи: приоритет каждой вершины больше приоритетов её потомков.
В простейшем случае приоритет каждой вершины можно считать равным её значению. В таком случае структура называется max-куча, поскольку корень поддерева является максимумом из значений элементов поддерева.
В качестве альтернативы, если сравнение перевернуть, то наименьший элемент будет всегда корневым узлом, такие кучи называют min-кучами.
Двоичную кучу удобно хранить в виде одномерного массива, причем
    • левый потомок вершины с индексом i имеет индекс 2*i+1,
    • правый потомок вершины с индексом i имеет индекс 2*i+2,
    • корень дерева – элемент с индексом 0,
    • высота двоичной кучи равна высоте дерева, то есть log2 N, где N – количество элементов массива



Корень дерева (кучи) – элемент с индексом 0.
Высота двоичной кучи равна высоте дерева, то есть

log2 (N+1)↑,

где N – количество элементов массива, ↑ – округление в большую сторону до ближайшего целого.
Для представленной кучи

log2 (10+1)↑ = 3,46↑ = 4

Способ построить кучу из неупорядоченного массива – это по очереди добавить все его элементы. Временная оценка такого алгоритма оценивается как

N·log2N.

Можно построить кучу за N шагов. Для этого сначала следует построить дерево из всех элементов массива, не заботясь о соблюдении основного свойства кучи, а потом вызвать метод упорядочения для всех вершин, у которых есть хотя бы один потомок (так как поддеревья, состоящие из одной вершины без потомков, уже упорядочены).
Потомки гарантированно есть у первых heapSize/2 вершин, где heapSize – размер кучи.

Реализация бинарной кучи на основе массива



            1.1.1. Реализация класса кучи

//Реализация класса кучи
class Heap {
  static const int SIZE = 100; // максимальный размер кучи
  int *h; // указатель на массив кучи
  int HeapSize; // размер кучи
public:
  Heap(); // конструктор кучи
  void addelem(int); // добавление элемента кучи
  void outHeap(); // вывод элементов кучи в форме кучи
  void out(); // вывод элементов кучи в форме массива
  int getmax(); // удаление вершины (максимального элемента)
  void heapify(int); // упорядочение кучи
};

            1.1.2. Конструктор кучи

//Конструктор кучи
Heap :: Heap() {
  h = new int[SIZE];
  HeapSize = 0;
}

            1.1.3. Добавление элемента кучи
Новый элемент добавляется на последнее место в массиве, то есть позицию с максимальным индексом.



Возможно, что при этом будет нарушено основное свойство кучи, так как новый элемент может быть больше родителя. В таком случае новый элемент «поднимается» на один уровень (менять с вершиной-родителем) до тех пор, пока не будет соблюдено основное свойство кучи.



Иначе говоря, новый элемент «всплывает», «проталкивается» вверх, пока не займет свое место. Сложность алгоритма не превышает высоты двоичной кучи (так как количество «подъемов» не больше высоты дерева), то есть равна O(log2 N).

void Heap :: addelem(int n) {
  int i, parent;
  i = HeapSize;
  h[i] = n;
  parent = (i-1)/2;
  while(parent >= 0 && i > 0) {
    if(h[i] > h[parent]) {
      int temp = h[i];
      h[i] = h[parent];
      h[parent] = temp;
    }
    i = parent;
    parent = (i-1)/2;
  }
  HeapSize++;
}

            1.1.4. Вывод элементов кучи

//Вывод элементов кучи
//Вывод элементов в форме кучи
void Heap:: outHeap(void) {
  int i = 0;
  int k = 1;
  while(i < HeapSize) {
    while((i < k) && (i < HeapSize)) {
      cout << h[i] << " ";
      i++;
    }
    cout << endl;
    k = k * 2 + 1;
  }
}

//Вывод элементов кучи в форме массива
void Heap:: out(void) {
  for(int i=0; i< HeapSize; i++) {
    cout << h[i] << " "; }
  cout << endl;
}

            1.1.5. Упорядочение кучи
В ходе других операций с уже построенной двоичной кучей также может нарушиться основное свойство кучи: вершина может стать меньше своего потомка.



Метод heapify восстанавливает основное свойство кучи для дерева с корнем в i-ой вершине при условии, что оба поддерева ему удовлетворяют. Для этого необходимо «опускать» i-ую вершину (менять местами с наибольшим из потомков), пока основное свойство не будет восстановлено (процесс завершится, когда не найдется потомка, большего своего родителя). Нетрудно понять, что сложность этого алгоритма также равна O(log2 N).



//Упорядочение кучи
void Heap:: heapify(int i) {
  int left, right;
  int temp;
  left = 2*i+1;
  right = 2*i+2;
  if(left < HeapSize) {
    if(h[i] < h[left]) {
      temp = h[i];
      h[i] = h[left];
      h[left] = temp;
      heapify(left);
    }
  }
  if(right < HeapSize) {
    if(h[i] < h[right]) {
      temp = h[i];
      h[i] = h[right];
      h[right] = temp;
      heapify(right);
    }
  }
}

В упорядоченном max-heap максимальный элемент всегда хранится в корне. Восстановить упорядоченность двоичной кучи после удаления максимального элемента можно, поставив на его место последний элемент и вызвав метод упорядочения для корня, то есть упорядочив все дерево.

            1.1.6. Удаление вершины кучи (максимального элемента)

//Удаление вершины кучи (максимального элемента)
int Heap:: getmax(void) {
  int x;
  x = h[0];
  h[0] = h[HeapSize-1];
  HeapSize--;
  heapify(0);
  return(x);
}

        1.3. Примеры бинарной кучи

            1.1.7. Бинарная куча #01. Реализация на C (arry)

Этот пример и в разделе «Бинарная куча #07. Лабораторная работа № 12»

Для начала разберёмся, что же такое бинарная куча. Рассмотрим на примере:



Нам дано дерево с корнем в вершине с номером 1. У вершины 1 два ребёнка: 2 и 3. У вершины 2 и у вершины 3 тоже по два ребёнка (4;5 и 6;7 соответственно). Каждый элемент кучи состоит из двух составляющих: номер элемента и его значение. Пускай для простоты в нашей куче номера и будут являться значениями. Итак, основные правила кучи:
    • У каждой вершины должно быть ровно по 2 ребёнка
    • Каждый ребёнок “хуже” своего отца.

Исключением является нижний ряд кучи - у этих вершин нет детей. В тоже время, нижний ряд не обязательно будет полностью заполнен - элементов может просто не хватить. В таком случае может случиться так, что у одной вершины предпоследнего ряда не будет хватать одного ребёнка. Вот пример:



Как видите, у вершины 5 всего один ребёнок (10) , но, тем не менее, данная куча правильна.
Теперь разберёмся, что же значит “хуже”. В нашем случае, “хуже” означает больше. Т.е. дети по значению больше отца, а отец в нашей куче всегда меньше своих детей. И действительно, 1<2 и 1<3 (вершина 1 - отец) ; 2<4 и 2<5 ; 3<6 и 3<7 и т.д. Параметр “хуже” в различных задачах может быть различным, это зависит от того, что мы хотим получить. Дети по значению могут быть больше или меньше своих родителей. Т.е. “хуже” будет либо меньше, либо больше. В других задачах параметр “хуже” может быть и другим…
Итак, посмотрите на следующую кучу и скажите, правильная ли она:



В любом случае, ответ давать нельзя, пока не известен параметр сравнивая детей с родителями. Пускай в данной куче ребёнок должен быть больше либо равен своему отцу. А вот теперь ответ однозначный - данная куча правильная. Почему же? Ведь левый ребёнок вершины со значением 2 - 5 и он меньше правого ребёнка (3)! Это, конечно, так, но в правилах кучи нет никаких правил сравнивания детей! Главное, чтобы оба ребёнка были “хуже” своего родителя, а как они относятся между собой и на каких позициях стоят - всё равно…
С этой кучей разобрались, для закрепления знаний давайте рассмотрим ещё одну кучу:



Параметр “хуже” у этой кучи такой же, как и у предыдущей кучи. Но эта куча неправильна, т.к. у вершины со значением 4 всего один ребёнок. Исправим эту кучу так, чтобы она стала правильной:



Вот теперь эта куча правильная…
Теперь разберёмся с нумерацией вершин. Вернёмся к первым двум пирамидам - у них значения совпадают с номерами вершин. На них можно увидеть, что нумерация вершин идёт слева направо. Это как будто мы выписываем все номера от 1 до количества вершин в линейку и в определённый момент строчка кончается - мы переходим на новую. Причём, как вы уже заметили, на каждом новом уровне (на строке) будет ровно 2 в степени (i-1) вершин, где i - номер уровня.
Теперь мы знаем основные правила кучи, знаем, как нумеруются вершины. Но как же хранить кучу в памяти компьютера? А вот для этого мы и учились правильно расстанавливать номера. При правильной расстановке у каждого элемента будет свой уникальный номер - почему бы нам ни хранить кучу линейным массивом? Запишем в линейный массив нашу последнюю кучу:



Вот и прекрасно. Советую вам самостоятельно попробовать восстановить бинарную кучу из этого массива. Ну как, получилось? Если не получилось, желательно всё-таки разобраться с этим моментом (попробовать самому записать кучу в линейный массив и восстановить из него). А мы идём дальше.
При работе с бинарной кучей очень часто нужно узнать ребёнка/отца данной вершины. На рисунке всё это хорошо видно, но как же быть, если куча записана в линейный массив? Конечно, можно восстановить рисунок, и по нему посмотреть нужные данные. Но от этого легче не станет - компьютер сам не сможет посмотреть на картинку и сказать, кто отец, а кто ребёнок, а каждый раз спрашивать человека не получится… В этом случае нам помогает одно интересное свойство кучи: k1=2i и k2=2i+1 (где i - номер вершины отца, k1 и k2 - номера вершин детей). По построению это свойство выполняется всегда. Можно посмотреть на примере кучи номеров:



Свойство проверить на любой вершине куче. Например, найдём детей вершины 6 => i = 6 => k1 = 2 * i = 2 * 6 = 12, k2 = 2 * i + 1 = 2 * 6 + 1 = 13 => дети вершины с номером 6 имеют номера 12 и 13. Это действительно так! :) Можете проверить на любой вершине - свойство выполнится. Однако за существованием вершины с таким номером должны следить мы сами - если номер вершины превысил количество вершин в куче, то такая вершина не существует.
Мы умеем находить детей вершины. А как же найти родителя? Очень просто! pr = i div 2 (номер отца вершины равен номеру ребёнка, целочисленно делённому на 2). Это свойство обратно предыдущему, проверьте его самостоятельно.
Ну вот, на этом теория закончена. Теперь осталось научиться правильно реализовывать это всё на практике…
Сразу прейдём к коду и постепенно будут даваться объяснения.
Для начала объявим глобальные переменные:

#include <stdio.h>
#include <malloc.h>
#include <iostream>

const long int MaxV = 5000;

long int a[MaxV];//массив для временного хранения элементов
long int n,i;//n-количество элементов; i-счётчик цикла

//Our heap variables
long int heap[MaxV]; //основной массив кучи
long int nheap, tmp; //nheap-размер нашей кучи; tmp-временное хранение данных

heap - основной массив нашей кучи; nheap - размер нашей кучи (количество элементов, находящихся на данный момент в куче); a - массив для временного хранения элементов (он нужен лишь для примера работ с кучей); n - количество элементов, которые нужно считать (также нужно для примера); i - счётчик цикла; tmp - переменная, для временного хранения каких-либо данных.
Вот и прекрасно, ху из ху разобрались, теперь научимся инициализировать кучу:

//инициализация кучи
void InitHeap(void){
  nheap = 0;
}

Здесь ничего сложного нет - просто обнуляем текущее количество элементов. Если хотите - можно также сделать и обнуление всего массива кучи, но это не обязательно.
Теперь научимся добавлять элементы в кучу:

void HeapAdd(long int x){
  nheap++;
  heap[nheap] = x;
  MoveUp(nheap);
}

Сначала мы увеличиваем на 1 текущее количество элементов. Потом ложим на последнюю позицию элемент x.
Но ведь после того, как мы положили элемент куча может испортиться, т.е. вновь положенный элемент может быть “лучше” своего предка. В таком случае нам нужно исправить кучу. Для этого мы используем процедуру MoveUp. В неё передаётся номер добавленного элемента.
Как же должна работать MoveUp? Давайте рассуждать вместе! Для этого воспользуемся примером кучи:



Давайте попробуем добавить в эту кучу элемент 4. Для этого находим первую свободную позицию и присваиваем этой позиции значение 4. В данном случае номер этой позиции будет ранен 15 (у вершины 7 всего один ребёнок - 9. Свободная позиция - позиция второго ребёнка):



Что мы делаем дальше? Правильно, сравниваем с отцом. В данном случае 4 лучше своего отца 7 (т.е. 4 < 7 ). В этом случае мы “поднимаем 4 выше”, т.е. меняем с отцом:



Дальше повторяем то же самое до тех пор, пока 4 не станет “хуже” своего отца:



Т.е. меняем местами вершины со значениями 4 и 5. Опять сравниваем с отцом: 4 > 3, т.е. ребёнок (4) “хуже” своего предка (3). Останавливаемся. Вот как выглядит этот код:

void MoveUp(long int ind){
  long int k;
  k = ind / 2; //номер вершины предка
  if( ind > 1 ){ //Если ind < 2 то мы находимся в корне
    if( heap[ind] < heap[k] ){
      //Если предок "хуже" ребёнка - меняем их местами и
      //рекурсивно пытаемся пропихнуть вершину выше
      tmp = heap[ind];
      heap[ind] = heap[k];
      heap[k] = tmp;
      MoveUp(k);
    }
  }
}

Сначала узнаём номер вершины предка. Если ind < 2 то мы находимся в корне - т.е. нужно выходить, т.к. у него нет предка. Если номера ребёнка и предка корректны - сравниваем их. Если предок “хуже” ребёнка - меняем их местами и рекурсивно пытаемся пропихнуть вершину выше. Для обмена элементов местами использовалась глобальная переменная tmp. Её можно было сделать и локальной.
Часто нужно достать самый “лучший” элемент из кучи и работать дальше с ним. При этом чаще всего элемент назад не возвращается, а продолжать работать с кучей приходится. Для этого также нужно исправлять кучу. Вот код получения самого “лучшего” элемента и удаления его из кучи:

long int ExtractMin(void){
  long int value;
  value = heap[1]; //Самый "лучший" элемент лежит на самой верхушке кучи
  heap[1] = heap[nheap]; //последний элемент ложим на 1 место
  //опускаем 1 элемент на нужное место
  heap[nheap] = 0;
  nheap--;
  MoveDown(1);
  return value;
}

Самый “лучший” элемент лежит на самой верхушке куче, т.е. является первым. Запоминаем его. Для того, чтобы кучу можно было восстановить, берём последний элемент и ложим его на 1 место. Теперь, чтобы исправить нашу кучу, нам нужно всего лишь опустить 1 элемент на нужное место. К сожалению, метод исправить кучу быстрее ещё не придуман, так что будем использовать этот. Процедура MoveDown очень похожа на MoveUp. Вот её код:

void MoveDown(long int ind){
  long int k;
  k = ind * 2; //номер первого ребёнка данной вершины
  if(k <= nheap){ //Если номер перевалил за количество элементов - выходим
    if( (k+1 <= nheap) && (heap[k] > heap[k+1]) ) k++; //Из двух детей выбираем лучшего
    if( heap[ind] > heap[k] ){ //Если предок "хуже" ребёнка - меняем их местами
      //рекурсивно пытаемся опустить отца ещё ниже
        tmp = heap[ind];
      heap[ind] = heap[k];
      heap[k] = tmp;
      MoveDown(k);
    }
  }
}

Рассмотрим её пошагово. k - номер первого ребёнка данной вершины. Если номер перевалил за количество элементов - выходим, иначе k - первый кандидат на всплывание. Из двух детей должен всплыть “лучший”, иначе свойство кучи после всплывания не будет выполнятся. Из двух детей выбираем лучшего (по умолчанию - 1 ребёнок; если 2 его лучше - запоминаем его, увеличив k на 1). Теперь сравниваем кандидата на всплывание с предком. Если предок “хуже” ребёнка - меняем их местами и рекурсивно пытаемся опустить отца ещё ниже.
Ну вот и всё. Теперь вы умеете реализовывать все процедуры кучи. Сразу отмечу, что опускание/поднимание можно было сделать и не рекурсивно, а циклом. Но рекурсивное написание проще. Если Вы хотите писать бинарную как-то иначе, советую посмотреть вам и другие пособия.
А мы сейчас напишем программку-пример работы с кучей.
Как вы уже заметили, массив кучи нельзя назвать отсортированным. Многие примеры куч были таковыми, так что не думаю, что у кого-то останутся сомнения ;) (если не верите, попробуйте записать наши кучи в виде массивов и увидите, что они не отсортированы). Давайте отсортируем массив при помощи бинарной кучи. Известно, что в корне дерева кучи лежит самый “лучший” элемент, следовательно, последовательно забирая лучшие элементы мы получим отсортированный массив. А вот и код:

void main(void){
  setlocale(LC_ALL,"Rus");
  InitHeap();
  printf("Insert (N)umber of elements: ");
  scanf("%d",&n);
  printf("Insert array, please:\n");
  for(i=0; i<n; i++){
    printf("Element %2d > ", i);
    scanf("%d",&tmp);
    HeapAdd(tmp);
  }
  for(i=0; i<n; i++){
    a[i] = ExtractMin();
  }
  printf("Sorted array is:\n");
  for(i=0; i<n; i++) printf("%d ",a[i]);
  printf("\n");
  fflush(stdin);
  //getchar();
  printf("\n");
  system("PAUSE");
}

С самого начала мы инициализируем кучу. Потом считываем количество элементов массива, которые нужно будет считать. Дальше считываем массив и поэлементно заносим его в кучу. На самом деле массив нам здесь считывать не обязательно - можно просто считывать временную переменную и добавлять её значение в кучу. Т.е. данный момент кода можно заменить на:

  for(i=0; i<n; i++){
    printf("Element %2d > ", i);
    scanf("%d",&tmp);
    HeapAdd(tmp);
  }

Дальше мы поэлементно достаём элементы из кучи в массив a и выводим уже отсортированный массив.
Как видите, ничего сложного нет. Теперь поговорим о скорости работы наших процедур:
InitHeap - O(1), т.к. мы делаем всего одно действие - обнуляем текущее количество вершин.
MoveUp - O(log N) - в самом худшем случае в куче уже будут лежать N элементов, и все они будут “хуже” нашего элемента - тогда нам нужно будет поднять элемент с самого низа до самого верха, т.е. совершить “количество уровней в данной куче” операций - это как раз и будет O(log N)…
MoveDown - O(log N) - аналогично MoveUp, только элемент опускается.
HeapAdd - O(log N) - добавление мы делаем за О(1), но поднятие элемента “стоит” O(log N) операций.
ExtractMin - O(log N) - узнаём и удаляем элемент за О(1), но восстановление кучи требует O(log N) операций.

Теперь поговорим о полезности данного алгоритма. Задач типа “напишите структуру данных бинарная куча” почти не бывает. Однако есть огромное множество алгоритмов, к которым можно “прикрутить” бинарную кучу - мы с вами уже отсортировали массив с помощью бинарной кучи, хотя кучи по началу там даже видно не было. Вот ещё примеры алгоритмов, которые с бинарной кучей работают во много раз быстрее, чем без неё: алгоритм Дейкстры, Крускала, упорядоченное хранения данных и работа с ними, некоторые алгоритмы сжатия и т.д. На самом деле, бинарную кучу можно использовать почти везде, главное увидеть, как правильно в данной задаче использовать кучу и что в ней хранить.
Ну вот мы и разобрались, что же такое бинарная куча. Теперь если вас попросят “выйти к доске и сделать кучу” вы смело её сделаете!

Полный код:

#include <stdio.h>
#include <malloc.h>
#include <iostream>

const long int MaxV = 5000;

long int a[MaxV];//массив для временного хранения элементов
long int n,i;//n-количество элементов; i-счётчик цикла

//Our heap variables
long int heap[MaxV]; //основной массив кучи
long int nheap, tmp; //nheap-размер нашей кучи; tmp-временное хранение данных

void MoveUp(long int ind){
  long int k;
  k = ind / 2; //номер вершины предка
  if( ind > 1 ){ //Если ind < 2 то мы находимся в корне
    if( heap[ind] < heap[k] ){
      //Если предок "хуже" ребёнка - меняем их местами и
      //рекурсивно пытаемся пропихнуть вершину выше
      tmp = heap[ind];
      heap[ind] = heap[k];
      heap[k] = tmp;
      MoveUp(k);
    }
  }
}

void MoveDown(long int ind){
  long int k;
  k = ind * 2; //номер первого ребёнка данной вершины
  if(k <= nheap){ //Если номер перевалил за количество элементов - выходим
    if( (k+1 <= nheap) && (heap[k] > heap[k+1]) ) k++; //Из двух детей выбираем лучшего
    if( heap[ind] > heap[k] ){ //Если предок "хуже" ребёнка - меняем их местами
      //рекурсивно пытаемся опустить отца ещё ниже
        tmp = heap[ind];
      heap[ind] = heap[k];
      heap[k] = tmp;
      MoveDown(k);
    }
  }
}

long int ExtractMin(void){
  long int value;
  value = heap[1]; //Самый "лучший" элемент лежит на самой верхушке кучи
  heap[1] = heap[nheap]; //последний элемент ложим на 1 место
  //опускаем 1 элемент на нужное место
  heap[nheap] = 0;
  nheap--;
  MoveDown(1);
  return value;
}

//инициализация кучи
void InitHeap(void){
  nheap = 0;
}

void HeapAdd(long int x){
  nheap++;
  heap[nheap] = x;
  MoveUp(nheap);
}

void main(void){
  setlocale(LC_ALL,"Rus");
  InitHeap();
  printf("Insert (N)umber of elements: ");
  scanf("%d",&n);
  printf("Insert array, please:\n");
  for(i=0; i<n; i++){
    printf("Element %2d > ", i);
    scanf("%d",&tmp);
    HeapAdd(tmp);
  }
  for(i=0; i<n; i++){
    a[i] = ExtractMin();
  }
  printf("Sorted array is:\n");
  for(i=0; i<n; i++) printf("%d ",a[i]);
  printf("\n");
  fflush(stdin);
  //getchar();
  printf("\n");
  system("PAUSE");
}




            1.1.8. Бинарная куча #02. Реализация на C++ (class)
Двоичная куча представляет собой полное бинарное дерево, для которого выполняется основное свойство кучи: приоритет каждой вершины больше приоритетов её потомков.
В простейшем случае приоритет каждой вершины можно считать равным её значению. В таком случае структура называется max-куча, поскольку корень поддерева является максимумом из значений элементов поддерева.
В качестве альтернативы, если сравнение перевернуть, то наименьший элемент будет всегда корневым узлом, такие кучи называют min-кучами.
Двоичную кучу удобно хранить в виде одномерного массива, причем
    • левый потомок вершины с индексом i имеет индекс 2*i+1,
    • правый потомок вершины с индексом i имеет индекс 2*i+2.



Корень дерева (кучи) – элемент с индексом 0.
Высота двоичной кучи равна высоте дерева, то есть

log2 (N+1)↑,

где N – количество элементов массива, ↑ – округление в большую сторону до ближайшего целого.
Для представленной кучи

log2 (10+1)↑ = 3,46↑ = 4

Способ построить кучу из неупорядоченного массива – это по очереди добавить все его элементы. Временная оценка такого алгоритма оценивается как

N·log2N.

Можно построить кучу за N шагов. Для этого сначала следует построить дерево из всех элементов массива, не заботясь о соблюдении основного свойства кучи, а потом вызвать метод упорядочения для всех вершин, у которых есть хотя бы один потомок (так как поддеревья, состоящие из одной вершины без потомков, уже упорядочены).
Потомки гарантированно есть у первых heapSize/2 вершин, где heapSize – размер кучи.

Реализация класса кучи

class Heap {
  static const int SIZE = 100; // максимальный размер кучи
  int *h;         // указатель на массив кучи
  int HeapSize; // размер кучи
public:
  Heap();  // конструктор кучи
  void addelem(int);  // добавление элемента кучи
  void outHeap();  // вывод элементов кучи в форме кучи
  void out();  // вывод элементов кучи в форме массива
  int getmax();  // удаление вершины (максимального элемента)
  void heapify(int);  // упорядочение кучи
};

Конструктор кучи

Heap :: Heap() {
  h = new int[SIZE];
  HeapSize = 0;
}

Добавление элемента кучи
Новый элемент добавляется на последнее место в массиве, то есть позицию с максимальным индексом.



Возможно, что при этом будет нарушено основное свойство кучи, так как новый элемент может быть больше родителя. В таком случае новый элемент «поднимается» на один уровень (менять с вершиной-родителем) до тех пор, пока не будет соблюдено основное свойство кучи.





Сложность алгоритма не превышает высоты двоичной кучи (так как количество «подъемов» не больше высоты дерева), то есть равна log2 N.

void Heap :: addelem(int n) {
// Добавление элементов в кучу
  int i, parent;
  i = HeapSize;
  h[i] = n;
  parent = (i-1)/2;
  while(parent >= 0 && i > 0)  {
    if(h[i] > h[parent]) {
      int temp = h[i];
      h[i] = h[parent];
      h[parent] = temp;
    }
    i = parent;
    parent = (i-1)/2;
  }
  HeapSize++;
}

Вывод элементов кучи

Вывод элементов в форме кучи

void Heap:: outHeap(void) {
// Вывод элементов в форме кучи
  int i = 0;
  int k = 1;
  while(i < HeapSize) {
    while((i < k) && (i < HeapSize)) {
      cout << h[i] << " ";
      i++;
    }
    cout << endl;
    k = k * 2 + 1;
  }
}

Вывод элементов кучи в форме массива

void Heap:: out(void) {
// Вывод элементов кучи в форме массива
  for(int i=0; i< HeapSize; i++) {
    cout << h[i] << " "; }
  cout << endl;
}

Упорядочение кучи

void Heap:: heapify(int i) {
// Упорядочение кучи
  int left, right;
  int temp;
  left = 2*i+1;
  right = 2*i+2;
  if(left < HeapSize) {
    if(h[i] < h[left]) {
      temp = h[i];
      h[i] = h[left];
      h[left] = temp;
      heapify(left);
    }
  }
  if(right < HeapSize) {
    if(h[i] < h[right]) {
      temp = h[i];
      h[i] = h[right];
      h[right] = temp;
      heapify(right);
    }
  }
}

В упорядоченном max-heap максимальный элемент всегда хранится в корне. Восстановить упорядоченность двоичной кучи после удаления максимального элемента можно, поставив на его место последний элемент и вызвав метод упорядочения для корня, то есть упорядочив все дерево.

Удаление вершины кучи (максимального элемента)

int Heap:: getmax(void) {
// Удаление вершины кучи (максимального элемента)
  int x;
  x = h[0];
  h[0] = h[HeapSize-1];
  HeapSize--;
  heapify(0);
  return(x);
}

Пример Создать бинарную кучу из 16 элементов. Определить максимальный элемент.

#include <stdio.h>
#include <malloc.h>
#include <iostream>
using namespace std;

class Heap {
  static const int SIZE = 100; // максимальный размер кучи
  int *h;         // указатель на массив кучи
  int HeapSize; // размер кучи
public:
  Heap();  // конструктор кучи
  void addelem(int);  // добавление элемента кучи
  void outHeap();  // вывод элементов кучи в форме кучи
  void out();  // вывод элементов кучи в форме массива
  int getmax();  // удаление вершины (максимального элемента)
  void heapify(int);  // упорядочение кучи
};

Heap :: Heap() {
  h = new int[SIZE];
  HeapSize = 0;
}

void Heap :: addelem(int n) {
  int i, parent;
  i = HeapSize;
  h[i] = n;
  parent = (i-1)/2;
  while(parent >= 0 && i > 0)  {
    if(h[i] > h[parent]) {
      int temp = h[i];
      h[i] = h[parent];
      h[parent] = temp;
    }
    i = parent;
    parent = (i-1)/2;
  }
  HeapSize++;
}

void Heap:: outHeap(void) {
  int i = 0;
  int k = 1;
  while(i < HeapSize) {
    while((i < k) && (i < HeapSize)) {
      cout << h[i] << " ";
      i++;
    }
    cout << endl;
    k = k * 2 + 1;
  }
}

void Heap:: out(void) {
  for(int i=0; i< HeapSize; i++) {
    cout << h[i] << " "; }
  cout << endl;
}

void Heap:: heapify(int i) {
  int left, right;
  int temp;
  left = 2*i+1;
  right = 2*i+2;
  if(left < HeapSize) {
    if(h[i] < h[left]) {
      temp = h[i];
      h[i] = h[left];
      h[left] = temp;
      heapify(left);
    }
  }
  if(right < HeapSize) {
    if(h[i] < h[right]) {
      temp = h[i];
      h[i] = h[right];
      h[right] = temp;
      heapify(right);
    }
  }
}

int Heap:: getmax(void) {
  int x;
  x = h[0];
  h[0] = h[HeapSize-1];
  HeapSize--;
  heapify(0);
  return(x);
}

int main() {
  Heap heap;
  int k;
  setlocale(LC_ALL, "Rus");
  //system("chcp 1251");
  system("cls");
  for(int i=0; i<16; i++) {
    cout << "Введите элемент " << i+1 << ": ";
    cin >> k;
    heap.addelem(k);
  }
  heap.outHeap();
  cout  << endl;
  heap.out();
  cout  << endl << "Максимальный элемент: " << heap.getmax();
  cout  << endl << "Новая куча:" << endl;
  heap.outHeap();
  cout  << endl;
  heap.out();
  cout  << endl << "Максимальный элемент: " << heap.getmax();
  cout  << endl << "Новая куча:" << endl;
  heap.outHeap();
  cout  << endl;
  heap.out();
  cin.get();cin.get();
  return 0;
}

Результат выполнения



            1.1.9. Бинарная куча #03. Реализация на C++ (class)
Один из алгоритмов, в котором используется бинарная куча — это HeapSort — сортировка методом бинарной кучи, которая в худшем и среднем случае сортирует за время O(N log N) (напомним, что QuickSort в худшем случае работает N^2).
HeapSort реализован в функции main.

#include <stdio.h>
#include <malloc.h>

typedef struct {
	// int value;
	int  key;
} ITEM;

class HEAP {
public:
	ITEM *h;
	int  size;

	HEAP(unsigned int n) {
		size = 0;
		h = (ITEM*)malloc(sizeof(ITEM) * n);
	}

	~HEAP() {
		if (h) free(h);
	}

	int add(ITEM x) {
		h[++size] = x;
		checkup(size);
		return 1;
	}

	int extract_min(ITEM *x) {
		if (size == 0) return 0;
		*x = h[1];
		h[1] = h[size--];
		checkdown(1);
		return 1;
	}

private:
	void checkup(int c) {
		int p;
		p = c / 2;
		if (p == 0)return;
		if (h[p].key > h[c].key) {
			ITEM tmp;
			tmp = h[p]; h[p] = h[c]; h[c] = tmp;
			checkup(p);
		}
	}

	void checkdown(int p) {
		int c;
		c = 2 * p;
		if (c > size) return;
		if (c + 1 <= size && h[c + 1].key < h[c].key) c++;

		if (h[c].key < h[p].key) {
			ITEM tmp;
			tmp = h[c]; h[c] = h[p]; h[p] = tmp;
			checkdown(c);
		}
	}
};

int main() {
	HEAP heap(1000);
	int n, i;
	ITEM x;

	printf("n= ");
	scanf_s("%d", &n);

	for (i = 0; i < n; i++){
		printf("%2d x.key= ", i);
		scanf_s("%d", &x.key);
		heap.add(x);
	}

	while (heap.extract_min(&x)) {
		printf("%d ", x.key);
	}

	scanf_s("%d", &n);
	return 0;
}



            1.1.10. Бинарная куча #04. Реализация на C (struct)
Ниже приведен более "индустриальный код", соответствующий стандартам. В нём реализовано динамическое выделением памяти.
Заложена возможность динамического увеличения размера кучи.

#include <stdio.h>
#include <malloc.h>
#include<iostream>
typedef int key_t;
typedef unsigned int value_t;

typedef struct {
   key_t  key;
   value_t value;
} pair_t ;

typedef struct {
    pair_t *data;
    unsigned int size;
    unsigned int data_size;
} bheap_t;

bheap_t* bheap_new( unsigned int initial_data_size ) {
    bheap_t *h = (bheap_t*) malloc( sizeof(bheap_t) );
    h->data = (pair_t*) malloc( sizeof(pair_t) * (1 + initial_data_size) );
    h->data_size = 1 + initial_data_size;
    h->size = 0;
    return h;
}

void bheap_delete(bheap_t *h) {
    if( h ) {
        if( h->data ) {
            free( h->data );
        }
        free(h);
    }
}

void bheap_checkup( bheap_t *h, unsigned int c ) {
    unsigned int p;
    for( p = c / 2;  p > 0 ; c = p , p = c / 2 ) {
        if( h->data[p].key > h->data[c].key ) {
            pair_t tmp = h->data[p]; h->data[p] = h->data[c]; h->data[c] = tmp;
        } else {
            break;
        }
    }
}

void bheap_checkdown( bheap_t *h, unsigned int p ) {
    unsigned int c;
    for( c = 2 * p ;  c <= h->size  ; p = c, c = 2 *p ) {
        if( c + 1 <= h->size && h->data[c + 1].key < h->data[c].key ) c++;
        if( h->data[c].key < h->data[p].key ) {
            pair_t  tmp;
            tmp =  h->data[c]; h->data[c] = h->data[p]; h->data[p] = tmp;
        } else {
            break;
        }
    }
}


void bheap_add( bheap_t *h, pair_t v ) {
    if( h->size + 1 >= h->data_size ) {
        h->data_size *= 2;
        h->data = (pair_t*) realloc( h->data, h->data_size * sizeof(pair_t) );
    }
    h->data[ ++(h->size) ] = v ;
    bheap_checkup( h, h->size );
}

int bheap_extract_min(bheap_t *h, pair_t *v) {
    if( h->size == 0 ) return 0;
    *v = h->data[1];
    h->data[1] = h->data[ (h->size)--];
    bheap_checkdown( h, 1 );
    return 1;
}

int main() {
    setlocale(LC_ALL,"Rus");
    bheap_t *h = bheap_new(1000);
    unsigned int n, i;
    pair_t v = {0, 0};

    printf("Введите количество элементов n= ");
    scanf("%u", &n);
    for( i = 0; i < n; i++ ){
        printf("Элемент %2d > ", i);
        scanf("%d", &v.key);
        v.value = i;
        bheap_add(h, v);
    }

    printf("\nРезультат:\n", i);
    while( bheap_extract_min(h, &v) ) {
        printf("%d ", v.key);
    }
    printf("\n");
    bheap_delete( h );

    printf("\n");
    system("PAUSE");
    return 0;
}




            1.1.11. Бинарная куча #05. Реализация на C (struct) (#04=#05)
Ниже приведен более "индустриальный код", соответствующий стандартам. В нём реализовано динамическое выделением памяти.
Заложена возможность динамического увеличения размера кучи.

#include<stdio.h>
#include<malloc.h>
typedef int key_t;
typedef unsigned int value_t;

typedef struct {
	key_t key;
	value_t value;
} pair_t;

typedef struct {
	pair_t *data;
	unsigned int size;
	unsigned int data_size;
} bheap_t;

bheap_t* bheap_new(unsigned int initial_data_size) {
	bheap_t *h = (bheap_t*)malloc(sizeof(bheap_t));
	h->data = (pair_t*)malloc(sizeof(pair_t) * (1 + initial_data_size));
	h->data_size = 1 + initial_data_size;
	h->size = 0;
	return h;
}

void bheap_delete(bheap_t *h) {
	if (h) {
		if (h->data) {
			free(h->data);
		}
		free(h);
	}
}

void bheap_checkup(bheap_t *h, unsigned int c) {
	unsigned int p;
	for (p = c / 2; p > 0; c = p, p = c / 2) {
		if (h->data[p].key > h->data[c].key) {
			pair_t tmp = h->data[p]; h->data[p] = h->data[c]; h->data[c] = tmp;
		}
		else {
			break;
		}
	}
}

void bheap_checkdown(bheap_t *h, unsigned int p) {
	unsigned int c;
	for (c = 2 * p; c <= h->size; p = c, c = 2 * p) {
		if (c + 1 <= h->size && h->data[c + 1].key < h->data[c].key) c++;
		if (h->data[c].key < h->data[p].key) {
			pair_t  tmp;
			tmp = h->data[c]; h->data[c] = h->data[p]; h->data[p] = tmp;
		}
		else {
			break;
		}
	}
}

void bheap_add(bheap_t *h, pair_t v) {
	if (h->size + 1 >= h->data_size) {
		h->data_size *= 2;
		h->data = (pair_t*)realloc(h->data, h->data_size * sizeof(pair_t));
	}
	h->data[++(h->size)] = v;
	bheap_checkup(h, h->size);
}

int bheap_extract_min(bheap_t *h, pair_t *v) {
	if (h->size == 0) return 0;
	*v = h->data[1];
	h->data[1] = h->data[(h->size)--];
	bheap_checkdown(h, 1);
	return 1;
}

int main() {
	bheap_t *h = bheap_new(1000);
	unsigned int n, i;
	pair_t v = { 0, 0 };

	printf("n= ");
	scanf_s("%u", &n);
	for (i = 0; i < n; i++){
		printf("%2d v.key= ", i);
		scanf_s("%d", &v.key);
		v.value = i;
		bheap_add(h, v);
	}

	while (bheap_extract_min(h, &v)) {
		printf("%d ", v.key);
	}
	printf("\n");
	bheap_delete(h);

	scanf_s("%d", &n);
	return 0;
}



            1.1.12. Бинарная куча #06. Реализация на C++ (class) (#03=#06)
Здесь приведена реализация структуры данных "Бинарная куча" на языках программирования C и C++ (см. далее).
Один из алгоритмов, в котором используется бинарная куча — это HeapSort — сортировка методом бинарной кучи, которая в худшем и среднем случае сортирует за время O(N log N) (напомним, что QuickSort в хуждем случае работает N^2).
HeapSort реализован в функции main.

#include<iostream>
#include<stdio.h>
using namespace std;

typedef struct {
 // int value;
    int  key; 
} ITEM;

class HEAP {
public:
    ITEM *h;
    int  size;
    
    HEAP(unsigned int n) {
       size = 0;
       h = (ITEM*) malloc( sizeof(ITEM) * n);
    }
    
    ~HEAP() {
        if(h) free(h);
    }

    int add(ITEM x) {
       h[++size]=x;
       checkup(size);
       return 1;
    }

    int extract_min(ITEM *x) {
      if(size ==0) return 0;
      *x = h[1];
      h[1] = h[size--];
      checkdown(1);
      return 1;
    }

private:
    void checkup(int c) {
        int p;
        p = c / 2;
        if( p == 0 )return;
        if(h[p].key > h[c].key) {
           ITEM tmp;
           tmp = h[p]; h[p] = h[c]; h[c] = tmp;
           checkup(p);
        }
    }
    
    void checkdown(int p) {
        int c;
        c = 2*p;
        if( c > size ) return;
        if( c+1 <= size && h[c + 1].key < h[c].key ) c++;
   
        if( h[c].key < h[p].key ) {
          ITEM tmp;
          tmp =  h[c]; h[c] = h[p]; h[p] = tmp;
          checkdown(c);
       }
    }
};

int main() {
    setlocale(LC_ALL,"Rus");
    HEAP heap(1000);
    int n, i;
    ITEM x;
    
    printf("Введите количество элементов n= ");
    scanf("%d", &n);
    
    for(i = 0; i < n; i++){
       printf("Элемент %2d > ", i);
       scanf("%d", &x.key);
       heap.add(x);
    }
    
    printf("\nРезультат:\n", i);
    while( heap.extract_min(&x) ) {
       printf("%2d ", x.key);
       //printf("%d ", x.key);
    }
    
    cout << "\n";
    system("PAUSE");
    return 0;
}



            1.1.13. Бинарная куча #07. Лабораторная работа № 12

#include <iostream>
using namespace std;

const long int MaxV = 5000;
long int a[MaxV];
long int n, i;
long int heap[MaxV];
long int nheap, tmp;
//-------------------------------
void initHeap(void)
{
	nheap = 0;
}
//-------------------------------
void moveUp(long int ind)
{
	long int k;
	k = ind / 2;
	if (ind > 1)
	{
		if (heap[ind] < heap[k])
		{
			tmp = heap[ind];
			heap[ind] = heap[k];
			heap[k] = tmp;
			moveUp(k);
		}
	}
}
//-------------------------------
void moveDown(long int ind)
{
	long int k;
	k = ind * 2;
	if (k <= nheap)
	{
		if ((k + 1 <= nheap) && (heap[k] > heap[k + 1]))
			k++;
		if (heap[ind] > heap[k])
		{
			tmp = heap[ind];
			heap[ind] = heap[k];
			heap[k] = tmp;
			moveDown(k);
		}
	}
}
//-------------------------------
void heapAdd(long int x)
{
	nheap++;
	heap[nheap] = x;
	moveUp(nheap);
}
//-------------------------------
long int extractMin(void)
{
	long int value;
	value = heap[1];
	heap[1] = heap[nheap];
	heap[nheap] = 0;
	nheap--;
	moveDown(1);
	return value;
}
//-------------------------------
void main(void)
{
	setlocale(LC_ALL, "Russian");
	initHeap();
	cout << "Введите количество элементов ";
	cin >> n;
	for (i = 0; i < n; i++)
	{
		cout << "Введите " << i + 1 << " элемент= ";
		cin >> tmp;
		heapAdd(tmp);
	}
	for (i = 0; i < n; i++)
	{
		a[i] = extractMin();
	}
	cout << "Результат= ";
	for (i = 0; i < n; i++)
		cout << a[i] << ' ';
	fflush(stdin);
	getchar();
}




1. Рекурсия и рекурсивные алгоритмы
1.1. Рекуррентные соотношения. Рекурсия и итерация
1.2. Сущность рекурсии
1.3. Виды рекурсии
1.3.1. Прямая рекурсия
1.3.2. Косвенная рекурсия.
1.3.3. Линейная рекурсия
1.3.4. Ветвящаяся рекурсия
1.3.5. Бесконечная рекурсия
1.3.6. Сложная рекурсия
1.3.6.1. Опережающее описание
1.3.7. Типовой пример.
1.4. Имитация работы цикла с помощью рекурсии
1.4.1. Пример 1. Инкремент счетчика итераций
1.4.2. Пример 2. Декремент счетчика итераций
1.4.3. Пример 3. Двойной цикл
1.4.4. Пример 4: Перевод числа в двоичную систему.
1.5. Произвольное количество вложенных циклов
1.6. Графы
1.6.1. Понятие и представление графа: матрица смежности, список смежности
1.6.2. Способы представления графов
1.6.2.1. Матрица смежности
1.6.2.2. Список смежности
1.6.3. Использование графа с использованием STL для конкурентного программирования
1.7. Фракталы
1.8. Деревья
1.8.1. Основные определения. Способы изображения деревьев
1.8.2. Прохождение деревьев
1.8.2.1. Алгоритм обхода в прямом порядке
1.8.2.2. Алгоритм обхода в обратном порядке
1.8.2.3. Алгоритм обхода в концевом порядке
1.8.3. Представление дерева в памяти компьютера
1.8.3.1. Рекурсивные структуры данных
1.8.3.1.1. Пример 1. Простой пример связанного списка
1.8.3.1.2. Пример 2. Связанный список (динамический список)
1.8.3.1.3. Пример 3. Односвязный однонаправленный список
1.8.3.1.4. Пример 4. Однонаправленный связанный список
1.9. Примеры рекурсивных алгоритмов
1.9.1. Рисование дерева
1.9.2. Ханойские башни
1.9.2.1. Прмер 1.
1.9.2.2. Прмер 2.
1.9.2.3. Прмер 3.
1.9.3. Синтаксический анализ арифметических выражений
1.9.3.1. Пример 1. Вычисление выражения (Pascal)
1.9.3.2. Пример 2. Синтаксический анализатор математических выражений
1.9.4. Быстрые сортировки
1.9.4.1. Алгоритм 1: «Быстрая» сортировка (quicksort).
1.9.4.1.1. Quicksort. Пример 1.
1.9.4.1.2. Quicksort. Пример 2.
1.9.4.1.3. Quicksort. Пример 3.
1.9.4.2. Алгоритм 2: Сортировка слиянием (merge sort).
1.9.4.2.1. Merge sort. Пример 1.
1.9.4.2.2. Merge sort. Пример 2.
1.9.4.2.3. Merge sort. Пример 3.
1.9.4.3. Алгоритм 3: Сортировка деревом (tree sort).
1.9.4.3.1. Tree sort. Пример 1.
1.9.4.3.2. Tree sort. Пример 2.
1.10. Рекурсия или цикл. Избавление от рекурсии
1.10.1. Рекурсия
1.10.2. Цикл
1.10.3. Контрольные примеры
1.10.3.1. Вычисление суммы
1.10.3.2. Вычисление факториала
1.10.4. Области применения рекурсии
1.10.5. Явное использование стека
1.10.6. Запоминание последовательности рекурсивных вызовов
1.10.7. Определение узла дерева по его номеру
1.11. Контрольные вопросы
1.12. Задачи
1.13. Литература
1.14. Другие материалы на этом сайте

http://www.tvd-home.ru/recursion

    1. Рекурсия и рекурсивные алгоритмы
Рекурсией называется ситуация, когда адгоритм вызывает сама себя. Впервые сталкиваясь с такой алгоритмической конструкцией, большинство людей испытывает определенные трудности, однако немного практики и рекурсия станет понятным и очень полезным инструментом в вашем программистском арсенале.

        1.1. Рекуррентные соотношения. Рекурсия и итерация
Говорят, что последовательность векторов задана рекуррентным соотношением, если задан начальный вектор  и функциональная зависимость последующего вектора от предыдущего



Простым примером величины, вычисляемой с помощью рекуррентных соотношений, является факториал



Очередной факториал  можно вычислить по предыдущему как:



Введя обозначение , получим соотношение:



Вектора  из формулы (1) можно интерпретировать как наборы значений переменных. Тогда вычисление требуемого элемента последовательности будет состоять в повторяющемся обновлении их значений. В частности для факториала:

x = 1;
for(i = 2; i <= n; i++)
x = x * i;
printf("%d", x);

Каждое такое обновление (x := x * i) называется итерацией, а процесс повторения итераций – итерированием.
Обратим, однако, внимание, что соотношение (1) является чисто рекурсивным определением последовательности и вычисление n-го элемента есть на самом деле многократное взятие функции f от самой себя:



В частности для факториала можно написать:

#include <stdio.h>
#include <iostream>
#include <conio.h>
#include <windows.h>
using namespace std;
int Factorial(int);
void main()
{
//FONT: Lucida Console
SetConsoleCP(1251); // установка кодовой страницы win-cp 1251 в поток ввода
SetConsoleOutputCP(1251); //установка кодовой страницы win-cp 1251 в поток вывода
setlocale(LC_ALL, "Rus");
printf("5! = %d\n", Factorial(5));
system("PAUSE");
}

int Factorial(int n)
{
if(n > 1)
 return (n * Factorial(n-1));
else
 return(1);
}



Следует понимать, что вызов функций влечет за собой некоторые дополнительные накладные расходы, поэтому первый вариант вычисления факториала будет несколько более быстрым. Вообще итерационные решения работают быстрее рекурсивных.
Прежде чем переходить к ситуациям, когда рекурсия полезна, обратим внимание еще на один пример, где ее использовать не следует.
Рассмотрим частный случай рекуррентных соотношений, когда следующее значение в последовательности зависит не от одного, а сразу от нескольких предыдущих значений. Примером может служить известная последовательность Фибоначчи, в которой каждый следующий элемент есть сумма двух предыдущих:



При «лобовом» подходе можно написать Fib(int n):

#include <stdio.h>
#include <iostream>
#include <conio.h>
#include <windows.h>
using namespace std;
int Fib(int);
void main()
{
//FONT: Lucida Console
SetConsoleCP(1251); // установка кодовой страницы win-cp 1251 в поток ввода
SetConsoleOutputCP(1251); //установка кодовой страницы win-cp 1251 в поток вывода
setlocale(LC_ALL, "Rus");
int pp = 13;
printf("Для %d число Фибоначчи = %d\n", pp, Fib(pp));
system("PAUSE");
}

int Fib(int n)
{
if(n == 1 || n == 2)
 return(n-1);
else
 return (Fib(n-1) + Fib(n-2));
}



Каждый вызов Fib создает сразу две копии себя, каждая из копий – еще две и т.д. Количество операций растет с номером n экспоненциально, хотя при итерационном решении достаточно линейного по n количества операций.
На самом деле, приведенный пример учит нас НЕ КОГДА рекурсию не следует использовать, а тому КАК ее не следует использовать. В конце концов, если существует быстрое итерационное (на базе циклов) решение, то тот же цикл можно реализовать с помощью рекурсивной процедуры или функции. Например:

#include <stdio.h>
#include <iostream>
#include <conio.h>
#include <windows.h>
using namespace std;
int Fib2(int, int, int);
void main()
{
//FONT: Lucida Console
SetConsoleCP(1251); // установка кодовой страницы win-cp 1251 в поток ввода
SetConsoleOutputCP(1251); //установка кодовой страницы win-cp 1251 в поток вывода
setlocale(LC_ALL, "Rus");
int pp = 13;
printf("Для %d число Фибоначчи = %d\n", pp, Fib2(1, 1, pp));
system("PAUSE");
}

int Fib2(int x1, int x2, int n)
// x1, x2 – начальные условия (1, 1)
// n – номер требуемого числа Фибоначчи
{
int x3;
if(n > 3){
 x3 = x1 + x2;
 x1 = x2;
 x2 = x3;
 return(Fib2(x1, x2, n-1));
}
else
 return(x2);
}



Второй вариант решения этой задачи

#include <stdio.h>
#include <iostream>
#include <conio.h>
#include <windows.h>
using namespace std;
unsigned long Fib3(long);
void main()
{
//FONT: Lucida Console
SetConsoleCP(1251); // установка кодовой страницы win-cp 1251 в поток ввода
SetConsoleOutputCP(1251); //установка кодовой страницы win-cp 1251 в поток вывода
setlocale(LC_ALL, "Rus");
for(int count = 1; count <= 15; count++)
 printf("Для %2d число Фибоначчи = %d\n", count, Fib3(count));
system("PAUSE");
}

unsigned long  Fib3(long n)
// n – номер требуемого числа Фибоначчи
{
if(n == 1 || n == 2)
 return(n-1);
else
 return(Fib3(n - 1) + Fib3(n - 2));
}



И все же итерационные решения предпочтительны. Спрашивается, когда же в таком случае, следует пользоваться рекурсией?
Любые рекурсивные процедуры и функции, содержащие всего один рекурсивный вызов самих себя, легко заменяются итерационными циклами. Чтобы получить что-то, не имеющее простого нерекурсивного аналога, следует обратиться к процедурам и функциям, вызывающим себя два и более раз. В этом случае множество вызываемых процедур образует уже не цепочку, а целое дерево. Существуют широкие классы задач, когда вычислительный процесс должен быть организован именно таким образом. Как раз для них рекурсия будет наиболее простым и естественным способом решения.

        1.2. Сущность рекурсии
Процедура или функция может содержать вызов других процедур или функций. В том числе процедура может вызвать саму себя. Никакого парадокса здесь нет – компьютер лишь последовательно выполняет встретившиеся ему в программе команды и, если встречается вызов процедуры, просто начинает выполнять эту процедуру. Без разницы, какая процедура дала команду это делать.
Пример рекурсивной процедуры:

#include <stdio.h>
#include <iostream>
#include <conio.h>
#include <windows.h>
using namespace std;

void Rec(int);
void main()
{
//FONT: Lucida Console
SetConsoleCP(1251); // установка кодовой страницы win-cp 1251 в поток ввода
SetConsoleOutputCP(1251); //установка кодовой страницы win-cp 1251 в поток вывода
setlocale(LC_ALL, "Rus");
Rec(3);
system("PAUSE");
}
void Rec(int a)
{
if(a > 0)
 Rec(a - 1);
printf("%d\n", a);
}



Рассмотрим, что произойдет, если в основной программе поставить вызов, например, вида Rec(3). Ниже представлена блок-схема, показывающая последовательность выполнения операторов.



Рис. 1. Блок схема работы рекурсивной процедуры.

Процедура Rec вызывается с параметром a = 3. В ней содержится вызов процедуры Rec с параметром a = 2. Предыдущий вызов еще не завершился, поэтому можете представить себе, что создается еще одна процедура и до окончания ее работы первая свою работу не заканчивает. Процесс вызова заканчивается, когда параметр a = 0. В этот момент одновременно выполняются 4 экземпляра процедуры. Количество одновременно выполняемых процедур называют глубиной рекурсии.
Четвертая вызванная процедура (Rec(0)) напечатает число 0 и закончит свою работу. После этого управление возвращается к процедуре, которая ее вызвала (Rec(1)) и печатается число 1. И так далее пока не завершатся все процедуры. Результатом исходного вызова будет печать четырех чисел: 0, 1, 2, 3.
Еще один визуальный образ происходящего представлен на рис. 2.



Рис. 2. Выполнение процедуры Rec с параметром 3 состоит из выполнения процедуры Rec с параметром 2 и печати числа 3. В свою очередь выполнение процедуры Rec с параметром 2 состоит из выполнения процедуры Rec с параметром 1 и печати числа 2. и т. д.
В качестве самостоятельного упражнения подумайте, что получится при вызове Rec(4).



Также подумайте, что получится при вызове описанной ниже процедуры Rec2(4), где операторы поменялись местами.

#include <stdio.h>
#include <iostream>
#include <conio.h>
#include <windows.h>
using namespace std;

void Rec2(int);
void main()
{
//FONT: Lucida Console
SetConsoleCP(1251); // установка кодовой страницы win-cp 1251 в поток ввода
SetConsoleOutputCP(1251); //установка кодовой страницы win-cp 1251 в поток вывода
setlocale(LC_ALL, "Rus");
Rec2(4);
system("PAUSE");
}
void Rec2(int a)
{
printf("%d\n", a);
if(a > 0)
 Rec2(a - 1);
}



Обратите внимание, что в приведенных примерах рекурсивный вызов стоит внутри условного оператора. Это необходимое условие для того, чтобы рекурсия когда-нибудь закончилась. Также обратите внимание, что сама себя процедура вызывает с другим параметром, не таким, с каким была вызвана она сама. Если в процедуре не используются глобальные переменные, то это также необходимо, чтобы рекурсия не продолжалась до бесконечности.

        1.3. Виды рекурсии
Рекурсия - метод определения класса объектов или методов предварительным заданием одного или нескольких (обычно простых) его базовых случаев или методов, а затем заданием на их основе правила построения определяемого класса, ссылающегося прямо или косвенно на эти базовые случаи.
Другими словами, рекурсия - способ общего определения объекта или действия через себя, с использованием ранее заданных частных определений. Рекурсия используется, когда можно выделить само подобие задачи.
Рекурсивный алгоритм (процедура, функция):
    • алгоритм называется рекурсивным, если в его определении содержится прямой или косвенный вызов этого же алгоритма;
    • рекурсивная функция - одно из математических уточнений интуитивного понятия вычислимой функции.

Адаптивный рекурсивный алгоритм - алгоритм, который благодаря рекурсивности учитывает те или иные индивидуальные характеристики решаемой задачи из области своего определения.
Базис рекурсии - это предложение, определяющее некую начальную ситуацию или ситуацию в момент прекращения. Как правило, в этом предложении записывается некий простейший случай, при котором ответ получается сразу, даже без использования рекурсии.
Шаг рекурсии - это правило, в теле которого обязательно содержится, в качестве подцели, вызов определяемого предиката. (Предикат (лат. Praedicatum — сказанное) в логике и лингвистике — сказуемое суждения, то, что высказывается (утверждается или отрицается) о субъекте. Предикат находится с субъектом в предикативном отношении и показывает наличие (отсутствие) у предмета некоторого признака). Прмер: «Это животное — кошка», «Авраам — отец Исаака», «Климат на севере суровый»
Подпрограмма - все, что находится внутри рекурсивной функции.
Глубина рекурсии - количество одновременно выполняемых процедур.
Основное правило рекурсии: до рекурсивного вызова должна стоять проверка на возврат из рекурсии. Существуют следующие виды рекурсии:

            1.1.1. Прямая рекурсия
Прямая рекурсия - непосредственный вызов алгоритма (функции, процедуры, метода) из текста самого метода.
В данном случае функция r1( ) вызывает саму себя.

#include <iostream>

using namespace std;

void r1 (int a);
void r2 (int a);
void r3 (int a);

void r1(int a)
{
cout << "#" << a <<" function r1" << endl;
if (a < 6)
 r1(a+1);
}

int main ( )
{
r1 (0);
system("PAUSE");
return NULL;
}



            1.1.2. Косвенная рекурсия.
При косвенной рекурсии имеется циклическая последовательность вызовов нескольких алгоритмов.
В данном случае функция r1( ) вызывает функцию r2( ), которая вызывает r3( ).
Функция r3( ) в свою очередь снова вызывает r1( ).

#include <iostream>

using namespace std;

void r1 (int a);
void r2 (int a);
void r3 (int a);

void r1(int a)
{
cout << "#" << a << " function r1" << endl;
if (a < 6)
 r2(a+1);
}

void r2(int a)
{
cout << "#" << a << " function r2" << endl;
if (a < 6)
 r3(a+1);
}

void r3(int a)
{
cout << "#" << a << " function r3" << endl;
if (a < 6)
 r1(a+1);
}

int main ( )
{
r1 (0);
system("PAUSE");
return NULL;
}



            1.1.3. Линейная рекурсия
Линейная рекурсия - если исполнение подпрограммы приводит только к одному вызову этой же самой подпрограммы, то такая рекурсия называется линейной.

#include <iostream>

using namespace std;

void function(int a);

void function (int a)
{
cout << " input a= " << a << endl;
if (a > 0)
 function(a - 1);
cout << "output a= " << a << endl;
}

int main ( )
{
function(3);
system("PAUSE");
return NULL;
}



            1.1.4. Ветвящаяся рекурсия
Ветвящаяся рекурсия - если каждый экземпляр подпрограммы может вызвать себя несколько раз, то рекурсия называется нелинейной или "ветвящейся".

#include <iostream>

using namespace std;

int function(int a);

int function (int a)
{
if (a > 3)
 a = function (a - 1) * function(a - 2);
return a;
}

int main ()
{
cout << function(6) << endl;
system("PAUSE");
return NULL;
}



            1.1.5. Бесконечная рекурсия
Бесконечная рекурсия (на самом деле это условное обозначение так как при переполнении памяти компьютера программа выдаст ошибку и/или завершит ее в аварийном режиме).
Одна из самых больших опасностей рекурсии - бесконечный вызов функцией самой себя.
Например:

void function()
{
function();
}

Другой пример:

int Function (unsigned int n)
// Unsigned int - тип, содержащий неотрицательные значения
{
if (n > 0)
{
 Function(n++);
 return n;
}
else
 return 0;
}

При использовании подобных алгоритмов появляется ошибка, предупреждающая о переполнении стека. Причиной такой проблемы чаще всего является отсутствие базиса, либо других точек останова, так же неправильно заданные точки прерывания рекурсии

            1.1.6. Сложная рекурсия
Возможна чуть более сложная схема: функция A вызывает функцию B, а та в свою очередь вызывает A. Это называется сложной рекурсией. При этом оказывается, что описываемая первой процедура должна вызывать еще не описанную. Чтобы это было возможно, требуется использовать опережающее описание.

    2. Опережающее описание
В теле каждой процедуры или функции может содержаться вызов других процедур или функций при условии, что они описаны раньше, чем процедура или функция их вызывающая. Однако есть возможность вызывать и те процедуры, которые описаны после вызывающей. Для этого надо скопировать заголовок вызываемой подпрограммы и разместить его выше всех описаний. Например:

//Опережающее описание функции F1 - заголовок без тела функции
float F1(float x);
float F6()
{
   float x;
   //Какие-то действия...
   //Вызов функции F1 возможен благодаря опережающему описанию
   x = F1(x);
   //Какие-то действия...
}

//Описание функции F1, теперь тело функции присутствует
float F1(float x)
{
//Какие-то действия...
return(F1); //Что-то
}

Это может понадобиться, когда есть две процедуры, вызывающие другу друга, например:

#include <stdio.h>
#include <iostream>
#include <conio.h>
#include <windows.h>
using namespace std;
void A(int n); //Опережающее описание первой процедуры
void B(int n); //Опережающее описание второй процедуры
void main()
{
   //FONT: Lucida Console
   SetConsoleCP(1251); // установка кодовой страницы win-cp 1251 в поток ввода
   SetConsoleOutputCP(1251); //установка кодовой страницы win-cp 1251 в поток вывода
   setlocale(LC_ALL, "Rus");
   A(3);
   system("PAUSE");
}

void A(int n){  //Полное описание процедуры A
   printf("A>>> %2d\n", n);
   B(n-1);
}

void B(int n) //Полное описание процедуры B
{
   printf("B>>> %2d\n", n);
   if(n < 10)
     A(n+2);
}

Процедура A вызывает процедуру B, та в свою очередь вызывает A, а та снова B и т.д. Данная цепочка вызовов закончится, поскольку B вызывается каждый раз с на единицу большим значением параметра n. Когда n перестанет быть меньше 10, процедура B завершится, не вызвав A, что позволит завершиться и прочим процедурам в цепочке.



Опережающее описание процедуры B позволяет вызывать ее из процедуры A. Опережающее описание процедуры A в данном примере не требуется и добавлено из эстетических соображений.
Если обычную рекурсию можно уподобить уроборосу (рис. 3), то образ сложной рекурсии можно почерпнуть из известного детского стихотворения, где «Волки с перепуга, скушали друг друга». Представьте себе двух съевших друг друга волков, и вы поймете сложную рекурсию.



Рис. 3. Уроборос – змей, пожирающий свой хвост. Рисунок из алхимического трактата «Synosius» Теодора Пелеканоса (1478г).



Рис. 4. Сложная рекурсия.

            2.1.1. Типовой пример.
Одной и наиболее востребованной операцией в экономической сфере является расчет процентов по вкладу. Пример задачи: вкладчик положил в банк сумму в sum денежных единиц под pr процентов за один период времени (год, месяц, неделя и т.д.). Составить программу, возвращающую величину вклада по истечении m периодов времени (m = 24)

#include <iostream>
#include <windows.h>

using namespace std;

double rec_fun(double sum, double pr, int m, int i)
{
if(m==i)
 return sum;
sum+=(sum*(pr/100));
return rec_fun(sum, pr, m, i+1);
}

int main ()
{
int m;
double sum, pr;
setlocale(LC_ALL, "Rus");
cout << "Введите начальную сумму вклада: ";
cin >> sum;
cout << "Ежемесячный процент по вкладу: ";
cin >> pr;
cout << "Количество месяцев вклада: ";
cin >> m;
cout  << endl << "За " << m << " месяцев сумма вклада составит: " << rec_fun(sum, pr, m, 0) << endl;
system("PAUSE");
return 0;
}




        1.4. Имитация работы цикла с помощью рекурсии
Если процедура вызывает сама себя, то, по сути, это приводит к повторному выполнению содержащихся в ней инструкций, что аналогично работе цикла. Некоторые языки программирования не содержат циклических конструкций вовсе, предоставляя программистам организовывать повторения с помощью рекурсии (например, Пролог, где рекурсия - основной прием программирования).
Для примера сымитируем работу цикла for. Для этого нам потребуется переменная счетчик шагов, которую можно реализовать, например, как параметр процедуры.

            2.1.2. Пример 1. Инкремент счетчика итераций

#include <stdio.h>
#include <iostream>
#include <conio.h>
#include <windows.h>
using namespace std;
void LoopImitation(int, int);
void main()
{
//FONT: Lucida Console
SetConsoleCP(1251); // установка кодовой страницы win-cp 1251 в поток ввода
SetConsoleOutputCP(1251); //установка кодовой страницы win-cp 1251 в поток вывода
setlocale(LC_ALL, "Rus");
LoopImitation(1, 10);
system("PAUSE");
}

void LoopImitation(int i, int n)
{
//Первый параметр – счетчик шагов, второй параметр – общее количество шагов
//Здесь любые инструкции, которые будут повторятся
printf("Hello N %d\n", i);
if(i < n) //Пока счетчик цикла не станет равным максимальному
//значению n, повторяем инструкции путем вызова
//нового экземпляра процедуры
LoopImitation(i+1, n);
}

Результатом вызова вида LoopImitation(1, 10) станет десятикратное выполнение инструкций с изменением счетчика от 1 до 10. В данном случае будет напечатано:



Вообще, не трудно видеть, что параметры процедуры это пределы изменения значений счетчика.
Можно поменять местами рекурсивный вызов и подлежащие повторению инструкции, как в следующем примере.

            2.1.3. Пример 2. Декремент счетчика итераций

#include <stdio.h>
#include <iostream>
#include <conio.h>
#include <windows.h>
using namespace std;
void LoopImitation2(int, int);
void main()
{
//FONT: Lucida Console
SetConsoleCP(1251); // установка кодовой страницы win-cp 1251 в поток ввода
SetConsoleOutputCP(1251); //установка кодовой страницы win-cp 1251 в поток вывода
setlocale(LC_ALL, "Rus");
LoopImitation2(1, 10);
system("PAUSE");
}

void LoopImitation2(int i, int n)
{
if(i < n)
 LoopImitation2(i+1, n);
printf("Hello N %d\n", i);
}

В этом случае, прежде чем начнут выполняться инструкции, произойдет рекурсивный вызов процедуры. Новый экземпляр процедуры также, прежде всего, вызовет еще один экземпляр и так далее, пока не дойдем до максимального значения счетчика. Только после этого последняя из вызванных процедур выполнит свои инструкции, затем выполнит свои инструкции предпоследняя и т.д. Результатом вызова LoopImitation2(1, 10) будет печать приветствий в обратном порядке:



            2.1.4. Пример 3. Двойной цикл
Если представить себе цепочку из рекурсивно вызванных процедур, то в примере 1 мы проходим ее от раньше вызванных процедур к более поздним. В примере 2 наоборот от более поздних к ранним.
Наконец, рекурсивный вызов можно расположить между двумя блоками инструкций. Например:

#include <stdio.h>
#include <iostream>
#include <conio.h>
#include <windows.h>
using namespace std;
void LoopImitation3(int, int);
void main()
{
//FONT: Lucida Console
SetConsoleCP(1251); // установка кодовой страницы win-cp 1251 в поток ввода
SetConsoleOutputCP(1251); //установка кодовой страницы win-cp 1251 в поток вывода
setlocale(LC_ALL, "Rus");
LoopImitation3(1, 10);
system("PAUSE");
}

void LoopImitation3(int i, int n)
{
//Здесь может располагаться первый блок инструкций
printf("Hello N %2d\n", i);
if(i < n)
 LoopImitation3(i+1, n);
//Здесь может располагаться второй блок инструкций
printf("Hello # %2d\n", i);
}

Здесь сначала последовательно выполнятся инструкции из первого блока затем в обратном порядке инструкции второго блока. При вызове LoopImitation3(1, 10) получим:



Потребуется сразу два цикла, чтобы сделать то же самое без рекурсии.
Тем, что выполнение частей одной и той же процедуры разнесено по времени можно воспользоваться. Например:

            2.1.5. Пример 4: Перевод числа в двоичную систему.
Получение цифр двоичного числа, как известно, происходит с помощью деления с остатком на основание системы счисления 2. Если есть число , то его последняя цифра в его двоичном представлении равна

.

Взяв же целую часть от деления на 2:

,

получим число, имеющее то же двоичное представление, но без последней цифры. Таким образом, достаточно повторять приведенные две операции пока поле очередного деления не получим целую часть равную 0. Без рекурсии это будет выглядеть так:

while(x > 0) do
{
c = x % 2; //c := x mod 2;
x = x / 2; //x := x div 2;
printf("%d", c);
}

Проблема здесь в том, что цифры двоичного представления вычисляются в обратном порядке (сначала последние). Чтобы напечатать число в нормальном виде придется запомнить все цифры в элементах массива и выводить в отдельном цикле.
С помощью рекурсии нетрудно добиться вывода в правильном порядке без массива и второго цикла. А именно:

#include <stdio.h>
#include <iostream>
#include <conio.h>
#include <windows.h>
using namespace std;
void BinaryRepresentation(int);
void main()
{
//FONT: Lucida Console
SetConsoleCP(1251); // установка кодовой страницы win-cp 1251 в поток ввода
SetConsoleOutputCP(1251); //установка кодовой страницы win-cp 1251 в поток вывода
setlocale(LC_ALL, "Rus");
printf("10 ==> ");
BinaryRepresentation(10);
printf("\n");
system("PAUSE");
}

void BinaryRepresentation(int x)
{
int c;
//Первый блок. Выполняется в порядке вызова процедур
c = x % 2; //c := x mod 2;
x = x / 2; //x := x div 2;
//Рекурсивный вызов
if(x > 0)
 BinaryRepresentation(x);
//Второй блок. Выполняется в обратном порядке
printf("%d", c);
}

Вообще говоря, никакого выигрыша мы не получили. Цифры двоичного представления хранятся в локальных переменных, которые свои для каждого работающего экземпляра рекурсивной процедуры. То есть, память сэкономить не удалось. Даже наоборот, тратим лишнюю память на хранение многих локальных переменных x. Тем не менее, такое решение кажется мне красивым.



        1.5. Произвольное количество вложенных циклов
Разместив рекурсивные вызовы внутри цикла, по сути, получим вложенные циклы, где уровень вложенности равен глубине рекурсии.
Для примера напишем процедуру, печатающую все возможные сочетания из k чисел от 1 до n (). Числа, входящие в каждое сочетание, будем печатать в порядке возрастания. Сочетания из двух чисел (k=2) печатаются так:

#include <iostream>
using namespace std;
int main()
{
// переходим на русский язык в консоли
setlocale(LC_ALL, "Rus");
int n = 5;
for (int i1 = 1; i1 <= n; i1++)
 for (int i2 = i1+1; i2 <= n; i2++)
  cout << i1 << " " << i2 << "\n";
system("PAUSE");
return 0;
}



Сочетания из трех чисел (k=3) так:

#include <iostream>
using namespace std;
int main()
{
// переходим на русский язык в консоли
setlocale(LC_ALL, "Rus");
int n = 5;
for (int i1 = 1; i1 <= n; i1++)
 for (int i2 = i1+1; i2 <= n; i2++)
  for (int i3 = i2+1; i3 <= n; i3++)
   cout << i1 << " " << i2 << " " << i3 << "\n";
system("PAUSE");
return 0;
}



Однако, если количество чисел в сочетании задается переменной, то придется прибегнуть к рекурсии.

// все комбинации цифр от 1 до k в n-значном числе
#include <iostream>
using namespace std;

void Combinations( int, int, int x[], int);

int main()
{
int t[10000];
int n=7;
int k=4;
int d=0;
// переходим на русский язык в консоли
setlocale(LC_ALL, "Rus");
cout << "Значность числа n= " << n << "\n";
cout << "Комбинации цифр k= " << k << "\n";
cout << "Счетчик глубины рекурсии d= " << d << "\n\n";
Combinations( n, k, t, d);
system("PAUSE");
return 0;
}

void Combinations( int n, int k, int Indexes[], int d)
{
//Indexes Массив, в котором будем формировать сочетания
//d   Счетчик глубины рекурсии
int i, i_min;
if(d < k){
 if(d == 0)
  i_min = 1;
 else
  i_min = Indexes[d-1] + 1;
 for (i = i_min; i <= n; i++){
  Indexes[d] = i;
  Combinations(n, k, Indexes, d+1);
 }
}
else{
 for (i = 0; i <= k-1; i++)
  cout << Indexes[i] << " ";
 cout << "\n";
}
}



// все комбинации цифр от 1 до k в n-значном числе
#include <iostream>
using namespace std;

void Combinations( int, int, int Indexes[], int);
int main()
{
int Indexes[10000] = {0};
int n=4;
int k=3;
int d=0;
// переходим на русский язык в консоли
setlocale(LC_ALL, "Rus");
Combinations( n, k, Indexes, d);
system("PAUSE");
return 0;
}

void Combinations( int n, int k, int Indexes[], int d)
{
//Indexes Массив, в котором будем формировать сочетания
//d   Счетчик глубины рекурсии
int i, i_min;
if(d < k){
 if(d = 0)
  i_min = 1;
 else
  i_min = Indexes[d-1] + 1;
 for (i = i_min; i <= n; i++){
   Indexes[d] = i;
   Combinations(n, k, Indexes, d+1);
 }
}
else{
 for (i = 0; i <= k-1; i++)
  cout << Indexes[i] << " ";
 cout << "\n";
}
}

Второй вариант этой же задачи.

// все комбинации цифр от 1 до k в n-значном числе
#include <iostream>
using namespace std;
int c=1;
int ind[100];
int i=1;
int asd=1;

void comb(int n, int k);
int main(){
for (int j=0; j<100; j++)
 ind[j]=1;
int n,k;
//cin >> n >> k;
n = 4;
k = 3;
cout << "n= " << n << " k= " << k << "\n";
for (int j=1; j<=n; j++)
 asd = asd*k;
for (i=1; i<=n; i++)
 cout << ind[i-1] << ' ';
cout << endl;
c++;
comb(n,k);
system("pause");
return 0;
}
void comb(int n, int k)
{
for (i=n-1; i>=1; i--)
 if((ind[i]<k) && (ind[i-1]<k)){
  ind[i]++;
  break;
 }
 else if(ind[i-1] < k){
  ind[i]=1;
  ind[i-1]++;
  break;
 }
 else if((ind[i-1] == k) && (ind[i] == k)){
  if(i-1 != 0){
   ind[i-2]++;
   ind[i-1]=1;
   ind[i]=1;
   break;
  }
 }
 else if(ind[i-1] == k){
  ind[i]++;
  break;
 }

for(i=1; i<=n; i++)
 cout << ind[i-1] << ' ';
cout << endl;
c++;
if(c == asd+1)
 return;
else
 comb(n,k);
}



Третий вариант этой же задачи.

// все комбинации цифр от 1 до k в n-значном числе
#include <iostream>
using namespace std;

int ind[100];
void comb(int n, int k, int t);

int main()
{
int n=4, k=3;
//cin>>n>>k;
cout << "n= " << n << " k= " << k << "\n";
comb(n, k, 0);
system("pause");
return 0;
}

void comb(int n, int k, int t)
{
   if(t == n){
       for(int i=0; i<n; i++)
           cout << ind[i] << " ";
       cout << endl;
       return;
   }
   for(int i=1; i<=k; i++){
       ind[t] = i;
       comb(n, k, t+1);
   }
}



        1.6. Графы

            2.1.6. Понятие и представление графа: матрица смежности, список смежности
Графом называют графическое изображение, состоящее из вершин (узлов) и соединяющих некоторые пары вершин ребер (рис. 11а).
Более строго: граф – совокупность множества вершин и множества ребер. Множество ребер – подмножество евклидова квадрата множества вершин (то есть ребро соединяет ровно две вершины).
Ребрам можно также присвоить направление. Граф в этом случае называется ориетированным (рис. 11б).



Рис. 11. (а) Граф. (б) Ориентированный граф.

Графы – фундаментальное понятие как в математике, так и в информатике. Проще всего объяснить его с помощью аналогии с дорожной системой. Существует определённый набор городов, некоторые из которых связаны дорогами, которые могут быть как односторонними, так и двухсторонними. Вся эта структура и называется графом.
Ну а более формально, граф – комбинация набора вершин и набора рёбер. Вершины – это города, а рёбра – дороги. Визуально граф можно представить так:



Этот граф состоит из 6 вершин, пронумерованных начиная с единицы, и 7 двухсторонних рёбер. Рёбра обычно записывают в виде пар вершин, которые они соединяют: 1-2, 1-5, 2-3, 2-5, 3-4, 4-5, 4-6.

Ориентированные и неориентированные графы
Мы уже упоминали, что "дороги" в графе могут быть как односторонними, так и двухсторонними. Для этого свойства существует отдельный термин: односторонние "дороги" называются ориентированными рёбрами (или дугами), а двухсторонние – неориентированными.
Граф, в котором все рёбра неориентированные, также называют неориентированным, а граф с ориентированными рёбрами, соответственно, ориентированным.



Слева изображён неориентированный граф, а справа – ориентированный. Как несложно догадаться, левый граф можно обходить как по часовой стрелке, так и против, а правый можно полностью обойти только по часовой, хотя одно из ребёр в нём также неориентированное (считается, что это два противоположных ориентированных ребра).

Пути и циклы
Путём в графе называется последовательность вершин, каждая из которых соединена со следующей ребром. Чаще всего под "путём" подразумевают простой путь, все вершины которого различны. Путь, который проходит через какую-либо вершину более одного раза называют сложным путём.
Если первая вершина пути совпадает с последней, то такой путь называют циклом.
Приведём примеры на этом графе:



Из множества возможных простых путей самый длинный: a−f−c−d−e−b−h(существуют и другие пути с такой же длиной).
Циклом является путь b−c−d−e−b(выделен цветом). Можно начать и с любой другой вершины, например, c−d−e−b−c.

Кратные рёбра и петли
Существует множество разновидностей графов, и среди них встречаются довольно специфические. В частности, так называемые мультиграфы разрешают наличие между двумя вершинами нескольких рёбер (называемых кратными рёбрами), а также наличие петель. Петля – ребро, входящее в ту же вершину, из которой исходит. Выглядят они следующим образом:



Красным выделены кратные рёбра, а синим – петли.
Мультиграфы встречаются в задачах реже чем обычные графы (называемые простыми), но всё же встречаются, поэтому стоит иметь о них элементарное представление.

Связные графы
Граф называется связным, если между любой парой вершин существует хотя бы один путь. Как пример рассмотрим следующий граф:



Одно из рёбер проведено штрихами. Если это ребро присутствует, то граф является связным. Если же его убрать, то связность теряется, граф разбивается на две части, друг с другом не связанные. Такие части называются компонентами связности.

Определение дерева
Дерево – вид графа, который можно назвать самым простым, но они обладают множеством особых свойств и встречаются в задачах чуть ли не чаще остальных графов.
Дерево – это связный граф без циклов, петель и кратных рёбер.
Все изображённые графы являются деревьями:



Среди множества свойств деревьев можно выделить два самых известных:
    • Количество рёбер связано с количеством вершин формулой E=V−1.
    • Между любой парой вершин существует ровно один путь.

            2.1.7. Способы представления графов
Существует два основных способа представления графов в программировании. Один из них, список смежности и матрица смежности, используется гораздо реже, но очень просто реализуется.

    3. Матрица смежности
Граф из N вершин задаётся матрицей (двумерным массивом) N*N, в которой g[i][j] – логическое значение, true или false, обозначающее, существует ли ребро из вершины i в вершину j.
В качестве примера решим простую задачу: для каждой вершины графа выведем количество рёбер, смежных с ней.

#include <iostream>
using namespace std;

bool graph[1000][1000];

int main() {
   int n, m; //количество вершин и рёбер соответственно
setlocale(LC_ALL, "Rus");
   //cin >> n >> m;
cout << "количество вершин n= ";
   cin >> n;
cout << "количество  рёбер m= ";
   cin >> m;
cout << "\n";

   for (int i = 0; i < m; i++) {
       int u, v;   //номера вершин, соединённых очередным ребром
 cout << "номера вершин, соединённых очередным ребром (u v) ";
       cin >> u >> v;

       u--, v--;   //Здесь стоит остановиться и вдуматься.
                   //Чаще всего в задачах вершины будут нумероваться с 1 до N,
                   //в отличие от индексации массивов в C++.

                   //У этой проблемы есть два решения.
                   //Первое: работать с номерами "как есть": создавать массивы размером N + 1,
                   //использовать циклы от 1 до N, и т.д.
                   //Второе: уменьшать номера вершин на единицу при вводе, и увеличивать обратно при выводе

                   //Какое из них использовать - ваш личный выбор.
                   //Для меня 1-индексация в С++ выглядит очень чужеродно, поэтому я использую второе решение.

       graph[u][v] = graph[v][u] = true;   //Если бы граф был ориентированным, то обратное ребро мы бы не создавали.
   }

  cout << "\n";
  for (int i = 0; i < n; i++) {
       int c = 0;
       for (int j = 0; j < n; j++) {
           if (graph[i][j]) {
               c++;
           }
       }
       cout << c << " edges adjacent to vertex " << i + 1 << endl;
   }
system("PAUSE");
}



Преимущества матрицы смежности:
    • Сложность проверки наличия ребра между двумя вершинами: O(1)

Недостатки матрицы смежности:
    • Занимает N2N2 памяти, что неприемлемо для достаточно больших графов.
    • Сложность перебора всех вершин, смежных с данной: O(N)

    4. Список смежности
Гораздо чаще для представления графов используется список смежности. Его идея заключается в хранении для каждой вершины расширяемого массива (вектора), содержащего всех её соседей.
Решим ту же задачу с использованием списка смежности (и С++11 для for-each):

https://brestprog.neocities.org/lections/graphs.html

//#include <iostream>
//#include <cliext/vector>
////#include <bits/stdc++.h>
//using namespace std;

#include <iostream>
#include <vector>
#include <algorithm>
#include <utility>
using namespace std;

vector<int> graph[100000];    //массив из 100000 векторов.

int main()
{
int n, m;       //количество вершин и рёбер соответственно
setlocale(LC_ALL, "Rus");
//cin >> n >> m;
cout << "количество вершин n= ";
cin >> n;
cout << "количество  рёбер m= ";
cin >> m;
cout << "\n";

for (int i = 0; i < m; i++) {
 int u, v;
 cout << "номера вершин, соединённых ребром (u v) ";
 cin >> u >> v;
 u--, v--;

 graph[u].push_back(v);
 graph[v].push_back(u);
}

for (int i = 0; i < n; i++) {
 int c = 0;
 for (int v : graph[i]) {     //можно было бы просто записать "int c = graph[i].size();",
  c++;                    //но такая реализация показывает, как можно перебирать
 }                           //соседние вершины.

 cout << c << " edges adjacent to vertex " << i + 1 << endl;
}
system("PAUSE");
}



Если требуется также удалять рёбра, то вместо вектора нужно использовать std::set.
Преимущества списка смежности:
    • Использует O(M) памяти, что оптимально.
    • Позволяет быстро перебирать соседей вершины.
    • Позволяет за O(logN) проверять наличие ребра и удалять его (при использовании std::set).

Недостатки списка смежности:
    • При работе с насыщенными графами (количество рёбер близко к N2) скорости O(logN) может не хватать (единственный повод использовать матрицу смежности).
    • Для взвешенных графов приходится хранить vector<pair<int, int>>, что усложняет код.

Теория графов находит применения в самых разных областях. Несколько примеров:
    • Логистика и транспортные системы. Вершинами будут склады с товарами или пункты назначения, а ребра – дороги, их соединяющие.
    • Маршрутизация сетей. Вершины – компьютеры, соединенные в сеть, ребра – связи между ними. Решается задача о путях передачи данных с одного компьютера на другой.
    • Компьютерная химия. Модели в виде графов используются для описания путей протекания сложных реакций. Вершины – участвующие в реакциях вещества, ребра – пути превращений веществ. Также графом является изображение структур молекул: вершины – атомы, ребра – химические связи.
    • Электрические сети.
    • Сайты в Интернете можно считать узлами ориентированного графа, ребрами которого будут гиперссылки.
    • И т. д.

Современная теория графов представляет собой мощную формальную систему, имеющую необозримое множество применений.
Путем или цепью в графе называется последовательность вершин, в которой каждая вершина соединена ребром со следующей. Пути, в которых начальная и конечная вершина совпадают, называют циклами. Если для каждой пары вершин существует путь их соединяющих, то такой граф называют связным.
В программировании используются три способа хранения в памяти информации о структуре графов.

1) Матрицы смежности
Квадратная матрица M, где как строки, так и столбцы соответствуют вершинам графа. Если вершины с номерами i и j соединены ребром, то Mij = 1, иначе Mij = 0. Для неориентированного графа матрица, очевидно, симметрична. Ориентированный граф задается антисимметричной матрицей. Если ребро выходит из узла i и приходит в узел j, то Mij = 1, а симметричный элемент Mji = -1.

2) Матрица инцидентности
Столбцы матрицы соответствуют вершинам, а строки ребрам. Если ребро с номером i соединяет вершины с номерами j и k, то элементы матрицы Iij = Iik = 1. Остальные элементы i-й строки равны 0.

3) Список ребер
Просто набор пар номеров вершин, соединенных ребрами.

Рассмотренные выше деревья являются частным случаем графов. Деревом будет любой связный граф, не содержащий циклов.
Задачи, возникающие в теории графов многочисленны и разнообразны. Про них пишутся толстые книги, и нет никакой возможности сколько-нибудь полно их здесь обозреть. Поэтому мы ограничимся замечанием, что многие из этих задач требуют систематического перебора вершин. Если перебирать вершины, связанные ребрами и при этом посещать каждую вершину только один раз, то множество посещаемых алгоритмом вершин будет образовывать дерево, а сам алгоритм естественно сделать рекурсивным.
Например, классической задачей является поиск пути из одной вершины в другую. Алгоритм поиска должен будет построить дерево возможных путей из начальной вершины, концевыми узлами которого будут вершины, из которых нельзя попасть ни в какую вершину, не принадлежащую ранее построенной ветви (не помеченную как уже посещенную). Задача будет решена, когда один из концевых узлов совпадет с конечной вершиной, путь в которую требуется найти.

            4.1.1. Использование графа с использованием STL для конкурентного программирования
https://www.geeksforgeeks.org/graph-implementation-using-stl-for-competitive-programming-set-1-dfs-of-unweighted-and-undirected/
Мы ввели основы графа и его представления. Здесь используется другое представление на основе STL, которое может быть полезно для быстрого внедрения графика с использованием векторов. Реализация предназначена для отображения списка смежности.

Замечание
Стандартная библиотека шаблонов (Standard Template Library, STL)

Ниже приведен пример неориентированного и невзвешенного графа с 5 вершинами.



Ниже представлен список граф смежности.



Используется вектор в STL для реализации графа с использованием представления списка смежности.
Vector: контейнер последовательности. Здесь мы используем его для хранения списков смежности всех вершин. Мы используем число вершин в качестве индекса в этом векторе.
Идея состоит в том, чтобы представлять граф как массив векторов, так что каждый вектор представляет собой список смежности вершины. Ниже приведена полная версия программы на C ++ для DFS Traversal.

// A simple representation of graph using STL,
// for the purpose of competitive programming
//#include<bits/stdc++.h>
//using namespace std;

#include <iostream>
#include <vector>
#include <algorithm>
#include <utility>
using namespace std;

// A utility function to add an edge in an
// undirected graph.
void addEdge(vector<int> adj[], int u, int v)
{
adj[u].push_back(v);
adj[v].push_back(u);
}

// A utility function to do DFS of graph
// recursively from a given vertex u.
void DFSUtil(int u, vector<int> adj[],
vector<bool> &visited)
{
visited[u] = true;
cout << u << " ";
for (int i = 0; i<adj[u].size(); i++)
 if (visited[adj[u][i]] == false)
  DFSUtil(adj[u][i], adj, visited);
}

// This function does DFSUtil() for all
// unvisited vertices.
void DFS(vector<int> adj[], int V)
{
vector<bool> visited(V, false);
for (int u = 0; u<V; u++)
 if (visited[u] == false)
  DFSUtil(u, adj, visited);
}

// Driver code
int main()
{
int const V = 5;
vector<int> adj[V];
addEdge(adj, 0, 1);
addEdge(adj, 0, 4);
addEdge(adj, 1, 2);
addEdge(adj, 1, 3);
addEdge(adj, 1, 4);
addEdge(adj, 2, 3);
addEdge(adj, 3, 4);
DFS(adj, V);
cout << endl;
system("PAUSE");
return 0;
}



https://www.geeksforgeeks.org/graph-implementation-using-stl-for-competitive-programming-set-2-weighted-graph/
Здесь обсуждается взвешенное графическое представление с использованием STL. Реализация предназначена для представления списка смежности взвешенного графика.



Мы используем два контейнера STL для представления графика:

    • vector: контейнер последовательности. Здесь мы используем его для хранения списков смежности всех вершин. Мы используем число вершин в качестве индекса в этом векторе.
    • pair: простой контейнер для хранения пары элементов. Здесь мы используем его для хранения соседнего числа вершин и веса края, соединяющегося с соседним.
Идея состоит в том, чтобы использовать вектор парных векторов. Ниже код реализует то же самое.

// C++ program to represent undirected and weighted graph
// using STL. The program basically prints adjacency list
// representation of graph
#include <iostream>
#include <vector>
#include <algorithm>
#include <utility>
using namespace std;

// To add an edge
void addEdge(vector <pair<int, int> > adj[], int u,
int v, int wt)
{
adj[u].push_back(make_pair(v, wt));
adj[v].push_back(make_pair(u, wt));
}

// Print adjacency list representaion ot graph
void printGraph(vector<pair<int, int> > adj[], int V)
{
int v, w;
for (int u = 0; u < V; u++)
{
 cout << "Node " << u << " makes an edge with \n";
 for (auto it = adj[u].begin(); it != adj[u].end(); it++)
 {
  v = it->first;
  w = it->second;
  cout << "\tNode " << v << " with edge weight ="
   << w << "\n";
 }
 cout << "\n";
}
}

// Driver code
int main()
{
int const V = 5;
vector<pair<int, int> > adj[V];
addEdge(adj, 0, 1, 10);
addEdge(adj, 0, 4, 20);
addEdge(adj, 1, 2, 30);
addEdge(adj, 1, 3, 40);
addEdge(adj, 1, 4, 50);
addEdge(adj, 2, 3, 60);
addEdge(adj, 3, 4, 70);
printGraph(adj, V);
cout << endl;
system("PAUSE");
return 0;
}



        1.7. Фракталы
Фракталами называют геометрические фигуры, обладающие свойством самоподобия, то есть состоящие из частей, подобных всей фигуре.
Классическим примером является кривая Коха, построение которой показано на рис. 12. Изначально берется отрезок прямой (рис. 12а). Он делится на три части, средняя часть изымается и вместо нее строится угол (рис. 12б), стороны которого равны длине изъятого отрезка (то есть 1/3 от длины исходного отрезка). Такая операция повторяется с каждым из получившихся 4-х отрезков (рис. 12в). И так далее (рис. 12г). Кривая Коха получается после бесконечного числа таких итераций. На практике построение можно прекратить, когда размер деталей окажется меньше разрешения экрана (рис. 12д).



Рис. 12. Процесс построения кривой Коха.

Фракталы, по сути, рекурсивные структуры и их построение естественно производить с помощью рекурсивных процедур.

        1.8. Деревья
Теоретической базой для рекурсивных функций, вызывающих себя более одного раза, служит раздел дискретной математики, изучающий деревья.

            4.1.2. Основные определения. Способы изображения деревьев
Определение: Деревом будем называть конечное множество T, состоящее из одного или более узлов, таких что:

    • Имеется один специальный узел, называемый корнем данного дерева.
    • Остальные узлы (исключая корень) содержатся в  попарно непересекающихся подмножествах , каждое из которых в свою очередь является деревом. Деревья называются поддеревьями данного дерева.

Это определение является рекурсивным. Если коротко, то дерево это множество, состоящее из корня и присоединенных к нему поддеревьев, которые тоже являются деревьями. Дерево определяется через само себя. Однако данное определение осмысленно, так как рекурсия конечна. Каждое поддерево содержит меньше узлов, чем содержащее его дерево. В конце концов, мы приходим к поддеревьям, содержащим всего один узел, а это уже понятно, что такое.



Рис. 3. Дерево.

На рис. 3 показано дерево с семью узлами. Хотя обычные деревья растут снизу вверх, рисовать их принято наоборот. При рисовании схемы от руки такой способ, очевидно, удобнее. Из-за данной несогласованности иногда возникает путаница, когда говорят о том, что один из узлов находится над или под другим. По этой причине удобнее пользоваться терминологией, употребляемой при описании генеалогических деревьев, называя более близкие к корню узлы предками, а более далекие потомками.
Узлы, не содержащие поддеревьев, называются концевыми узлами или листьями. Множество не пересекающихся деревьев называется лесом. Например, лес образуют поддеревья, исходящие из одного узла.
Графически дерево можно изобразить и некоторыми другими способами. Некоторые из них представлены на рис. 4. Согласно определению дерево представляет собой систему вложенных множеств, где эти множества или не пересекаются или полностью содержатся одно в другом. Такие множества можно изобразить как области на плоскости (рис. 4а). На рис. 4б вложенные множества располагаются не на плоскости, а вытянуты в одну линию. Рис. 4б также можно рассматривать как схему некоторой алгебраической формулы, содержащей вложенные скобки. Рис. 4в дает еще один популярный способ изображения древовидной структуры в виде уступчатого списка.



Рис. 4. Другие способы изображения древовидных структур: (а) вложенные множества; (б) вложенные скобки; (в) уступчатый список.

Уступчатый список имеет очевидное сходство со способом форматирования программного кода. Действительно, программа, написанная в рамках парадигмы структурного программирования, может быть представлена как дерево, состоящее из вложенных друг в друга конструкций.
Также можно провести аналогию между уступчатым списком и внешним видом оглавлений в книгах, где разделы содержат подразделы, те в свою очередь поподразделы и т.д. Традиционный способ нумерации таких разделов (раздел 1, подразделы 1.1 и 1.2, подподраздел 1.1.2 и т.п.) называется десятичной системой Дьюи. В применении к дереву на рис. 3 и 4 эта система даст:

1. A;
1.1 B;
1.2 C;
1.2.1 D;
1.2.2 E;
1.2.3 F;
1.2.3.1 G;

            4.1.3. Прохождение деревьев
Во всех алгоритмах, связанных с древовидными структурами неизменно встречается одна и та же идея, а именно идея прохождения или обхода дерева. Это – такой способ посещения узлов дерева, при котором каждый узел проходится точно один раз. При этом получается линейная расстановка узлов дерева. В частности существует три способа: можно проходить узлы в прямом, обратном и концевом порядке.

    5. Алгоритм обхода в прямом порядке
Алгоритм обхода в прямом порядке сводится к:
    • Попасть в корень,
    • Пройти все поддеревья слева направо в прямом порядке.

Данный алгоритм рекурсивен, так как прохождение дерева содержит прохождение поддеревьев, а они в свою очередь проходятся по тому же алгоритму.
В частности для дерева на рис. 3 и 4 прямой обход дает последовательность узлов: A, B, C, D, E, F, G.
Получающаяся последовательность соответствует последовательному слева направо перечислению узлов при представлении дерева с помощью вложенных скобок и в десятичной системе Дьюи, а также проходу сверху вниз при представлении в виде уступчатого списка.
При реализации этого алгоритма на языке программирования попадание в корень соответствует выполнение процедурой или функцией некоторых действий, а прохождение поддеревьев – рекурсивным вызовам самой себя. В частности для бинарного дерева (где из каждого узла исходит не более двух поддеревьев) соответствующая процедура будет выглядеть так:

// Preorder Traversal – английское название для прямого порядка
void PreorderTraversal({Аргументы})
{
//Прохождение корня
DoSomething({Аргументы});

//Прохождение левого поддерева
if {Существует левое поддерево}
 PreorderTransversal({Аргументы 2});

//Прохождение правого поддерева
if {Существует правое поддерево}
 PreorderTransversal({Аргументы 3});
}

То есть сначала процедура производит все действия, а только затем происходят все рекурсивные вызовы.

    6. Алгоритм обхода в обратном порядке
Алгоритм обхода в обратном порядке сводится к:
    • Пройти левое поддерево,
    • Попасть в корень,
    • Пройти следующее за левым поддерево.
    • Попасть в корень,
    • и т.д пока не будет пройдено крайнее правое поддерево.

То есть проходятся все поддеревья слева на право, а возвращение в корень располагается между этими прохождениями. Для дерева на рис. 3 и 4 это дает последовательность узлов: B, A, D, C, E, G, F.
В соответствующей рекурсивной процедуре действия будут располагаться в промежутках между рекурсивными вызовами. В частности для бинарного дерева:

// Inorder Traversal – английское название для обратного порядка
void InorderTraversal({Аргументы})
{
//Прохождение левого поддерева
if {Существует левое поддерево}
 InorderTraversal({Аргументы 2});

//Прохождение корня
DoSomething({Аргументы});

//Прохождение правого поддерева
if {Существует правое поддерево}
 InorderTraversal({Аргументы 3});
}

    7. Алгоритм обхода в концевом порядке
Алгоритм обхода в концевом порядке сводится к:
    • Пройти все поддеревья слева на право,
    • Попасть в корень.

Для дерева на рис. 3 и 4 это даст последовательность узлов: B, D, E, G, F, C, A.
В соответствующей рекурсивной процедуре действия будут располагаться после рекурсивных вызовов. В частности для бинарного дерева:

// Postorder Traversal – английское название для концевого порядка
void PostorderTraversal({Аргументы})
{
//Прохождение левого поддерева
if {Существует левое поддерево}
 PostorderTraversal({Аргументы 2});

//Прохождение правого поддерева
if {Существует правое поддерево}
 PostorderTraversal({Аргументы 3});

//Прохождение корня
DoSomething({Аргументы});
}

            7.1.1. Представление дерева в памяти компьютера
Если некоторая информация располагается в узлах дерева, то для ее хранения можно использовать соответствующую динамическую структуру данных. На Паскале это делается с помощью переменной типа запись (record), содержащей указатели на поддеревья того же типа. Например, бинарное дерево, где в каждом узле содержится целое число можно сохранить с помощью переменной типа PTree, который описан ниже:

type
PTree = ^TTree;
TTree = record
 Inf: integer;
 LeftSubTree, RightSubTree: PTree;
end;

В языке С++

struct TTree
{
int Inf;
struct TTree *LeftSubTree, *RightSubTree;
} PTree;


Каждый узел имеет тип PTree. Это указатель, то есть каждый узел необходимо создавать, вызывая для него процедуру New. Если узел является концевым, то его полям LeftSubTree и RightSubTree присваивается значение null(nil). В противном случае узлы LeftSubTree и RightSubTree также создаются процедурой New.
Схематично одна такая запись изображена на рис. 5.



Рис. 5. Схематичное изображение записи типа TTree. Запись имеет три поля: Inf – некоторое число, LeftSubTree и RightSubTree – указатели на записи того же типа TTree.

Пример дерева, составленного из таких записей, показан на рисунке 6.



Рис. 6. Дерево, составленное из записей типа TTree. Каждая запись хранит число и два указателя, которые могут содержать либо nil, либо адреса других записей того же типа.

Если вы ранее не работали со структурами состоящими из записей, содержащих ссылки на записи того же типа, то рекомендуем ознакомиться с материалом о рекурсивных структурах данных.

    8. Рекурсивные структуры данных
Пусть описан тип-запись, и одним из полей этой записи является указатель. В этот указатель можно записать адрес, по которому данная запись располагается, либо, что более интересно адрес другой записи того же типа. Это позволяет при помощи указателей создать структуру данных, называемую связанным списком.
Пример описания такой структуры данных для языка Pascal:

type
 PListElement = ^TListElement;
 TListElement = record
   <Произвольные поля записи>
   NextElement: PListElement;
end;

Пример описания такой структуры данных для языка C++:

struct TListElement
{
struct TListElement ^TListElement;
//<Произвольные поля записи>
struct TListElement *NextElement;
} PListElement;

Здесь сначала описывается тип – указатель PListElement на запись типа TListElement. Затем идет описание самого типа записи, одно из полей которой имеет тип PListElement. Получается, что мы используем идентификатор TListElement еще до того, как его описали. Обычно такие вещи запрещено делать, но в данном случае, когда описывается ссылочный тип, из этого правила сделано исключение.
Если имеется запись этого типа, то можно с помощью указателя динамически создать еще один элемент этого типа. По указателю в этом новом элементе еще один элемент и т.д., сколько потребуется. Такая структура данных называется однонаправленным связанным списком. Ее схематическое изображение показано на рис. 1.



Рис. 1. Связанный список.

                    8.1.1.1.1. Пример 1. Простой пример связанного списка

// Программа на С++ - простой пример связанного списка
#include <stdio.h>
#include <strstream>
#include <iostream>
using namespace std;
struct sSS
{
int x;
struct sSS *nextSS;
} varSS, *firstSS, *currentSS;

void SSlocation(struct sSS *ptr1);
void output_data(struct sSS *ptr2);
int data_in(struct sSS *ptr3);

int main(void)
{
firstSS = (struct sSS *) new (struct sSS);
if(firstSS == NULL) exit(1);
if(data_in(&varSS) != 0) exit(1);
*firstSS = varSS;
currentSS = firstSS;
while(data_in(&varSS) == 0)
{
 currentSS -> nextSS = (struct sSS *) new (struct sSS);
 if(currentSS -> nextSS == NULL) return(1);
 currentSS = currentSS -> nextSS;
 *currentSS = varSS;
}
currentSS -> nextSS = NULL; // указывает на конец списка
SSlocation(firstSS);
cout << "\n";
system("PAUSE");
return(0);
}

void SSlocation(struct sSS *node)
{
do{
 output_data(node);
} while ((node = node -> nextSS) != NULL);
}

void output_data(struct sSS *ptrSS)
{
cout << "\n";
cout << "x: " << ptrSS -> x ;
}

int data_in(struct sSS *ptrSS)
{
cout << "Enter new information for x (\"-1\" quits) >>> ";
cin >> ptrSS -> x;
if(ptrSS -> x == -1) return (1);
return(0);
}



                    8.1.1.1.2. Пример 2. Связанный список (динамический список)

//Связанный список (динамический список)
#include <iostream>
using namespace std;

//стуктура, описывающая узел связанного списка
struct Node
{
   int data;
   Node *next;
};

//класс, описывающих объект "связанный список"
class List
{
private:
   Node *head; //"голова" связанного списка

public:
   List() //конструктор класса без параметров
   {
       head = NULL; //первого элемента пока нет
   }

   //метод, добавляющий новый узел в список
   void addNode(int d)
   {
       Node *nd = new Node; //динамически создаем новый узел

       nd->data = d;        //задаем узлу данные
       nd->next = NULL;     //новый узел в конце, поэтому NULL

       if(head == NULL)     //если создаем первый узел
           head = nd;
       else                 //если узел уже не первый
       {
           Node *current = head;

           //ищем в цикле предшествующий последнему узел
           while(current->next != NULL)
               current = current->next;

           //предшествующий указывает на последний
           current->next = nd;
       }
   }

   //метод, выводящий связанный список на экран
   void printList()
   {
       Node *current = head;

       while(current != NULL)
       {
           cout << current->data << endl;
           current = current->next;
       }
   }
};

int main()
{
   List myList;

   myList.addNode(5);
   myList.addNode(11);
   myList.addNode(27);
   myList.addNode(35);
   myList.addNode(50);

   myList.printList();
system("PAUSE");
return 0;
}



                    8.1.1.1.3. Пример 3. Односвязный однонаправленный список
Под односвязным однонаправленным списком подразумевается реализация последовательного расположения набора элементов. Начиная с некоторого узла, мы считаем его первым, в этом узле есть ссылки на следующий, и так далее. В большинстве случаев первый узел делают пустым, потому что тогда со списком легче работать. В односвязном списке каждый узел имеет ссылки только на следующий элемент, то есть мы не можем двигаться с конца списка до его начала. Однонаправленный список заканчивается пустым ссылкой NULL.
Давайте подумаем, какие функции могут нам понадобиться для работы со списком. Наверное, это - организация самого списка, вывод списка, сортировка списка, вставка нового элемента в отсортированный список. Так что сначала надо организовать сам узел, из совокупности которых будет формироваться список.

struct List
{
  int item; //полезная информация узла списка
  List *next;//ссылка на следующий элемент списка.
};

Теперь нам нужно создать переменную start типа List, которая будет указывать на первый элемент списка.

   List *start = new List; //выделяем память для первого элемента
   start->next = NULL;// на данный момент первый элемент одновременно является и последним том next ссылается на NULL

Так же как мы выделяли память для первого элемента, так же нужно будет делать и для всех последующих.
Теперь рассмотрим часть кода, которая будет формировать список.

   List *pList = start;
   for (int i=0; i<20; i+=2){
       List *tmp = new List;//Выделяем память для
       tmp->item = i;// здесь все понятно
       tmp->next = NULL;//мы вставляем узел в конец списка и поэтому next = NULL
       pList->next = tmp;//теперь pList-> next указывает на созданный узел
       pList = pList->next;//Передвигаем указатель на последний элемент.
   }

здесь мы используем рабочий указатель для того, чтобы не менять start, который всегда указывать на первый узел списка.
Давайте выведем в консоль созданный список. Для этого напишем отдельную функцию:

void show (List *start)//параметр - указатель на начало списка.
{
   List *pList; //рабочий указатель
   pList = start->next;//в начале он ссылается на второй узел списка.
   while (pList != NULL){
       cout << pList->item << endl;//Выводим данные
       pList = pList->next;//передвигаем указатель на один узел.
   }
}

Теперь напишем функцию, которая будет вставлять элемент в отсортированный список.

void insert (List *start, int Node)//указатель на начало списка, число которое нужно вставить в список.
{
   List *pList;//рабочий указатель.
   pList = start->next;//в начале он ссылается на второй узел списка.
   while (pList->next != NULL){
       if (pList == start->next && pList->item >Node){ //ета проверка нужна для того, чтоб проверить не надо ли вставить елемент в начало списка.
           List *temp = new List; //временная переменная, в которую буедм записывать узел, на который ссылается pList
           *temp = *pList;//запоминаем *pList в *tmp. Здесь мы запоминаем не адрес, а именно значение
           pList->item = Node;//теперь в item записываем елемент который нужно было вставить в список.
           pList->next = temp;//и в next записываем адрес tmp
           break;
       }
       if (pList->item <= Node && pList->next->item >= Node){ //Если элемент надо всативить не на начало и не в конец списка.
           List *tmp = new List;//Выделяем память для нового узла
           tmp->item = Node;
           tmp->next = pList->next;
           pList->next = tmp; //Вставляем узел после узла, на который указывает pList
           break;
       }
       pList = pList->next; //передвигаем указатель на следующий елемент.
       if (pList->next == NULL && Node>=pList->item){ //Проверяем не нужно вставить узел в конец списка.
           List *tmp = new List;
           tmp->item = Node;
           tmp->next = NULL; //Так как вставляем узел в конец списка то его элемент next должен ссылаться на NULL
           pList->next = tmp;//вставляем узел в список.
           break;
       }
   }
}

Теперь напишем функцию, которая будет сортировать список. Будем использовать один из простейших алгоритмов сортировки - сортировка пузырьком.

void sort(List *start) //параметр - указатель на начало списка.
{
   List *pList; // указатель для внешнего цыкла for
   List *ppList; // для внутреннего
   for (pList = start->next; pList != NULL; pList = pList->next) //пробегаемся по всех узлах списка
       for (ppList = start->next; ppList->next != NULL; ppList = ppList->next) //а здесь только до узла, next которого указывает на NULL
           //обычный обмен значениями
           if (ppList->item > ppList->next->item){
               int tmp;
               tmp = ppList->item; //
               ppList->item = ppList->next->item;
               ppList->next->item = tmp;
           }
}

И последняя функция - удаление элемента из списка:

void dell(List *start, int Node) //указатель на начало списка, и значение которое мы будем искать в списке, если найдем значит нужно удалить.
{
   List *pList = start->next; //рабочий указатель, который будем использовать для пробека по списку.
   List *prev = start; //указатель, который всегда будет указывать на елемент предедущий до pList.
   while (pList != NULL){ //пробегаемся по всему списку
       //проверка - нужно ли удаление
       if (pList->item == Node){
           // временней узел, в который будем записывать значение того узла который нужно удалить.
           List *tmp = new List;
           *tmp = *pList;
           //теперь нужно сделать так, чтоб елемент next предыдущего узла указывал на узел, который идет после pList,то есть на pList->next
           prev->next = pList->next;
           delete tmp;
       }
       prev = pList; // перемещаем указатель prev на один елемент
       pList = pList->next; //так же перемещаем next.
   }
}

Вот как это примерно выглядит:

#include <iostream>
using namespace std;

struct List
{
  int item; //полезная информация узла списка
  List *next;//ссылка на следующий элемент списка.
};

void create_List(List *start)
{
   //так как *start - указатель на начало списка, нам нужен рабочий указатель с помощью которого мы будем работать с целым списком.
   List *pList = start->next; //так как первый элемент будет пустым, присваиваем рабочем указателе ссылка на следующий элемент, который нужно заполнить.
   //теперь нужно создать наш список. Заполним его елементы числами.
   for (int i=0; i<20; i+=2){
       List *tmp = new List; //Выделяем память, для следующего узла.
       tmp->item = i; //заполняем елемент узла, который хранить полезные данные
       tmp->next = NULL; //Мы вставляем элементы в конец списка. Это означает, что каждый элемент который мы добавляем имеет ссылаться на NULL
       pList->next = tmp; //Добавляем созданный узел в список.
       pList = pList->next; //Сдвигаем указатель на один елемент. Теперь он указывает на последний елемент который мы добавили.
   }
}

void show (List *start)//параметр - указатель на начало списка.
{
   List *pList; //рабочий указатель
   pList = start->next;//в начале он ссылается на второй узел списка.
   while (pList != NULL){
       cout << pList->item << endl;//Выводим данные
       pList = pList->next;//передвигаем указатель на один узел.
   }
}

void insert (List *start, int Node)//указатель на начало списка, число которое нужно вставить в список.
{
   List *pList;//рабочий указатель.
   pList = start->next;//в начале он ссылается на второй узел списка.
   while (pList->next != NULL){
       if (pList == start->next && pList->item >Node){ //ета проверка нужна для того, чтоб проверить не надо ли вставить елемент в начало списка.
           List *temp = new List; //временная переменная, в которую буедм записывать узел, на который ссылается pList
           *temp = *pList;//запоминаем *pList в *tmp. Здесь мы запоминаем не адрес, а именно значение
           pList->item = Node;//теперь в item записываем елемент который нужно было вставить в список.
           pList->next = temp;//и в next записываем адрес tmp
           break;
       }
       if (pList->item <= Node && pList->next->item >= Node){ //Если элемент надо всативить не на начало и не в конец списка.
           List *tmp = new List;//Выделяем память для нового узла
           tmp->item = Node;
           tmp->next = pList->next;
           pList->next = tmp; //Вставляем узел после узла, на который указывает pList
           break;
       }
       pList = pList->next; //передвигаем указатель на следующий елемент.
       if (pList->next == NULL && Node>=pList->item){ //Проверяем не нужно вставить узел в конец списка.
           List *tmp = new List;
           tmp->item = Node;
           tmp->next = NULL; //Так как вставляем узел в конец списка то его элемент next должен ссылаться на NULL
           pList->next = tmp;//вставляем узел в список.
           break;
       }
   }
}

void sort(List *start) //параметр - указатель на начало списка.
{
   List *pList; // указатель для внешнего цыкла for
   List *ppList; // для внутреннего
   for (pList = start->next; pList != NULL; pList = pList->next) //пробегаемся по всех узлах списка
       for (ppList = start->next; ppList->next != NULL; ppList = ppList->next) //а здесь только до узла, next которого указывает на NULL
           //обычный обмен значениями
           if (ppList->item > ppList->next->item){
               int tmp;
               tmp = ppList->item; //
               ppList->item = ppList->next->item;
               ppList->next->item = tmp;
           }
}

void dell(List *start, int Node) //указатель на начало списка, и значение которое мы будем искать в списке, если найдем значит нужно удалить.
{
   List *pList = start->next; //рабочий указатель, который будем использовать для пробека по списку.
   List *prev = start; //указатель, который всегда будет указывать на елемент предедущий до pList.
   while (pList != NULL){ //пробегаемся по всему списку
       //проверка - нужно ли удаление
       if (pList->item == Node){
           // временней узел, в который будем записывать значение того узла который нужно удалить.
           List *tmp = new List;
           *tmp = *pList;
           //теперь нужно сделать так, чтоб елемент next предыдущего узла указывал на узел, который идет после pList,то есть на pList->next
           prev->next = pList->next;
           delete tmp;
       }
       prev = pList; // перемещаем указатель prev на один елемент
       pList = pList->next; //так же перемещаем next.
   }
}

int main()
{
   List *start = new List; //выделяем память для первого элемента
   start->next = NULL;// на данный момент первый элемент одновременно является и последним том next ссылается на NULL
   List *pList = start;
   for (int i=0; i<20; i+=2){
       List *tmp = new List;//Выделяем память для
       tmp->item = i;// здесь все понятно
       tmp->next = NULL;//мы вставляем узел в конец списка и поэтому next = NULL
       pList->next = tmp;//теперь pList-> next указывает на созданный узел
       pList = pList->next;//Передвигаем указатель на последний элемент.
   }

   show (start);
   insert(start,2);
   insert(start,5);
   cout << "=========\n";
   show (start);
   dell(start,2);
   dell(start,2);
   dell (start,18);
   cout << "================\n";
   show(start);
system("PAUSE");
   return 0;
}



Преимуществами динамических списков является то, что мы можем достаточно легко вставить элемент или удалить его из списка. В массиве это несколько сложнее. Также преимуществом является то, что размер списка можно изменить в любой момент выполнения программы.
Но в списках есть и недостатки. Одним из важнейших является то, что мы не можем получить доступ к k-му узлу так же как в массиве, в списках мы вынуждены пройтись по всем элементам, которые идут до k. Также узлы в списке не размещаются последовательно в памяти и программа работает немного медленнее, чем при работе с массивом, где все элементы размещены последовательно.

                    8.1.1.1.4. Пример 4. Однонаправленный связанный список
Пусть в виде однонаправленного связанного списка хранятся целые числа. Создать процедуры, которые:
а) Создают список, динамически выделяя из кучи память под заданное число элементов N.
б) Заполняют информационную часть элементов списка числами 10, 20, …, N.
в) Печатают в столбик информационную часть списка.
б) Заменяют информационную часть элементов списка числами 1, 2, …, N.
г) Уничтожают элементы(узлы) списка, возвращая в кучу выделенную под них память.

Решение:

#include <stdio.h>
#include <iostream>
#include <conio.h>
#include <windows.h>
using namespace std;

struct List{
int item; //Информационное поле
List *next; //Ссылка на следующий элемент списка
};

void CreateList(List *start, int Num)
{
//Процедура создает список, содержащий Num элементов
//начинающийся с элемента start
   cout << "===CreateList()===" << endl;//
start->next = NULL; //первый элемент одновременно является и последним
     //поэтому next ссылается на NULL
List *pList = start;
//При работе с однонаправленными списками принципиально
//важно не потерять ссылку на первый элемент. Поэтому
//дальнейшие операции будем проводить не с start, а со
//вспомогательной переменной tmp
for(int n=1; n<=Num; n++){
 List *tmp = new List; //Выделяем память, для следующего узла
 tmp->item = n * 10;  //елемент узла, который хранить полезные данные
 tmp->next = NULL;  //вставляем элементы в конец списка.
       //Это означает, что каждый элемент
       //который мы добавляем имеет ссылаться на NULL
 cout << "Created Object: " << n << " item= " << tmp->item << "\n";
 pList->next = tmp;  //Добавляем созданный узел в список
 pList = pList->next; //Сдвигаем указатель на один елемент.
       //Теперь он указывает на последний элемент, который мы добавили
}
}

void PrintList(List *start)//параметр - указатель на начало списка
{
//Процедура печатает информационную часть элементов списка
   cout << "===PrintList()===" << endl;//
   List *pList; //рабочий указатель
   pList = start->next;//в начале он ссылается на второй узел списка
while(pList != NULL){
       cout << pList->item << endl;//Выводим данные
       pList = pList->next;//передвигаем указатель на один узел
}
}

void FillList(List *start)
{
//Процедура заполняет информационную часть элементов списка
//числами 1, 2, 3, …
   cout << "===FillList()===" << endl;//
   List *pList; //рабочий указатель
   pList = start->next;//в начале он ссылается на второй узел списка
int n = 1;
  while(pList != NULL){
 pList->item = n;
 cout << "Filled Object: " << n << " item = " << pList->item << "\n";
 n = n + 1;
 pList = pList->next;
  }
}

void DeleteNode(List *start, int Node)
{
//Процедура освобождающая память, выделенную под список
List *pList = start->next;//рабочий указатель, который будем использовать для пробега по списку
List *prev = start; //указатель, который всегда будет указывать на елемент предедущий до pList
//Поскольку список все равно уничтожается,
//можем спокойно изменять Head
while(pList != NULL){//пробегаемся по всему списку
 if (pList->item == Node){//проверка - нужно ли удаление
  // временней узел, в который будем записывать значение того узла который нужно удалить
  List *tmp = new List;
  *tmp = *pList;
  //теперь нужно сделать так, чтоб елемент next предыдущего узла указывал на узел,
  //который идет после pList,то есть на pList->next
           prev->next = pList->next;
           delete tmp;
 }
       prev = pList; //перемещаем указатель prev на один елемент
       pList = pList->next; //так же перемещаем next.
}
}

void main()
{
struct List *start = new List;//выделяем память для первого элемента
CreateList(start, 5); //Создаем список из 5-ти элементов
cout << "\n";
PrintList(start); //Печатаем информационные части элементов списка
cout << "\n";
FillList(start); //В информационные части пишем числа 1, 2, 3, 4, 5
cout << "\n";
PrintList(start); //Печатаем информационные части элементов списка
cout << "\n";
DeleteNode(start, 2); //удаление узла
PrintList(start); //Печатаем информационные части элементов списка
system("PAUSE");
}



        1.9. Примеры рекурсивных алгоритмов
            8.1.2. Рисование дерева
Рассмотрим алгоритм рисования деревца, изображенного на рис. 6. Если каждую линию считать узлом, то данное изображение вполне удовлетворяет определению дерева, данному в предыдущем разделе.



Рис. 6. Деревце.

Рекурсивная процедура, очевидно должна рисовать одну линию (ствол до первого разветвления), а затем вызывать сама себя для рисования двух поддеревьев. Поддеревья отличаются от содержащего их дерева координатами начальной точки, углом поворота, длиной ствола и количеством содержащихся в них разветвлений (на одно меньше). Все эти отличия следует сделать параметрами рекурсивной процедуры.
Пример такой процедуры, написанный на Delphi, представлен ниже:

procedure Tree(
 Canvas: TCanvas; //Canvas, на котором будет рисоваться дерево
 x,y: extended; //Координаты корня
 Angle: extended; //Угол, под которым растет дерево
 TrunkLength: extended; //Длина ствола
 n: integer //Количество разветвлений (сколько еще предстоит
            //рекурсивных вызовов)
);
var
 x2, y2: extended; //Конец ствола (точка разветвления)
begin
    x2 := x + TrunkLength * cos(Angle);
    y2 := y - TrunkLength * sin(Angle);
    Canvas.MoveTo(round(x), round(y));
    Canvas.LineTo(round(x2), round(y2));
    if n > 1 then
    begin
      Tree(Canvas, x2, y2, Angle+Pi/4, 0.55*TrunkLength, n-1);
      Tree(Canvas, x2, y2, Angle-Pi/4, 0.55*TrunkLength, n-1);
    end;
end;

Для получения рис. 6 эта процедура была вызвана со следующими параметрами:

Tree(Image1.Canvas, 175, 325, Pi/2, 120, 15);

Заметим, что рисование осуществляется до рекурсивных вызовов, то есть дерево рисуется в прямом порядке.

            8.1.3. Ханойские башни
Согласно легенде в Великом храме города Бенарас, под собором, отмечающим середину мира, находится бронзовый диск, на котором укреплены 3 алмазных стержня, высотой в один локоть и толщиной с пчелу. Давным-давно, в самом начале времен монахи этого монастыря провинились перед богом Брамой. Разгневанный, Брама воздвиг три высоких стержня и на один из них поместил 64 диска из чистого золота, причем так, что каждый меньший диск лежит на большем. Как только все 64 диска будут переложены со стержня, на который Бог Брама сложил их при создании мира, на другой стержень, башня вместе с храмом обратятся в пыль и под громовые раскаты погибнет мир.
В процессе требуется, чтобы больший диск ни разу не оказывался над меньшим. Монахи в затруднении, в какой же последовательности стоит делать перекладывания? Требуется снабдить их софтом для расчета этой последовательности.
Независимо от Брамы данную головоломку в конце 19 века предложил французский математик Эдуард Люка. В продаваемом варианте обычно использовалось 7-8 дисков (рис. 7).



Рис. 7. Головоломка «Ханойские башни».

Предположим, что существует решение для n-1 диска. Тогда для перекладывания n дисков надо действовать следующим образом:
    • Перекладываем n-1 диск.
    • Перекладываем n-й диск на оставшийся свободным штырь.
    • Перекладываем стопку из n-1 диска, полученную в пункте (1) поверх n-го диска.

Поскольку для случая n = 1 алгоритм перекладывания очевиден, то по индукции с помощью выполнения действий (1) – (3) можем переложить произвольное количество дисков.
Создадим рекурсивную процедуру, печатающую всю последовательность перекладываний для заданного количества дисков. Такая процедура при каждом своем вызове должна печатать информацию об одном перекладывании (из пункта 2 алгоритма). Для перекладываний из пунктов (1) и (3) процедура вызовет сама себя с уменьшенным на единицу количеством дисков.

//n – количество дисков
//a, b, c – номера штырьков. Перекладывание производится со штырька a,
//на штырек b при вспомогательном штырьке c.
procedure Hanoi(n, a, b, c: integer);
begin
 if n > 1 then
 begin
   Hanoi(n-1, a, c, b);
   writeln(a, ' -> ', b);
   Hanoi(n-1, c, b, a);
 end else
   writeln(a, ' -> ', b);
 end;

Заметим, что множество рекурсивно вызванных процедур в данном случае образует дерево, проходимое в обратном порядке.

    9. Прмер 1.

// Ханойские башни
#include <iostream>
#include <Windows.h>
using namespace std;

void Towers(int number, int from, int to, int free)
{
//number - это колличество дисков
//from - это стержень с которого переносим все диски.
//to - это стержень на который переносим все диски.
//free - это третий стержень.
   SetConsoleOutputCP(1251);
   if(number!=0){
       Towers(number-1, from, free, to);
 cout << "\n  Снимаем " << number << "-й диск с " << from
  << "-го стержня и одеваем его на " << to << "-й стержень";
 Towers(number-1,  free, to, from);
   }
}
void main()
{
   setlocale(LC_ALL,"rus");
   Towers(3, 1, 3, 2);
   cout<<"\n  ";
system("PAUSE");
}



    10. Прмер 2.

// Ханойские башни
#include <iostream>
using namespace std;

void HanoyTown(int nLevel, char from, char to, char mid)
{
if (nLevel > 0)
{
 HanoyTown(nLevel-1, from, mid, to);
 printf(("%c ==> %c\n"), from, to);
 HanoyTown(nLevel-1, mid, to, from);
}
}

int main()
{
   setlocale(LC_ALL,"rus");
HanoyTown(3, 'A', 'C', 'B');
system("PAUSE");
return 0;
}



    11. Прмер 3.

// Ханойские башни
#include <iostream>
using namespace std;

void hanoi_towers(int quantity, int from, int to, int buf_peg)
//quantity-число колец, from-начальное положение колец(1-3),to-конечное положение колец(1-3)
//buf_peg - промежуточный колышек(1-3)
{
   if (quantity != 0){
 hanoi_towers(quantity-1, from, buf_peg, to);
 cout << from << " -> " << to << endl;
 hanoi_towers(quantity-1, buf_peg, to, from);
   }
}

int main()
{
   setlocale(LC_ALL,"rus");
   int start_peg, destination_peg, buffer_peg, plate_quantity;
   cout << "Номер первого столбика: ";
   cin  >> start_peg;
   cout << "Номер конечного столбика: ";
   cin  >> destination_peg;
   cout << "Номер промежуточного столбика: ";
   cin  >> buffer_peg;
   cout << "Количество дисков: ";
   cin  >> plate_quantity;

   hanoi_towers(plate_quantity, start_peg, destination_peg, buffer_peg);
system("PAUSE");
return 0;
}



Полезно:
https://habrahabr.ru/post/200758/



            11.1.1. Синтаксический анализ арифметических выражений
Задача синтаксического анализа заключается в том, чтобы по имеющейся строке, содержащей арифметическое выражение, и известным значениям, входящих в нее переменных, вычислить значение выражения.
Процесс вычисления арифметических выражений можно представить в виде бинарного дерева. Действительно, каждый из арифметических операторов (+, –, *, /) требует двух операндов, которые также будут являться арифметическими выражениями и, соответственно могут рассматриваться как поддеревья. Рис. 8 показывает пример дерева, соответствующего выражению:





Рис. 8. Синтаксическое дерево, соответствующее арифметическому выражению (6).

В таком дереве концевыми узлами всегда будут переменные (здесь x) или числовые константы, а все внутренние узлы будут содержать арифметические операторы. Чтобы выполнить оператор, надо сначала вычислить его операнды. Таким образом, дерево на рисунке следует обходить в концевом порядке. Соответствующая последовательность узлов



называется обратной польской записью арифметического выражения.
При построении синтаксического дерева следует обратить внимание на следующую особенность. Если есть, например, выражение



и операции сложения и вычитания мы будем считывать слева на право, то правильное синтаксическое дерево будет содержать минус вместо плюса (рис. 9а). По сути, это дерево соответствует выражению  Облегчить составление дерева можно, если анализировать выражение (8) наоборот, справа налево. В этом случае получается дерево с рис. 9б, эквивалентное дереву 8а, но не требующее замены знаков.
Аналогично справа налево нужно анализировать выражения, содержащие операторы умножения и деления.



Рис. 9. Синтаксические деревья для выражения a – b + c при чтении слева направо (а) и справа налево (б).


    12. Пример 1. Вычисление выражения (Pascal)
В файле SynAn.pas приведен пример функции, вычисляющей значения выражений, содержащих только одну переменную x. Дадим краткое описание реализованного там алгоритма:

unit SynAn;

interface

//Вычисляет выражение s при значении переменной x
function CalcExpression(s: string; x: extended): extended;


//Вычисляет выражение s, не содержащее знаков + и - вне скобок при значении
//переменной x
function CalcMultDiv(s: string; x: extended): extended;

//Вычисляет выражения в скобках, вызывая для них CalcExpression или, если
//выражение простое (константа или просто x), возвращает его значение.
function CalcValuesOrOpenParentheses(s: string; x: extended): extended;

//Входное n - номер закрывающей скобки. Процедура находит и записывает в n
//номер соответствующей открывающей скобки.
procedure SkipParentheses(s: string; var n: integer);

//Находит и записывает в n номер символа, содержащего "+" или "-"
procedure FindPlusMinus(s: string; var n: integer);

//Находит и записывает в n номер символа, содержащего "*" или "/"
procedure FindMultDiv(s: string; var n: integer);

implementation

//Вычисляет выражение s при значении переменной x
function CalcExpression(s: string; x: extended): extended;
var
 n: integer;
 s2: string;
 Res: extended;
begin
    n := length(s);
    Res:=0;
    repeat
      FindPlusMinus(s, n);
      s2 := Copy(s, n+1, length(s));
      if s[n] = '-' then
        Res := Res - CalcMultDiv(s2, x)
      else
        Res := Res + CalcMultDiv(s2, x);
      Delete(s, n, length(s));
      n := n - 1;
    until n < 1;
    CalcExpression := Res;
end;

//Вычисляет выражение s, не содержащее знаков + и - вне скобок при значении
//переменной x
function CalcMultDiv(s: string; x: extended): extended;
var
 n: integer;
 s2: string;
 Res: extended;
begin
    n := length(s);
    Res:=1;
    repeat
      FindMultDiv(s, n);
      s2 := Copy(s, n+1, length(s));
      if s[n] = '/' then
        Res := Res / CalcValuesOrOpenParentheses(s2, x)
      else
        Res := Res * CalcValuesOrOpenParentheses(s2, x);
      Delete(s, n, length(s));
      n := n - 1;
    until n < 1;
    CalcMultDiv := Res;
end;

//Вычисляет выражения в скобках, вызывая для них CalcExpression или, если
//выражение простое (константа или просто x), возвращает его значение.
function CalcValuesOrOpenParentheses(s: string; x: extended): extended;
var
 c: integer;
 Res: extended;
begin
    if s[1] = '(' then
      Res := CalcExpression(Copy(s, 2, length(s)-2), x)
    else
      if s = 'x' then
        Res := x
      else
        Val(s, Res, c);
    CalcValuesOrOpenParentheses := Res;
end;

//Находит и записывает в n номер символа, содержащего "+" или "-"
procedure FindPlusMinus(s: string; var n: integer);
begin
    repeat
      if s[n] = ')' then
        SkipParentheses(s, n);
      n := n - 1;
    until (n < 1)or(s[n] = '+')or(s[n] = '-');
end;

//Находит и записывает в n номер символа, содержащего "*" или "/"
procedure FindMultDiv(s: string; var n: integer);
begin
    repeat
      if s[n] = ')' then
        SkipParentheses(s, n);
      n := n - 1;
    until (n < 1)or(s[n] = '*')or(s[n] = '/');
end;

//Входное n - номер закрывающей скобки. Процедура находит и записывает в n
//номер соответствующей открывающей скобки.
procedure SkipParentheses(s: string; var n: integer);
var
 pn: integer; //Счетчик скобок
begin
    pn := 1;
    repeat
      n := n - 1;
      if s[n] = ')' then
        pn := pn + 1;
      if s[n] = '(' then
        pn := pn - 1;
    until pn = 0;
end;
end.

    • Вычисляющая выражение функция (CalcExpression) находит в строке все знаки «+» и «–», не заключенные в скобки. Эти знаки разбивают выражение на части, содержащие (вне скобок) только операции умножения и деления. Для вычисления значений этих частей вызывается функция CalcMultDiv.
    • Функция CalcMultDiv находит в строке все знаки «*» и «/», не заключенные в скобки. Эти знаки разбивают выражение на части, содержащие числовые константы, переменную x или выражения в скобках. Для вычисления значений этих частей вызывается функция CalcValuesOrOpenParentheses.
    • Функция CalcValuesOrOpenParentheses определяет тип попавшего ей на вход выражения. Если это числовая константа или переменная x, то она возвращает их значение. Если это выражение в скобках, то для его вычисления рекурсивно вызывается процедура CalcExpression.

Заметим, что в данном примере вычисления производятся одновременно с анализом строкового выражения. Это приводит к тому, что для некоторых выражений вычисления могут происходить в 100 – 1000 раз медленнее, чем, если бы эти выражения были скомпилированы как часть программы. Если одно и то же выражение требуется вычислить много раз при различных значения переменных, то следует разделить анализ строки и вычисления. Такой подход может позволить ускорить вычисления в сотни раз.
Результатом анализа строки должна быть последовательность узлов дерева в концевом порядке. Каждый узел должен хранить информацию о подузлах и о той операции, которая в нем совершается. Например, узлы можно реализовать в виде записей, одно из полей который имеет процедурный тип. Другой вариант – каждый узел это объект, где операция реализована как виртуальный метод.

    13. Пример 2. Синтаксический анализатор математических выражений
В данном примере рассматривается программа, которая будет принимать на входе строку с математическим выражением (например 2+8*(9/4-1,5)^2) и выдавать соответствующий результат. Для анализа выражения будем использовать алгоритм рекурсивного спуска. Преимущество этого алгоритма заключается в том, что мы можем обеспечить выполнение арифметических операций в нужном порядке, в соответствии с законами математики. Наш анализатор будет состоять из нескольких функций, которые будут вызываться одна из другой. В каждой функции будут выполняться определенные арифметические действия, нам лишь необходимо вызывать функции в нужной последовательности, которую диктуют нам правила математики. Это и есть принцип алгоритма.

Разбиение строки на лексемы.
Прежде чем обрабатывать выражение, необходимо разбить его на составляющие части (лексемы). Лексема — минимальная, не делимая часть выражения. Например выражение 25+2*3 состоит из следующих лексем: 25, +, 2, *, 3.
Для разбиения выражения на лексемы напишем функцию getToken(). Данная функция будет возвращать очередную лексему из строки с указанием ее типа. В нашем случаи нам понадобится три типа: число, оператор и переменная. Оператор - это знаки +, -, *, /, %, (, ). Переменные — это латинские буквы от A до Z (Примечание: в данном примере анализатор не может обрабатывать переменные. Их обработку я рассмотрю в следующем примере, чуть позже)
И так, приступим к написанию функции getToken, вот ее код:

char *expr; //Указатель на обрабатываемую строку
char token[80]; //Лексема
enum {Empty, Operator, Variable, Number} type; //Тип лексемы

int* getToken(char *expr)
{
   static int i=0;
   type=Empty;

   if(expr[i]=='\0'){ //Если конец выражения
       i=0;
       return 0;
   }
   while(isspace(expr[i])) i++; //Пропустить разделительные символы

   if(strchr("+-*/%^=()", expr[i])){
       *token = expr[i];
       *(token+1) = '\0';
       type = Operator;
   }
   else if(isalpha(expr[i])){
       *token = expr[i];
       *(token+1) = '\0';
       type = Variable;
   }
   else if(isdigit(expr[i])){
       int j=0;
       token[j]=expr[i];
       while(isdigit(expr[i+1])||expr[i+1]=='.')
           token[++j]=expr[++i];
       token[j+1]='\0';
       type=Number;
   }
   i++;
   return &i;
}

Функция принимает указатель на обрабатываемую строку *expr. В начале функции объявлена статическая переменная i, которая хранит номер текущий позиции в анализируемой строке, далее устанавливается пустой тип лексемы (данный тип будет свидетельствовать о том, что лексем больше нет). Далее происходит проверка, не достигнут ли конец строки, и если он достигнут функция завершает свою работу. Потом с помощью библиотечной функции isspace пропускаются все разделительные символы (такие как пробел, символ табуляции и другие). Далее с помощь библиотечных функций strchr (поиск подстроки в строке), isalpha и isdigit происходит определение типа лексемы. Лексема записывается в глобальную переменную token[80], а ее тип определяется глобальным константным перечисление type. После этого функция возвращает адрес i, это необходимо, что бы обеспечить возможность обнулить эту переменную вне функции getToken().

После того, как мы получили возможность разбивать выражение на лексемы, мы можем приступить к его анализу. Ниже приведен полный код анализатора. Файл Parser.h

#ifndef PARSER_H_INCLUDED
#define PARSER_H_INCLUDED

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <math.h>

int* getToken(char*); //Получает лексему из строки
void pars(char*); //Точка входа анализатора
int fSum(double*); //Обрабатывает сложение и вычитание
int fMulti(double*); //Обрабатывает умножение и деление
int fExp(double*); //Возведение в степень
int fUnary(double*); //Обработка унарных операторов
int fBrack(double*); //Обрабатывает выражение в скобках
int fAtom(double*); //Получает значение числа

char *expr; //Указатель на обрабатываемую строку
char token[80]; //Лексема
enum {Empty, Operator, Variable, Number} type; //Тип лексемы
enum {No, Syntax, Zero} error; //Значение ошибки

void pars(char *line)
{
   int *pointer;
   double result;
   error=No;
   expr=line;
   pointer=getToken(expr);
   fSum(&result);
   *pointer=0;

   switch(error)
   {
    case No:
       sprintf(expr, "%f", result);
       break;
    case Syntax:
       strcpy(expr, "Syntax error!");
       break;
    case Zero:
       strcpy(expr, "Divide by zero!");
       break;
   }
}

int* getToken(char *expr)
{
   static int i=0;
   type=Empty;

   if(expr[i]=='\0'){ //Если конец выражения
       i=0;
       return 0;
   }
   while(isspace(expr[i])) i++; //Пропустить разделительные символы

   if(strchr("+-*/%^=()", expr[i])){
       *token = expr[i];
       *(token+1) = '\0';
       type = Operator;
   }
   else if(isalpha(expr[i])){
       *token = expr[i];
       *(token+1) = '\0';
       type = Variable;
   }
   else if(isdigit(expr[i])){
       int j=0;
       token[j]=expr[i];
       while(isdigit(expr[i+1])||expr[i+1]=='.')
           token[++j]=expr[++i];
       token[j+1]='\0';
       type=Number;
   }
   i++;
   return &i;
}

int fSum(double *anw)
{
   char op;
   double temp;
   if(fMulti(anw)) return 1;

   while((op = *token) == '+' || op == '-'){
       getToken(expr);
       fMulti(&temp);
       switch(op)
       {
        case '+':
           *anw += temp;
           break;
        case '-':
           *anw -= temp;
           break;
       }
   }
return 0;
}

int fMulti(double *anw)
{
   char op;
   double temp;
   if(fExp(anw)) return 1; //Ошибка

   while((op = *token) == '*' || op == '/' || op == '%'){
       getToken(expr);
       if(fExp(&temp)) return 1; //Ошибка
       switch(op)
       {
        case '*':
           *anw *= temp;
           break;
        case '/':
           if(temp == 0.0)
           {
               error=Zero;
               return 1;
           }
           *anw /= temp;
           break;
        case '%':
           *anw = (int)*anw % (int)temp;
           break;
       }
   }
   return 0;
}

int fExp(double *anw)
{
   double temp;
   if(fUnary(anw)) return 1; //Ошибка

   while(*token  == '^'){
       getToken(expr);
       if(fUnary(&temp)) return 1; //Ошибка
       *anw = pow(*anw, temp);
   }
   return 0;
}

int fUnary(double *anw)
{
   char op=0;
   if(*token == '+' || *token == '-'){
       op = *token;
       getToken(expr);
   }
   if(fBrack(anw)) return 1; //Ошибка
   if(op == '-') *anw = -(*anw);
   return 0;
}

int fBrack(double *anw)
{
   if(*token == '('){
       getToken(expr);
       fSum(anw);

       if(*token != ')'){
           error=Syntax;
           return 1;
       }
       getToken(expr);
   }
   else
       if(fAtom(anw)) return 1; //Ошибка
   return 0;
}

int fAtom(double *anw)
{
   if(type == Number){
       *anw = atof(token);
       getToken(expr);
   }
   else{
       error=Syntax;
       return 1;
   }
   return 0;
}
#endif // PARSER_H_INCLUDED

Обратите внимание, что весь код в файле Parser.h находится между условными выражениями #ifndef и #endif, а так же определена константа #define PARSER_H_INCLUDED, это позволяет исключить повторное включение данного файла в ваш проект.
В начале подключаются необходимые библиотечные функции и объявляются прототипы всех функций. Точкой входа анализатора является функция pars(), она принимает указатель на обрабатываемую строку и присваивает его значение глобальной переменной *expr, что бы все функции могли обращаться к этой строке. Далее функция вызывает getToken() и в переменную token[80] попадает первая лексема. Потом вызывается первая из арифметических функций — fSum() и ей передается адрес переменной result, в которой в итоге будет содержаться результат вычислений.
Функция fSum() вызывает следующую — fMulti(), та в свою очередь вызывает fExp(). Когда управление переходит к функции fUnary(), она проверяет, не является ли лексема унарным плюсом или унарным минусом, если это так, функция записывает лексему (т.е. знак + или -) в переменную op и получает следующую лексему. Далее вызывается функция fBrack(), она проверяет, не является ли лексема знаком открывающийся скобки, и если это так функция рекурсивно вызывает fSum() и начинается вычисление выражения в скобках. Самой последний в цепочки вызывается функция fAtom(), она с помощью библиотечной функции atof() преобразует лексему в число типа double и записывает ее по адресу *anw, т.е. в переменную result.
Далее управление передается функциям в обратном порядке. После завершения fAtom() мы попадаем в функцию fBrack(), потом в fUnary(). Функция fUnary() проверяет, содержится ли в переменной op унарный минус, и если это необходимо, она изменяет переменную result. Далее в функции fExp() происходит обработка возведения в степени, после чего мы попадаем в функцию fMulti(), которая проверяет, является ли текущая лексема знаком умножения, деления или знаком %(остаток от деления), если необходимо, функция производит нужные подсчеты. Реализуется это следующим образом: вначале функция fMulti() записывает текущий оператор в переменную op, затем вызывается функция fExp(), которой передается адрес временной переменной temp и вся цепочка начинается сначала. После завершения цепочки управление возвращается в функцию fMulti(), а переменная temp содержит значения второго операнда для оператора, который сохранен в переменной op. После выполнения арифметических действий управление переходит к функции fSum(), которая действует аналогично функции fMulti().
После всего этого функция переменная result содержит результат вычислений. Функция pars() копирует этот результат в исходную строку, на которую указывает *expr, и работа анализатора завершается.
Теперь необходимо рассмотреть что будет, если в одной из функция произойдет ошибка, например не верное исходное выражение (20-8**3). В данном выражении два раза подряд встречается оператор умножения, следовательно анализатор не сможет обработать его. Все арифметические функции возвращает 0, если работа завершена без ошибки, и 1 если она обнаружена. При вызове каждой функции проверяется ее возвращенное значение, например

if(fMulti(anw)) return 1;

Если какая-либо функция обнаружила ошибку, она устанавливает соответствующее значение ошибки в перечислении error, и тут же завершает свою работу вернув 1. Далее по цепочки завершаются все функции, а функция pars() вместо результата копирует в обрабатываемую строку соответствующее сообщение об ошибке.

Использование анализатора.
Следующая небольшая программа демонстрирует использование анализатора. Файл parser_console.cpp

char *expr; //Указатель на обрабатываемую строку
char token[80]; //Лексема
enum {Empty, Operator, Variable, Number} type; //Тип лексемы

int* getToken(char *expr)
{
   static int i=0;
   type=Empty;

   if(expr[i]=='\0'){ //Если конец выражения
       i=0;
       return 0;
   }
   while(isspace(expr[i])) i++; //Пропустить разделительные символы

   if(strchr("+-*/%^=()", expr[i])){
       *token = expr[i];
       *(token+1) = '\0';
       type = Operator;
   }
   else if(isalpha(expr[i])){
       *token = expr[i];
       *(token+1) = '\0';
       type = Variable;
   }
   else if(isdigit(expr[i])){
       int j=0;
       token[j]=expr[i];
       while(isdigit(expr[i+1])||expr[i+1]=='.')
           token[++j]=expr[++i];
       token[j+1]='\0';
       type=Number;
   }
   i++;
   return &i;
}

В конечном представлении анализатор оформлен в виде программы

#include <iostream>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <math.h>

using namespace std;

int* getToken(char*); //Получает лексему из строки
void pars(char*); //Точка входа анализатора
int fSum(double*); //Обрабатывает сложение и вычитание
int fMulti(double*); //Обрабатывает умножение и деление
int fExp(double*); //Возведение в степень
int fUnary(double*); //Обработка унарных операторов
int fBrack(double*); //Обрабатывает выражение в скобках
int fAtom(double*); //Получает значение числа

char *expr; //Указатель на обрабатываемую строку
char token[80]; //Лексема
enum {Empty, Operator, Variable, Number} type; //Тип лексемы
enum {No, Syntax, Zero} error; //Значение ошибки

void pars(char *line)//Точка входа анализатора
{
   int *pointer;
   double result;
   error=No;
//принимает указатель (line) на обрабатываемую строку и
//присваивает его значение глобальной переменной *expr,
// что бы все функции могли обращаться к этой строке
   expr=line;
   pointer=getToken(expr);//в переменную token[80] попадает первая лексема
   fSum(&result);//вызывается первая из арифметических функций
    //ей передается адрес переменной result
   *pointer=0;

   switch(error)
   {
    case No:
       sprintf(expr, "%f", result);//копирует результат в исходную строку, на которую указывает *expr
       break;
    case Syntax:
       strcpy(expr, "Syntax error!");
       break;
    case Zero:
       strcpy(expr, "Divide by zero!");
       break;
   }
}

int* getToken(char *expr)//Получает лексему из строки
{
   static int i=0;//номер текущий позиции в анализируемой строке
   type=Empty;//пустой тип лексемы (данный тип будет свидетельствовать о том, что лексем больше нет)

   if(expr[i]=='\0') //Если конец выражения. Конец строки?
   {
       i=0;
       return 0;
   }
   while(isspace(expr[i])) i++; //Пропустить разделительные символы.
       //Пропускаются все разделительные символы (пробел, табуляции и другие)

// token[80] глобальная переменная
// ее тип определяется глобальным константным перечисление type
   if(strchr("+-*/%^=()", expr[i])) //поиск подстроки в строке
   {
       *token = expr[i];
       *(token+1) = '\0';
       type = Operator;
   }
   else if(isalpha(expr[i])) //определение типа лексемы
   {
       *token = expr[i];
       *(token+1) = '\0';
       type = Variable;
   }
   else if(isdigit(expr[i])) //определение типа лексемы
   {
       int j=0;
       token[j]=expr[i];
       while(isdigit(expr[i+1])||expr[i+1]=='.')
           token[++j]=expr[++i];
       token[j+1]='\0';
       type=Number;
   }
   i++;

   return &i; //необходимо, что бы обеспечить возможность обнулить эту переменную вне функции getToken()
}

int fSum(double *anw)//Обрабатывает сложение и вычитание
{
   char op;
   double temp;
   if(fMulti(anw)) return 1;//вызывается следующая арифметическая функция

   while((op = *token) == '+' || op == '-')
   {
       getToken(expr);
       fMulti(&temp);
       switch(op)
       {
        case '+':
           *anw += temp;
           break;
        case '-':
           *anw -= temp;
           break;
       }
   }

return 0;
}

int fMulti(double *anw)//Обрабатывает умножение и деление
{
   char op;
   double temp;
   if(fExp(anw)) return 1; //Ошибка
      ////вызывается следующая арифметическая функция

   while((op = *token) == '*' || op == '/' || op == '%')//запись текущего оператора в переменную op
   {
       getToken(expr);
 //передается адрес временной переменной temp и вся цепочка начинается сначала
       if(fExp(&temp)) return 1; //Ошибка
       switch(op)
       {
        case '*':
           *anw *= temp;
           break;
        case '/':
           if(temp == 0.0)
           {
               error=Zero;
               return 1;
           }
           *anw /= temp;
           break;
        case '%':
           *anw = (int)*anw % (int)temp;
           break;
       }
   }

return 0;
}

int fExp(double *anw)//Возведение в степень
//обработка возведения в степени
{
   double temp;
   if(fUnary(anw)) return 1; //Ошибка

   while(*token  == '^')
   {
       getToken(expr);
       if(fUnary(&temp)) return 1; //Ошибка
       *anw = pow(*anw, temp);
   }

return 0;
}

int fUnary(double *anw)//Обработка унарных операторов
//проверяет, не является ли лексема унарным плюсом или унарным минусом,
//если это так, функция записывает лексему (т.е. знак + или -) в переменную op и
//получает следующую лексему
{
   char op=0;
   if(*token == '+' || *token == '-')
   {
       op = *token;
       getToken(expr);
   }
   if(fBrack(anw)) return 1; //Ошибка

//содержится ли в переменной op унарный минус, и
//если это необходимо, изменяет переменную result
   if(op == '-') *anw = -(*anw);

return 0;
}

int fBrack(double *anw)//Обрабатывает выражение в скобках
//проверяет, не является ли лексема знаком открывающийся скобки, и если
//это так функция рекурсивно вызывает fSum() и начинается вычисление выражения в скобках
{
   if(*token == '(')
   {
       getToken(expr);
       fSum(anw);

       if(*token != ')')
       {
           error=Syntax;
           return 1;
       }
       getToken(expr);
   }
   else
       if(fAtom(anw)) return 1; //Ошибка

return 0;
}

int fAtom(double *anw)//Получает значение числа
//с помощью библиотечной функции atof() преобразует лексему
//в число типа double и записывает ее по адресу *anw,
//т.е. в переменную result
{
   if(type == Number)
   {
       *anw = atof(token);
       getToken(expr);
   }
   else
   {
       error=Syntax;
       return 1;
   }

return 0;
}


int main(void)
{
   char expr[255]; //Содержит вычисляемое выражение
   while(1)
   {
       printf("expration>> ");
       gets(expr);
       if(!*expr) break; //Если введена пустая строка - завершить программу
       pars(expr); //Точка входа анализатора. Вычислить выражение
       printf("    Result: %s\n\n", expr);
   }
   return 0;
}

Обработка выражения происходит в бесконечном цикле до тех пор, пока не будет введена пустая строка



            13.1.1. Быстрые сортировки
Простые методы сортировки вроде метода выбора или метода пузырька сортируют массив из n элементов за O(n2) операций. Однако с помощью принципа «разделяй и властвуй» удается построить более быстрые, работающие за O(n log2 n) алгоритмы. Суть этого принципа в том, что решение получается путем рекурсивного разделения задачи на несколько простые подзадачи того же типа до тех пор, пока они не станут элементарными. Приведем в качестве примеров несколько быстрых алгоритмов такого рода.

    14. Алгоритм 1: «Быстрая» сортировка (quicksort).
    • Выбирается опорный элемент (например, первый или случайный).
    • Реорганизуем массив так, чтобы сначала шли элементы меньшие опорного, потом равные ему, затем большие. Для этого достаточно помнить, сколько было найдено меньших (m1) и больших (m2), чем опорный и ставить очередной элемент на место с индексом m1, а очередной больший на место с индексом n-1-m2.

После выполнения такой операции опорный элемент и равные ему стоят на своем месте, их переставлять больше не придется. Между «меньшей» и «большей» часть массива перестановок также быть не может. То есть эти части можно сортировать независимо друг от друга.

    • Если «меньшая» или «большая» часть состоит из одного элемента, то она уже отсортирована и делать ничего не надо. Иначе сортируем эти части с помощью алгоритма быстрой сортировки (то есть, выполняем для нее шаги 1-3).

Как видите, быстрая сортировка состоит из выполнения шагов 1 и 2 и рекурсивного вызова алгоритма для получившихся частей массива.

                    14.1.1.1.1. Quicksort. Пример 1.
Быстрая сортировка представляет собой усовершенствованный метод сортировки, основанный на принципе обмена. Пузырьковая сортировка является самой неэффективной из всех алгоритмов прямой сортировки. Однако усовершенствованный алгоритм является лучшим из известных методом сортировки массивов. Он обладает столь блестящими характеристиками, что его изобретатель Ч. Хоар назвал его быстрой сортировкой.
Для достижения наибольшей эффективности желательно производить обмен элементов на больших расстояниях. В массиве выбирается некоторый элемент, называемый разрешающим. Затем он помещается в то место массива, где ему полагается быть после упорядочивания всех элементов. В процессе отыскания подходящего места для разрешающего элемента производятся перестановки элементов так, что слева от них находятся элементы, меньшие разрешающего, и справа — большие (предполагается, что массив сортируется по возрастанию).
Тем самым массив разбивается на две части:
    • не отсортированные элементы слева от разрешающего элемента;
    • не отсортированные элементы справа от разрешающего элемента.

Чтобы отсортировать эти два меньших подмассива, алгоритм рекурсивно вызывает сам себя.
Если требуется сортировать больше одного элемента, то нужно
    • выбрать в массиве разрешающий элемент;
    • переупорядочить массив, помещая элемент на его окончательное место;
    • отсортировать рекурсивно элементы слева от разрешающего;
    • отсортировать рекурсивно элементы справа от разрешающего.

Ключевым элементом быстрой сортировки является алгоритм переупорядочения.
Рассмотрим сортировку на примере массива:

Рассмотрим сортировку на примере массива:

10, 4, 2, 14, 67, 2, 11, 33, 1, 15.

Для реализации алгоритма переупорядочения используем указатель left на крайний левый элемент массива. Указатель движется вправо, пока элементы, на которые он показывает, остаются меньше разрешающего. Указатель right поставим на крайний правый элемент массива, и он движется влево, пока элементы, на которые он показывает, остаются больше разрешающего.
Пусть крайний левый элемент — разрешающий pivot. Установим указатель left на следующий за ним элемент; right — на последний. Алгоритм должен определить правильное положение элемента 10 и по ходу дела поменять местами неправильно расположенные элементы.



Движение указателей останавливается, как только встречаются элементы, порядок расположения которых относительно разрешающего элемента неправильный.
Указатель left перемещается до тех пор, пока не покажет элемент больше 10; right движется, пока не покажет элемент меньше 10.



Эти элементы меняются местами и движение указателей возобновляется.



Процесс продолжается до тех пор, пока right не окажется слева от left.



Тем самым будет определено правильное место разрешающего элемента.
Осуществляется перестановка разрешающего элемента с элементом, на который указывает right.



Разрешающий элемент находится в нужном месте: элементы слева от него имеют меньшие значения; справа — большие. Алгоритм рекурсивно вызывается для сортировки подмассивов слева от разрешающего и справа от него.
Реализация алгоритма быстрой сортировки

#include <stdio.h>
#include <stdlib.h>
// Функция быстрой сортировки
void quickSort(int *numbers, int left, int right)
{
 int pivot; // разрешающий элемент
 int l_hold = left; //левая граница
 int r_hold = right; // правая граница
 pivot = numbers[left];
 while (left < right) // пока границы не сомкнутся
 {
   while ((numbers[right] >= pivot) && (left < right))
     right--; // сдвигаем правую границу пока элемент [right] больше [pivot]
   if (left != right) // если границы не сомкнулись
   {
     numbers[left] = numbers[right]; // перемещаем элемент [right] на место разрешающего
     left++; // сдвигаем левую границу вправо
   }
   while ((numbers[left] <= pivot) && (left < right))
     left++; // сдвигаем левую границу пока элемент [left] меньше [pivot]
   if (left != right) // если границы не сомкнулись
   {
     numbers[right] = numbers[left]; // перемещаем элемент [left] на место [right]
     right--; // сдвигаем правую границу вправо
   }
 }
 numbers[left] = pivot; // ставим разрешающий элемент на место
 pivot = left;
 left = l_hold;
 right = r_hold;
 if (left < pivot) // Рекурсивно вызываем сортировку для левой и правой части массива
   quickSort(numbers, left, pivot - 1);
 if (right > pivot)
   quickSort(numbers, pivot + 1, right);
}
int main()
{
 int a[10];
 // Заполнение массива случайными числами
 for (int i = 0; i<10; i++)
a[i] = rand() % 20 - 10;
 // Вывод элементов массива до сортировки
 for (int i = 0; i<10; i++)
   printf("%d ", a[i]);
 printf("\n");
 quickSort(a, 0, 9); // вызов функции сортировки
 // Вывод элементов массива после сортировки
 for (int i = 0; i<10; i++)
   printf("%d ", a[i]);
 printf("\n");
 getchar();
 return 0;
}



                    14.1.1.1.2. Quicksort. Пример 2.

Представляется рекурсивный пример реализации быстрой сортировки. Массив, который нужно отсортировать будет глобальным, если же вы захотите сделать его локальным, то просто передавайте его как параметр в функцию. Конечно, после того, как вы сделаете это вам нужно будет использовать template для того, чтобы ваша функция работала со всеми типами данных. Приведем код рекурсивной сортировки quicksort:

#include <iostream>
using namespace std;
int a[100];
void quickSort(int l, int r)
{
   int x = a[l + (r - l) / 2];
   //запись эквивалентна (l+r)/2,
   //но не вызввает переполнения на больших данных
   int i = l;
   int j = r;
   //код в while обычно выносят в процедуру particle
   while(i <= j){
       while(a[i] < x) i++;
       while(a[j] > x) j--;
       if(i <= j){
           swap(a[i], a[j]);//взаимозамена элементов
           i++;
           j--;
       }
   }
   if (i<r)
       quickSort(i, r);

   if (l<j)
       quickSort(l, j);
}

int main()
{
   int n;//количество элементов в массиве
   setlocale(LC_ALL, "Rus");
   cout << "Количество элементов в массиве: ";
   cin >> n;
   for(int i = 0; i < n; i++){
       cout << "array a[" << i << "]= ";
       cin >> a[i];
   }
   quickSort(0, n-1);
   cout << "\n";
   for(int i = 0; i < n; i++){
       cout << a[i] << " ";
   }
   cout << "\n";
   system("PAUSE");
   return 0;
}



                    14.1.1.1.3. Quicksort. Пример 3.

#include <stdio.h>
#include <stdlib.h>
#include <iostream>

using namespace std;

void quickSort(int arr[], int left, int right) {
   int i = left, j = right;
   int tmp;
   int pivot = arr[(left + right) / 2];

   /* partition */
   while (i <= j) {
       while (arr[i] < pivot)
       i++;
       while (arr[j] > pivot)
       j--;
       if (i <= j) {
           tmp = arr[i];
           arr[i] = arr[j];
           arr[j] = tmp;
           i++;
           j--;
       }
   };

   /* recursion */
   if (left < j)
 quickSort(arr, left, j);
   if (i < right)
 quickSort(arr, i, right);
}


int main()
{
 int a[10];
 // Заполнение массива случайными числами
 for (int i = 0; i<10; i++)
a[i] = rand() % 20 - 10;
 // Вывод элементов массива до сортировки
 for (int i = 0; i<10; i++)
printf("%d ", a[i]);
 printf("\n");
 quickSort(a, 0, 9); // вызов функции сортировки
 // Вывод элементов массива после сортировки
 printf("\n");
 for (int i = 0; i<10; i++)
   printf("%d ", a[i]);
 printf("\n");
 getchar();
 return 0;
}



    15. Алгоритм 2: Сортировка слиянием (merge sort).
    • Делим массив на две части примерно одинакового размера и, если получившаяся половина массива содержит больше одного элемента, то сортируем ее с помощью сортировки слиянием. Как видите, этот пункт содержит рекурсивное обращение ко всему алгоритму в целом.
    • Соединяем две отсортированные половины так, чтобы получился один отсортированный массив. Для этого помещаем во вспомогательный массив элементы из первой половины, пока они не превосходят очередного элемента из второй половины. Затем начинаем помещать туда элементы второй половины, пока они не превосходят очередного элемента из первой половины. Затем снова берем элементы первой половины и т.д. Эта операция называется слиянием и требует столько шагов, сколько элементов в обоих соединяемых массивах.

                    15.1.1.1.1. Merge sort. Пример 1.
http://programmado.ru/59-sortirovka-sliyaniem-na-s.html

Сортировка слиянием на С++



Сортировка слиянием - это довольно быстрая сортировка, время работы которой О(n * log n). Однако ее недостатком является тот факт, что она требует относительно много памяти.
Итак, пусть дан некоторый неупорядоченный массив int a[maxn].
Основная идея состоит в том, что на каждом шаге мы разбиваем массив на 2 равные части, сортируем их, а потом сливаем два отсортированных куска. То есть получается рекурсивная сортировка, т.к. каждую из этих 2 частей мы будем сортировать аналогично. Выход из рекурсии будет происходить тогда, когда у нас остается меньше 3 элементов. Если их остается всего 2, то меняем их между собой по мере надобности. Если остается только 1 элемент, то оставляем его в покое.

Пример. Пусть дан исходный массив из 7 элементов:

#include <iostream>
#include <conio.h>
using namespace std;

#define maxn 100
//int n;
//int a[maxn];

int n = 7;
int a[7] = {7, 4, 2, 1, 0, 5, 3};

void merge(int l, int r) {
   if (r == l)
       return; //остался один элемент
   if (r - l == 1) { //осталось два элемента
       if (a[r] < a[l])
           swap(a[r], a[l]); //перестановка элементов местами
       return;
   }
   int m = (r + l) / 2; //деление массива на части
   merge(l, m);//рекурсия для левой части массива обрабатывается впервую очередь
   merge(m + 1, r);//рекурсия для правой части массива выполняется второй
//начинает работать на 3 шаге примера(выполняет слияние)
   int buf[maxn];
   int xl = l;//
   int xr = m + 1;//
   int cur = 0;
//формируем сортированный буффер (сливание)
   while (r - l + 1 != cur) {
       if (xl > m)
           buf[cur++] = a[xr++];
       else if (xr > r)
           buf[cur++] = a[xl++];
       else if (a[xl] > a[xr])
           buf[cur++] = a[xr++];
       else buf[cur++] = a[xl++];
   }
//перазаписываем массив из буфера
   for (int i = 0; i < cur; i++)
       a[i + l] = buf[i];
}

int main()
{
   setlocale(LC_ALL, "Rus");
//cout << "Количество элементов в массиве: ";
//cin >> n;
//for (int i = 0; i < n; i++){
// cout << "array a[" << i << "]= ";
// cin >> a[i];
//}
//n=7;
//a[0]=7; a[1]=4; a[2]=2; a[3]=1; a[4]=0; a[5]=5; a[6]=3;
   merge(0, n - 1);
   for (int i = 0; i < n; i++)
       cout << a[i] << " ";
   getch();
   return 0;
}



                    15.1.1.1.2. Merge sort. Пример 2.
https://prog-cpp.ru/sort-merge/

Алгоритмы сортировки массивов не всегда применимы, если сортируемые данные расположены в структуре с последовательным доступом, которая характеризуется тем, что в каждый момент имеется непосредственный доступ к одному и только одному компоненту.
Основной применяемый метод для сортировки файлов — сортировка слиянием.
Сортировка слиянием — алгоритм сортировки, который упорядочивает списки (или другие структуры данных, доступ к элементам которых можно получать только последовательно, например — потоки) в определённом порядке.
Слияние означает объединение двух (или более) последовательностей в одну упорядоченную последовательность при помощи циклического выбора элементов, доступных в данный момент.
Сначала задача разбивается на несколько подзадач меньшего размера. Затем эти задачи решаются с помощью рекурсивного вызова или непосредственно, если их размер достаточно мал. Затем их решения комбинируются, и получается решение исходной задачи.
Операция, которая однократно обрабатывает множество данных, называется фазой.
Наименьший подпроцесс, который, повторяясь, образует процесс сортировки, называется проходом или этапом.
Процедура слияния предполагает объединение двух предварительно упорядоченных подпоследовательностей размерности n/2 в единую последовательность размерности n. Начальные элементы предварительно упорядоченных последовательностей сравниваются между собой, и из них выбирается наименьший. Соответствующий указатель перемещается на следующий элемент. Процедура повторяется до тех пор, пока не достигнут конец одной из подпоследовательностей. Оставшиеся элементы другой подпоследовательности при этом передаются в результирующую последовательность в неизменном виде.



Сортировка слиянием во многом похожа на метод быстрой сортировки.  Производительность сортировки слиянием лежит между производительностью пирамидальной и быстрой сортировки. Но в отличие от пирамидальной и быстрой сортировок, метод сортировки слиянием ведет себя стабильно, поскольку он не зависит от перестановок элементов в массиве.
Еще одним достоинством сортировки слиянием является то, что он удобен для структур с последовательным доступом к элементам, таким как файлы на внешнем устройстве или связные списки. Этот метод, прежде всего, используется для внешней сортировки.
Недостатки метода заключаются в том, что он требует дополнительной памяти по объему равной объему сортируемого файла. Поэтому для больших файлов проблематично организовать сортировку слиянием в оперативной памяти.
В случаях, когда гарантированное время сортировки важно и размещение в оперативной памяти, возможно, следует предпочесть метод сортировки слиянием.

Алгоритм двухпутевого слияния
Исходная последовательность разбивается на две подпоследовательности:



Эти две подпоследовательности объединяются в одну, содержащую упорядоченные пары.



Полученная последовательность снова разбивается на две, и пары объединяются в упорядоченные четверки:



Полученная последовательность снова разбивается на две и собирается в упорядоченные восьмерки.



Данная операция повторяется до тех пор, пока полученная упорядоченная последовательность не будет иметь такой же размер, как у сортируемой.
Основной операцией является слияние. При слиянии требуется дополнительная память для размещения файла, образующегося при слиянии. Операция линейно зависит от количества элементов в объединяемых массивах.

#include <stdio.h>
#include <stdlib.h>
// Функция сортировки двухпутевым слиянием
void merge(int *a, int n)
{
int mid = n / 2; // находим середину сортируемой последовательности
if (n % 2 == 1)
 mid++;
int h = 1; // шаг
// выделяем память под формируемую последовательность
int *c = (int*)malloc(n * sizeof(int));
int step;
while (h < n){
 step = h;
 int i = 0;   // индекс первого пути
 int j = mid; // индекс второго пути
 int k = 0;   // индекс элемента в результирующей последовательности
 while (step <= mid){
  while ((i < step) && (j < n) && (j < (mid + step))){
   // пока не дошли до конца пути
   // заполняем следующий элемент формируемой последовательности
   // меньшим из двух просматриваемых
   if (a[i] < a[j]){
    c[k] = a[i];
    i++; k++;
   }
   else {
    c[k] = a[j];
    j++; k++;
   }
  }
  while (i < step){
   // переписываем оставшиеся элементы первого пути (если второй кончился раньше)
   c[k] = a[i];
   i++; k++;
  }
  while ((j < (mid + step)) && (j<n)){
   // переписываем оставшиеся элементы второго пути (если первый кончился раньше)
   c[k] = a[j];
   j++; k++;
  }
  step = step + h; // переходим к следующему этапу
 }
 h = h * 2;
 // Переносим упорядоченную последовательность (промежуточный вариант) в исходный массив
 for (i = 0; i<n; i++)
  a[i] = c[i];
}
}

int main()
{
int a[8];
// Заполнение массива случайными числами
for (int i = 0; i<8; i++)
 a[i] = rand() % 20 - 10;
// Вывод элементов массива до сортировки
for (int i = 0; i<8; i++)
 printf("%d ", a[i]);
printf("\n");
merge(a, 8); // вызов функции сортировки
// Вывод элементов массива после сортировки
for (int i = 0; i<8; i++)
 printf("%d ", a[i]);
printf("\n");
getchar();
return 0;
}



                    15.1.1.1.3. Merge sort. Пример 3.
http://cybern.ru/mergesortcpp.html

Основной недостаток алгоритма сортировки слиянием — это использование дополнительной памяти. Для того, чтобы удобно работать с ней в качестве контейнера для массива используется вектор. Для демонстрации алгоритма сортировки слиянием изначальный вектор заполняется случайными значениями.

#include <vector>
#include <iostream>
using namespace std;
vector <int> merge(vector <int> a, vector <int> b)
//функция сливает два вектора
{
   vector<int> c(a.size()+b.size());//результирующий вектор
   //количество использованных вершин
   int kol1 = 0;//в векторе а
   int kol2 = 0;//в векторе b
   //заполним массив c
   for(int i = 0; i < c.size(); i++){
       //если мы уже полностью использовали вектора а,
       //то нам осталось дописать элементы вектора b
       if(kol1==a.size()){
           c[i] = b[kol2];
           kol2++;
           continue;
       }
       //наоборот
       if(kol2==b.size()){
           c[i] = a[kol1];
           kol1++;
           continue;
       }
       //так как наши вектора еще не полностью
       //использованы, то нужно сравнить какое
       //значение ставить на следующее место
       if(a[kol1]<=b[kol2]){
           c[i] = a[kol1];
           kol1++;
       }
       else{
           c[i] = b[kol2];
           kol2++;
       }
   }
   return c;
}

//функция сортирует вектор
vector<int> merge_sort(vector <int> a)
{
   //если размер вектора меньше 1,
   //то он отсортирован
   if(a.size()<=1)
       return a;
   vector<int> b,c;
   b.assign(a.begin(), a.end()-(a.size()/2));
   c.assign(a.end()-(a.size()/2), a.end());
   return merge(merge_sort(b),merge_sort(c));
}
int main()
{
   vector<int> a;
   for(int i = 0; i < 10; i++){
       a.push_back(rand());
   }
   a = merge_sort(a);
   for(int i = 0;i < a.size();i++){
       cout<<a[i]<<" ";
   }
getchar();
   return 0;
}



    16. Алгоритм 3: Сортировка деревом (tree sort).
Прежде чем переходить к объяснению сути алгоритма введем одно понятие. Двоичным деревом поиска называется бинарное дерево, в узлах которого располагаются числа таким образом, что в левом поддереве каждого узла находятся числа меньшие, чем в этом узле, а в правом поддереве больше или равные тому, что в этом узле. На рис. 10 показано два примера деревьев поиска, составленных из одних и тех же чисел.



Рис. 10. Двоичные деревья поиска, составленные из чисел 1, 3, 4, 6, 7, 8, 10, 13, 14.

Если для каждой вершины высота поддеревьев различается не более чем на единицу, то дерево называется сбалансированным. Сбалансированные деревья поиска также называются АВЛ-деревьями (по первым буквам фамилий изобретателей Г. М. Адельсона-Вельского и Е. М. Ландиса). Как видно на рис. 10а показано сбалансированное дерево, на рис. 10б несбалансированное.
Заметим, что расположение чисел по возрастанию получится, если обходить эти деревья в обратном прядке.
Сортировка деревом получится, если мы сначала последовательно будем добавлять числа из массива в двоичное дерево поиска, а затем обойдем его в обратном порядке.
Если дерево будет близко к сбалансированному, то сортировка потребует примерно n log2 n операций. Если не повезет и дерево окажется максимально несбалансированным, то сортировка займет n2 операций.

                    16.1.1.1.1. Tree sort. Пример 1.
https://prog-cpp.ru/sort-tree/

Сортировка с помощью дерева осуществляется на основе бинарного дерева поиска.
Бинарное (двоичное) дерево поиска – это бинарное дерево, для которого выполняются следующие дополнительные условия (свойства дерева поиска):
    • оба поддерева – левое и правое, являются двоичными деревьями поиска;
    • у всех узлов левого поддерева произвольного узла X значения ключей данных меньше, чем значение ключа данных самого узла X;
    • у всех узлов правого поддерева произвольного узла X значения ключей данных не меньше, чем значение ключа данных узла X.

Данные в каждом узле должны обладать ключами, на которых определена операция сравнения меньше.
Для сортировки с помощью дерева исходная сортируемая  последовательность представляется в виде структуры данных "дерево".
Например, исходная последовательность имеет вид:

4, 3, 5, 1, 7, 8, 6, 2

Корнем дерева будет начальный элемент последовательности. Далее все элементы, меньшие корневого, располагаются в левом поддереве, все элементы, большие корневого, располагаются в правом поддереве. Причем это правило должно соблюдаться на каждом уровне.
После того, как все элементы размещены в структуре "дерево", необходимо вывести их, используя инфиксную форму обхода.



#include <iostream>
using namespace std;
// Структура - узел дерева
struct tnode
{
 int field;           // поле данных
 struct tnode *left;  // левый потомок
 struct tnode *right; // правый потомок
};
// Вывод узлов дерева (обход в инфиксной форме)
void treeprint(tnode *tree)
{
 if (tree != NULL) {      //Пока не встретится пустой узел
   treeprint(tree->left);  //Рекурсивная функция вывода левого поддерева
   cout << tree->field << " "; //Отображаем корень дерева
   treeprint(tree->right); //Рекурсивная функция вывода правого поддерева
 }
}

// Добавление узлов в дерево
struct tnode * addnode(int x, tnode *tree) {
 if (tree == NULL)     // Если дерева нет, то формируем корень
 {
   tree = new tnode; //память под узел
   tree->field = x;   //поле данных
   tree->left = NULL;
   tree->right = NULL; //ветви инициализируем пустотой
 }
 else     // иначе
   if (x < tree->field)   //Если элемент x меньше корневого, уходим влево
     tree->left = addnode(x, tree->left); //Рекурсивно добавляем элемент
   else  //иначе уходим вправо
     tree->right = addnode(x, tree->right); //Рекурсивно добавляем элемент
   return(tree);
}

//Освобождение памяти дерева
void freemem(tnode *tree)
{
 if (tree != NULL){    // если дерево не пустое
   freemem(tree->left);   // рекурсивно удаляем левую ветку
   freemem(tree->right);  // рекурсивно удаляем правую ветку
   delete tree;           // удаляем корень
 }
}
// Тестирование работы
int main()
{
 struct tnode *root = 0;    // Объявляем структуру дерева
 setlocale(LC_ALL, "Rus");  // переходим на русский язык в консоли
 //system("cls");
 int a;            // текущее значение узла
 // В цикле вводим 8 узлов дерева
 cout << "Введите 8 узлов\n";
 for (int i = 0; i< 8; i++){
   cout << "Введите узел " << i + 1 << ": ";
   cin >> a;
   root = addnode(a, root); // размещаем введенный узел на дереве
 }
 cout << "\n\n";
 treeprint(root);    // выводим элементы дерева, получаем отсортированный массив
 freemem(root);      // удаляем выделенную память
 cout << "\n";
 system("PAUSE");
 //cin.get();  cin.get();
 return 0;
}



                    16.1.1.1.2. Tree sort. Пример 2.
http://algolist.manual.ru/sort/faq/q7.php

Двоичным(бинарным) деревом назовем упорядоченную структуру данных, в которой каждому элементу - предшественнику или корню (под)дерева - поставлены в соответствие по крайней мере два других элемента (преемника).
Причем для каждого предшественника выполнено следующее правило: левый преемник всегда меньше, а правый преемник всегда больше или равен предшественнику.
Вместо 'предшественник' и 'преемник' также употребляют термины 'родитель' и 'сын'. Все элементы дерева также называют 'узлами'.
При добавлении в дерево нового элемента его последовательно сравнивают с нижестоящими узлами, таким образом вставляя на место.
Если элемент >= корня - он идет в правое поддерево, сравниваем его уже с правым сыном, иначе - он идет в левое поддерево, сравниваем с левым, и так далее, пока есть сыновья, с которыми можно сравнить.
Вот процесс построения дерева из последовательности

44 55 12 42 94 18 06 67



Дерево может быть и более-менее ровным, как на (*), может и иметь всего две основные ветви (**), а если входная последовательность уже отсортирована, то дерево выродится в линейный список.
Если мы будем рекурсивно обходить дерево по правилу "левый сын - родитель - правый сын", то, записывая все встречающиеся элементы в массив, мы получим упорядоченное в порядке возрастания множество. Это и есть основана идея сортировки деревом.
Более подробно правило обхода можно сформулировать как обойти левое поддерево - вывести корень - обойти правое поддерево, где рекурсивная процедура 'обойти' вызывает себя еще раз, если сталкивается с узлом-родителем и выдает очередной элемент, если у узла нет сыновей.

/*********** сортировка с помощью двоичного дерева *************/
#include <stdio.h>
#include <stdlib.h>

typedef struct tree
{
int a;              // данные
struct tree *left;  // левый  сын
struct tree *right; // правый сын
} TREE;

TREE *add_to_tree(TREE *root, int new_value)
{
  if (root==NULL)  // если нет сыновей - создаем новый элемент
    {
       root = (TREE*)malloc(sizeof(TREE));
       root->a = new_value;
       root->left = root->right = 0;
       return root;
    }
  if (root->a < new_value) // добавлем ветвь
    root->right = add_to_tree(root->right, new_value);
  else
    root->left  = add_to_tree(root->left,  new_value);
  return root;
}

void tree_to_array(TREE *root, int a[]) // процедура заполнения массива
{
static int max2=0;                  // счетчик элементов нового массива
if (root==NULL) return;             // условие окончания - нет сыновей
tree_to_array(root->left, a);       // обход левого поддерева
a[max2++] = root->a;
tree_to_array(root->right, a);      // обход правого поддерева
free(root);
}

void sort_tree(int a[], int elem_total) // собственно сортировка
{
TREE *root;
int i;

root = NULL;
for (i=0; i<elem_total; i++) // проход массива и заполнение дерева
  root = add_to_tree(root, a[i]);
tree_to_array(root, a); // заполнение массива
}
 /* тестовая программа */
void main() {
int i;
/* Это будем сортировать */
int a[14]={ 0,7,8,3,52,14,16,18,15,13,42,30,35,26 };
printf("Initial array:\n");
for (i=0; i<14; i++) printf("%d ",a[i]);

sort_tree(a, 14);

printf("\n\nsorted array:\n");
for (i=0;i <14; i++) printf("%d ",a[i]);
getchar();
}



Общее быстродействие метода O(nlogn). Поведение неестественно, устойчивости, вообще говоря, нет.
Основной недостаток этого метода - большие требования к памяти под дерево. Очевидно, нужно n места под ключи и, кроме того, память на 2 указателя для каждого из них.
Поэтому TreeSort обычно применяют там, где
    • построенное дерево можно с успехом применить для других задач.
    • данные уже построены в 'дерево'. } не тратится
    • данные можно считывать непосредственно в дерево. } лишняя
    • например, при потоковом вводе с консоли или из файла. } память

Кроме того, ее элементы иногда используются в смежных задачах. Другое описание метода 'древесной сортровки' можно найти, например, у H. Вирта в книге 'Алгоритмы + Структуры Данных = Программы'.
Основное различие - строится не представление данных в виде дерева, а 'дерево выбора'. С помощью n/2 сравнений можно определить наименьший элемент из каждой пары, при помощи следующих n/4 - наименьший из каждой пары таких наименьших ключей и т.д
При этом за n-1 сравнений мы можем построить дерево выбора, как показано для чисел

44 55 12 42 94 18 06 67:

Это HЕ двоичное дерево в смысле, определенном выше. И это HЕ пирамида, используемая в HeapSort.
Hа втором шаге мы спускаемся по пути, указанному наименьшим ключом и исключаем его, последовательно заменяя либо на 'дыру' (или ключ 'бесконечность'(БЕСК), либо на элемент, находящийся на противоположной ветви промежуточного узла:





а) взяли ключ 06 сверху
б) опять выбрали наименьший с учетом, что любой ключ < БЕСК.

Очевидно, требуется n операций на создание первоначального дерева,  а затем n шагов, каждый по log n сравнений для выбора нового наименьшего.
Такой вариант TreeSort довольно сильно отличается от изложенного выше. Этот алгоритм еще называют 'выбор с замещением' и его можно неплохо применять в тех же случаях, что и выше.
При этом он может быть даже выгоднее предыдущего метода, хотя бы потому, что не нужно запоминать позицию, на которой мы остановились при обходе дерева, т.е можно взять верхний элемент -> восстановить дерево -> проделать некоторые операции -> взять следующий элемент и т.п.
Обходить же дерево удобно сразу целиком, либо какую-то его большую часть.Кроме того, самой структура дерева выбора также может быть полезна.
Однако, нужно учесть, что памяти для дерева выбора нужно на 2n-1 элементов (элемент = ключ + указатели), в отличие от n элементов для простого дерева.
Пример использования выбора с замещением можно увидеть в многофазной сортировке (см соответствующий вопрос). Элементы обоих 'древесных' сортировок также используются в смежных

        1.10. Рекурсия или цикл. Избавление от рекурсии
Программисты находятся в постоянном поиске наиболее продуктивных способов повышения производительности приложений. И хотя большинству программистов известны концепции циклов и рекурсии, многие используют лишь один из этих методов, не задумываясь о том, насколько можно повысить производительность, выбрав оптимальный подход. На самом деле даже небольшое изменение может оказать значительное влияние на производительность приложений.

            16.1.2. Рекурсия
Рекурсией в программировании называется метод, вызывающий сам себя. Несмотря на простоту определения, этот подход достаточно сложен для понимания, поскольку человеку не свойственен подобный стиль мышления. Более того, существуют рекурсии разных типов, что вносит еще большую путаницу. Чаще всего применяются рекурсии следующих двух типов:
Головная рекурсия— рекурсивный вызов выполняется ближе к началу метода и является одним из первых обрабатываемых объектов. Поскольку он вызывает сам себя, ему приходится полагаться на результаты предыдущей операции, помещенной в стек вызовов. Из-за использования стека вызовов существует вероятность переполнения стека, если стек вызовов недостаточно велик.
Концевая рекурсия— рекурсивный вызов выполняется в конце и является последней строкой обрабатываемого кода. Этот метод не использует стек вызовов независимо от глубины рекурсии.
В математике рекурсия распространена достаточно широко, поэтому проще будет объяснить ее на примере рекурсивного вызова. Выражение 5! (факториал числа 5) можно записать следующим способом:

5!
5 * 4!
5 * 4 * 3!
5 * 4 * 3 * 2!
5 * 4 * 3 * 2 * 1!
5 * 4 * 3 * 2 * 1

В листинге 1 приведен пример вычисления 5! с помощью головной рекурсии.

	public long getFactorial(long currNum) {
		if (currNum == 1)
			return 1;

		return currNum * getFactorial(currNum - 1);
	}

В этом случае рекурсивные вызовы не используют стек вызовов для хранения информации, необходимой для расчета факториала. Вместо этого они передают результат предыдущему вызову.

getFactorial(5,0)
getFactorial(4,5)
getFactorial(3,20)
getFactorial(2,60)
getFactorial(1,120)
getFactorial(0,120)
120

            16.1.3. Цикл
Языки программирования предоставляют циклы нескольких разных типов, очень хорошо знакомых большинству программистов. В языке программирования Java, C имеются циклы for, do и while. Цикл — это многократное исполнение нескольких операторов. Циклы не заносят данные в стек вызовов независимо от числа исполнений цикла. Важным отличием циклов от рекурсивных функций является тот факт, что циклы используют для подсчета числа исполнений итератор, а рекурсивные функции для определения момента выхода должны выполнять сравнение результатов. Другим важным отличием является возможность применения в циклах фильтров и прочих селекторов. Примером такой ситуации может служить цикл foreach.

            16.1.4. Контрольные примеры
Приведенные ниже контрольные примеры запускались в 64-разрядной среде исполнения IBM Java Runtime Environment (JRE) 7.0.4.0 (с аргументом командной строки -Xms256m -Xmx256m -Dcom.ibm.tools.attach.enable=no). Чтобы среда исполнения не тратила время на расширение и сжатие кучи, JRE запускалась с фиксированным размером кучи 256 МБ. Отключение API Attach не позволяет JRE запускать приложения-агенты (обычно используемые для мониторинга), что нормализует производительность в каждом тесте. При увеличении стека вызовов для инициализации стека и поддержания его на уровне 3 МБ использовался аргумент командной строки -Xss3m -Xssi3m.

    17. Вычисление суммы
При суммировании чисел цикл показал значительно более высокую производительность, а концевая рекурсия оказалась быстрее головной. При увеличении стека вызовов Java до 3 МБ головная рекурсия сравнялась по скорости с концевой, но все же не смогла догнать цикл.



Рисунок 1. Вычисление суммы

    18. Вычисление факториала
Этот примечательный пример иллюстрирует зависимость результатов от используемых операторов. При использовании простого типа данных int лучшие результаты во всех случаях получились для цикла. Применение типа int ограничивает величину результата до 32-разрядного целого числа со знаком. Для больших факториалов можно использовать тип данных BigInteger, но такая конструкция будет более затратной. Результаты применения BigInteger показали, что использование головной рекурсии в паре с концевой обеспечивает лучшее быстродействие, чем чисто концевая рекурсия или цикл.

Неправильный русунок



Рисунок 2. Вычисление факториала

            18.1.1. Области применения рекурсии
Рекурсия является очень мощным инструментом программирования. Ее можно использовать для решения задач, которые более эффективно представляются рекурсией и могут использовать стек вызовов. Как правило, это относится к задачам сортировки, которые эффективно решаются с помощью рекурсии, обеспечивающей более высокую скорость, чем циклы.
В задаче, получившей название Ханойская башня, даны три стрежня и диски разного размера, которые в исходном состоянии надеты на первый стержень в виде башни. Задача состоит в том, чтобы перенести башню на другой стержень, при этом запрещается класть большой диск на маленький. Эту замечательную задачу можно легко решить с помощью рекурсии за 2n - 1 ходов, где n — число дисков.
Например, возьмем четыре диска и попытаемся перенести их со стержня A на стержень C, используя стержень B для временного хранения. С помощью описанной ниже рекурсивной функции это может быть выполнено за 15 ходов. Процесс решения можно визуализироватьэтим апплетом. Функция вызывается (2n * 2) – 1, или 31 раз. Причина, по которой число вызовов функции не равно числу ходов, кроется в том, что для обработки ходов необходимо установить стек вызовов. В этом примере используется головная рекурсия (листинг 4).

Листинг 4.

	private  static void solveTower(int num, int fromPeg, int toPeg,
		int tempPeg) {
		if (num > 0) {
			// move a disc from the fromPeg to the tempPeg
			solveTower(num - 1, fromPeg, tempPeg, toPeg);

			System.out.println("Disc moved from " + fromPeg + " to " + toPeg);

			// move disc from the tempPeg to the toPeg
			solveTower(num - 1, tempPeg, toPeg, fromPeg);
		}
	}

Результат для четырех дисков показан ниже



Ханойская башня — широко распространённая задача, которую можно решить с помощью рекурсии. Однако не все задачи столь очевидны, многие из них требуют времени на анализ и решение. Ханойскую башню можно решить и с помощью циклов, однако это потребует использования нескольких различных циклов и итераторов. Это решение будет работать дольше и потребует большего объема кода.
Ниже показан итерационный способ решения Ханойской башни. В этом примере использованы операции с битами, которые работают быстрей математических операций. За основу была взята эта программа на языке C.

Листинг 6.

	int  numMoves = (1 << numDiscs) - 1;
	int[] pegs = { 1, 2, 3, 1, 3, 2 };
	int  count = 0;

	for (int currMove = 1; currMove <= numMoves; currMove++) {
		int disc = 0;
		while ((currMove >> disc & 1) == 0) {
			disc++;
		}
		int level = (numDiscs - disc) & 1;
		int fromPeg = (currMove >> ++disc) % 3;
		fromPeg = pegs[fromPeg + (level * 3)];
		int toPeg = (fromPeg + level) % 3 + 1;
		System.out.println(++count + ". Disc moved from " + fromPeg + " to " + toPeg);
	}

Заключение
Хотя многим программистам привычнее работать с циклами, рекурсию также нельзя сбрасывать со счетов, особенно если она дает прирост производительности или позволяет выгодно использовать стек вызовов. Не всегда легко предсказать, какой метод даст лучшие результаты, поэтому обязательно нужно проводить тесты производительности. При использовании головной рекурсии также необходимо принимать во внимание размер стека.

Что предпочтительнее цикл или рекурсия?
На этот вопрос ответить непросто. Зачастую циклы дают лучшую производительность, чем рекурсивные вызовы, поскольку вызовы методов потребляют больше ресурсов, чем исполнение обычных операторов. В случае головной рекурсии стек вызовов разрастается, и его необходимо просматривать для получения конечного ответа. Тем не менее, это утверждение справедливо не всегда и зависит от типа решаемой задачи.

Аргументы для ответа
    • рекурсия - это правильный способ обработки данных, например, в некоторых функциях сортировки, в бинарных деревьях и т.д. Для задач (например, обход вложенных каталогов), когда при этом у каждого имеется ряд своих отдельных переменных (например, количество файлов в данном каталоге), или асинхронных потоков, то поддерживать легче будет рекурсию. Да и рекурсия в данном случае будет удобнее, потому что обход одного каталога совсем не зависит от результатов обхода другого соседнего каталога, и они могут работать параллельно, независимо друг от друга. А затем в конце просто объединяют все свои результаты.
    • рекурсия будет эффективна, если рекурсивная функция кешируемая, например, она запоминает результат и при следующем запросе просто возвращается кешированный вариант с циклом работать привычнее (проще), хотя кто-то владеет рекурсией лучше, чем циклом
    • создание и уничтожение кадров стека более дорого, чем простой переход.
    • вы всегда сможете усовершенствовать цикл и заставить его работать быстрее, чем рекурсивная функция, потому, что в цикле отсутствует постоянная настройка новых кадров стека
    • в цикле решать задачи, где результат следующего полностью зависит от результата предыдущего (например, факториал)
    • если мыслишь решение задачи как функциональную зависимость (пусть для того же факториала), то тебе поможет рекурсия. Она позволит отделить тебе одно вычисление от другого, которое опирается только на результат первого. Впрочем, если ты четко видишь, что именно следует делать с переменными предыдущей итерации, чтоб получить следующий результат, то цикл будет организовать проще.
    • Используй то, что более удобно. Если реализация очевидна в терминах цикла, не следует использовать рекурсию. И наоборот.
    • Если бы что-нибудь одно было предпочтительнее другого во всех случаях, этого другого бы не было.

Любой рекурсивный алгоритм может быть переписан без использования рекурсии. Заметим, что быстродействие алгоритмов при избавлении от рекурсии, как правило, повышается. Еще одной причиной чтобы избавиться от рекурсии является ограничение на объем хранимых программой локальных переменных и значений параметров одновременно выполняющихся процедур. При очень глубокой рекурсии этот объем возрастает, и программа перестает работать, выдавая ошибку «Stack overflow» (переполнение стека).
Так почему же люди продолжают пользоваться рекурсивными алгоритмами? Очевидно, потому что это проще и естественнее, чем соответствующие нерекурсивные решения. Тем не менее, знание о способах обойтись без рекурсии необходимо.
Ниже представлено несколько вариантов того, как это можно сделать.

            18.1.2. Явное использование стека
Стеком называется структура данных, в которой добавление и извлечение данных происходит с одного конца, называемого вершиной стека (рис. 13). Наглядным образом стека может служить стопка тарелок – добавлять или забрать тарелки можно только сверху. Каждая тарелка соответствует элементу данных.



Рис. 13. Наглядное представление стека. Push (проталкивание) – традиционное название для операции добавления данных в стек, Pop (выталкивание) – традиционное название для операции извлечения данных из стека.

Когда одна процедура или функция вызывает другую, то параметры первой процедуры, а также место, с которого ее выполнение должно продолжиться после того как отработает вызванная процедура (точка возврата), запоминаются в так называемом стеке вызовов. Если вызванная процедура в свою очередь чего-нибудь вызывает, то ее параметры и точка возврата также добавляются в стек.
При рекурсивных вызовах стек вызовов хранит цепочку из данных об одновременно работающих процедурах. Во всех продвинутых средах разработки эту цепочку вместе с запомненными параметрами процедур можно просмотреть во время отладки. Соответствующая команда обычно называется “Call Stack” (в Delphi ей соответствует сочетание клавиш Ctrl – Alt – S).
Универсальный способ избавиться от рекурсии – это самостоятельно запрограммировать те действия со стеком, которые фактически происходят, когда вы используете рекурсивные вызовы. Покажем, как это можно сделать, на примере дважды вызывающей себя рекурсивной процедуры.
Для начала реализуем в виде класса стек, хранящий параметры процедуры:

type
 //Запись для хранения параметров процедур
 Parameters = record
   //Список параметров
 end;

 //Стек удобно реализовать с помощью связанных списков
 //(http://www.tvd-home.ru/prog/16_4)
 PList = ^List;
 List = record
   Data: Parameters;
   Next: PList;
 end;

 //Описанный одновсязанный список соединим с методами
 //добавления и удаления элементов и получим стек.
 Stack = class
 private
   StackTop: PList;
 public
   //Добавление данных
   procedure Push(NewData: Parameters);
   //Извлечение данных
   function Pop: Parameters;
   //Проверка наличия данных
   function Empty: boolean;
 end;

implementation

//Добавление данных
procedure Stack.Push(NewData: Parameters);
var
 NewElement: PList;
begin
 New(NewElement);
 NewElement^.Data := NewData;
 NewElement^.Next := StackTop;
 StackTop := NewElement;
end;

//Извлечение данных
function Stack.Pop: Parameters;
var
 PopedElement: PList;
begin
 PopedElement := StackTop;
 StackTop := StackTop^.Next;
 Pop := PopedElement^.Data;
 Dispose(PopedElement);
end;

//Проверка наличия данных
function Stack.Empty: boolean;
begin
 Empty := StackTop = nil;
end;

Рассмотрим обобщенную рекурсивную процедуру с двумя вызовами самой себя.

procedure Recurs(P1: Parameters);
begin
 DoSomething(P1);
 if <условие> then
 begin
   P2 := F(P1);
   Recurs(P2);
   P3 := G(P1);
   Recurs(P3);
 end;
end;

В данной процедуре некоторые действия (DoSomething) выполняются много раз при разных значениях параметров. Нерекурсивный аналог должен хранить эти параметры в стеке. Каждый рекурсивный вызов будет соответствовать добавлению очередных параметров в стек. Вместо рекурсии появляется цикл, который выполняется, пока в стеке есть необработанные параметры.

procedure NonRecurs(P1: Parameters);
var
 S: Stack;
 P: Parameters;
begin
 S := Stack.Create;
 S.Push(P1);
 while not S.Empty do
 begin
   P1 := S.Pop;
   DoSomething(P1);
   if <условие> then
   begin
     P3 := G(P1);
     S.Push(P3);
     P2 := F(P1);
     S.Push(P2);
   end;
 end;
end;

Обратите внимание, что рекурсивные вызовы шли сначала для параметров P2, потом для P3. В нерекурсивной процедуре в стек отправляются сначала параметры P3, а только потом P2. Это связано с тем, что при рекурсивных вызовах в стек, по сути, отправляется недовыполненная часть процедуры, которая в нашем случае содержит вызов Recurs(P3).
Упомянутой выше перестановки можно избежать, если вместо стека использовать очередь – структуру данных, где добавление и извлечение элементов происходит с разных концов. Это будет некоторым отступлением от точной имитации процессов при рекурсивных вызовах. Однако в данном примере это кажется более удобным: каждый рекурсивный вызов будет прямо заменяться добавлением параметров в очередь.

            18.1.3. Запоминание последовательности рекурсивных вызовов
Как говорилось выше, рекурсивные вызовы образуют дерево, где каждый узел соответствует вызову одной процедуры. Последовательность выполнения этих процедур соответствует тому или иному алгоритму обхода узлов. Если требуется много раз обойти узлы одного и того же дерева, то можно один раз обойти их рекурсивно, запомнить количество и последовательность узлов, а затем, пользуясь этой информацией, обходить узлы уже нерекурсивно.
Например, обсуждалась задача вычисления арифметических выражений, заданных строкой. Может возникнуть ситуация, когда одно и то же выражение потребуется вычислить много раз при различных значениях переменной x. Синтаксическое дерево, которое требуется обходить при таких вычислениях, не зависит от x. Можно обойти его один раз, построив при этом массив, где каждый элемент будет соответствовать узлу дерева, а их последовательность – порядку обхода. Повторные вычисления при новом x потребуют только нерекурсивного перебора элементов массива.
Еще один пример такого запоминания в задаче о вычислении значений многомерных полиномов смотрите тут: http://tvd-home.ru/numerical/polynom.
Такой подход не избавляет нас от рекурсии полностью. Однако он позволяет ограничиться только одним обращением к рекурсивной процедуре, что может быть достаточно, если мотивом является забота о максимальной производительности.

            18.1.4. Определение узла дерева по его номеру
Идея данного подхода в том, чтобы заменить рекурсивные вызовы простым циклом, который выполнится столько раз, сколько узлов в дереве, образованном рекурсивными процедурами. Что именно будет делаться на каждом шаге, следует определить по номеру шага. Сопоставить номер шага и необходимые действия – задача не тривиальная и в каждом случае ее придется решать отдельно.
Например, пусть требуется выполнить k вложенных циклов по n шагов в каждом:

for i1 := 0 to n-1 do
 for i2 := 0 to n-1 do
   for i3 := 0 to n-1 do
     …

for (int i1 = 0; i1 <= n-1; i1++)
 for (int i2 = 0; i2 <= n-1; i2++)
   for (int i3 = 0; i3 <= n-1; i3++)
     …

Если k заранее неизвестно, то написать их явным образом, как показано выше невозможно. Используя прием, продемонстрированный в разделе 6.5 можно получить требуемое количество вложенных циклов с помощью рекурсивной процедуры:

procedure NestedCycles(Indexes: array of integer; n, k, depth: integer);
var
 i: integer;
begin
 if depth <= k then
   for i:=0 to n-1 do
   begin
     Indexes[depth] := i;
     NestedCycles(Indexes, n, k, depth + 1);
   end
 else
   DoSomething(Indexes);
end;

void NestedCycles(int array, int Indexes, int n, int k, int depth)
{
int i;
if(depth <= k)
 for(i=0; i<-=n-1; i++){
  Indexes[depth] = i;
  NestedCycles(Indexes, n, k, depth + 1);
 }
   DoSomething(Indexes);
}

Чтобы избавиться от рекурсии и свести все к одному циклу, обратим внимание, что если нумеровать шаги в системе счисления с основанием n, то каждый шаг имеет номер, состоящий из цифр i1, i2, i3, … или соответствующих значений из массива Indexes. То есть цифры соответствуют значениям счетчиков циклов. Номер шага в обычной десятичной системе счисления:



Всего шагов будет nk. Перебрав их номера в десятичной системе счисления и переведя каждый из них в систему с основанием n, получим значения индексов:

M := round(IntPower(n, k));
for i := 0 to M-1 do
begin
 Number := i;
 for p := 0 to k-1 do
 begin
   Indexes[k – p] := Number mod n;
   Number := Number div n;
 end;
 DoSomething(Indexes);
end;

M = round(IntPower(n, k));
for(i=0; i<-=M-1; i++){
Number = i;
for(p=0; i<-=k-1; p++){
 Indexes[k – p] = Number % n;
 Number = Number / n;
}
DoSomething(Indexes);
}

Еще раз отметим, что метод не универсален и под каждую задачу придется придумывать что-то свое.
Еще один замечательный пример - вычисление по номеру шага перекладываний в задаче о Ханойских башнях смотрите тут: http://algolist.manual.ru/maths/combinat/hanoi.php


        1.11. Контрольные вопросы
1. Определите, что сделают приведенные ниже рекурсивные процедуры и функции.
(а) Что напечатает приведенная ниже процедура при вызове Rec(4)?
1
2
3
4
5
6
7
procedure Rec(a: integer);
begin
 writeln(a);
 if a>0 then
   Rec(a-1);
 writeln(a);
end;
(б) Чему будет равно значение функции Nod(78, 26)?
1
2
3
4
5
6
7
8
9
10
function Nod(a, b: integer): integer;
begin
 if a > b then
   Nod := Nod(a – b, b)
 else
   if b > a then
     Nod := Nod(a, b – a)
   else
     Nod := a;
end;
(в) Что будет напечатано приведенными ниже процедурами при вызове A(1)?
1
2
3
4
5
6
7
8
9
10
11
12
13
14
procedure A(n: integer);
procedure B(n: integer);

procedure A(n: integer);
begin
   writeln(n);
   B(n-1);
end;
procedure B(n: integer);
begin
   writeln(n);
   if n < 5 then
     A(n+2);
end;
(г) Что напечатает нижеприведенная процедура при вызове BT(0, 1, 3)?
1
2
3
4
5
6
7
8
9
10
procedure BT(x: real; D, MaxD: integer);
begin
 if D = MaxD then
   writeln(x)
 else
 begin
   BT(x – 1, D + 1, MaxD);
   BT(x + 1, D + 1, MaxD);
 end;
end;
2. Уроборос – змей, пожирающий собственный хвост (рис. 14) в развернутом виде имеет длину L, диаметр около головы D, толщину брюшной стенки d. Определите, сколько хвоста он сможет в себя впихнуть и в сколько слоев после этого будет уложен хвост?

Рис. 14. Развернутый уроборос.
3. Для дерева на рис. 10а укажите последовательности посещения узлов при прямом, обратном и концевом порядке обхода.
4. Изобразите графически дерево, заданное с помощью вложенных скобок: (A(B(C, D), E), F, G).
5. Изобразите графически синтаксическое дерево для следующего арифметического выражения:

Запишите это выражение в обратной польской записи.
6. Для приведенного ниже графа (рис. 15) запишите матрицу смежности и матрицу инцидентности.

Рис. 15.
        1.12. Задачи
1. Вычислив факториал достаточно большое количество раз (миллион или больше), сравните эффективность рекурсивного и итерационного алгоритмов. Во сколько раз будет отличаться время выполнения и как это отношение будет зависеть от числа, факториал которого рассчитывается?
2. Напишите рекурсивную функцию, проверяющую правильность расстановки скобок в строке. При правильной расстановке выполняются условия:
  (а) количество открывающих и закрывающих скобок равно.
   (б) внутри любой пары открывающая – соответствующая закрывающая скобка, скобки расставлены правильно.
Примеры неправильной расстановки: )(, ())(, ())(() и т.п.
3. В строке могут присутствовать скобки как круглые, так и квадратные скобки. Каждой открывающей скобке соответствует закрывающая того же типа (круглой – круглая, квадратной- квадратная). Напишите рекурсивную функцию, проверяющую правильность расстановки скобок в этом случае.
Пример неправильной расстановки: ( [ ) ].
4. Число правильных скобочных структур длины 6 равно 5: ()()(), (())(), ()(()), ((())), (()()).
Напишите рекурсивную программу генерации всех правильных скобочных структур длины 2n.
Указание: Правильная скобочная структура минимальной длины «()». Структуры большей длины получаются из структур меньшей длины, двумя способами:
  (а) если меньшую структуру взять в скобки,
   (б) если две меньших структуры записать последовательно.
5. Создайте процедуру, печатающую все возможные перестановки для целых чисел от 1 до N.
6. Создайте процедуру, печатающую все подмножества множества {1, 2, …, N}.
7. Создайте процедуру, печатающую все возможные представления натурального числа N в виде суммы других натуральных чисел.
8. Создайте функцию, подсчитывающую сумму элементов массива по следующему алгоритму: массив делится пополам, подсчитываются и складываются суммы элементов в каждой половине. Сумма элементов в половине массива подсчитывается по тому же алгоритму, то есть снова путем деления пополам. Деления происходят, пока в получившихся кусках массива не окажется по одному элементу и вычисление суммы, соответственно, не станет тривиальным.
Замечание: Данный алгоритм является альтернативой приему накопления суммы. В случае вещественнозначных массивов он, обычно, позволяет получать меньшие погрешности округления.
9. Запрограммируйте быстрые методы сортировки массивов, описанные в разделе 6.4.
10. Создайте процедуру, рисующую кривую Коха (рис. 12).
11. Воспроизведите рис. 16. На рисунке на каждой следующей итерации окружности в 2.5 раза меньше (этот коэффициент можно сделать параметром).

Рис. 16.
        1.13. Литература
1. Д. Кнут. Искусство программирования на ЭВМ. т. 1. (раздел 2.3. «Деревья»).
2. Н. Вирт. Алгоритмы и структуры данных.
        1.14. Другие материалы на этом сайте
Близкие разделы учебника по программированию:
   Рекуррентные соотношения
    Рекурсивные структуры данных
Вычисление полиномов от нескольких переменных - еще один пример рекурсивного алгоритма.




1. Хеш-таблицы
1.1. Ключевые термины темы
1.2. Простое представление хеш-таблиц
1.3. Практическое применение хеш-таблиц
1.4. Алгоритмы хеширования данных
1.4.1. Таблица прямого доступа
1.4.2. Метод остатков от деления
1.4.3. Метод функции середины квадрата
1.4.4. Метод свертки
1.4.5. Открытое хеширование
1.4.6. Закрытое хеширование (открытая индексация)
1.5. Основные, наиболее часто используемые функции хэширования
1.6. Коллизи (они же столкновения)
1.6.1. Пример коллизий
1.6.2. Методы разрешения коллизий
1.6.3. Борьба с коллизиями
1.6.3.1. Метод цепочек
1.6.3.2. Открытая индексация (или закрытое хеширование)
1.6.4. Переполнение таблицы и рехеширование
1.6.5. Оценка качества хеш-функции
1.7. Организация данных для ускорения поиска по вторичным ключам
1.7.1. Инвертированные индексы
1.7.2. Битовые карты
1.8. Примеры
1.8.1. Пример 1
1.8.2. Пример 2.1
1.8.3. Пример 2.2
1.8.4. Пример 3.1
1.8.5. Пример 3.2
1.8.6. Лабораторная работа № 13. Хэш-таблицы c открытой адресацией
1.8.7. Лабораторная работа № 14. Хэш-таблицы c цепочками
1.9. Выводы
1.10. Для самостоятельной работы. Лабораторная работа ХХ. Алгоритмы хеширования данных

1. Хеш-таблицы
Среди всех структур данных, имеющихся в распоряжении у замечательной науки информатики, есть одна, которой многие люди восхищаются больше, чем другими. Это – хеш-таблица (Hash Table), несомненное достижение в области компьютерных наук. Практически все современные языки программирования имеют реализации хеш-таблиц в своих библиотеках. Чаще всего мы работаем с ними в виде словарей (или ассоциативных массивов), представляющих собой контейнеры множества пар ключ-значение.
Так как же устроены хеш-таблицы, почему они удобны, эффективны, и зачем нам или пользоваться? Здесь приводится краткое введение в хеш-таблицы для тех, кто не знает и по каким-то причинам не хочет или не может изучить классические труды. Одна из причин, побудивших написать этот текст, так это то, как показал опыт, что тема хеш-таблиц достаточно часто встречается в вопросах на собеседованиях.
Хеш-таблица (hash table) — это специальная структура данных для хранения пар ключей и их значений. По сути это ассоциативный массив, в котором ключ представлен в виде хеш-функции.

 

Хеш-таблица - динамическая структура данных, которая реализует интерфейс ассоциативного массива, то есть позволяет хранить пару <Ключ, Значение> и выполнять 3 операции: добавление новой пары, операции поиска, операции удаления по ключу.
Чтобы понять, что такое хеш-таблица, вспомним массив. Мы можем получить доступ к элементу с помощью его ключа, причем может быть такой случай, что есть ячейки содержащие элементы и есть не содержащие.
Существуют два основных варианта хеш-таблиц: с цепочками и открытой адресацией. Хеш-таблица содержит некоторый массив H, элементы которого есть пары (хеш-таблица с открытой адресацией) или списки пар (хеш-таблица с цепочками).
Выполнение операции в хеш-таблице начинается с вычисления хеш-функции от ключа. Получающееся хеш-значение I = hash(key) играет роль индекса в массиве H. Затем выполняемая операция (добавление, удаление или поиск) перенаправляется объекту, который хранится в соответствующей ячейке массива H[i].
Ситуация, когда для различных ключей получается одно и то же хеш-значение, называется коллизией. Такие события не так уж и редки — например, при вставке в хеш-таблицу размером 365 ячеек всего лишь 23-х элементов вероятность коллизии уже превысит 50% (если каждый элемент может равновероятно попасть в любую ячейку). Поэтому механизм разрешения коллизий — важная составляющая любой хеш-таблицы.
В некоторых специальных случаях удаётся избежать коллизий вообще. Например, если все ключи элементов известны заранее (или очень редко меняются), то для них можно найти некоторую совершенную хеш-функцию, которая распределит их по ячейкам хеш-таблицы без коллизий. Хеш-таблицы, использующие подобные хеш-функции, не нуждаются в механизме разрешения коллизий, и называются хеш-таблицами с прямой адресацией.
Число хранимых элементов, делённое на размер массива H (число возможных значений хеш-функции), называется коэффициентом заполнения хеш-таблицы (load factor) и является важным параметром, от которого зависит среднее время выполнения операций.
Для ускорения доступа к данным в таблицах можно использовать предварительное упорядочивание таблицы в соответствии со значениями ключей.
При этом могут быть использованы методы поиска в упорядоченных структурах данных, например, метод половинного деления, что существенно сокращает время поиска данных по значению ключа. Однако при добавлении новой записи требуется переупорядочить таблицу. Потери времени на повторное упорядочивание таблицы могут значительно превышать выигрыш от сокращения времени поиска. Поэтому для сокращения времени доступа к данным в таблицах используется так называемое случайное упорядочивание или хеширование. При этом данные организуются в виде таблицы при помощи хеш-функции h, используемой для вычисления адреса по значению ключа.
 
Рис.3.1. Хеш-таблица

Идеальной хеш-функцией является такая hash-функция, которая для любых двух неодинаковых ключей дает неодинаковые адреса.

 

Подобрать такую функцию можно в случае, если все возможные значения ключей заранее известны. Такая организация данных носит название совершенное хеширование. В случае заранее неопределенного множества значений ключей и ограниченной длины таблицы подбор совершенной функции затруднителен. Поэтому часто используют хеш-функции, которые не гарантируют выполнение условия.
Рассмотрим пример реализации алгоритма несовершенной хеш-функции. Предположим, что ключ состоит из четырех символов. При этом таблица имеет диапазон адресов от 0 до 10000.

long MyHashFunction(char key[4])
{
	long f;
	//ключ по коду ASCII для каждого символа
	//вычисление функции по значению ключа
	f = (int)key[1] - (int)key[2] + (int)key[3] - (int)key[4];
	//совмещение начала области значений функции с начальным
	//адресом хеш-таблицы (a=1)
	f = f + 255 * 2;
	//совмещение конца области значений функции с конечным адресом
	//хеш-таблицы (a=10 000)
	f = (f * 10000) / (255 * 4); //целочисленное деление (div)
	return(hash = f);
}

При заполнении таблицы возникают ситуации, когда для двух неодинаковых ключей функция вычисляет один и тот же адрес. Данный случай носит название коллизия, а такие ключи называются ключи-синонимы.

1.1. Ключевые термины темы
Хеширование – это преобразование входного массива данных определенного типа и произвольной длины в выходную битовую строку фиксированной длины.
Хеш-таблица – это структура данных, реализующая интерфейс ассоциативного массива, то есть она позволяет хранить пары вида "ключ- значение" и выполнять три операции: операцию добавления новой пары, операцию поиска и операцию удаления пары по ключу.
Коэффициент заполнения хеш-таблицы – это количество хранимых элементов массива, деленное на число возможных значений хеш-функции.
Первичные ключи – это ключи, позволяющие однозначно идентифицировать запись.
Вторичные ключи – это ключи, не позволяющие однозначно идентифицировать запись в таблице.
Пространство ключей – это множество всех теоретически возможных значений ключей записи.
Пространство записей – это множество тех ячеек памяти, которые выделяются для хранения таблицы.
Хеш-таблицы с прямой адресацией – это хеш-таблицы, использующие инъективные хеш-функции и не нуждающиеся в механизме разрешения коллизий.
Синонимы – это совпадающие ключи в хеш-таблице.
Коллизия – это ситуация, когда разным ключам соответствует одно значение хеш-функции.
Закрытое хеширование или Метод открытой адресации – это технология разрешения коллизий, которая предполагает хранение записей в самой хеш-таблице.
Открытое хеширование или Метод цепочек – это технология разрешения коллизий, которая состоит в том, что элементы множества с равными хеш-значениями связываются в цепочку-список.
Повторное хеширование – это поиск местоположения для очередного элемента таблицы с учетом шага перемещения.

1.2. Простое представление хеш-таблиц
Чтобы разобраться, что такое хеш-таблицы, представьте, что вас попросили создать библиотеку и заполнить ее книгами. Но вы не хотите заполнять шкафы в произвольном порядке.
Первое, что приходит в голову — разместить все книги в алфавитном порядке и записать все в некий справочник. В этом случае не придется искать нужную книгу по всей библиотеке, а только по справочнику.
А можно сделать еще удобнее. Если изначально отталкиваться от названия книги или имени автора, то лучше использовать некий алгоритм хеширования, который обрабатывает входящее значение и выдает номер шкафа и полки для нужной книги.
Зная этот алгоритм хэширования, вы быстро найдете нужную книгу по ее названию.
Учтите, что хеш-функция должна иметь следующие свойства:
•	Всегда возвращать один и тот же адрес для одного и того же ключа;
•	Не обязательно возвращает разные адреса для разных ключей;
•	Использует все адресное пространство с одинаковой вероятностью;
•	Быстро вычислять адрес.

Пример:
Каждой строке соответствует индекс равный (n=длина строки-1). Например: строка "Alex" индекс 3. Вот так можно записать строки.
•	Хеш функция у нас будет: Hash_Func(string)=Strlen(string) (то есть вычисление длины).
•	Доступ к массиву мы получаем вот так: Mas[Hash_Func(string)].

length	value
2	"joe"
3	"Alex"
4	"Pavel"

Но! вот в чем беда! Если мы хотим вставить еще 1 имя, например "Petr", то этому имени будет соответствовать ОДИН И ТОТ ЖЕ КЛЮЧ 3, который является индексом 3. Это называется Коллизией, когда один и тот же ключ указывает на несколько значений ключа.
Иллюстрация коллизии (2 ключа относятся к одной и той же ячейки массива, ключи k2 и k3):

 

Разрешение случаев с коллизией является важной задачей Computer Science. Решениями проблемы являются:
•	Метод цепочек (открытое хеширование).
•	Метод открытой адресации (закрытое хеширование).

1.3. Практическое применение хеш-таблиц
Хеш-таблицы имеют очень большое практическое применение:
•	Для поиска информации о водителе лишь по его номеру в водительском удостоверении.
•	Таблица символов компилятора. Хеширование является методом ускорения поиска. Компилятор встречает некоторую лексему (Лексема — последовательность допустимых символов языка программирования, имеющая смысл для транслятора)  и пытается найти ее в своей базе данных или таблице символических имен. Таблица символических имен современного компилятора в MS Windows может содержать несколько тысяч или десятков тысяч лексем. Для ускорения поиска был придуман следующий прием. Компилятор, найдя лексему в тексте программы, определяет ее хеш-ключ. Наша лексема — это просто слово, состоящее из последовательности кодов символов. Для определения хеш-кода следует сложить все коды символов. Лексем с таким хеш-кодом в базе данных уже значительно меньше. Компилятор определяет номер списка с заданным кодом и перебирает этот список, а не всю базу данных.
•	При программировании шахмат тоже используется хеширование. Основная особенность состоит в том, что хеш-индекс должен очень точно отражать позицию, и поиск должен производиться максимально быстро. У нас даже нет времени на перебор списков с одним индексом. Списков, как правило, нет вообще. Для каждого значения хеш-ключа существует только одна позиция. Если возникла коллизия и встретилась позиция с таким же ключом, то она записывается поверх прежней. Зачем при программировании шахмат и других подобных игр хеширование и запоминание позиций? Дело в том, что при переборе мы имеем не дерево игры в прямом смысле, а граф. Позиции повторяются через некоторое количество полуходов, и даже в одну и ту же позицию можно прийти различными путями. Можно воспользоваться некоторой информацией о позиции, которая уже встречалась. Самое простое и эффективное — это использовать позицию, чтобы улучшить порядок ходов. Это особенно выразительно при итеративных углублениях. Улучшение упорядочивания ходов — основное назначение хеш-таблицы. Перестановки или повторы позиций тоже играют свою роль. Особенно их много в конце игры.
•	Для баз данных телефонных номеров.
•	Каталог книг.
•	Для хранения паролей пользователей.
•	Браузер хранит адреса посещенных страниц в хеш-таблице.

1.4. Алгоритмы хеширования данных
Существует ГОСУДАРСТВЕННЫЙ СТАНДАРТ РЕСПУБЛИКИ БЕЛАРУСЬ СТБ 34.101.77-2016 «Информационные технологии и безопасность. АЛГОРИТМЫ ХЭШИРОВАНИЯ»

Процесс поиска данных в больших объемах информации сопряжен с временными затратами, которые обусловлены необходимостью просмотра и сравнения с ключом поиска значительного числа элементов. Сокращение поиска возможно осуществить путем локализации области просмотра. Например, отсортировать данные по ключу поиска, разбить на непересекающиеся блоки по некоторому групповому признаку или поставить в соответствие реальным данным некий код, который упростит процедуру поиска.
В настоящее время используется широко распространенный метод обеспечения быстрого доступа к информации, хранящейся во внешней памяти – хеширование.
Хеширование (или хэширование, англ. hashing ) – это преобразование входного массива данных определенного типа и произвольной длины в выходную битовую строку фиксированной длины. Такие преобразования также называются хеш-функциями или функциями свертки, а их результаты называют хешем, хеш-кодом, хеш-таблицей или дайджестом сообщения (англ. message digest ).
Хеш-таблица – это структура данных, реализующая интерфейс ассоциативного массива, то есть она позволяет хранить пары вида "ключ- значение" и выполнять три операции: операцию добавления новой пары, операцию поиска и операцию удаления пары по ключу. Хеш-таблица является массивом, формируемым в определенном порядке хеш-функцией.
Принято считать, что хорошей, с точки зрения практического применения, является такая хеш-функция, которая удовлетворяет следующим условиям:
•	функция должна быть простой с вычислительной точки зрения;
•	функция должна распределять ключи в хеш-таблице наиболее равномерно;
•	функция не должна отображать какую-либо связь между значениями ключей в связь между значениями адресов;
•	функция должна минимизировать число коллизий – то есть ситуаций, когда разным ключам соответствует одно значение хеш-функции (ключи в этом случае называются синонимами ).

При этом первое свойство хорошей хеш-функции зависит от характеристик компьютера, а второе – от значений данных.
Если бы все данные были случайными, то хеш-функции были бы очень простые (например, несколько битов ключа). Однако на практике случайные данные встречаются достаточно редко, и приходится создавать функцию, которая зависела бы от всего ключа. Если хеш-функция распределяет совокупность возможных ключей равномерно по множеству индексов, то хеширование эффективно разбивает множество ключей. Наихудший случай – когда все ключи хешируются в один индекс.
При возникновении коллизий необходимо найти новое место для хранения ключей, претендующих на одну и ту же ячейку хеш-таблицы. Причем, если коллизии допускаются, то их количество необходимо минимизировать. В некоторых специальных случаях удается избежать коллизий вообще. Например, если все ключи элементов известны заранее (или очень редко меняются), то для них можно найти некоторую инъективную хеш-функцию, которая распределит их по ячейкам хеш-таблицы без коллизий. Хеш-таблицы, использующие подобные хеш-функции, не нуждаются в механизме разрешения коллизий, и называются хеш-таблицами с прямой адресацией.
Хеш-таблицы должны соответствовать следующим свойствам.
•	Выполнение операции в хеш-таблице начинается с вычисления хеш-функции от ключа. Получающееся хеш-значение является индексом в исходном массиве.
•	Количество хранимых элементов массива, деленное на число возможных значений хеш-функции, называется коэффициентом заполнения хеш-таблицы ( load factor ) и является важным параметром, от которого зависит среднее время выполнения операций.
•	Операции поиска, вставки и удаления должны выполняться в среднем за время O(1). Однако при такой оценке не учитываются возможные аппаратные затраты на перестройку индекса хеш-таблицы, связанную с увеличением значения размера массива и добавлением в хеш-таблицу новой пары.
•	Механизм разрешения коллизий является важной составляющей любой хеш-таблицы.

Хеширование полезно, когда широкий диапазон возможных значений должен быть сохранен в малом объеме памяти, и нужен способ быстрого, практически произвольного доступа. Хэш-таблицы часто применяются в базах данных, и, особенно, в языковых процессорах типа компиляторов и ассемблеров, где они повышают скорость обработки таблицы идентификаторов. В качестве использования хеширования в повседневной жизни можно привести примеры распределение книг в библиотеке по тематическим каталогам, упорядочивание в словарях по первым буквам слов, шифрование специальностей в вузах и т.д.

Существует несколько типов функций хеширования, каждая из которых имеет свои преимущества и недостатки и основана на представлении данных. Приведем обзор и анализ некоторых наиболее простых из применяемых на практике хеш-функций.

1.4.1. Таблица прямого доступа
Простейшей организацией таблицы, обеспечивающей идеально быстрый поиск, является таблица прямого доступа. В такой таблице ключ является адресом записи в таблице или может быть преобразован в адрес, причем таким образом, что никакие два разных ключа не преобразуются в один и тот же адрес. При создании таблицы выделяется память для хранения всей таблицы и заполняется пустыми записями. Затем записи вносятся в таблицу – каждая на свое место, определяемое ее ключом. При поиске ключ используется как адрес и по этому адресу выбирается запись. Если выбранная запись пустая, то записи с таким ключом вообще нет в таблице. Таблицы прямого доступа очень эффективны в использовании, но, к сожалению, область их применения весьма ограничена.
Назовем пространством ключей множество всех теоретически возможных значений ключей записи. Назовем пространством записей множество тех ячеек памяти, которые выделяются для хранения таблицы. Таблицы прямого доступа применимы только для таких задач, в которых размер пространства записей может быть равен размеру пространства ключей. В большинстве реальных задач размер пространства записей много меньше, чем пространства ключей. Так, если в качестве ключа используется фамилия, то, даже ограничив длину ключа десятью символами кириллицы, получаем 3310 возможных значений ключей. Даже если ресурсы вычислительной системы и позволят выделить пространство записей такого размера, то значительная часть этого пространства будет заполнена пустыми записями, так как в каждом конкретном заполнении таблицы фактическое множество ключей не будет полностью покрывать пространство ключей.
В целях экономии памяти можно назначать размер пространства записей равным размеру фактического множества записей или превосходящим его незначительно. В этом случае необходимо иметь некоторую функцию, обеспечивающую отображение точки из пространства ключей в точку в пространстве записей, то есть, преобразование ключа в адрес записи: a=h(k), где a – адрес, k – ключ.
Идеальной хеш-функцией является инъективная функция, которая для любых двух неодинаковых ключей дает неодинаковые адреса.

1.4.2. Метод остатков от деления
Простейшей хеш-функцией является деление по модулю числового значения ключа Key на размер пространства записи HashTableSize. Результат интерпретируется как адрес записи. Следует иметь в виду, что такая функция хорошо соответствует первому, но плохо – последним трем требованиям к хеш-функции и сама по себе может быть применена лишь в очень ограниченном диапазоне реальных задач. Однако операция деления по модулю обычно применяется как последний шаг в более сложных функциях хеширования, обеспечивая приведение результата к размеру пространства записей.
Если ключей меньше, чем элементов массива, то в качестве хеш-функции можно использовать деление по модулю, то есть остаток от деления целочисленного ключа Key на размерность массива HashTableSize, то есть:

Key % HashTableSize

Данная функция очень проста, хотя и не относится к хорошим. Вообще, можно использовать любую размерность массива, но она должна быть такой, чтобы минимизировать число коллизий. Для этого в качестве размерности лучше использовать простое число. В большинстве случаев подобный выбор вполне удовлетворителен. Для символьной строки ключом может являться остаток от деления, например, суммы кодов символов строки на HashTableSize.
На практике, метод деления – самый распространенный.

//функция создания хеш-таблицы метод деления по модулю
int Hash(int Key, int HashTableSize) {
//HashTableSize
    return Key % HashTableSize;
}

1.4.3. Метод функции середины квадрата
Следующей хеш-функцией является функция середины квадрата. Значение ключа преобразуется в число, это число затем возводится в квадрат, из него выбираются несколько средних цифр и интерпретируются как адрес записи.

1.4.4. Метод свертки
Еще одной хеш-функцией можно назвать функцию свертки. Цифровое представление ключа разбивается на части, каждая из которых имеет длину, равную длине требуемого адреса. Над частями производятся определенные арифметические или поразрядные логические операции, результат которых интерпретируется как адрес. Например, для сравнительно небольших таблиц с ключами – символьными строками неплохие результаты дает функция хеширования, в которой адрес записи получается в результате сложения кодов символов, составляющих строку-ключ.
В качестве хеш-функции также применяют функцию преобразования системы счисления. Ключ, записанный как число в некоторой системе счисления P, интерпретируется как число в системе счисления Q>P. Обычно выбирают Q=P+1. Это число переводится из системы Q обратно в систему P, приводится к размеру пространства записей и интерпретируется как адрес.

1.4.5. Открытое хеширование
Основная идея базовой структуры при открытом (внешнем) хешировании заключается в том, что потенциальное множество (возможно, бесконечное) разбивается на конечное число классов. Для В классов, пронумерованных от 0 до В-1, строится хеш-функция h(x) такая, что для любого элемента х исходного множества функция h(x) принимает целочисленное значение из интервала 0,1,...,В-1, соответствующее классу, которому принадлежит элемент х. Часто классы называют сегментами, поэтому будем говорить, что элемент х принадлежит сегменту h(x). Массив, называемый таблицей сегментов и проиндексированный номерами сегментов 0,1,...,В-1, содержит заголовки для B списков. Элемент х, относящийся к i -му списку – это элемент исходного множества, для которого h(x)=i.
Если сегменты примерно одинаковы по размеру, то в этом случае списки всех сегментов должны быть наиболее короткими при данном числе сегментов. Если исходное множество состоит из N элементов, тогда средняя длина списков будет N/B элементов. Если можно оценить величину N и выбрать В как можно ближе к этой величине, то в каждом списке будет один или два элемента. Тогда время выполнения операторов словарей будет малой постоянной величиной, не зависящей от N.

Пример 1. Программная реализация открытого хеширования.

#include <iostream>
#include <fstream>
using namespace std;

typedef int T;  // тип элементов
typedef int hashTableIndex; // индекс в хеш-таблице
#define compEQ(a,b) (a == b)
typedef struct Node_ {
       T data;// данные, хранящиеся в вершине
       struct Node_ *next; // следующая вершина
} Node;

Node **hashTable;
int hashTableSize;
hashTableIndex myhash(T data);
Node *insertNode(T data);
void deleteNode(T data);
Node *findNode (T data);

int main()
{
  int i, *a, maxnum;
  setlocale(LC_ALL, "rus");
  cout << "Введите количество элементов maxnum : ";
  cin >> maxnum;
  cout << "Введите размер хеш-таблицы HashTableSize : ";
  cin >> hashTableSize;
  a = new int[maxnum];
  hashTable = new Node*[hashTableSize];
  for (i = 0; i < hashTableSize; i++)
    hashTable[i] = NULL;
  // генерация массива
  for (i = 0; i < maxnum; i++)
    a[i] = rand();
  // заполнение хеш-таблицы элементами массива
  for (i = 0; i < maxnum; i++) {
    insertNode(a[i]);
  }
  // поиск элементов массива по хеш-таблице
  for (i = maxnum-1; i >= 0; i--) {
    findNode(a[i]);
  }
  // вывод элементов массива в файл List.txt
  ofstream out("List.txt");
  for (i = 0; i < maxnum; i++){
    out << a[i];
    if ( i < maxnum - 1 ) out << "\t";
  }
  out.close();
  // сохранение хеш-таблицы в файл HashTable.txt
  out.open("HashTable.txt");
  for (i = 0; i < hashTableSize; i++){
    out << i << "  :  ";
    Node *Temp = hashTable[i];
    while ( Temp ){
      out << Temp->data << " -> ";
      Temp = Temp->next;
    }
    out << endl;
  }
  out.close();
  // очистка хеш-таблицы
    for (i = maxnum-1; i >= 0; i--) {
        deleteNode(a[i]);
    }
  system("pause");
  return 0;
}

// хеш-функция размещения вершины
hashTableIndex myhash(T data) {
  return (data % hashTableSize);
}

// функция поиска местоположения и вставки вершины в таблицу
Node *insertNode(T data) {
  Node *p, *p0;
  hashTableIndex bucket;
  // вставка вершины в начало списка
  bucket = myhash(data);
  if ((p = new Node) == 0) {
    fprintf (stderr, "Нехватка памяти (insertNode)\n");
    exit(1);
  }
  p0 = hashTable[bucket];
  hashTable[bucket] = p;
  p->next = p0;
  p->data = data;
  return p;
}

//функция удаления вершины из таблицы
void deleteNode(T data) {
  Node *p0, *p;
  hashTableIndex bucket;
  p0 = 0;
  bucket = myhash(data);
  p = hashTable[bucket];
  while (p && !compEQ(p->data, data)) {
    p0 = p;
    p = p->next;
  }
  if (!p) return;
  if (p0)
    p0->next = p->next;
  else
    hashTable[bucket] = p->next;
  free (p);
}

// функция поиска вершины со значением data
Node *findNode (T data) {
  Node *p;
  p = hashTable[myhash(data)];
  while (p && !compEQ(p->data, data))
    p = p->next;
  return p;
}

 

List.txt (элементы массива)

 

HashTable. txt (хеш-таблица)

 

1.4.6. Закрытое хеширование (открытая индексация)
При закрытом (внутреннем) хешировании в хеш-таблице хранятся непосредственно сами элементы, а не заголовки списков элементов. Поэтому в каждой записи (сегменте) может храниться только один элемент. При закрытом хешировании применяется методика повторного хеширования. Если осуществляется попытка поместить элемент х в сегмент с номером h(х), который уже занят другим элементом (коллизия), то в соответствии с методикой повторного хеширования выбирается последовательность других номеров сегментов h1(х), h2(х), .., куда можно поместить элемент х. Каждое из этих местоположений последовательно проверяется, пока не будет найдено свободное. Если свободных сегментов нет, то, следовательно, таблица заполнена, и элемент х добавить нельзя.
При поиске элемента х необходимо просмотреть все местоположения h(x),h1(х),h2(х),..., пока не будет найден х или пока не встретится пустой сегмент. Чтобы объяснить, почему можно остановить поиск при достижении пустого сегмента, предположим, что в хеш-таблице не допускается удаление элементов. Пусть h3(х) – первый пустой сегмент. В такой ситуации невозможно нахождение элемента х в сегментах h4(х), h5(х) и далее, так как при вставке элемент х вставляется в первый пустой сегмент, следовательно, он находится где-то до сегмента h3(х). Но если в хеш-таблице допускается удаление элементов, то при достижении пустого сегмента, не найдя элемента х, нельзя быть уверенным в том, что его вообще нет в таблице, так как сегмент может стать пустым уже после вставки элемента х. Поэтому, чтобы увеличить эффективность данной реализации, необходимо в сегмент, который освободился после операции удаления элемента, поместить специальную константу, которую назовем, например, DEL. В качестве альтернативы специальной константе можно использовать дополнительное поле таблицы, которое показывает состояние элемента. Важно различать константы DEL и NULL – последняя находится в сегментах, которые никогда не содержали элементов. При таком подходе выполнение поиска элемента не требует просмотра всей хеш-таблицы. Кроме того, при вставке элементов сегменты, помеченные константой DEL, можно трактовать как свободные, таким образом, пространство, освобожденное после удаления элементов, можно рано или поздно использовать повторно. Но если невозможно непосредственно сразу после удаления элементов пометить освободившиеся сегменты, то следует предпочесть закрытому хешированию схему открытого хеширования.

1.4.6.1. Повторное хеширование
Существует несколько методов повторного хеширования, то есть определения местоположений h(x), h1(х), h2(х),...:
•	линейное опробование;
•	квадратичное опробование;
•	двойное хеширование.

Линейное опробование сводится к последовательному перебору сегментов таблицы с некоторым фиксированным шагом:

адрес=h(x)+ci,

где i – номер попытки разрешить коллизию;
c – константа, определяющая шаг перебора.
При шаге, равном единице, происходит последовательный перебор всех сегментов после текущего. Квадратичное опробование отличается от линейного тем, что шаг перебора сегментов нелинейно зависит от номера попытки найти свободный сегмент:

адрес=h(x)+ci+di2,

где i – номер попытки разрешить коллизию,
c и d – константы.

Благодаря нелинейности такой адресации уменьшается число проб при большом числе ключей-синонимов. Однако даже относительно небольшое число проб может быстро привести к выходу за адресное пространство небольшой таблицы вследствие квадратичной зависимости адреса от номера попытки.
Еще одна разновидность метода открытой адресации, которая называется двойным хешированием, основана на нелинейной адресации, достигаемой за счет суммирования значений основной и дополнительной хеш-функций:

адрес=h(x)+ih2(x).

Очевидно, что по мере заполнения хеш-таблицы будут происходить коллизии, и в результате их разрешения очередной адрес может выйти за пределы адресного пространства таблицы. Чтобы это явление происходило реже, можно пойти на увеличение длины таблицы по сравнению с диапазоном адресов, выдаваемым хеш-функцией. С одной стороны, это приведет к сокращению числа коллизий и ускорению работы с хеш-таблицей, а с другой – к нерациональному расходованию памяти. Даже при увеличении длины таблицы в два раза по сравнению с областью значений хеш-функции нет гарантии того, что в результате коллизий адрес не превысит длину таблицы. При этом в начальной части таблицы может оставаться достаточно свободных сегментов. Поэтому на практике используют циклический переход к началу таблицы.
Однако в случае многократного превышения адресного пространства и, соответственно, многократного циклического перехода к началу будет происходить просмотр одних и тех же ранее занятых сегментов, тогда как между ними могут быть еще свободные сегменты. Более корректным будет использование сдвига адреса на 1 в случае каждого циклического перехода к началу таблицы. Это повышает вероятность нахождения свободных сегментов.
В случае применения схемы закрытого хеширования скорость выполнения вставки и других операций зависит не только от равномерности распределения элементов по сегментам хеш-функцией, но и от выбранной методики повторного хеширования (опробования) для разрешения коллизий, связанных с попытками вставки элементов в уже заполненные сегменты. Например, методика линейного опробования для разрешения коллизий – не самый лучший выбор.
Как только несколько последовательных сегментов будут заполнены, образуя группу, любой новый элемент при попытке вставки в эти сегменты будет вставлен в конец этой группы, увеличивая тем самым длину группы последовательно заполненных сегментов. Другими словами, для поиска пустого сегмента в случае непрерывного расположения заполненных сегментов необходимо просмотреть больше сегментов, чем при случайном распределении заполненных сегментов. Отсюда также следует очевидный вывод, что при непрерывном расположении заполненных сегментов увеличивается время выполнения вставки нового элемента и других операций.

Пример 2. Программная реализация закрытого хеширования.

#include <iostream>
#include <fstream>
using namespace std;

typedef int T;  // тип элементов
typedef int hashTableIndex;// индекс в хеш-таблице
int hashTableSize;
T *hashTable;
bool *used;

hashTableIndex myhash(T data);
void insertData(T data);
void deleteData(T data);
bool findData (T data);
int dist (hashTableIndex a,hashTableIndex b);

int main(){
  int i, *a, maxnum;
  setlocale(LC_ALL, "rus");
  cout << "Введите количество элементов maxnum : ";
  cin >> maxnum;
    cout << "Введите размер хеш-таблицы hashTableSize : ";
  cin >> hashTableSize;
  a = new int[maxnum];
  hashTable = new T[hashTableSize];
  used = new bool[hashTableSize];
  for (i = 0; i < hashTableSize; i++){
    hashTable[i] = 0;
    used[i] = false;
  }
  // генерация массива
  for (i = 0; i < maxnum; i++)
    a[i] = rand();
  // заполнение хеш-таблицы элементами массива
  for (i = 0; i < maxnum; i++)
    insertData(a[i]);
  // поиск элементов массива по хеш-таблице
  for (i = maxnum-1; i >= 0; i--)
    findData(a[i]);
  // вывод элементов массива в файл List.txt
  ofstream out("List.txt");
  for (i = 0; i < maxnum; i++){
    out << a[i];
    if ( i < maxnum - 1 ) out << "\t";
  }
  out.close();
  // сохранение хеш-таблицы в файл HashTable.txt
  out.open("HashTable.txt");
  for (i = 0; i < hashTableSize; i++){
    out << i << "  :  " << used[i] << " : " << hashTable[i] << endl;
  }
  out.close();
  // очистка хеш-таблицы
  for (i = maxnum-1; i >= 0; i--) {
    deleteData(a[i]);
  }
  system("pause");
  return 0;
}

// хеш-функция размещения величины
hashTableIndex myhash(T data) {
    return (data % hashTableSize);
}

// функция поиска местоположения и вставки величины в таблицу
void insertData(T data) {
  hashTableIndex bucket;
    bucket = myhash(data);
  while  ( used[bucket] && hashTable[bucket] != data)
    bucket = (bucket + 1) % hashTableSize;
  if ( !used[bucket] ) {
    used[bucket] = true;
    hashTable[bucket] = data;
  }
}

// функция поиска величины, равной data
bool findData (T data) {
  hashTableIndex bucket;
  bucket = myhash(data);
  while ( used[bucket] && hashTable[bucket] != data )
    bucket = (bucket + 1) % hashTableSize;
  return used[bucket] && hashTable[bucket] == data;
}

//функция удаления величины из таблицы
void deleteData(T data){
  int bucket, gap;
  bucket = myhash(data);
  while ( used[bucket] && hashTable[bucket] != data )
    bucket = (bucket + 1) % hashTableSize;
  if ( used[bucket] && hashTable[bucket] == data ){
    used[bucket] = false;
    gap = bucket;
    bucket = (bucket + 1) % hashTableSize;
    while ( used[bucket] ){
      if ( bucket == myhash(hashTable[bucket]) )
        bucket = (bucket + 1) % hashTableSize;
      else if ( dist(myhash(hashTable[bucket]),bucket) < dist(gap,bucket) )
        bucket = (bucket + 1) % hashTableSize;
      else {
        used[gap] = true;
        hashTable[gap] = hashTable[bucket];
        used[bucket] = false;
        gap = bucket;
        bucket++;
      }
    }
  }
}

// функция вычисления расстояние от a до b (по часовой стрелке, слева направо)
int dist (hashTableIndex a,hashTableIndex b){
  return (b - a + hashTableSize) % hashTableSize;
}

 

List.txt

 

HashTable.txt (хеш-таблица)

 

До сих пор рассматривались способы поиска в таблице по ключам, позволяющим однозначно идентифицировать запись. Такие ключи называются первичными. Возможен вариант организации таблицы, при котором отдельный ключ не позволяет однозначно идентифицировать запись. Такая ситуация часто встречается в базах данных. Идентификация записи осуществляется по некоторой совокупности ключей. Ключи, не позволяющие однозначно идентифицировать запись в таблице, называются вторичными ключами. Даже при наличии первичного ключа, для поиска записи могут быть использованы вторичные.
Идея хеширования впервые была высказана Г.П. Ланом при создании внутреннего меморандума IBM в январе 1953 г. с предложением использовать для разрешения коллизий метод цепочек. Примерно в это же время другой сотрудник IBM, Жини Амдал, высказала идею использования открытой линейной адресации. В открытой печати хеширование впервые было описано Арнольдом Думи (1956 год), указавшим, что в качестве хеш-адреса удобно использовать остаток от деления на простое число. А. Думи описывал метод цепочек для разрешения коллизий, но не говорил об открытой адресации. Подход к хешированию, отличный от метода цепочек, был предложен А.П. Ершовым (1957 год), который разработал и описал метод линейной открытой адресации.

1.4.7. Примеры хеш-функций
Хеш-функция – функция, преобразовывающая входную последовательность данных произвольного размера в выходную последовательность фиксированного размера. Процесс преобразования данных называется хешированием. Результат хеширования – хеш-код (хеш-сумма, хеш).
При решении класса практических задач выбирается такая хеш-функция, которая является наиболее оптимальной именно для данного класса. В общем случае следует использовать «хорошую» функцию. Когда хеш-функцию называют «хорошей», то подразумевают под этим, что она:
•	вычисляется достаточно быстро;
•	сводит к минимуму число коллизий.

Предотвратить коллизии могут далеко не все хеш-функции, но «хорошие» способны минимизировать вероятность их появления. При определенных обстоятельствах (известна некоторая информация о ключах), можно найти идеальную хеш-функцию, т. е. такую, которая полностью исключает возможность появления коллизий.
Использовать хеш-функцию или нет, зависит от того насколько целесообразно применение ее свойств, а также свойств алгоритма, по которому она может быть реализована на ЯП. В одних ситуациях наиболее важна высокая скорость работы, в других равномерное распределение хеш-кодов и т. п. Далее будут рассмотрены два наиболее известных метода хеширования.

1.4.7.1. Метод деления
Пусть k – ключ (тот, что необходимо хешировать), а N – максимально возможное число хеш-кодов. Тогда метод хеширования посредством деления будет заключаться во взятии остатка от деления k на N:

h(k)=k mod N, где mod – операция взятия остатка от деления.

Например, на вход подаются следующие ключи k:

3, 6, 7, 15, 32, 43, 99, 100, 133, 158

Определим N равным 10, из чего последует, что возможные значения хешей лежат в диапазоне 0…9. Используя данную функцию, получим следующие значения хеш-кодов:

Ключ	Хеш-код
3	h(3)=3
6	h(6)=6
7	h(7)=7
15	h(15)=5
32	h(32)=2
43	h(42)=2
99	h(99)=9
100	h(100)=0
133	h(133)=3
158	h(158)=8

На C++ программу, выполняющую хеширование методом деления можно записать так:

#include <iostream>
using namespace std;

int HashFunction(int k)
{
	return (k%10);
}

void main()
{
	setlocale(LC_ALL, "Rus");
	int key;
	cout<<"Ключ > "; cin>>key;
	cout<<"HashFunction("<<key<<")="<<HashFunction(key)<<endl;
	system("pause>>void");
}

 

Во избежание большого числа коллизий рекомендуется выбирать N простым числом, и не рекомендуется степенью с основанием 2 и показателем m (2m). Вообще, по возможности, следует выбирать N, опираясь на значения входящих ключей. Так, например если все или большинство k=10m (m – натуральное число), то неудачным выбором будет N=10*m и N=10m.

1.4.7.2. Метод умножения.
Получить из исходной последовательности ключей последовательность хеш-кодов, используя метод умножения (мультипликативный метод), значит воспользоваться хеш-функцией:

h(k)=[N*({k*A})]

Здесь A – рациональное число (Рациональное число (лат. ratio — отношение, деление, дробь) — число, которое можно представить обыкновенной дробью , числитель — целое число, а знаменатель — натуральное число, к примеру 2/3), по модулю меньшее единицы (0<A<1), а k и N обозначают то же, что и в предыдущем методе: ключ и размер хеш-таблицы. Также правая часть функции содержит три пары скобок:
( ) – скобки приоритета;
[ ] – скобки взятия целой части;
{ } – скобки взятия дробной части.

Аргумент хеш-функции k (k≥0) в результате даст значение хеш-кода h(k)=x, лежащие в диапазоне 0…N-1. Для работы с отрицательными числами можно число x взять по модулю.
От выбора A и N зависит то, насколько оптимальным окажется хеширование умножением на определенной последовательности. Не имея сведений о входящих ключах, в качестве N следует выбрать одну из степеней двойки, т. к. умножение на 2m равносильно сдвигу на m разрядов, что компьютером производиться быстрее. Неплохим значением для A (в общем случае) будет (√5-1)/2≈0,6180339887. Оно основано на свойствах золотого сечения:
Золотое сечение – такое деление величины на две части, при котором отношение большей части к меньшей равно отношению всей величины к ее большей части.
Отношение большей части к меньшей, выраженное квадратичной иррациональностью:

φ=(√5+1)/2≈1,6180339887

Для мультипликативной хеш-функции было приведено обратное отношение:

1/φ=(√5-1)/2≈0,6180339887

При таком A, хеш-коды распределяться достаточно равномерно, но многое зависит от начальных значений ключей.
Для демонстрации работы мультипликативного метода, положим N=13, A=0,618033. В качестве ключей возьмем числа: 25, 44 и 97. Подставим их в функцию:

h(k)=[13*({25*0,618033})]=[13*{15,450825}]=[13*0,450825]=[5,860725]=5
h(k)=[13*({44*0,618033})]=[13*{27,193452}]=[13*0,193452]=[2,514876]=2
h(k)=[13*({97*0,618033})]=[13*{59,949201}]=[13*0,949201]=[12,339613]=12

Реализация метода на C++ с использованием оговоренных N и A:

#include <iostream>
#include <math.h>       /* fmod */
using namespace std;

int HashFunction(int k)
{
	int N=13; double A=0.618033;
	int h=N*fmod(k*A, 1);
//fmod of  5.3 / 2   is 1.300000
//fmod of 18.5 / 4.2 is 1.700000

	return h;
}

void main()
{
	setlocale(LC_ALL, "Rus");
	int key;
	cout<<"Ключ > "; cin>>key;
	cout<<"HashFunction("<<key<<")="<<HashFunction(key)<<endl;
	system("pause>>void");
}

 

 

 

http://mf.grsu.by/UchProc/livak/b_protect/zok_7.htm
1.5. Основные, наиболее часто используемые функции хэширования
Функции хэширования играют главную роль в современной криптографии.

. 

Красная лиса перепрыгивает через синюю собаку
Fox	DFCD 3454 BBEA 788A 751A 696C 24D9 7009 CA99 2D17
The red fox jumps over the blue dog	0086 46BB FB7D CBE2 823C ACC7 6CD1 90B1 EE6E 3ABC
The red fox jumps ouer the blue dog	8FD8 7558 7851 4F32 D1C6 76B1 79A9 0DA4 AEFE 4819
The red fox jumps oevr the blue dog	FCD3 7FDB 5AF2 C6FF 915F D401 C0A9 7D9A 46AF FB45
The red fox jumps oer the blue dog	8ACA D682 D588 4C75 4BF4 1799 7D88 BCF8 92B9 6A6C

В настоящее время механизм хэш-функций используется на практике очень широко.
Кроме шифрования данных с помощью хэш-функций реализуют
•	Проверку целостности данных (обнаружение изменений)
Идея заключается в сохранении хэш-кода и последующем сравнении с эталоном повторно вычисленного для тех же данных хэш-значения.
Очевидно, что неравенство сравниваемых величин означает нарушение целостности.
•	Системы аутентификации
Используют хэширование паролей.
•	Создание и проверку ЭЦП
Механизм хэш-функций применяется для уменьшения времени, необходимого для генерации и проверки подписи, а также для сокращения ее длины.

При построении функций хэширования требуется, чтобы вычислительно трудным являлось решение следующих криптоаналитических задач:
•	по заданному y = h( x) определить x (односторонняя функция h);
•	для заданного x найти другое x´ , такое, что h(x)= h(x´) (свободная от коллизий функция h);
•	найти пару x, x´ (x ≠ x´) , такую, что h(x)= h(x´) (строго свободная от коллизий функция h).

Замечание
Значение хэш-функции также называют
•	Хэш-код
•	Функция (значение) свертки
•	Профиль сообщения
•	Дайджест сообщения
•	Криптографическая контрольная сумма
•	Цифровой отпечаток
•	Код аутентичности сообщения
•	Код обнаружения манипуляций

Характеристики, которыми должна обладать хеш-функция:
•	должна уметь выполнять преобразования данных произвольной длины в фиксированную;
•	должна иметь открытый алгоритм, чтобы можно было исследовать её криптостойкость;
•	должна быть односторонней, то есть не должно быть математической возможности по результату определить исходные данные;
•	должна «сопротивляться» коллизиям, то есть не должна выдавать одинаковых значений при разных входных данных;
•	не должна требовать больших вычислительных ресурсов;
•	при малейшем изменении входных данных результат должен существенно изменяться.

Перечислим и кратко охарактеризуем наиболее часто используемые функции хэширования, применяемые для ЭЦП.
•	SHA - Secure Hash Algorithm (1992)
160-разрядный хэш-код (дайджест). НЕ устойчив к коллизиям.
512-битовые блоки.
•	SHA-1  - Secure Hash Algorithm 1 (1995)
Модификация SHA. Исправлены недостатки. Решает проблему коллизий.
•	MAC - Message Authentication Code - код аутентификации (проверки подлинности) сообщения.
Это зависящая от ключа однонаправленная хэш-функция. Простейшим способом преобразования хэш-функции в MAC является шифрование хэш-значения симметричным алгоритмом.
•	HMAC
Один из вариантов добавления секретного ключа в уже существующий алгоритм хэширования. Функция хэширования в этом алгоритме интерпретируется как «черный ящик», то есть функция хэширования реализована как отдельный модуль и ее можно менять.
Алгоритм HMAC [представлен в документе RFC 2104] принят как обязательный в протоколе IPSec и используется в ряде других протоколов Internet (TLS, SET и другие)
Широко используются на практике также функции, разработанные Роном Ривестом:
•	MD2 - Message Digest #2
Низкоскоростной, но очень надежный алгоритм, создающий 128-разрядные дайджесты данных любого объема.
•	MD4 - Message Digest #4 (1990)
Более скоростной, но менее надежный алгоритм, создающий 128-разрядные дайджесты данных любого объема. 512-битовые блоки. Есть дефекты.
•	MD5 - Message Digest #5 (1992)
Версия MD4 с повышенной надежностью, преимущества также и в скорости. 128-разрядные дайджесты данных любого объема.
Неустойчив к коллизиям! Не используется для долговременных ЭЦП.

Обратим внимание, что алгоритмы SHA надежнее алгоритмов MDx, так как вырабатывают более длинный хэш-код (160 бит против 128 бит), что снижает вероятность того, что разные входные последовательности будут преобразованы в одно значение хэш-кода.
Современные технологии распределенных вычислений и многопроцессорные компьютеры демонстрируют недостаточную защищенность 128-битовых хэш-кодов. «Кроме того, были разработаны сценарии целого ряда атак, демонстрирующих уязвимость MD5 в отношении современных методов криптоанализа» [Шнайер].
Однако, до сих пор не разработаны атаки, демонстрирующие уязвимость SHA  в отношении современных методов криптоанализа; «сведения об успешных криптографических атаках на алгоритм SHA отсутствуют» [Шнайер].
Заметим также, что в российском стандарте ГОСТ Р 34.11-94 (в основе схемы Эль-Гамаля и Шнорра) длина хэш-кода равна 256 битам.

1.6. Коллизи (они же столкновения)
1.6.1. Пример коллизий
На самом деле ничего нового во всем этом нет. В действительности данный эффект достигается за счет методов быстрого поиска коллизий для хеш функции разработанных еще в 2004-2006 годах. Если кто не знает, коллизия это два разных набора данных, имеющих одно и тоже хеш-значение. Так вот, в 2004 году группа китайских исследователей разработала алгоритм, основанный на дифференциальном криптоанализе, позволяющий за относительно небольшое время находить два различных случайных блока данных, размером по 128 байт каждый, имеющих одну и ту же md5 сумму.

Замечание
Что такое md5 сумма и зачем она нужна? Есть файл, который мы скачали из сети, например, файл образа Ubuntu. Как нам удостовериться, что закачанный файл (который находится теперь на нашем компьютере) совпадает с файлом, который лежит на сервере, откуда мы скачали файл? Другими словами как понять, что файл не был изменен при закачке. Для этого и используется механизм вычисления контрольной суммы. Автор или хозяин файла вычисляет при помощи специальной утилиты эту самую md5 сумму, которая представляет собой, строку вида 2413b8c71bea3e0bccd2d51c630ff190. Затем выкладывает ее рядом с файлом в текстовом виде или в виде файла с расширением md5. Скачав файл, мы можем также вычислить md5 сумму и если числа совпадут, то файл является точной копией и не изменился во время закачки. Данную сумму каждого файла можно просчитать с помощью программы MD5_File Checker ( не требует установки в системе) . Совпадение контрольных сумм скачиваемого и скачанного образа, дает гарантию, что при скачивании файл не был поврежден. Кроме данной суммы существуют еще CRC32 и SHA-1-суммы, подсчитывающие хэш другими способами.

И хотя алгоритм этот в свое время произвел эффект взорвавшейся бомбы быстродействие его оставляло желать лучшего. Но уже в 2006 году чешский криптограф Властимил Клима предложил для поиска коллизий новый метод, позволяющий найти разную пару случайных 128 байтных блоков с одной md5 суммой на персональном компьютере меньше чем за минуту.
Вы скажите, но что нам даст обладание такой парой сообщений, мало того что они короткие(всего 128 байт), так еще, в добавок, и случайные, т.е. метод не позволяет для заданного сообщения подобрать другое, с идентичным хешем. Однако это открывает огромный простор для различного рода атак на выполняемые файлы. И виной тому служит следующая особенность работы любой хеш функции: Хеш функция по своей природе итеративна (повторяется). Это означает, что при подсчете хеша сообщение разбивается на блоки, к каждому блоку применяется функция сжатия, зависящая от некоторой переменной, называемой вектор инициализации. Результат этой функции будет являться вектором инициализации для следующего блока. Результат функции после работы с последним блоком и будет окончательным хеш значением нашего сообщения.
Схематично это можно представить следующим образом:

si+1 = f(si, Mi), где si вектор инициализации для i-го блока.

Метод Властимила Клима позволяет для любого заданного значения si подобрать два 128-байтных блока M,M` и N,N` таких, что f(f(s, M), M') = f(f(s, N), N').
Таким образом, с помощью данной методики можно сконструировать два файла с одинаковой md5 суммой, но имеющих различные 128 байт в середине.

M0, M1, ..., Mi-1, Mi, Mi+1, Mi+2, ..., Mn,

M0, M1, ..., Mi-1, Ni, Ni+1, Mi+2, ..., Mn.

Обратите внимание что хеши обоих этих файлов совпадут, т.к. различающиеся блоки Mi, Mi+1 и Ni, Ni+1 вернут в качестве si+2 одно и тоже значение, т.к. f(f(s, Mi), Mi+1) = f(f(s, Ni), Ni+1), а поскольку все последующие данные идентичны то последующие значения функции сжатия для обоих файлов будут совпадать.

Что это нам дает
Теперь перейдем от вещей абстрактных и отдаленных к вопросу практическому. Предположим, что у нас есть исполняемый файл

M0, M1, X, X, …, Mn.

Но его основе мы можем создать два разных файла

M0, M1, N1, N1, …, Mn и
M0, M1, N2, N1,…, Mn

(просто меняем блоки X на N1 и N2). Если блоки N1 и N2 – это коллизии то хеш-сумма этих файлов будет совпадать. Теперь представим, что этот исполняемый файл имеет следующую структуру:

if (X == X) then
	{ good_program }
Else
	{ evil_program }

Вот собственно и весь секрет данного фокуса.

#include<iostream>
#include <string>
using namespace std;
//переменные str1 и str2 в данном примере являются теми самыми элементами X.
static char *str1="qwertyuioplkjhgfdaszxcvbnmkjhgfdsaqwertyuikjh"\
"gbvfdsazxdcvgbhnjikmjhbgfvcdsazxdcfrewqikolkjnhgfqwertyuioplkjh"\
"gfdaszxcvbnmkjhgfdsaqwertyuikjhgbvfdsazxdcvgbhnjikmjhbgfvcdsa"\
"zxdcfrewqikolkjnhgfq123";
static char *str2="qaswderftgyhujikolpmnbvcxzasxdcfvgbhnjmkijuy"\
"gtfdeswaqscfvgyjqaswderftgyhujikolpmnbvcxzasxdcfvgbhnjmkijuyg"\
"tfdeswaqscfvgyjqaswderftgyhujikolpmnbvcxzasxdcfvgbhnjmkijuygt"\
"fdeswaqscfvgyjqwertyuikja2";

int good()
{
  int a;
  std::cout<<"Good, nice programme!";
  std::cin>>a;
  return 0;
}
int bed()
{
  int a;
  for(int i=0; i<1000; i++)
  {
  std::cout<<"Evil, evil code!"; // Зло, злой код
  }
  std::cin>>a;
  return 0;
}
int main()
{
//строки s1 и s2 содержат только блоки с коллизиями без лишних элементов
  string s1=str1;
  string s2=str2;
  s1.erase(0,56);// Erases part of the string, reducing its length
  s1.erase(128,8);
  s2.erase(0,64);
   if (s1==s2) {
  return good();
 } else {
  return bed();
 }
  return 0;
}

 

Для презентации проверка (коллизий нет)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include <iostream>

#define HASH_MUL 31
#define HASH_SIZE 128

unsigned int hash(char *s, int inti[])
{
	unsigned int h = 0;
	char *p;
	int j=0;
	for (p = s; *p != '\0'; p++, j++){
		//h = h * HASH_MUL + (unsigned int)*p;
		h = h * HASH_MUL + inti[j];
		printf("*p=%c\t%d\th=%12d\thash=%3d\n", *p, inti[j], h, h % HASH_SIZE);
	}
	return h % HASH_SIZE; //
}

int main()
{
	setlocale(LC_ALL, "rus");
	//Волк 194 238 235 234
	//Жираф 198 232 240 224 244
	static char *str1="Волк";
	static char *str2="Жираф";
	static int itr1[4]={194, 238, 235, 234};
	static int itr2[5]={198, 232, 240, 224, 244};
	unsigned int h1 = hash(str1, itr1);
	printf("\n");
	unsigned int h2 = hash(str2, itr2);
	_getch();
	return 0;
}

 

Но в большинстве случаев приходится бороться с коллизиями. Обычно применяются методы цепочек и открытой индексации.

Коллизии осложняют использование хеш-таблиц, так как нарушают однозначность соответствия между хеш-кодами и данными. Тем не менее, существуют способы преодоления возникающих сложностей:
•	метод цепочек (внешнее или открытое хеширование);
•	метод открытой адресации (закрытое хеширование).

1.6.2. Методы разрешения коллизий
Для разрешения коллизий используются различные методы, которые в основном сводятся к методам цепочек и открытой адресации.

 

Рис.3.2. Разновидности методов разрешение коллизий

Методом цепочек называется метод, в котором для разрешения коллизий во все записи вводятся указатели, используемые для организации списков √ цепочек переполнения. В случае возникновения коллизии при заполнении таблицы в список для требуемого адреса хеш-таблицы добавляется еще один элемент.
Поиск в хеш-таблице с цепочками переполнения осуществляется следующим образом. Сначала вычисляется адрес по значению ключа. Затем осуществляется последовательный поиск в списке, связанном с вычисленным адресом.
Процедура удаления из таблицы сводится к поиску элемента и его удалению из цепочки переполнения.

 
Рис.3.3. Разрешение коллизий при добавлении элементов методом цепочек

Метод открытой адресации состоит в том, чтобы, пользуясь каким-либо алгоритмом, обеспечивающим перебор элементов таблицы, просматривать их в поисках свободного места для новой записи.
 
Рис.3.4. Разрешение коллизий при добавлении элементов методами открытой адресации.

Линейное опробование сводится к последовательному перебору элементов таблицы с некоторым фиксированным шагом

a=h(key) + c*i ,

где i - номер попытки разрешить коллизию. При шаге равном единице происходит последовательный перебор всех элементов после текущего.
Квадратичное опробование отличается от линейного тем, что шаг перебора элементов не линейно зависит от номера попытки найти свободный элемент

a = h(key2) + c*i + d*i2

Благодаря нелинейности такой адресации уменьшается число проб при большом числе ключей-синонимов.
Однако даже относительно небольшое число проб может быстро привести к выходу за адресное пространство небольшой таблицы вследствие квадратичной зависимости адреса от номера попытки.
Еще одна разновидность метода открытой адресации, которая называется двойным хешированием, основана на нелинейной адресации, достигаемой за счет суммирования значений основной и дополнительной хеш-функций

a=h1(key) + i*h2(key).

Опишем алгоритмы вставки и поиска для метода линейное опробование.
Вставка
1.	i = 0
2.	a = h(key) + i*c
3.	Если t(a) = свободно, то t(a) = key, записать элемент, стоп элемент добавлен
4.	i = i + 1, перейти к шагу 2

Поиск
1.	i = 0
2.	a = h(key) + i*c
3.	Если t(a) = key, то стоп элемент найден
4.	Если t(a) = свободно, то стоп элемент не найден
5.	i = i + 1, перейти к шагу 2

Аналогичным образом можно было бы сформулировать алгоритмы добавления и поиска элементов для любой схемы открытой адресации. Отличия будут только в выражении, используемом для вычисления адреса (шаг 2). С процедурой удаления дело обстоит не так просто, так как она в данном случае не будет являться обратной процедуре вставки.
Дело в том, что элементы таблицы находятся в двух состояниях: свободно и занято. Если удалить элемент, переведя его в состояние свободно, то после такого удаления алгоритм поиска будет работать некорректно. Предположим, что ключ удаляемого элемента имеет в таблице ключи синонимы. В том случае, если за удаляемым элементом в результате разрешения коллизий были размещены элементы с другими ключами, то поиск этих элементов после удаления всегда будет давать отрицательный результат, так как алгоритм поиска останавливается на первом элементе, находящемся в состоянии свободно.
Скорректировать эту ситуацию можно различными способами. Самый простой из них заключается в том, чтобы производить поиск элемента не до первого свободного места, а до конца таблицы. Однако такая модификация алгоритма сведет на нет весь выигрыш в ускорении доступа к данным, который достигается в результате хеширования.
Другой способ сводится к тому, чтобы проследить адреса всех ключей-синонимов для ключа удаляемого элемента и при необходимости переразместить соответствующие записи в таблице. Скорость поиска после такой операции не уменьшится, но затраты времени на само переразмещение элементов могут оказаться очень значительными.
Существует подход, который свободен от перечисленных недостатков. Его суть состоит в том, что для элементов хеш-таблицы добавляется состояние удалено. Данное состояние в процессе поиска интерпретируется, как занято, а в процессе записи как свободно.
Сформулируем алгоритмы вставки поиска и удаления для хеш-таблицы, имеющей три состояния элементов.

Вставка
1.	i = 0
2.	a = h(key) + i*c
3.	Если t(a) = свободно или t(a) = удалено, то t(a) = key, записать элемент, стоп элемент добавлен
4.	i = i + 1, перейти к шагу 2

Удаление
1.	i = 0
2.	a = h(key) + i*c
3.	Если t(a) = key, то t(a) = удалено, стоп элемент удален
4.	Если t(a) = свободно, то стоп элемент не найден
5.	i = i + 1, перейти к шагу 2

Поиск
1.	i = 0
2.	a = h(key) + i*c
3.	Если t(a) = key, то стоп элемент найден
4.	Если t(a) = свободно, то стоп элемент не найден
5.	i = i + 1, перейти к шагу 2

Алгоритм поиска для хеш-таблицы, имеющей три состояния, практически не отличается от алгоритма поиска без учета удалений. Разница заключается в том, что при организации самой таблицы необходимо отмечать свободные и удаленные элементы. Это можно сделать, зарезервировав два значения ключевого поля. Другой вариант реализации может предусматривать введение дополнительного поля, в котором фиксируется состояние элемента. Длина такого поля может составлять всего два бита, что вполне достаточно для фиксации одного из трех состояний. На языке TurboPascal данное поле удобно описать типом Byte или Char.

1.6.3. Борьба с коллизиями
В идеальном случае, когда заранее известны все пары ключ-значение, достаточно легко реализовать идеальную хеш-таблицу, в которой время поиска будет постоянным (используется идеальная хеш-функция, которая определяет положения в таблице по целым значениям и без столкновений).

1.6.3.1. Метод цепочек
Метод цепочек. Технология сцепления элементов состоит в том, что элементы множества, которым соответствует одно и то же хеш-значение, связываются в цепочку-список. В позиции номер i хранится указатель на голову списка тех элементов, у которых хеш-значение ключа равно i ; если таких элементов в множестве нет, в позиции i записан NULL. На рис. 38.1 демонстрируется реализация метода цепочек при разрешении коллизий. На ключ 002 претендуют два значения, которые организуются в линейный список.

 

Рис. 38.1. Разрешение коллизий при помощи цепочек

Каждая ячейка массива является указателем на связный список (цепочку) пар ключ-значение, соответствующих одному и тому же хеш-значению ключа. Коллизии просто приводят к тому, что появляются цепочки длиной более одного элемента.
Операции поиска или удаления данных требуют просмотра всех элементов соответствующей ему цепочки, чтобы найти в ней элемент с заданным ключом. Для добавления данных нужно добавить элемент в конец или начало соответствующего списка, и, в случае если коэффициент заполнения станет слишком велик, увеличить размер массива и перестроить таблицу.
При предположении, что каждый элемент может попасть в любую позицию таблицы с равной вероятностью и независимо от того, куда попал любой другой элемент, среднее время работы операции поиска элемента составляет O(1+k), где k – коэффициент заполнения таблицы.

Идея метода цепочек состоит в том, что все элементы множества, которые относятся к одному и тому же ключу входят в связный список.

 

Итак! В этом примере, в i позициях содержится указатель на голову списка. Т.е. в массиве с ячейками (1,3,4); в остальных других хранится null (0,2,5);
Возвращаясь к нашему примеру с именами, переделаем его в соответствии с новым методом:

length	value
2	*head1 ["Joe"->"Rex"->Null]
3	*head2 ["Alex"->"Petr"->"Oleg"->Null]
4	*head3 ["Pavel"->Null]

В этом примере 0,1,5 элементы указатели равны Null
Процедура вставки происходит так: Вычисляется хеш-функция от строки и вставляется в голову списка (push_front) на определенный индекс равный значению функции.
Вставка происходит за O(1).
Поиск или удаление элемента зависит от длины списка, худший случай: O(n) - когда, все элементы хешируются в одну и ту же ячейку. Если функция распределяем n ключей по m ячейкам таблицы равномерно, то в каждом списке будет содержаться порядка k=n/m ключей. Это число называется коэффициентом заполнения хеш-таблицы. В этом случае время поиска: O(1+k), это показано в книжке Кормана, могу скинуть ссылку на нее, если интересно.
Добавлю, что в случае, когда коэффициент заполнения будет слишком велик, надо будет увеличить размер массива и, возможно, перестроить таблицу.

Этот метод часто называют открытым хешированием. Его суть проста — элементы с одинаковым хешем попадают в одну ячейку в виде связного списка.

 

То есть, если ячейка с хешем уже занята, но новый ключ отличается от уже имеющегося, то новый элемент вставляется в список в виде пары ключ-значение.
Если выбран метод цепочек, то вставка нового элемента происходит за O(1), а время поиска зависит от длины списка и в худшем случае равно O(n). Если количество ключей n, а распределяем по m-ячейкам, то соотношение n/m будет коэффициентом заполнения.
В C++ метод цепочек реализуется так:

//Проверка ячейки и создание списка
class LinkedHashEntry {
private:
      int key;
      int value;
      LinkedHashEntry *next;
public:
      LinkedHashEntry(int key, int value) {
            this->key = key;
            this->value = value;
            this->next = NULL;
      }

      int getKey() {
            return key;
      }

      int getValue() {
            return value;
      }

      void setValue(int value) {
            this->value = value;
      }

      LinkedHashEntry *getNext() {
            return next;
      }

      void setNext(LinkedHashEntry *next) {
            this->next = next;
      }
};

1.6.3.2. Открытая индексация (или закрытое хеширование)
Метод открытой адресации. В отличие от хеширования с цепочками, при открытой адресации никаких списков нет, а все записи хранятся в самой хеш-таблице. Каждая ячейка таблицы содержит либо элемент динамического множества, либо NULL.
В этом случае, если ячейка с вычисленным индексом занята, то можно просто просматривать следующие записи таблицы по порядку до тех пор, пока не будет найден ключ K или пустая позиция в таблице. Для вычисления шага можно также применить формулу, которая и определит способ изменения шага. На рис. 38.2 разрешение коллизий осуществляется методом открытой адресации. Два значения претендуют на ключ 002, для одного из них находится первое свободное (еще незанятое) место в таблице.

 

Рис. 38.2. Разрешение коллизий при помощи открытой адресации

При любом методе разрешения коллизий необходимо ограничить длину поиска элемента. Если для поиска элемента необходимо более 3 – 4 сравнений, то эффективность использования такой хеш-таблицы пропадает и ее следует реструктуризировать (т.е. найти другую хеш-функцию), чтобы минимизировать количество сравнений для поиска элемента
Для успешной работы алгоритмов поиска, последовательность проб должна быть такой, чтобы все ячейки хеш-таблицы оказались просмотренными ровно по одному разу.
Удаление элементов в такой схеме несколько затруднено. Обычно поступают так: заводят логический флаг для каждой ячейки, помечающий, удален ли элемент в ней или нет. Тогда удаление элемента состоит в установке этого флага для соответствующей ячейки хеш-таблицы, но при этом необходимо модифицировать процедуру поиска существующего элемента так, чтобы она считала удаленные ячейки занятыми, а процедуру добавления – чтобы она их считала свободными и сбрасывала значение флага при добавлении.

Идея метода открытой адресации состоит в том, что нету никаких списков, а все элементы хранятся в хеш-таблице. Ячейка хранит либо элемент либо NULL (по желанию ваш граничный элемент, в C# если использовать тип object, то null).
Для того, чтобы вставить ячейку, можно двигаться по списку пока не найдем пустую ячейку и вставить туда элемент. Этот метод решения коллизий называется линейное хеширование.

 

Линейное хеширование достаточно просто реализуется, однако с ним связана существенная проблема – кластеризация. Это явление создания длинных последовательностей занятых ячеек, которое увеличивает среднее время поиска в таблице. Для снижения эффекта кластеризации используется другая стратегия разрешения коллизий – двойное хеширование. Основная идея заключается в том, что для определения шага смещения исследований при коллизии в ячейке используется другая хеш-функция, вместо линейного смещения на одну позицию.
Общий прием состоит в следующем: если хеш-функция вырабатывает позицию для первого кандидата i = Hash_Func(key) Mod (capacity), то последующие позиции определяются как i + increment, i +2 * increment, i +3 * increment и так далее, все по модулю capacity. Величина increment вычисляется как:

Hash_Func(key) Mod (capacity -1)

Пример:

 

i,i1,i2 ячейки заняты, i=2, i1=4, i2=6, i3=8, capacity=11

Последующие index=i+increment (increment = 2 Mod 10 = 2)

Второй распространенный метод — открытая индексация. Это значит, что пары ключ-значение хранятся непосредственно в хеш-таблице. А алгоритм вставки проверяет ячейки в некотором порядке, пока не будет найдена пустая ячейка. Порядок вычисляется на лету.

 

Самая простая в реализации последовательность проб — линейное пробирование (или линейное исследование). Здесь все просто — в случае коллизии, следующие ячейки проверяются линейно, пока не будет найдена пустая ячейка.
А алгоритм поиска ищет ячейки в том же порядке, что и при вставке, пока не найдет нужный элемент или пустую ячейку, которая говорит о том, что ключ отсутствует. В случае, если таблица будет заполнена, ее придется динамически расширять.
Метод линейного пробирования для открытой индексации на C++:

//Проверка ячеек и вставка значения
class HashEntry {
private:
      int key;
      int value;
public:
      HashEntry(int key, int value) {
            this->key = key;
            this->value = value;
      }

      int getKey() {
            return key;
      }

      int getValue() {
            return value;
      }

      void setValue(int value) {
            this->value = value;
      }
};

Хеширование и хеш-таблицы применяются для более удобного хранения пар ключ-значение. Если нужна максимальная эффективность, то используйте хеш-таблицы со списками будет намного быстрее, чем обычная таблица.

1.6.4. Переполнение таблицы и рехеширование
Очевидно, что по мере заполнения хеш-таблицы будут происходить коллизии и в результате их разрешения методами открытой адресации очередной адрес может выйти за пределы адресного пространства таблицы. Что бы это явление происходило реже, можно пойти на увеличение длины таблицы по сравнению с диапазоном адресов, выдаваемым хеш-функцией.

 
Рис.3.5. Циклический переход к началу таблицы.

С одной стороны это приведет к сокращению числа коллизий и ускорению работы с хеш-таблицей, а с другой к нерациональному расходованию адресного пространства. Даже при увеличении длины таблицы в два раза по сравнению с областью значений хеш-функции нет гарантии того, что в результате коллизий адрес не превысит длину таблицы. При этом в начальной части таблицы может оставаться достаточно свободных элементов. Поэтому на практике используют циклический переход к началу таблицы.
Рассмотрим данный способ на примере метода линейного опробования. При вычислении адреса очередного элемента можно ограничить адрес, взяв в качестве такового остаток от целочисленного деления адреса на длину таблицы n.

Вставка
1.	i = 0
2.	a = (h(key) + c*i) mod n
3.	Если t(a) = свободно или t(a) = удалено, то t(a) = key, записать элемент, стоп элемент добавлен
4.	i = i + 1, перейти к шагу 2

В данном алгоритме мы не учитываем возможность многократного превышения адресного пространства. Более корректным будет алгоритм, использующий сдвиг адреса на 1 элемент в случае каждого повторного превышения адресного пространства. Это повышает вероятность найти свободные элементы в случае повторных циклических переходов к началу таблицы.

Вставка
1.	i = 0
2.	a = ((h(key) + c*i) div n + (h(key) + c*i) mod n) mod n
3.	Если t(a) = свободно или t(a) = удалено, то t(a) = key, записать элемент, стоп элемент добавлен
4.	i = i + 1, перейти к шагу 2
5.	a = ((h(key) + c*i) div n + (h(key) + c*i) mod n) mod n

Рассматривая возможность выхода за пределы адресного пространства таблицы, мы не учитывали факторы заполненности таблицы и удачного выбора хеш-функции. При большой заполненности таблицы возникают частые коллизии и циклические переходы в начало таблицы. При неудачном выборе хеш-функции происходят аналогичные явления. В наихудшем варианте при полном заполнении таблицы алгоритмы циклического поиска свободного места приведут к зацикливанию. Поэтому при использовании хеш-таблиц необходимо стараться избегать очень плотного заполнения таблиц. Обычно длину таблицы выбирают из расчета двукратного превышения предполагаемого максимального числа записей. Не всегда при организации хеширования можно правильно оценить требуемую длину таблицы, поэтому в случае большой заполненности таблицы может понадобиться рехеширование. В этом случае увеличивают длину таблицы, изменяют хеш-функцию и переупорядочивают данные.
Производить отдельную оценку плотности заполнения таблицы после каждой операции вставки нецелесообразно, поэтому можно производить такую оценку косвенным образом по числу коллизий во время одной вставки. Достаточно определить некоторый порог числа коллизий, при превышении которого следует произвести рехеширование. Кроме того, такая проверка гарантирует невозможность зацикливания алгоритма в случае повторного просмотра элементов таблицы.
Рассмотрим алгоритм вставки, реализующий предлагаемый подход.

Вставка
1.	i = 0
2.	a = ((h(key) + c*i) div n + (h(key) + c*i) mod n) mod n
3.	Если t(a) = свободно или t(a) = удалено, то t(a) = key, записать элемент, стоп элемент добавлен
4.	Если i > m , то стоп требуется рехеширование
5.	i = i + 1, перейти к шагу 2

В данном алгоритме номер итерации сравнивается с пороговым числом m. Следует заметить, что алгоритмы вставки, поиска и удаления должны использовать идентичное образование адреса очередной записи.

Удаление
1.	i = 0
2.	a = ((h(key) + c*i) div n + (h(key) + c*i) mod n) mod n
3.	Если t(a) = key, то t(a) =удалено, стоп элемент удален
4.	Если t(a) = свободно или i>m, то стоп элемент не найден
5.	i = i + 1, перейти к шагу 2

Поиск
1.	i = 0
2.	a = ((h(key) + c*i) div n + (h(key) + c*i) mod n) mod n
3.	Если t(a) = key, то стоп элемент найден
4.	Если t(a) = свободно или i>m, то стоп элемент не найден
5.	i = i + 1, перейти к шагу 2

1.6.5. Оценка качества хеш-функции
Как уже было отмечено, очень важен правильный выбор хеш-функции. При удачном построении хеш-функции таблица заполняется более равномерно, уменьшается число коллизий и уменьшается время выполнения операций поиска, вставки и удаления. Для того чтобы предварительно оценить качество хеш-функции можно провести имитационное моделирование. Моделирование проводится следующим образом. Формируется целочисленный массив, длина которого совпадает с длиной хеш-таблицы. Случайно генерируется достаточно большое число ключей, для каждого ключа вычисляется хеш-функция. В элементах массива просчитывается число генераций данного адреса. По результатам такого моделирования можно построить график распределения значений хеш-функции. Для получения корректных оценок число генерируемых ключей должно в несколько раз превышать длину таблицы.

 
Рис. 3.6. Распределение коллизий в адресном пространстве таблицы

Если число элементов таблицы достаточно велико, то график строится не для отдельных адресов, а для групп адресов. Например, все адресное пространство разбивается на 100 фрагментов и подсчитывается число попаданий адреса для каждого фрагмента. Большие неравномерности свидетельствуют о высокой вероятности коллизий в отдельных местах таблицы. Разумеется, такая оценка является приближенной, но она позволяет предварительно оценить качество хеш-функции и избежать грубых ошибок при ее построении.
Оценка будет более точной, если генерируемые ключи будут более близки к реальным ключам, используемым при заполнении хеш-таблицы. Для символьных ключей очень важно добиться соответствия генерируемых кодов символов тем кодам символов, которые имеются в реальном ключе. Для этого стоит проанализировать, какие символы могут быть использованы в ключе.
Например, если ключ представляет собой фамилию на русском языке, то будут использованы русские буквы. Причем первый символ может быть большой буквой, а остальные малыми. Если ключ представляет собой номерной знак автомобиля, то также несложно определить допустимые коды символов в определенных позициях ключа.
Рассмотрим пример генерации ключа из десяти латинских букв, первая из которых является большой, а остальные малыми.
Пример
: ключ 10 символов, 1-й большая латинская буква
2-10 малые латинские буквы
var i:integer; s:string[10];
begin
s[1]:=chr(random(90-65)+65);
for i:=2 to 10 do s[i]:=chr(random(122-97)+97);
end

В данном фрагменте используется тот факт, что допустимые коды символов располагаются последовательными непрерывными участками в кодовой таблице. Рассмотрим более общий случай. Допустим, необходимо сгенерировать ключ из m символов с кодами в диапазоне от n1 до n2.

Генерация ключа из m символов c кодами в диапазоне от n1 до n2
(диапазон непрерывный)

for i:=1 to m do str[i]:=chr(random(n2-n1)+n1);

На практике возможны варианты, когда символы в одних позициях ключа могут принадлежать к разным диапазонам кодов, причем между этими диапазонами может существовать разрыв.

Генерация ключа из m символов c кодами
в диапазоне от n1 до n4 (диапазон имеет разрыв от n2 до n3)

 

for i:=1 to m do
begin
x:=random((n4 - n3) + (n2 √ n1));
if x<=(n2 - n1) then str[i]:=chr(x + n1)
else str[i]:=chr(x + n1 + n3 √ n2)
end;

Рассмотрим еще один конкретный пример. Допустим известно, что ключ состоит из 7 символов. Из них три первые символа большие латинские буквы, далее идут две цифры, остальные малые латинские.

Пример: длина ключа 7 символов
•	3 большие латинские (коды 65-90)
•	2 цифры (коды 48-57)
•	2 малые латинские (коды 97-122)

var
key: string[7];
begin
for i:=1 to 3 do key[i]:=chr(random(90-65)+65);
for i:=4 to 5 do key[i]:=chr(random(57-48)+57);
for i:=6 to 7 do key[i]:=chr(random(122-97)+97);
end;

В рассматриваемых примерах мы исходили из предположения, что хеширование будет реализовано на языке Turbo Pascal, а коды символов соответствуют альтернативной кодировке.

1.7. Организация данных для ускорения поиска по вторичным ключам
До сих пор рассматривались способы поиска в таблице по ключам, позволяющим однозначно идентифицировать запись. Мы будем называть такие ключи первичными ключами. Возможен вариант организации таблицы, при котором отдельный ключ не позволяет однозначно идентифицировать запись. Такая ситуация часто встречается в базах данных. Идентификация записи осуществляется по некоторой совокупности ключей. Ключи, не позволяющие однозначно идентифицировать запись в таблице, называются вторичными ключами.
Даже при наличии первичного ключа, для поиска записи могут быть использованы вторичные. Например, поисковые системы internet часто организованы как наборы записей, соответствующих Web-страницам. В качестве вторичных ключей для поиска выступают ключевые слова, а сама задача поиска сводится к выборке из таблицы некоторого множества записей, содержащих требуемые вторичные ключи.

1.7.1. Инвертированные индексы
Рассмотрим метод организации таблицы с инвертированными индексами. Для таблицы строится отдельный набор данных, содержащий так называемые инвертированные индексы. Вспомогательный набор содержит для каждого значения вторичного ключа отсортированный список адресов записей таблицы, которые содержат данный ключ.
Поиск осуществляется по вспомогательной структуре достаточно быстро, так как фактически отсутствует необходимость обращения к основной структуре данных. Область памяти, используемая для индексов, является относительно небольшой по сравнению с другими методами организации таблиц.
 
Рис.3.7. Метод организации таблицы с инвертированными индексами

Недостатками данной системы являются большие затраты времени на составление вспомогательной структуры данных и ее обновление. Причем эти затраты возрастают с увеличение объема базы данных.
Система инвертированных индексов является чрезвычайно удобной и эффективной при организации поиска в больших таблицах.

1.7.2. Битовые карты
Для таблиц небольшого объема используют организацию вспомогательной структуры данных в виде битовых карт. Для каждого значения вторичного ключа записей основного набора данных записывается последовательность битов. Длина последовательности битов равна числу записей. Каждый бит в битовой карте соответствует одному значению вторичного ключа и одной записи. Единица означает наличие ключа в записи, а ноль отсутствие.
 
Рис.3.8. Организация вспомогательной структуры данных в виде битовых карт

Основным преимуществом такой организации является очень простая и эффективная организация обработки сложных запросов, которые могут объединять значения ключей различными логическими предикатами. В этом случае поиск сводится к выполнению логических операций запроса непосредственно над битовыми строками и интерпретации результирующей битовой строки. Другим преимуществом является простота обновления карты при добавлении записей.
К недостаткам битовых карт следует отнести увеличение длины строки пропорционально длине файла. При этом заполненность карты единицами уменьшается с увеличением длины файла. Для большой длине таблицы и редко встречающихся ключах битовая карта превращается в большую разреженную матрицу, состоящую в основном из одних нулей.

1.8. Примеры

1.8.1. Пример 1
// Реализация хеш-таблицы через остаток от деления
// Добавление и поиск элементов осуществлятся через имя (name). В реальных условиях
// такая таблица будет иметь много коллизий, но, поскольку задание является тестовым,
// то избран самый простой, быстрый и наглядный метод реализации.

#include <iostream>
#include <string>

#define PRIME_SIZE 29 // Использовано просто число

using namespace std;

class Person // Класс, который содержит немного информации о человеке.
{
public:
    Person *next; // При возникновении коллизии элементы будут помещены в односвязный список.
    string name;
    string surname;
    int age;

    Person()
    {
        this->next = NULL;
    }

    Person (string name, string surname, int age = 0)
    {
        this->name = name;
        this->surname = surname;
        this->age = age;
        this->next = NULL;
    }

    ~Person()
    {
        //cout << "Delete " << this->name << endl;
        if ( this->next != NULL )
        {
            delete this->next;
        }
    }
};

class HashTable // Хеш-таблица, представленная в виде массива элементов (которые в свою очередь представляют список).
{
    Person *table[PRIME_SIZE];

    // Самая простоя хеш-функция. Считает сумму ASCII кодов, делит на константу и
    // получает остаток от деления.
    static int hash ( string str )
    {
        int asciisum = 0;
        for ( int i = 0; i < str.length(); i++ )
        {
            asciisum += str[i];
        }
        return asciisum % PRIME_SIZE;
    }

public:

    HashTable()
    {
        for ( int i = 0; i < PRIME_SIZE; i++ )
        {
            table[i] = NULL;
        }
    }

    ~HashTable()
    {
        //cout << "Delete table\n";
        for ( int i = 0; i < PRIME_SIZE; i++ )
        {
            delete table[i];
        }
    }

    // Вставляет элемент в таблицу
    void push ( string name, string surname, int age )
    {
        int hashNumber = hash(name);
        Person *pers = new Person(name, surname, age);
        Person *place = table[hashNumber];
        if ( place == NULL )
        {
            table[hashNumber] = pers;
            return;
        }

        while ( place->next != NULL )
        {
            place = place->next;
        }
        place->next = pers;
    }

    // Получает элемент из таблицы по его имени.
    Person* find ( string name )
    {
        int hashNumber = hash ( name );
        Person *result = table[hashNumber];
        if ( !result )
        {
            cout << "Element not found" << endl;
            return NULL;
        }
        while ( result->name != name )
        {
            if ( !result->next )
            {
                cout << "Element not found" << endl;
                break;
            }
            result = result->next;
        }
        return result;
    }
};

int main()
{
    HashTable newTable;
    newTable.push("Artyom", "Devyatov", 20);
    newTable.push("Vasya", "Petrov", 23);
    newTable.push("Ilja", "Saveljev", 28);
    newTable.push("Ilaj", "Savanna", 43); // Имеет коллизию с Ilja
    newTable.push("Dmitry", "Kuzychev", 31);

    Person * search = newTable.find("Ilaj");
    if ( search )
    {
        cout << search->surname << endl;
    }
	int a;
	cin >> a;
    return 0;
}

1.8.2. Пример 2.1

#include <iostream>
#include <string>
#include <list>
#include <algorithm>

// Класс "Идентификатор"
// Поскольку это только пример, то в данном случае является просто обёрткой над
// строкой. В реалиности может содержать много дополнительной информации, такой,
// как тип переменной, признак используемости, уровень вложенности и так далее.
class Identifier
{
public:
    // Задаётся имя переменной при создании
    Identifier(const std::string &name):
    m_name(name)
    {
    }

public:
    // Получается имя переменной
    std::string name() const
    {
        return m_name;
    }
   
private:
    std::string m_name;
};

// Необходимо для поиска переменной по имени
bool operator==(const Identifier &left, const Identifier &right)
{
    return left.name() == right.name();
}

// Функция, вычисляющая хэш
// Принимает идентификатор, хэш которого надо посчитать
// Возвращает вычисленный хэш
size_t hash(const Identifier &id)
{
    // Если имя переменной составляет один символ - возвращается его код,
    // умноженный на два
    if (id.name().length() == 1)
        return 2 * size_t(id.name()[0]);
   
    // Иначе возвращается сумма кодов первых двух символов
    return size_t(id.name()[0]) + size_t(id.name()[1]);
}

// Класс исключение "Идентификатор не найден"
// Нужен для выдачи сообщения о том, что идентификатор не найден в таблице,
// наружу функции поиска идентификатора
class IDNotFoundException : std::exception
{
public:
    IDNotFoundException(const std::string id_name):
    m_what(std::string("Identifier \'") + id_name + "\' not found!")
    {
    }
   
    virtual ~IDNotFoundException() throw()
    {
    }
   
public:
    const char *what() const throw()
    {
        return m_what.c_str();
    }
   
private:
    std::string m_what;
};

// Класс "Хэш-таблица", основанная на методе цепочек
// Метод цепочек заключается в следующем: таблица представляет собой массив
// связных списков фиксированного размера. Вычисленный хэш-функцией хэш является
// индексом в этом массиве списков. Известно, что список по этому индексу будет
// содержать все идентификаторы, для которых функция вернула одинаовый хэш.
// Осталось только найти идентификатор в данном списке и возвратить ссылку на
// него.
class HashTable
{
public:
    // Минимально возможное значение хэша
    static const size_t min_hash_value = int('A') + int('0');
    // Максимально возможное значение хэша
    static const size_t max_hash_value = int('z') + int('z');
    // Размер массива списков - хэш-таблицы
    static const size_t hash_table_size = max_hash_value - min_hash_value;
   
public:
    // Добавление идентификатора в хэш-таблицу
    void add(const Identifier &id)
    {
        // Добавление идентификатора в список, расположенный в таблице по
        // индексу, вычисленному хэш-функцией (с учётом смещения)
        m_hash_table[hash(id) - min_hash_value].push_back(id);
    }
   
    // Поиск идентификатора в таблице по имени
    Identifier &get(const std::string &id_name)
    {
        // Сохраняется ссылка на список, в котором потенциально будет
        // расположен идентификатор (для простоты)
        std::list<Identifier>& line = m_hash_table[hash(id_name) - min_hash_value];
       
        // Поиск идентификаторы в списке по имени
        std::list<Identifier>::iterator it =
            std::find(line.begin(), line.end(), id_name);
       
        // Если при поиске были просмотренны все элементы списка,и ни один не
        // подошёл - сообщаем о том, что идентификатор не найден, посредством
        // исключения
        if (it == line.end())
            throw IDNotFoundException(id_name);
       
        // Если идентификатор найден - возвращаем ссылку на него
        return *it;
    }
   
private:
    // Хэш-таблица - массив связных списков идентификаторов
    std::list<Identifier> m_hash_table[hash_table_size];
};

int main()
{
    // Создаём хэш-таблицу
    HashTable ht;
   
    // Добавляем в неё различные идентификаторы
    ht.add(Identifier("a"));
    ht.add(Identifier("aa"));
    ht.add(Identifier("if"));
    ht.add(Identifier("fi"));
   
    // На случай, если идентификатор не будет найден, заворачиваем код поиска
    // идентификаторов в блок try/catch
    try
    {
        // Выводим на экран информацию о различных идентификаторах
        std::cout << ht.get("a").name() << std::endl;
        std::cout << ht.get("aa").name() << std::endl;
        std::cout << ht.get("if").name() << std::endl;
        std::cout << ht.get("fi").name() << std::endl;
        // Проверяем случай, когда идентификатор не должен быть найден
        std::cout << ht.get("hello").name() << std::endl;
    }
    catch (const IDNotFoundException &ex)
    {
        // Если идентификатор не найден - сообщаем об этом
        std::cerr << ex.what() << std::endl;
    }
	int x;
	std::cin >> x;
    return 0;
}

 

1.8.3. Пример 2.2

#include <iostream>
#include <string>
#include <list>
#include <algorithm>

class Identifier
{
public:
    Identifier(const std::string& name):
    m_name(name)
    {
    }
   
public:
    std::string name() const
    {
        return m_name;
    }
   
private:
    std::string m_name;
};

bool operator==(const Identifier& left, const Identifier& right)
{
    return left.name() == right.name();
}

size_t hash(const Identifier& id)
{
    if (id.name().length() == 1)
        return 2 * size_t(id.name()[0]);
   
    return size_t(id.name()[0]) + size_t(id.name()[1]);
}

class IDNotFoundException : std::exception
{
public:
    IDNotFoundException(const std::string id_name):
    m_what(std::string("Identifier \'") + id_name + "\' not found!")
    {
    }
   
    virtual ~IDNotFoundException() throw()
    {
    }
   
public:
    const char *what() const throw()
    {
        return m_what.c_str();
    }
   
private:
    std::string m_what;
};

class HashTable
{
public:
    static const size_t min_hash_value = int('A') + int('0');
    static const size_t max_hash_value = int('z') + int('z');
    static const size_t hash_table_size = max_hash_value - min_hash_value;
   
public:
    void add(const Identifier& id)
    {
        m_hash_table[hash(id) - min_hash_value].push_back(id);
    }
   
    Identifier& get(const std::string& id_name)
    {
        std::list<Identifier>& line = m_hash_table[hash(id_name) - min_hash_value];
       
        std::list<Identifier>::iterator it =
            std::find(line.begin(), line.end(), id_name);
       
        if (it == line.end())
            throw IDNotFoundException(id_name);
       
        return *it;
    }
   
private:
    std::list<Identifier> m_hash_table[hash_table_size];
};

int main()
{
    HashTable ht;
   
    ht.add(Identifier("a"));
    ht.add(Identifier("aa"));
    ht.add(Identifier("if"));
    ht.add(Identifier("fi"));
   
    try
    {
        std::cout << ht.get("a").name() << std::endl;
        std::cout << ht.get("aa").name() << std::endl;
        std::cout << ht.get("if").name() << std::endl;
        std::cout << ht.get("fi").name() << std::endl;
        std::cout << ht.get("hello").name() << std::endl;
    }
    catch (const IDNotFoundException& ex)
    {
        std::cerr << ex.what() << std::endl;
    }
	int x;
	std::cin >> x;
    return 0;
}

 

1.8.4. Пример 3.1


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>

#define HASH_MUL 31
#define HASH_SIZE 128

// Хеш-функция для строк [KP, "Practice of Programming"]
unsigned int hash(char *s)
{
	unsigned int h = 0;
	char *p;
	for (p = s; *p != '\0'; p++){
		h = h * HASH_MUL + (unsigned int)*p;
		printf("*p=%c\th=%12d\thash=%3d\n", *p, h, h % HASH_SIZE);
	}
	return h % HASH_SIZE; // hash("ivanov") = 1
}

int main()
{
	unsigned int h = hash("ivanov");
	printf("\n");
	unsigned int h2 = hash("Beloded");
    _getch();
	return 0;
}

 

1.8.5. Пример 3.2

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>

#define HASHTAB_SIZE 71
#define HASHTAB_MUL 31

struct listnode {
	char *key;
	int value;
	struct listnode *next;
};
struct listnode *hashtab[HASHTAB_SIZE];

unsigned int hashtab_hash(char *key)
{
	unsigned int h = 0;
	char *p;
	for (p = key; *p != '\0'; p++) {
		h = h * HASHTAB_MUL + (unsigned int)*p;
	}
	return h % HASHTAB_SIZE;
}

void hashtab_init(struct listnode **hashtab)
{
	int i;
	for (i = 0; i < HASHTAB_SIZE; i++) {
		hashtab[i] = NULL;
	}
}

void hashtab_add(struct listnode **hashtab,
				 char *key, int value)
{
	struct listnode *node;
	int index = hashtab_hash(key);
	// Вставка в начало списка
	//node = malloc(sizeof(*node));//вызывает ошибку
	node = (listnode*)malloc(sizeof(listnode));//это работает
	//node = new listnode;//это работает
	if (node != NULL) {
		node->key = key;
		node->value = value;
		node->next = hashtab[index];
		hashtab[index] = node;
	}
}

struct listnode *hashtab_lookup(
	struct listnode **hashtab,
	char *key)
{
	int index;
	struct listnode *node;
	index = hashtab_hash(key);
	for (node = hashtab[index];
		node != NULL; node = node->next){
			if (strcmp(node->key, key) == 0)
				return node;
	}
	return NULL;
}

void hashtab_delete(struct listnode **hashtab, char *key)
{
	int index;
	struct listnode *p, *prev = NULL;
	index = hashtab_hash(key);
	for (p = hashtab[index]; p != NULL; p = p->next) {
		if (strcmp(p->key, key) == 0) {
			if (prev == NULL)
				hashtab[index] = p->next;
			else
				prev->next = p->next;
			free(p);
			return;
		}
		prev = p;
	}
}

int main()
{
	struct listnode *node;
	hashtab_init(hashtab);
	hashtab_add(hashtab, "Tigr", 190);
	hashtab_add(hashtab, "Slon", 2300);
	hashtab_add(hashtab, "Volk", 60);
	node = hashtab_lookup(hashtab, "Slon");
	printf("Node: %s, %d\n", node->key, node->value);

	hashtab_delete(hashtab, "Slon");
	node = hashtab_lookup(hashtab, "Slon");
	if (node != NULL) {
		printf("Node: %s, %d\n", node->key, node->value);
	}
	else {
		printf("Key 'Slon' not found\n");
	}
    _getch();

	return 0;
}

//int main()
//{
//	struct listnode *node;
//	hashtab_init(hashtab);
//	hashtab_add(hashtab, "Tigr", 190);
//	hashtab_add(hashtab, "Slon", 2300);
//	hashtab_add(hashtab, "Volk", 60);
//	node = hashtab_lookup(hashtab, "Slon");
//	printf("Node: %s, %d\n", node->key, node->value);
//	hashtab_delete(hashtab, "Slon");
//	node = hashtab_lookup(hashtab, "Slon");
//	if (node != NULL) {
//		printf("Node: %s, %d\n", node->key, node->value);
//	}
//	else {
//		printf("Key 'Slon' not found\n");
//	}
//    _getch();
//	return 0;
//}

 

1.8.6. Лабораторная работа № 13. Хэш-таблицы c открытой адресацией

Hash.h

#pragma once
#define HASHDEL (void*) -1
struct Object
{
	void** data;
	Object(int, int(*)(void*));
	int size;  int N;
	int(*getKey)(void*);
	bool insert(void*);
	int searchInd(int key);
	void* search(int key);
	void* deleteByKey(int key);
	bool deleteByValue(void*);
	void scan(void(*f)(void*));
};
static void* DEL = (void*)HASHDEL;
Object create(int size, int(*getkey)(void*));
#undef HASHDEL

Hash.cpp

#include "Hash.h"
#include <iostream>

int HashFunction(int key, int size, int p)    //Хэш-функция
{
	double key2=5 * ((0.6180339887499 * key) - int((0.6180339887499 * key)));
	return (p + key) % size;	
	//или return ((int)(p+fmod(((key*(sqrt(5.0)-1))/2), 1)))%size;
}
//-------------------------------
int Next_hash(int hash, int size, int p)
{
	return (hash + 5 * p + 3 * p * p) % size;
}
//-------------------------------
Object create(int size, int(*getkey)(void*))
{
	return *(new Object(size, getkey));
}
//-------------------------------
Object::Object(int size, int(*getkey)(void*))
{
	N = 0; 
	this->size = size; 
	this->getKey = getkey;  
	this->data = new void*[size];
	for (int i = 0; i < size; ++i)
		data[i] = NULL;
}
//-------------------------------
bool Object::insert(void* d)
{
	bool b = false;
	if (N != size)
		for (int i = 0, t = getKey(d), j = HashFunction(t, size, 0);
i != size && !b;  j = Next_hash(j, size, ++i))
			if (data[j] == NULL || data[j] == DEL)
			{
				data[j] = d; 
				N++; 
				b = true;
			}
	return b;
}
//-------------------------------
int Object::searchInd(int key)
{
	int t = -1; 
	bool b = false;
	if (N != 0)
		for (int i = 0, j = HashFunction(key, size, 0);
data[j] != NULL && i != size && !b;	j = HashFunction(key, size, ++i))
			if (data[j] != DEL)
				if (getKey(data[j]) == key)
				{
					t = j;
					b = true;
				}
	return t;
}
//-------------------------------
void* Object::search(int key)
{
	int t = searchInd(key);
	return(t >= 0) ? (data[t]) : (NULL);
}
//-------------------------------
void* Object::deleteByKey(int key)
{
	int i = searchInd(key);
	void* t = data[i];
	if (t != NULL)
	{
		data[i] = DEL;
		N--;
	}
	return t;
}
//-------------------------------
bool Object::deleteByValue(void* d)
{
	return(deleteByKey(getKey(d)) != NULL);
}
//-------------------------------
void Object::scan(void(*f)(void*))
{
	for (int i = 0; i < this->size; i++)
	{
		std::cout << " Элемент" << i;
		if ((this->data)[i] == NULL)
			std::cout << "  пусто" << std::endl;
		else 
			if ((this->data)[i] == DEL)
					std::cout << "  удален" << std::endl;
			else
				f((this->data)[i]);
	}
}

MyF.cpp

#include "Hash.h"
#include <iostream>
using namespace std;

struct AAA
{
	int key;
	char *mas;
	AAA(int k, char*z)
	{
		key = k;  mas = z;
	} AAA() {}
};
//-------------------------------
int key(void* d)
{
	AAA* f = (AAA*)d;   return f->key;
}
//-------------------------------
void AAA_print(void* d)
{
	cout << " ключ " << ((AAA*)d)->key << " - " << ((AAA*)d)->mas << endl;
}
//-------------------------------
int main()
{
	setlocale(LC_ALL, "rus");
	AAA a1(1, "one"), a2(2, "two"), a3(4, "three"), a4(2, "fo");
	int siz = 10;
	cout << "Введите размер хэш-таблицы" << endl;
	cin >> siz;
	Object H = create(siz, key);   //создать	
	int choice;  int k;
	for (;;)
	{
		cout << "1 - вывод хэш-таблицы" << endl;
		cout << "2 - добавление элемента" << endl;
		cout << "3 - удаление элемента" << endl;
		cout << "4 - поиск элемента" << endl;
		cout << "0 - выход" << endl;
		cout << "сделайте выбор" << endl;   cin >> choice;
		switch (choice)
		{
		case 0:
			exit(0);
		case 1: 
			H.scan(AAA_print);
			break;
		case 2:
			{AAA *a = new AAA;
			char *str = new char[20];
			cout << "введите ключ" << endl;
			cin >> k;
			a->key = k;
			cout << "введите строку" << endl;
			cin >> str; a->mas = str;
			if (H.N == H.size)
				cout << "Таблица заполнена" << endl;
			else
				H.insert(a);
			}  break;
		case 3:
			{	cout << "введите ключ для удаления" << endl;
			cin >> k;
			H.deleteByKey(k);
			}  break;
		case 4:
			{cout << "введите ключ для поиска" << endl;
			cin >> k;
			if (H.search(k) == NULL)
				cout << "Элемент не найден" << endl;
			else
				AAA_print(H.search(k));
			}
			break;
		}
	}
	return 0;
}

 

1.8.7. Лабораторная работа № 14. Хэш-таблицы c цепочками

Hash_Twin_Chain.h

//Заголовочный файл Hash_ Twin_Chain.h
#pragma once
#include "Lists.h"
namespace hashTC
{
	struct Object
	{
		int size;
		int(*FunKey)(void*);
		listx::Object* Hash;
		Object(int size, int(*f)(void*))
		{
			size = size;	
			FunKey = f;
			Hash = new listx::Object[size];
		};
		int hashFunction(void* data);
		bool insert(void* data);
		listx::Element* search(void* data);
		bool deleteByData(void* data);
		void Scan();
	};
	Object create(int size, int(*f)(void*));
}

Lists.h

//Заголовочный файл Lists.h
#include <stddef.h>
#pragma once
#define LISTNIL (Element*)-1
namespace listx
{
	struct Element
	{
		Element* prev;
		Element* next;
		void* data;
		Element(Element* prev, void* data, Element* next)
		{
			prev = prev;
			data = data;
			next = next;
		}
		Element* getNext()
		{
			return next;
		};
		Element* getPrev()
		{
			return prev;
		};
	};
	static Element* NIL = NULL;
	struct Object
	{
		Element* head;
		Object()
		{
			head = NIL;
		};
		Element* getFirst()
		{
			return head;
		};
		Element* getLast();
		Element* search(void* data);
		bool insert(void* data);
		bool deleteByElement(Element* e);
		bool deleteByData(void* data);
		void scan();
	};
	Object create();
}
#undef LISTNIL

Hash_Table.cpp

#include "Hash_Twin_Chain.h"
#include "Lists.h"
#include <iostream>

struct AAA
{
	int key;
	char *mas;
	AAA(int k, char*z)
	{
		key = k;
		mas = z;
	}
};
namespace hashTC
{
	Object create(int size, int(*f)(void*))
	{
		return *(new Object(size, f));
	}
	int Object::hashFunction(void* data)
	{
		return (FunKey(data) % size);
	};
	bool Object::insert(void* data)
	{
		return (Hash[hashFunction(data)].insert(data));
	};
	bool Object::deleteByData(void* data)
	{
		return (Hash[hashFunction(data)].deleteByData(data));
	};
	listx::Element* Object::search(void* data)
	{
		return Hash[hashFunction(data)].search(data);
	};
	void Object::Scan()
	{
		for (int i = 0; i < size; i++)
		{
			Hash[i].scan(); 
			std::cout << '\n';
		}
	};
}

Lists.cpp

#include "Lists.h"
#include <iostream>

struct AAA        //элемент таблицы
{
	int key;
	char *mas;
};
namespace listx
{
	bool Object::insert(void* data)
	{
		bool rc = NULL;
		if (head == NULL)
			head = new Element(NULL, data, head);
		else
			head = (head->prev = new Element(NULL, data, head));
		return rc;
	}
//-------------------------------
	Element* Object::search(void* data)
	{
		Element* rc = head;
		while ((rc != NULL) && ((((AAA*)rc->data)->key) != ((AAA*)data)->key))
			rc = rc->next;
		return rc;
	}
//-------------------------------
	bool Object::deleteByElement(Element* e)
	{
		bool rc = NULL;
		if (rc = (e != NULL))
		{
			if (e->next != NULL) 
				e->next->prev = e->prev;
			if (e->prev != NULL) 
				e->prev->next = e->next;
			else
				head = e->next;
			delete e;
		}
		std::cout << "Элемент удален" << std::endl;
		return rc;
	}
//-------------------------------
	bool Object::deleteByData(void* data)
	{
		return deleteByElement(search(data));
	}
//-------------------------------
	Element* Object::getLast()
	{
		listx::Element* e = this->getFirst(),
			          *rc = this->getFirst();
		while (e != NULL)
		{
			rc = e;
			e = e->getNext();
		};
		return rc;
	}
	Object create()
	{
		return *(new Object());
	};
//-------------------------------
	void Object::scan()   
	{
		listx::Element* e = this->getFirst();
		while (e != NULL)
		{
			std::cout << ((AAA*)e->data)->key << '-' << ((AAA*)e->data)->mas << " / ";
			e = e->getNext();
		};
	}
}

MyF.cpp

#include "Hash_Twin_Chain.h"
#include <iostream>
#include <stddef.h>
using namespace std;

struct AAA
{
	int key;
	char *mas;
	AAA(int k, char*z)
	{
		key = k;
		mas = z;
	}
	AAA()
	{
		key = 0; 
		mas = "";
	}
};
//-------------------------------
int hf(void* d)
{
	AAA* f = (AAA*)d;
	return f->key;
}
//-------------------------------
void AAA_print(listx::Element* e)
{
	std::cout << ((AAA*)e->data)->key << '-' << ((AAA*)e->data)->mas << " / ";
}

//-------------------------------
int main()
{
	setlocale(LC_ALL, "rus");
	int current_size = 7;
	cout << "Ведите размер хэш-таблицы" << endl; 
	cin >> current_size;
	hashTC::Object H = hashTC::create(current_size, hf);
	int choice;
	int k;
	for (;;)
	{
		cout << "1 - вывод хэш-таблицы" << endl;
		cout << "2 - добавление элемента" << endl;
		cout << "3 - удаление элемента" << endl;
		cout << "4 - поиск элемента" << endl;
		cout << "0 - выход" << endl;
		cout << "сделайте выбор" << endl;
		cin >> choice;
		switch (choice)
		{
		case 0: //выход
			exit(0);
		case 2: //добавление элемента
		{
			AAA *a = new AAA;
			char *str = new char[20];
			cout << "введите ключ" << endl;
			cin >> k;
			a->key = k;
			cout << "введите строку" << endl;
			cin >> str;
			a->mas = str;
			H.insert(a);
		}
			break;
		case 1:
			H.Scan();
			break;
		case 3: //удаление элемента
		{
			AAA *b = new AAA;
			cout << "введите ключ" << endl;
			cin >> k;
			b->key = k;
			H.deleteByData(b);
		}
			break;
		case 4: //поиск элемента
			AAA *c = new AAA;
			cout << "введите ключ" << endl;
			cin >> k;
			c->key = k;
			if (H.search(c) == NULL)
				cout << "Элемент не найден" << endl;
			else {
				cout << "Первый элемент с данным клю-чом" << endl;
				AAA_print(H.search(c));
				cout << endl;
			}
			break;
		}
	}
	return 0;
}

 

1.9. Выводы
•	В настоящее время используется широко распространенный метод обеспечения быстрого доступа к большим объемам информации – хеширование.
•	Для установления соответствия ключей и данных строится хеш-таблица.
•	Хеш-таблица строится при помощи хеш-функций. Практическое применение получили функции прямого доступа, остатков от деления, середины квадрата, свертки.
•	При построении хеш-таблиц могут возникать коллизии, то есть ситуации неоднозначного соответствия данных ключу.
•	Разрешение коллизий проводится методом цепочек (открытое или внешнее хеширование) или методом открытой адресации (закрытое хеширование).
•	Поиск свободных ключей в методе открытой адресации может проводиться методом повторного хеширования с помощью линейного опробования, квадратичного опробования или двойного хеширования.
•	Идентификация данных в таблицах может осуществляться как по первичному, так и по вторичному ключу.
•	Хеширование имеет широкое практическое применение в теории баз данных, кодировании, банковском деле, криптографии и других областях.

1.10. Для самостоятельной работы. Лабораторная работа ХХ. Алгоритмы хеширования данных
Цель работы: изучить построение функции хеширования и алгоритмов хеширования данных и научиться разрабатывать алгоритмы открытого и закрытого хеширования при решении задач на языке C++.
При выполнении лабораторной работы для каждого задания требуется написать программу на языке С++, которая получает на данные с клавиатуры или из входного файла, выполняет их обработку в соответствии с требованиями задания и выводит результат в выходной файл. Для обработки данных необходимо реализовать функции алгоритмов хеширования данных. Ограничениями на входные данные являются максимальный размер строковых данных, допустимый диапазон значений используемых числовых типов в языке С++.

Задания к лабораторной работе.
Выполните приведенные ниже задания.
•	Составьте хеш-таблицу, содержащую буквы и количество их вхождений во введенной строке. Вывести таблицу на экран. Осуществить поиск введенной буквы в хеш-таблице.
•	Постройте хеш-таблицу из слов произвольного текстового файла, задав ее размерность с экрана. Выведите построенную таблицу слов на экран. Осуществите поиск введенного слова. Выполните программу для различных размерностей таблицы и сравните количество сравнений. Удалите все слова, начинающиеся на указанную букву, выведите таблицу.
•	Постройте хеш-таблицу для зарезервированных слов, используемого языка программирования (не менее 20 слов), содержащую HELP для каждого слова. Выдайте на экран подсказку по введенному слову. Добавьте подсказку по вновь введенному слову, используя при необходимости реструктуризацию таблицы. Сравните эффективность добавления ключа в таблицу или ее реструктуризацию для различной степени заполненности таблицы.
•	В текстовом файле содержатся целые числа. Постройте хеш-таблицу из чисел файла. Осуществите поиск введенного целого числа в хеш-таблице. Сравните результаты количества сравнений при различном наборе данных в файле.

Указания к выполнению работы.
Каждое задание необходимо решить в соответствии с изученным алгоритмами хеширования данных, реализовав программный код на языке С++. Рекомендуется воспользоваться материалами лекции 38, где подробно рассматриваются описание используемых в работе алгоритмов, примеры их реализации на языке С++. Программу для решения каждого задания необходимо разработать методом процедурной абстракции, используя функции, коды которых требуется сопроводить комментариями. Результаты обработки данных следует выводить в выходной файл и дублировать вывод на экране. В отчете следует отразить разработку и обоснование математической модели решения задачи и результаты тестирования программ.
Следует реализовать каждое задание в соответствии с приведенными этапами:
•	изучить словесную постановку задачи, выделив при этом все виды данных;
•	сформулировать математическую постановку задачи;
•	выбрать метод решения задачи, если это необходимо;
•	разработать графическую схему алгоритма;
•	записать разработанный алгоритм на языке С++;
•	разработать контрольный тест к программе;
•	отладить программу;
•	представить отчет по работе.

Требования к отчету.
Отчет по лабораторной работе должен соответствовать следующей структуре.
•	Титульный лист.
•	Словесная постановка задачи. В этом подразделе проводится полное описание задачи. Описывается суть задачи, анализ входящих в нее физических величин, область их допустимых значений, единицы их измерения, возможные ограничения, анализ условий при которых задача имеет решение (не имеет решения), анализ ожидаемых результатов.
•	Математическая модель. В этом подразделе вводятся математические описания физических величин и математическое описание их взаимодействий. Цель подраздела – представить решаемую задачу в математической формулировке.
•	Алгоритм решения задачи. В подразделе описывается разработка структуры алгоритма, обосновывается абстракция данных, задача разбивается на подзадачи. Схема алгоритма выполняется по ЕСПД (ГОСТ 19.003-80 и ГОСТ 19.002-80).
•	Листинг программы. Подраздел должен содержать текст программы на языке программирования С++, реализованный в среде MS Visual Studio 2010.
•	Контрольный тест. Подраздел содержит наборы исходных данных и полученные в ходе выполнения программы результаты.
•	Выводы по лабораторной работе.
•	Ответы на контрольные вопросы.

Контрольные вопросы
•	Каков принцип построения хеш-таблиц?
•	Существуют ли универсальные методы построения хеш-таблиц? Ответ обоснуйте.
•	Почему возможно возникновение коллизий?
•	Каковы методы устранения коллизий? Охарактеризуйте их эффективность в различных ситуациях.
•	Назовите преимущества открытого и закрытого хеширования.
•	В каком случае поиск в хеш-таблицах становится неэффективен?
•	Как выбирается метод изменения адреса при повторном хешировании?



1. Файлы в C++.
1.1. Структура стандартной библиотеки ввода-вывода.
1.2. Предопределенные потоки
1.3. От файла STREAM.H к файлу IOSTREAM.H
1.4. Список классов iostream.
1.5. Простота ввода/вывода в С ++
1.5.1. Потоки cin, cout и сегг
1.5.2. Операции выделения ( >> ) и вставки ( << )
1.6. Опции ввода/вывода в С/С++.
1.7. Операции и методы классов
1.7.1. Вывод символов в C++
1.7.2. Преобразование системы счисления в C++
1.7.3. Форматирование строк в C++
1.7.4. Форматирование чисел в C++
1.7.5. Файловый ввод и вывод в C++
1.8. Классы ios_base и ios.
1.9. Потоки вывода.
1.9.1. Функции open, close и is_open
1.9.2. Функция flush
1.9.3. Функция put
1.9.4. Функция seekp и tellp
1.9.5. Функция write
1.9.6. Функция str
1.9.7. Классы потокового вывода.
1.10. Потоки ввода.
1.10.1. Функция gcount
1.10.2. Функция get
1.10.3. Функция getline
1.10.4. Функция ignore
1.10.5. Функция peek
1.10.6. Функция putback
1.10.7. Функция read
1.10.8. Функция seekg
1.10.9. Функция sync
1.10.10. Функция unget
1.10.11. Функция str
1.10.12. Классы потокового ввода.
1.11. Потоки ввода-вывода.
1.12. Классы буферизированных потоков.
1.13. Класс строковых потоков.
1.14. Форматирование потока.
1.15. Резидентные в памяти потоки
1.16. Буферы и синхронизация.
1.17. Условные признаки файлов в C++
1.18. Опрос и установка состояния потока
1.19. Ошибки потоков
1.20. Часто применяемые функции
1.21. Двоичные файлы.
1.22. Объединение программ на С и С++. Использование спецификатора extern "С".
1.23. Манипуляторы.
1.23.1. Манипуляторы без параметров.
1.23.2. Манипуляторы с одним параметром.
1.23.3. Манипуляторы с несколькими параметрами.

1. Файлы в C++.

http://www.itmathrepetitor.ru/s-lekciya-9-rabota-s-potokami-v-s/

1.1. Структура стандартной библиотеки ввода-вывода.
В языке программирования С++ стандартная библиотека ввода-вывода организована как иерархия шаблонов классов. Эта библиотека содержит два стандартных множества конкретизированных шаблонов этой иерархии: одно для работы с символами типа char, другое для работы с символами типа wchar_t. Классы для работы с символами типа wchar_t имеют те же имена, что и классы для работы с символами типа char, но с префиксом w.
Ниже перечислены заголовочные файлы, которые содержат интерфейсы классов из стандартной библиотеки ввода-вывода:

<ios>	ios_base, ios
<istream>	istream
<ostream>	ostream
<iostream>	iostream, cin, cout, cerr
<fstream>	ifstream, fstream, ofstream, filebuf
<sstream>	istringstream, stringstream, ostringstream, stringbuf
<streambuf>	streambuf

1.2. Предопределенные потоки
Теперь самое время заняться изучением реализации потоков ввода-вывода. Наряду с функциями библиотеки времени выполнения, предназначенными для ввода-вывода, в C++ включен дополнительный набор объектно-ориентированных подпрограмм ввода-вывода. Главным преимуществом системы ввода-вывода C++ является то, что она может перегружаться для создаваемых вами классов. В настоящее время используются две версии библиотеки ввода-вывода C++: старая или традиционная, основанная на предварительном варианте стандарта C++, и новая, определенная международным стандартом Standard C++. Внешне эти версии почти не различаются. Однако внутренняя их реализация совершенно различна. Новая версия библиотеки широко использует шаблоны классов. Поскольку мы еще не рассмотрели использование шаблонов классов, эти детали реализации мы будем опускать.
Поток ввода-вывода - это логическое устройство, предназначенное для приема и выдачи информации пользователю. Поток связан с физическим устройством с помощью системы ввода-вывода C++. Тем самым поток обеспечивает пользователю единый интерфейс при работе с системой ввода-вывода. Это означает, что, например, для вывода информации на экран монитора и для записи ее в файл используется одна и та же функция. Когда программа на C++ начинает выполняться, автоматически создаются восемь предопределенных стандартных потоков. Эти стандартные потоки связаны со стандартными файлами stdin, stdout и stderr языка С.

Предопределенные стандартные потоки и связанные с ними стандартные файлы языка С
Поток для "узких" символов	Поток для "широких" символов	Стандартный файл языка С
cin	wcin	stdin
cout	wcout	stdout
cerr	wcerr	stderr
clog	wclog	stderr

Как и стандартные файлы языка С, все эти потоки по умолчанию связаны с терминалом. Объект cin управляет вводом из буфера потока, связанного с объектом stdin, объявленным в <cstdio>. По умолчанию эти два потока синхронизированы. Объект cout управляет буфером потока, связанным с объектом stdout. объявленным в <cstdio>. По умолчанию эти два потока также синхронизированы. Поток clog - это просто буферизованная версия потока cerr. В буферизованной версии потока запись на реальное внешнее устройство делается, только когда буфер полон. Поэтому clog является более эффективным для перенаправления вывода в файл, в то время как cerr используется главным образом для вывода на экран терминала.
Система ввода-вывода содержит две иерархии классов: одну, предназначенную для работы с ASCII-символами, имеющими длину 8 бит, и другую, предназначенную для работы с UNICODE-символами, имеющими длину 16 бит. Символы первого набора называются "узкими", а второго - "широкими". Стандартные потоки, перечисленные в столбце 2 таблицы, предназначены для работы с "широкими " символами. На самом деле ситуация несколько сложнее, поскольку шаблонные классы представляют собой просто классы, содержащие типы данных в качестве параметров. Поэтому имена классов у каждой из иерархий одинаковы, но предназначены они для использования с разными наборами символов, которые им передаются в качестве параметра. В дальнейшем мы будем говорить о классах этих иерархий, употребляя только их имена. В основе иерархии потоковых классов лежит класс basic_ios, который в качестве своего подобъекта абстрактный класс basic_streambuf. Последний является базовым классом для создания буфера потока, который управляет передачей элементов в поток и из него для специализированных видов потоков.
Класс basic_ios является базовым для нескольких производных классов, среди которых классы basic_istream, basic_ostream и basic_iostream. Он содержит наиболее общие функции, необходимые для всех потоков, и обслуживает информацию о состоянии, которая отражает целостность потока и буфер потока. Этот класс также обслуживает связь потоковых классов с классами буферов потоков с помощью функции-члена rdbuf (). Классы, производные от basic_ios, специализируют операции ввода-вывода. В свою очередь, basic_ios использует класс ios_base, который также является базовым классом для всех потоковых классов. Он не зависит от типа символов и инкапсулирует информацию, необходимую для всех потоков. Эта информация включает в себя:
	управляющую информацию для синтаксического анализа и форматирования;
	дополнительную информацию для нужд пользователя (которая предоставляет путь для расширения потоков, как мы увидим позже):
	наполнение потока региональными (или локальными) символами.

Кроме того, этот класс определяет несколько типов данных, используемых всеми потоковыми классами, такие как флаги форматирования, биты состояния, режимы открытия файлов и т.д.

С точки зрения UNIX клавиатура и экран -- это файлы. Есть три стандартные константы:

FILE *stdin
FILE *stdout
FILE *stderr

Это три стандартных заранее открытых файла.

stdin - это стандартный файл (поток) ввода, а stdout -- стандартный файл (поток) вывода. Таким образом:

scanf(...) в точности эквивалентно fscanf(stdin, ...)
printf(...) в точности эквивалентно fprintf(stdout, ...)

Такой гибкостью можно воспользоваться при написании программы для работы с файлами. Например, для отладки программы можно выводить информацию на экран монитора, а не в файл. Для этого в начале работы с файлом пишем две строчки:

//FILE *f = fopen(...);
FILE *f = stdin;

При этом код программы будет содержать такие функции: fscanf(f, ...) или fprintf(f, ...). А когда отладка законичится, просто снимаем/ставим соответствующие комментарии в двух строчках программы.

stderr -- это стандартный файл (поток) ошибок. По умолчанию выводит данные на экран.

Но существует заметное отличие этого "файла" от stdin и stdout: stderr -- небуферизованный файл (поток). Поэтому в этот файл (поток) все байты уходят без "задержки", которая могла бы возникнуть при буферизированном подходе. Понятно, что польза от этого подхода заключается в том, что вместо кода:

fprintf(stdout, ...);
fflush(stdout);

мы пишем:

fprintf(stderr, ...);

В языке C++ объекты для работы с файлами называются потоками (streams). В данном случае слово "поток" означает то же самое, что и "файл" в языке C.
Классы для работы с файлами в языке C++ называются std::istream и std::ostream для ввода и вывода соответственно. 

1.3. От файла STREAM.H к файлу IOSTREAM.H
Одним из самых впечатляющих усовершенствований компилятора C++ является новая библиотека ввода/вывода, библиотека iostream. Средства ввода/вывода не включены в сам язык C++; они реализованы на этом языке и поставляются как компоненты стандартной библиотеки C++, что позволяет по мере необходимости развивать возможности ввода/вывода. Эта новая библиотека iostream заменяет предыдущую версию библиотеки ввода/вывода, которая называлась библиотекой потоков версии Release 1.2 (описана в книге Страуструпа "Язык программирования C++" — Stroustrup, The C++ Programming Language [Addison-Wesley, Reading, Massachusetts: 1990]).
На нижнем уровне C++ интерпретирует файл как последовательность или как поток байтов. На этом уровне концепция типов данных отсутствует. Одна компонента библиотеки ввода/вывода отвечает за передачу этих байтов. Однако с точки зрения пользователя файл состоит из смешанной последовательности цифр и букв или, что возможно, из объектов класса. Другая компонента библиотеки ввода/вывода обеспечивает интерфейс между двумя этими уровнями. В библиотеке iostream предопределен набор операций для выполнения считывания и записи встроенных типов данных. Также библиотека обеспечивает пользовательские расширения для обработки классов.
Базовые операции ввода обеспечивает класс istream, а операции вывода — класс ostream. Двунаправленный ввод/вывод поддерживается классом iostream, который является производным от istream и ostream. Для пользователя предопределены четыре потоковых объекта:

cin	Объект класса istream, связанный со стандартным вводом
cout	Объект класса ostream, связанный со стандартным выводом
сегг	Небуферизированный выходной объект класса ostream, связанный со стандартным устройством ошибок
clog	Буферизированный выходной объект класса ostream, связанный со стандартным устройством ошибок

В любую программу, использующую библиотеку iostream, должен быть включен заголовочный файл iostream.h. Поскольку iostream.h рассматривает stream.h как псевдоним, программы, написанные с использованием stream.h, могут требовать изменений, а могут и не требовать — в зависимости от конкретных структур.
Новую библиотеку ввода/вывода можно также использовать для выполнения файловых операций ввода и вывода. Связать файл с программой можно при помощи описаний трех следующих классов:

fstream	Производный от iostream, связывает файл с приложением для считывания и записи
ifstream	Производный от istream, связывает файл с приложением только для считывания
ofstream	Производный от ostream, связывает файл с приложением только для записи

Код для открытия файла и его чтения выглядит примерно так:

ifstream ifs;
ifs.open("file1.txt");
// далее с помощью оператора >> можно читать из файла, если он успешно открылся;

Аналогично можно использовать конструктор с параметром: ifs("file1.txt"); после чего создается объект и открывается по возможности файл.
В классе istream есть метод close(), который закрывает файл (на подобие работы с файлами в языке C). Однако вызывать этот метод необязательно. Дело в том, что в деструкторе класса этот метод вызовется автоматически.
Работа с объектами классов ofstream и ofstream и fstream осуществляется по аналогичному сценарию.

1.4. Список классов iostream.
За исключением классов буферизированных потоков, все объекты ввода/вывода, описанные в библиотеке классов iostream, используют один и тот же абстрактный базовый класс потоков, называемый ios. Как показано в таблице, эти производные классы делятся на четыре категории.

Классы потокового ввода
istream	Используется как универсальное средство ввода или как родительский класс для других производных классов потокового ввода
ifstream	Используется для ввода из файлов
istream_withassign	Используется для ввода из потока cin
istrstream	Используется для ввода строк

Классы потокового вывода
ostream	Используется как универсальное средство потокового вывода или как родительский класс для других производных классов потокового вывода
ofstream	Используется для вывода в файл
ofstream_withassign	Используется для вывода в потоки cout, cerr и clog
ostrstream	Используется для вывода строк

Классы потокового ввода/вывода
iostream	Используется как универсальное средство ввода и вывода или как родительский класс для других производных классов потокового ввода/вывода
fstream	Класс файлового потокового ввода/вывода
strstream	Класс потокового ввода/вывода строк
stdiostream	Стандартный класс потокового ввода/вывода

Классы буферизированных потоков
streambuf	Используется как родительский класс для производных объектов
filebuf	Класс буферизированных потоков для дисковых файлов
strstreambuf	Класс буферизированнных потоков для строк
stdiobuf	Класс буферизированных потоков для стандартного файлового ввода/вывода

На рисунке показаны взаимоотношения между перечисленными классами потока ios.

 

Для обработки реального ввода/вывода во всех производных от ios классах iostream используется объект класса streambuf. В библиотеке классов iostream используются следующие три производных класса для буферизированных потоков:
filebuf	Обеспечивает буферизированный ввод/вывод дисковых файлов
strstreambuf	Поддерживает хранящийся в памяти байтовый массив, содержащий данные потока
stdiobuf	Обеспечивает буферизированный дисковый ввод/вывод, при этом всю буферизацию выполняет стандартная система ввода/вывода

Напомним, что все производные классы обычно являются расширениями наследуемых определений родительского класса. Этим объясняется тот факт, что в некотором производном классе могут часто использоваться операции или методы класса, которые непосредственно не описываются в этом классе.
Это означает, что если нужно хорошо понять работу любого производного класса, то следует вернуться к описанию базового или родительского класса.
Во всех последующих примерах используется некий производный класс, полученный на основе какого-нибудь родительского класса. В одних примерах задействуются методы производного класса, в других — наследуемые характеристики. Эти примеры помогут понять многие преимущества производных классов и наследуемых свойств. Поначалу эти концепции могут показаться сложными, однако вскоре становится ясным, что для того, чтобы воспользоваться функциональными возможностями какого-либо ранее описанного класса, достаточно описать производный класс на основе предопределенного.

1.5. Простота ввода/вывода в С ++
В пакет компилятора Micrisoft Visual C++ включена стандартная библиотека, содержащая функции, часто используемые в среде C++. В C++ по-прежнему можно пользоваться библиотекой стандартного ввода/вывода С, описанной в заголовочном файле stdio.h. В C++, однако, имеется другой заголовочный файл, называемый iostream.h, который реализует набор собственных функций ввода/вывода.
В языке C++ потоковый ввод/вывод описывается как набор классов в iostream.h. Эти классы используют перегруженные операции "занести в" и "получить из" << и >>. Для того чтобы лучше понять, почему библиотека потоков в C++ более удобна, чем в С, давайте сначала посмотрим, как С управляет вводом и выводом.
Во-первых, напоминаем, что в С отсутствуют встроенные операции ввода или вывода; функции, подобные printf(), являются частью стандартной библиотеки, но не самого языка. В C++ также нет встроенных средств ввода/вывода; это обеспечивает большую гибкость при разработке эффекгивного пользовательского интерфейса со структурами данных проектируемого приложения.
Проблема с вводом и выводом в С заключается в реализации этих функций, плохо согласующихся между собой, если рассматривать возвращаемые значения и списки параметров. По этой причине программисты предпочитают использовать функции форматированного ввода/вывода printf(), scanf() и другие — в особенности, в тех случаях, когда обрабатываемыми объектами являются числа или другие несимвольные величины. Такие функции форматированного ввода/вывода удобны и, в своем большинстве, согласованы по интерфейсу; однако, они громоздки, поскольку должны работать с объектами различных форматов.
В языке C++ концепция класса обеспечивает модульное решение задачи манипуляции с данными. В стандартной библиотеке C++ имеются три класса ввода/вывода, являющиеся альтернативой функциям универсального ввода/вывода в С. Эти классы содержат описания для одной и той же пары операций, << и >>, которые оптимизируются для всех типов данных.

1.5.1. Потоки cin, cout и сегг
Аналогами потоков stdin, stdout и stderr, имеющих прототипы в файле stdio.h, в C++ являются cin, cout и сеrr, описанные в iostream.h. Эти три потока открываются автоматически при запуске программы и становятся интерфейсом между программой и пользователем. Поток cin связан с клавиатурой терминала. Потоки cout и сегг связаны с видеодисплеем.
Еще в header <iostream> объявлены переменные std::cin и std::cerr для стандартного потока ввода и потока ошибок соответственно. Они являются объектами классов std::istream и std::ostream соотсветственно.
Аналогично тому, как stderr отличается от stdin, в языке C++ std::cerr отличается от std::cout отсутствием буферизации.
В классе std::istream есть перегруженный оператор >>. Можно считывать информацию из стандартного потока ввода (с клавиатуры).

1.5.2. Операции выделения ( >> ) и вставки ( << )
Ввод и вывод в C++ значительно усовершенствован и упрощен, для чего использованы операции библиотеки потоков >> ("получить из" или выделение — extraction) и << ("занести в" или вставка — insertion). Одним из главных усовершенствований C++ по сравнению с С является возможность перегрузки операций, которая позволяет компилятору на основании информации о типах переменных выбирать одноименную функцию или операцию, которая должна выполняться. Операции выделения и вставки являются хорошими примерами этой новой возможности C++. Каждая операция перегружена и поэтому может управлять всеми стандартными типами данных C++, включая классы. Два следующих фрагмента иллюстрируют легкость использования базовых операций ввода/вывода в C++. Сначала посмотрим на оператор вывода С, использующий printf():

printf("Integer value: %d, Float value: %f",lvalue,fvalue);

А это — эквивалентный оператор на C++:

cout << "Integer value: " << lvalue << ", Float value: " << fvalue;

При внимательном анализе оператора C++ можно увидеть как перегруженная операция вставки используется для обработки трех различных типов данных: строки, целого числа и числа с плавающей точкой. Вам больше не потребуется искать символ %, необходимый в языке С в спецификациях формата для функций printf() и scanf(). В результате перегрузки операция вставки будет анализировать тип передаваемых ей данных и определять соответствующий формат.
Аналогичная ситуация существует для операции выделения, выполняющей ввод данных. Взгляните на следующий пример на С и на его эквивалент на C++:

/* С-код */
scanf ("%d%f%c", &ivalue, &fvalue, &с) ;

// C++ -код
cin >> ivalue >> fvalue >> c;

Теперь не требуется использовать перед переменными операцию определения адреса (&). В C++ операция выделения берет на себя заботу по определению адреса переменной, требований к памяти и форматированию.
Увидев в двух примерах на C++ операции << и >>, вы можете удивиться тому, что выбраны именно эти операции. Чтобы запомнить, какая операция выполняет вывод, а какая — ввод, проще всего рассматривать две этих операции по отношению к файлам потокового ввода/вывода. Когда вам необходимо ввести информацию, вы выделяете ее (>>) из входного потока cin и заносите в некоторую переменную — например, ivalue. Для вывода информации вы берете копию информации из переменной ivalue и вставляете ее (<<) в выходной поток cout.
Непосредственным результатом перегрузки операций является то, что в C++ программа может расширять операции вставки и выделения. В следующем фрагменте программы показано, как можно перегрузить операцию вставки так, чтобы она печатала новый тип stclient:

ostream& operator << (ostream& osout, stclient staclient)
{
	osout << " " << staclient.pszname;
	osout << " " << staclient.pszaddress;
	osout << " " << staclient.pszphone;
}

Если предположить, что структурная переменная staclient была инициализирована, то для печати информации достаточно одного оператора:

cout << staclient;

И последней, но немаловажной, особенностью операций вставки и выделения является их дополнительное преимущество — малый размер результирующего кода. Универсальные функции ввода/вывода printf() и scanf() помимо своего кода включают в исполняемый модуль программы много зачастую ненужной информации. Если вы работаете в С только с целыми числами, то все равно включаете весь код для преобразования дополнительных стандартных типов данных. В C++, напротив, компилятор включает только те процедуры, которые действительно нужны.
Библиотека потоков C++ предоставляет несколько преимуществ в сравнении с функциями ввода-вывода библиотеки времени выполнения.
Безопасность типов. Давайте сравним вызов функций stdio с использованием стандартных потоков. Вызов stdio для чтения выглядит следующим образом:

int i = 25;
char name[50] = "Простая строка";
fprintf(stdout, "%d %s", i, name);

Он правильно напечатает:

25 Простая строка

Однако, если вы по невнимательности поменяете местами аргументы хотя fprintf(), ошибка обнаружится только во время исполнения программы. Может произойти все что угодно: от странного вывода до краха системы. Этого не может случиться в случае использования стандартных потоков:

cout << i << ' ' << name << '\n';

Tак как имеются перегруженные версии оператора сдвига operator << (), первый оператор всегда будет вызван. Функция cout << i вызывает operator << (int), a cout << name вызывает operator << (const char*). Следовательно, использование стандартных потоков является безопасным по типам данных.
Расширяемость для новых типов. Другим преимуществом стандартных потоков является то, что определённые пользователем типы данных могут быть без труда в них встроены. Рассмотрим тип Pair, мы хотим напечатать:

struct Pair {int x; string у;}

Все, что нам нужно сделать, это -- перегрузить оператор operator << () для этого типа Pair, и мы сможем осуществлять вывод следующим образом:

Pair p(25, "December");
cout << р;

Соответствующий оператор operator << () может быть реализован так:

ostream<char>&operator<<(ostream<char>& о, const Pair& p)
{return 0 << р.х<< ' ' << р.у;}

Простота и последовательность. Библиотека потоков поддерживает единообразный интерфейс ввода-вывода, благодаря широкому использованию перегруженных функций и операторов. Это приводит к более простому и интуитивно понятному синтаксису.

Операции помещения и извлечения из потока
Вывод в поток выполняется с помощью оператора вставки (в поток), которым является перегруженный оператор сдвига влево <<. Левым его операндом является объект потока вывода. Правым его операндом может являться любая переменная, для которой определен вывод в поток (т.е. переменная любого встроенного типа или любого определенного пользователем типа, для которого она перегружена). Например,

cout << "Hello!\n";

приводит к выводу в предопределенный поток cout строки "Hello! ".
Оператор << возвращает ссылку на объект ostream, для которого он вызван. Это позволяет строить цепочки вызовов оператора вставки в поток, которые выполняются слева направо:

int i = 5;
double d = 2.08;
cout << "i = " << i << " d = " << d << '\n';

Эта инструкция приведет к выводу на экран следующей строки:

i = 5, d = 2.08

Оператор вставки в поток поддерживает следующие встроенные типы данных: bool, char, short, int. long, char* (рассматриваемый как строка), float, double, long double, и void*:

ostream type& operator<< (bool n);
ostream_type& operator<< (short n);
ostream type& operator<<(unsigned short n);
ostream type& operator<< (int n);
ostream_type& operator<< (unsigned int n);
ostream_type& operator<< (long n);
ostream_type& operator<< (unsigned long n);
ostream_type& operator<< (float f);
ostream_type& operator<< (double f);
ostream_type& operator<< (long double f);
ostream_type& operator<< (const void *p);

Целочисленные типы форматируются в соответствии с правилами, принятыми по умолчанию, для функции printf () (если они не изменены путем установки различных флагов форматирования). Например, следующие две инструкции дают одинаковый результат:

int i;
long l;
cout << i << " ' << l;
printf("%d%ld",i, l);

Тип void* используется для отображения адреса указателя:

int i;
//Отображить адрес указателя
//в 16-ричной форме.
cout << &i;

Для ввода информации из потока используется оператор извлечения, который является перегруженный оператор сдвига вправо >>. Левым операндом оператора >> является объект класса istream. Это позволяет строить цепочки инструкций извлечения из потока, выполняемых слева направо. Правым операндом может быть любой тип данных, для которого определен поток ввода.

istream_type& operator>>(bool& n);
istream_tvpe& operator>>(short& n);
istream_type& operator>>(unsigned short& n);
istream_type& operator>> (int& n);
istream_type& operator>>(unsigned int& n);
istream_type& operator>>(long& n);
istream_type& operator>>(unsigned long& n);
istream_type& operator>>(float& f);
istream_type& operator>>(double& f);
istream_type& operator>>(long double& f);
istream_type& operator>>(void*& p);

По умолчанию оператор >> пропускает символы-заполнители, затем считывает символы, соответствующие типу заданной переменной. Пропуск ведущих символов-заполнителей устанавливается специально для этого предназначенным флагом форматирования. Рассмотрим следующий пример:

int i;
double d;
cin >> i >> d;

Последняя инструкция приводит к тому, что программа пропускает ведущие символы-заполнители и считывает целое число i. Затем она игнорирует любые символы-заполнители, следующие за целым числом, и считывает переменную с плавающей точкой d.
Для переменной типа char* (рассматриваемого как строка) оператор >> пропускает символы-заполнители и сохраняет следующие за ними символы, пока не появится следующий символ-заполнитель. Затем в указанную переменную добавляется нуль-символ.
В следующей программе показано использование операции ввода (или выделения) >> для считывания различных типов данных:

//04.12INSTR1
// Программа на C++, демонстрирующая использование операции
// выделения >> для ввода типов char, int, float, double и строк
#include "stdafx.h"
#include <iostream>
using namespace std;

#define INUMCHARS 45
#define INULL_CHAR 1
void main(void)
{
	char canswer;
	int ivalue;
	float fvalue;
	double dvalue;
	char pszname[INUMCHARS+INULL_CHAR];
	
// Эта программа позволяет вводить различные типы данных.
// Вы хотите ее испробовать ? // Напечатайте y — да или n — нет:
	cout << "This program allows you to enter various data types." << "\n";
	cout << "Would you like to try it?" << "\n\n";
	cout << "Please type a y for YES and n for NO: ";
	cin >> canswer;
	if(canswer == 'y')
	{
		cout << "\n" << "Enter an integer value: "; // Введите целое число
		cin >> ivalue;
		cout << "ivalue=" << ivalue << "\n\n";
			cout << "Enter a float value: "; // Введите вещественное число
			cin >> fvalue;
			cout << "fvalue=" << fvalue << "\n\n";
		cout << "Enter a double value: "; // Введите число двойной точности
		cin >> dvalue;
		cout << "dvalue=" << dvalue << "\n\n";
			cout << "Enter your first name: "; // Введите ваше имя
			cin >> pszname;
			cout << "pszname=" << pszname;
			cout << "\n\n";
	}
}

Результаты работы программы:

 

В приведенном примере для вывода строк-запросов используется простейшая форма операции вставки <<. Обратите внимание на то, что в программе используются четыре различных типа данных, но все операторы ввода cin >> выглядят одинаково, отличаясь только именем переменной. Те из вас, кто быстро печатает, но устал от поиска редко используемых символов %, " и & (необходимых для scanf()), могут дать отдых пальцам и глазам. Операция выделения в C++ значительно упрощает код и уменьшает вероятность ошибок.
Поскольку C++ быстро эволюционирует, вам необходимо с осторожностью использовать коды С или C++, встречающиеся в устаревшей литературе. Если вы, к примеру, запустите приведенную программу с компилятором C++ Release 1.2, то результат работы программы будет выглядеть несколько некорректно и будет оличаться от приведенного.

Это объясняется тем, что входной поток в C++ Release 1.2 обрабатывает символ перевода строки, введенный после печати буквы "y”. Операция вставки >> считывает, но не отбрасывает символ перевода строки. В следующей программе эта проблема решена, для чего добавлен еще один оператор ввода:

// 04.12INSRT2
// Программа на C++, демонстрирующая использование операции
// выделения >> для ввода типов char, int, float, double и строк
#include "stdafx.h"
#include <iostream>
using namespace std;

#define INUMCHARS 45
#define INULL_CHAR 1

void main(void)
{
	char canswer, c0x0Anewline;
	int ivalue;
	float fvalue;
	double dvalue;
	char pszname[INUMCHARS+INULL_CHAR];
	cout << "This program allows you to enter various data types." << "\n";
	cout << "Would you like to try it?" << "\n\n";
	cout << "Please type a y for YES and n for NO: ";
	cin >> canswer;
	cin.get(c0x0Anewline);
	if(canswer == 'y')
	{
		cout << "\n" << "Enter an integer value: ";
		cin >> ivalue;
		cout << "ivalue=" << ivalue << "\n\n";
			cout << "Enter a float value: ";
			cin >> fvalue;
			cout << "fvalue=" << fvalue << "\n\n";
		cout << "Enter a double value: ";
		cin >> dvalue;
		cout << "dvalue=" << dvalue << "\n\n";
			cout << "Enter your first name: ";
			cin >> pszname;
			cout << "pszname=" << pszname;
			cout << "\n\n";
	}
}

Вы заметили изменения? После считывания canswer программа выполняет оператор

	cin.get(c0x0Anewline);

Он обрабатывает символ перевода строки, и после запуска программа выдает следующий результат:

 

Оба алгоритма работают правильно с момента появления версии C++ Release 2.0. Стоит, однако, еще раз напомнить, что необходимо с осторожностью подходить к старым листингам программ. Если использовать старые версии программ на С и C++ с существующими компиляторами, то можно потратить много часов, пытаясь понять, почему ввод/вывод выполняется не так, как ожидалось.
В следующем примере демонстрируется использование различных форм операции вывода или вставки <<:

// 04.12EXTRCT
// Программа на C++, демонстрирующая использование операции
// вставки << для вывода типов char, integer, float, double и строк
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
using namespace std;

void main(void)
{
	char c = 'A';
	int ivalue = 10;
	float fvalue = (float)45.67;
	double dvalue = 2.3e32;
	char fact[] = "For all have ..."; // Сколько не имей …
	cout << "Once upon a time there were "; // Жили однажды
	cout << ivalue << " people." << endl; // ... человек
	cout << "Some of them earrend " << fvalue; // Некоторые зарабатывали
	cout << " dollars per hour." << "\n"; //... долларов в час
	cout << "While others earrend " << dvalue << " per year!"; // Другие зарабатывали ... в год!
	cout << "\n\n" << "But you know what they say: "; // И знаете, что они говорили:
	cout << "\"" << fact << "\"" << "\n\n";
	cout << "So, none of them get an ";	// Поэтому никто из них не получает
	cout << c;				// высший балл
	cout << "!";
	cout << "\n\n";
}

Результат работы программы следующий:

 

Первое, что нужно отметить при сравнении исходного текста программы на C++ и полученного результата, это то, что операция вставки << не генерирует автоматически символ перевода строки. При необходимости это можно делать непосредственно, включая в программу символ \n или endl.
Константа endl очень полезна при выводе данных в интерактивном режиме, поскольку помимо вывода в поток символа перевода строки выполняется очистка выходного буфера. Для этого можно также использовать команду flush; однако, при этом не происходит перевода строки. Заметим также, что символ перевода строки может включаться после соответствующей операции вставки << и как часть литеральной строки, что видно в программе по второму и четвертому операторам <<. Нужно отметить, что, хотя операция вставки и удобна для форматирования целых и вещественных чисел, она не очень хорошо выводит числа двойной точности. Еще одна особенность этой операции проявляется в версии C++ Release 1.2 при выводе символов. Взгляните на следующий оператор:

cout << с;

В версии Release 1.2 вы получили бы следующий результат:

So, none of them get an 65!

Это вызвано тем, что символ преобразуется в эквивалентный ASCII-код. Для вывода символьной информации в версии Release 1.2 нужно использовать функцию put(). Поэтому данный оператор следует записать так:

cout.put(с);

Попробуйте запустить следующий пример:

// 04.12STRING
// Программа на C++, показывающая, что происходит при использовании
// операции выделения >> со строковыми данными
#include "stdafx.h"
#include <iostream>
using namespace std;


#define INUMCHARS 45
#define INUL_CHARACTER 1

void main(void)
{
	char pszname [INUMCHARS+INUL_CHARACTER];
	// Введите, пожалуйста, ваше имя и фамилию
	cout << "Please enter your first and second name: ";
	cin >> pszname;
	// Спасибо
	cout << "Thank you, " << pszname;
	cout << "\n\n";
}

Результат выполнения программы следующий:

 

Это — еще одна особенность, о которой нужно помнить при вводе строк. Операция выделения >> прекращает считывание информации, когда встречает разделительный символ, который может представлять собой символ пробела, табуляции или перевода строки. Поэтому при печати pszname выводится только первое имя. Эту проблему можно решить, если переписать программу, используя функцию cin.get():

// 04.12CINGET
// Программа на C++, показывающая, что происходит при использовании
// операции выделения >> вместе с функцией cin.get() при обработке полной строки
#include "stdafx.h"
#include <iostream>
using namespace std;

#define INUMCHARS 45
#define INUL_CHARACTER 1

void main(void)
{
	char pszname [INUMCHARS+INUL_CHARACTER];
	cout << "Please enter your first and second name: ";
	cin.get(pszname, INUMCHARS);
	cout << "Thank you, " << pszname;
	cout << "\n\n";
}

Результат выполнения этой программы следующий:

 

Функция cin.get() имеет два дополнительных параметра. В приведенном примере использовался только один из них — количество вводимых символов. Функция cin.get() считывает всю информацию, включая пробельные символы, до тех пор, пока не будет введено указанное максимальное число символов или считывание будет продолжаться до следующего символа перевода строки; это зависит от того, какое условие выполнится раньше. Третий, необязательный и не показанный здесь параметр задает символ окончания считывания. Например, следующий оператор будет считывать в переменную pszname INUMCHARS символов или все символы, предшествующие символу * или символу перевода строки, в зависимости от того, что раньше выполнится:

cin.get(pszname, INUMCHARS, '*');

1.6. Опции ввода/вывода в С/С++.
Ранее были представлены концепции и синтаксис объектно-ориентированных классов, конструкторов, деструкторов, методов классов и операций. Теперь можно переходить к более глубокому анализу ввода/вывода в С++.
Так же как и в С, в языке С++ отсутствуют какие-либо встроенные процедуры ввода/ввода. Вместо них все компиляторы С++ поставляются с объектно-ориентированными классами iostream. Эти стандартные объекты классов ввода/вывода синтаксически согласованы, поскольку разрабатывались авторами языка С++. Если нужно написать некоторое приложение С++, переносимое на другие компиляторы С++, то можно использовать классы iostream. В компиляторе Visual С/С++ имеются следующие средства (5 вариантов) для осуществления ввода/вывода в С/С++.
Библиотека С небуферизированного ввода/вывода — Компилятор С обеспечивает небуферизированный ввод/вывод при помощи функций _read() и _write(). Эти функции весьма популярны у программистов на С по причине своей эффективности и легкости их адаптации.
Буферизированный ввод/вывод ANSI С — В С имеются также буферизированные функции fread() и fwrite(). Они описаны в библиотеке stdio.h и выполняют собственную буферизацию перед непосредственным обращением к базовым процедурам ввода/вывода.
Библиотека С ввода/вывода на консоль и в порты — В С имеются дополнительные процедуры ввода/вывода, не имеющие аналогов в С++: _getch(), _ungetch() и _kbhit(). Во всех приложениях, не относящихся к Windows, можно использовать эти функции, обеспечивающие прямой доступ к аппаратному обеспечению.
Библиотека Microsoft классов iostream — Библиотека классов iostream предоставляет программам на С++ возможности объектно-ориентированного ввода/вывода. Ее можно использовать вместо таких функций, как scanf(), printf(), fscanf() и fprintf(). Однако, эти классы iostream не являются обязательными для программ на С++ и многие символьные объекты, например cin, cout, cerr и clog, не совместимы с графическим интерфейсом пользователя Windows.
Библиотека Microsoft Foundation Class — Класс Microsoft CFile, находящийся в библиотеке МFС, обеспечивает приложения С++ и, в особенности, Windows - приложения средствами объектного дискового ввода/вывода. Использование этих библиотечных процедур гарантирует переносимость приложения и легкость сопровождения.

Замечание
Общий совет заключается в том, что не надо смешивать техники для работы с файлами.
Например, не надо в одной и той же программе использовать функции из стандартной библиотеки C (fread/fwrite) и классы-потоки из языка C++ (istream/ostream).

1.7. Операции и методы классов
Для того чтобы принимать аргументы любых встроенных типов данных, включая char *, операции выделения >> и вставки << были модифицированы. Их также можно расширить, и они будут принимать в качестве параметров классы.
Первый случай несовместимости при преобразовании программ на C++, использующих старые библиотеки ввода/вывода, может возникнуть при модификации устаревшего расширения cout << form. В новой версии каждый объект класса iostream имеет переменные, управляющие операциями форматирования: например, преобразованием системы счисления для целых чисел или точностью числа с плавающей точкой.
Флагами статуса формата можно манипулировать при помощи функций setf() и unsetf(). Метод класса setf() используется для установки определенного флага статуса формата. Имеются два перегруженных варианта:

setf(long);
setf(long, long);

Первым аргументом может быть либо битовый флаг формата, либо битовое поле формата. В таблице перечислены флаги формата, которые можно использовать в варианте setf(long) (когда имеется только флаг формата).

Флаг	Значение
ios:: showbase	Отображает числовые константы в формате, который может читать компилятор C++
ios:: showpoint	Отображает числа float с точкой и нулями в конце
ios:: dec	Форматирует числа в десятичной системе счисления (система счисления по умолчанию)
ios:: oct	Форматирует числа в восьмеричной системе счисления
ios:: hex	Форматирует числа в шестнадцатеричной системе счисления
ios:: fixed	Показывает числа float в фиксированном формате
ios:: scientific	Показывает числа float в экспоненциальном формате
ios:: showpos	Отображает знак "плюс" (+) перед положительными числами
ios:: skipws	Пропускает пробельные символы на входе
ios:: left	Выравнивает слева все значения (дополняя справа указанным заполняющим символом)
ios: right	Выравнивает справа все значения (дополняя слева указанным заполняющим символом, опция по умолчанию)
ios:: internal	Добавляет заполняющие символы после любого знака или указателя системы счисления до начала числа
ios:: uppercase	Отображает заглавные "А" — "F" для шестнадцатеричных чисел; и "Е" для экспоненциальных значений
ios:: unitbuf	Заставляет ostream::osfx очищать поток после каждой операции вставки (по умолчанию сегг буферизируется)
ios::stdio	Заставляет ostream::osfx очищать stdout и stderr после каждой вставки

В следующей таблице перечислены некоторые битовые поля формата, которые можно использовать в варианте setf(long, Iong) (когда имеется флаг формата и битовое поле формата):

Битовое поле	Значение	Флаги
ios:: basefield	Целые числа	ios:: hex, ios:: oct, ios:: dec
ios:: floatfield	Числа с плавающей точкой	ios:: fixed, ios:: scientific

Имеются некоторые предопределенные установки по умолчанию. Например, целые числа пишутся и читаются как десятичные. Можно изменить основание системы счисления на восьмеричное, шестнадцатеричное или же обратно на десятичное. По умолчанию число с плавающей точкой выводится с точностью шесть цифр. Точность можно изменить при помощи метода определения точности. Эти новые методы классов используются в следующей программе на C++:

// 04.12ADVIO
// Программа на C++, демонстрирующая использование методов
// класса для преобразования и форматирования, имеющихся в версиях выше
// Release 2.0. Также в программе показано, как преобразовать все
// устаревшие операторы form версии Release 1.2
//
//#include "stdafx.h"
#include <stdio.h>
#include <strstream>
#include <iostream>

//using namespace std;

//
#include <string.h>
#include <strstrea.h>
#define INULL_TERMINATOR 1

void row (void);

int main()
{
char		c	=	'A',
		psz1[]	=	"In making a living today many no ",
		psz2[]	=	"longer leave any room for life.";

int		iln	=	0,
		ivalue	=	1234;

double		dPi	=	3.14159265;

// новые объявления, необходимые для Release 2.0
char		psz_padstring5[5+INULL_TERMINATOR],
		psz_padstring38[38+INULL_TERMINATOR];

/////////////////////////////// преобразования ˙ ///////////////////////////////

// печать символа с
// R1.2 cout << form("\n[%2d] %c", ++ln, c) ;
// обратите внимание на то, что для вывода char операция << перегружена
row(); // [ 1]
cout << c;

// печать ASCII-кода символа с
// R1.2 form("\n[%2d] %d",++ln, c);
row(); // [ 2]
cout << (int)c;

// печать символа с ASCII-кодом 90
// R1.2 form("\n[%2d] %c",++ln, 90);
row(); // [ 3]
cout << (char) 90;

// печать ivalue в виде восьмеричного числа
// R1.2 form("\n[%2d] %o",++ln, ivalue);
row(); // [ 4]
cout << oct << ivalue;

// печать шестнадцатеричного числа строчными буквами
// R1.2 form("\n[%2d] %õ",++ln, ivalue);
row(); // [ 5]
cout << hex << ivalue;

// печать шестнадцатеричного числа заглавными буквами
// R1.2 form("\n[%2d] %X",++ln, ivalue);
row(); // [ 6]
cout.setf (ios:: uppercase);
cout << hex << ivalue;
cout.unsetf(ios:: uppercase);	// выключить заглавные
cout << dec;			// вернуться к десятичному счислению

// опции преобразования и форматирования
// минимальная ширина 1
// R1.2 form("\n[%2d] %c",++ln, c);
row(); // [ 7]
cout << c;

// минимальная ширина 5, выравнивание вправо
// R1.2 form("\n[%2d] %5c",++ln,c) ;
row(); // [ 8]
ostrstream (psz_padstring5, sizeof (psz_padstring5)) << "	" << c << ends;
cout << psz_padstring5;

// минимальная ширина 5, выравнивание влево
// R1.2 form("\n[%2d] %-5c",++ln, c) ;
row(); // [ 9]
ostrstream(psz_padstring5, sizeof(psz_padstring5)) << c << "	" << ends;
cout << psz_padstring5;

// ширина 33 автоматически
// R1.2 form("\n[%d] %s",++ln, pszl);
row(); // [10]
cout << psz1;

// ширина 31 автоматически
// R1.2 form("\n[%d] %s",++ln, psz2);
row(); // [11]
cout << psz2;

// минимальная ширина 5 отменяется, ширина определяется автоматически
// R1.2 form("\n[%d] %5s",++ln, pszl);
// заметьте, что ширину 5 отменить не удалось!
row(); // [12]
cout.write(psz1,5);

// минимальная ширина 38, выравнивание вправо
// R1.2 form("\n[%d] %38s",++ln, psz1);
// обратите внимание на то, что при ширине 38 в конце появляется мусор
row(); // [13]
cout.write(psz1, 38);

// ниже следует правильный вариант
cout << "\n\nCorrected approach:\n";
ostrstream(psz_padstring38,sizeof(psz_padstring38)) << "	" << psz1 << ends;
row(); // [14]
cout << psz_padstring38;

// минимальная ширина 38, выравнивание влево
// R1.2 form("\n[%d] %-38s",++ln, psz2);
ostrstream(psz_padstring38, sizeof(psz_padstring38)) << psz2 << "	" << ends;
row(); // [15]
cout << psz_padstring38;

// ширина lvalue по умолчанию
// R1.2 form("\n[%d] %d",++ln, ivalue);
row(); // [16]
cout << ivalue;

// печать lvalue со знаком (+)
// R1.2 form("\n[%d] %+d",++ln, ivalue);
row(); // [17]
cout.setf(ios:: showpos);	 // для номера строки (+) не нужен
cout << ivalue;
cout.unsetf(ios:: showpos);

// минимальная ширина З отменяется, ширина определяется автоматически
// R1.2 form("\n[%d] %3d",++ln, lvalue);
row(); // [18]
cout.width(3);	// номер строки не нужно дополнять до 3
cout << ivalue;

// минимальная ширина 10, выравнивание вправо
// R1.2 form("\n[%d] %10d",++ln, ivalue);
row(); // [19]
cout.width(10);	// влияет только на первое выводимое значение
cout << ivalue;

// минимальная ширина 10, выравнивание влево
// R1.2 form("\n[%d] %-d",++ln, ivalue);
row(); // [20]
cout.width(10);
cout.setf(ios:: left);
cout << ivalue;
cout.unsetf(ios:: left);

// выравнивание вправо с начальными нулями
// R1.2 form("\n[%d] %010d",++ln, ivalue);
row(); // [21]
cout.width(10);
cout.fill('0');
cout << ivalue;
cout.fill(' ');

// число цифр по умолчанию
// R1.2 form("\n[%d] %f",++ln, dPi) ;
row(); // [22]
cout << dPi;

// минимальная ширина 20, выравнивание вправо
// R1.2 form("\n[%d] %20f",++ln, dPi) ;
row(); // [23]
cout.width(20);
cout << dPi;

// выравнивание вправо с ведущими нулями
// R1.2 form("\n[%d] %020f",++ln, dPi) ;
row(); // [24]
cout.width(20);
cout.fill('0');
cout << dPi;
cout.fill(' ');

// минимальная ширина 20, выравнивание влево
//R1.2 form("\n[%d] %-20f",++ln, dPi);
row(); // [25]
cout.width(20);
cout.setf(ios:: left);
cout << dPi;

// выравнивание влево с нулями в конце
// R1.2 form("\n[%d] %-020f",++ln, dPi);
row(); // [26]
cout.width(20);
cout.fill('0');
cout << dPi;
cout.unsetf(ios:: left);
cout.fill(' ');

// дополнительная точность при форматировании
// минимальная ширина 19, печать всех 19
// R1.2 form("\n[%d] %19.19s",++ln, psz1);
row(); // [27]
cout << psz1;

// печать первых 2 символов
// R1.2 form("\n[%d] %.2s",++ln, psz1);
row(); // [28]
cout.write(psz1,2);

// печать 2 символов, выравнивание вправо
// R1.2 form("\n[%d] %19.2s",++ln, psz1);
row(); // [29]
cout << "	";
cout.write(psz1,2);

// печать 2 символов, выравнивание влево
// R1.2 form("\n[%d] %-19.2s",++ln, psz1);
row(); // [30]
cout.write(psz1,2);

// использование аргументов печати
// R1.2 form("\n[%d] %*.*s", ++ln, 19, 6, psz1);
row(); // [31]
cout << "	";
cout.write(psz1, 6);

// ширина 10, 8 справа от '.'
// R1.2 form("\n[%d] %10.8f",++ln, dPi);
row(); // [32]
cout.precision(9);
cout << dPi;

// ширина 20, точность 2 с выравниванием вправо
// R1.2 form("\n[%d] %20.2f",++ln, dPi) ;
row(); // [33]
cout.width(20) ;
cout.precision(2);
cout << dPi;

//4 десятичных позиции, выравнивание влево
// R1.2 form("\n[%d] %-20.4f",++ln, dPi);
row(); // [34]
cout.precision(4);
cout << dPi;

//4 десятичных позиции, выравнивание вправо
// R1.2 form("\n[%d] %20.4f",++ln, dPi);
row(); // [35]
cout. width (20);
cout << dPi;

// ширина 20, экспоненциальный формат
// R1.2 form("\n[%d] %20.2e",++ln, dPi);
row(); // [36]
cout.setf (ios:: scientific);
cout.width(20);
cout << dPi;
cout.unsetf (ios:: scientific);
cout << "\n";
return (0);
}
void row (void)
{
	static int ln=0;
	cout << "\n[";
	cout.width(2);
	cout << ++ln << "] ";
}

Результат работы программы можно использовать при написании ваших собственных операторов сложного вывода:

 

В следующих разделах рассматриваются те операторы вывода, использованные в приведенной программе, которые требуют особого обсуждения. Одно необходимое замечание: файл strstream.h автоматически включает iostream.h. Файл strstream.h требуется для форматирования выводимых строк. Если в вашей программе нужен вывод только числовых данных или простой вывод символов и строк, то необходимо включить только файл iostream.h.

1.7.1. Вывод символов в C++
В новой библиотеке ввода/вывода (версии Release 2.0 и выше) для обработки символьных данных операция вставки « была перегружена. В ранних версиях следующий оператор напечатал бы ASCII-код символа с:

cout << с;

В нынешней библиотеке печатается сама символьная переменная. Если же нужно получить ASCII-код, то используется такой оператор:

cout << (int)c;

1.7.2. Преобразование системы счисления в C++
Есть два способа для вывода значения в разных системах счисления:

cout << hex << ivalue;

и другой способ

cout.setf(ios::hex, ios::basefield);
cout << ivalue;

В обоих случаях с момента выполнения оператора и далее устанавливается новая система счисления (хотя это нужно не всегда). Каждое выводимое значение будет форматироваться как шестнадцатеричное. Переход к некоторому другому основанию выполняется при помощи функции unsetf():

cout.unsetf(ios::hex, ios::basefield);

Если вам нужно выводить шестнадцатеричные числа заглавными буквами, то используйте следующий оператор:

cout.setf(ios::uppercase);

Когда необходимость в этом пропадает, опцию нужно выключить:

cout.unsetf(ios::uppercase);

1.7.3. Форматирование строк в C++
Распечатать строку в C++ несложно. Однако, форматирование строк изменилось, так как расширение cout << form, существовавшее в версии Release 1.2, теперь отсутствует. Для форматирования строки можно объявить массив символов, а затем выбрать необходимый формат вывода при распечатке буфера строки:

pszpadstring38[38 + INULL_TERMINATOR];
…
ostrstream(pszpadstring38,sizeof(pszpadstring38)) << "->" << psz1;

Метод класса ostrstream() является частью файла strstream.h и имеет три параметра: указатель на массив символов, размер массива и выводимая информация. Для выравнивания вправо этот оператор в начало строки psz1 добавляет пробелы. Часть строки можно вывести при помощи метода write объекта cout:

cout.write(psz1,5);

Этот оператор выведет первые пять символов строки psz1.

1.7.4. Форматирование чисел в C++
Возможен ли форматированный вывод, которым мы пользовались в языке C фунцией printf()? Например, как вывести ту же переменную N в 16-ой записи? В языке C++ форматированный вывод возможен при помощи вывода на экран специальной управляющей команды:

std::cout << std::ios::hex << N;

В точности то же самое выведет команда printf("%x", N);
Чтобы не писать перед кажой переменной ее формат, можно использовать функцию:

std::cout.setf(std::ios::hex);

Она установит формат вывода в стандартный поток вывода на экран. Этот подход настолько же мощный, как и использование форматной печати с помощью printf.

Можно без затруднений форматировать числовые данные: выравнивать вправо или влево, менять точность и формат (с плавающей точкой или экспоненциальный), добавлять в начало или в конец заполняющие символы, управлять знаком. Имеются некоторые установки по умолчанию. Например: по умолчанию выполняется выравнивание вправо, и точность чисел с плавающей точкой равна шести. В следующем фрагменте программы выводится значение dPi, выравненное влево в поле шириной 20 символов и с нулями в конце:

cout.width(20);
cout.setf(ios:: left);
cout.fill ('0');
cout << dPi;

Если добавить следующий оператор, то переменная dPi будет выводиться с точностью 2:

cout.precision(2);

Многие флаги вывода (например, выравнивание влево, выбор заглавных букв для шестнадцатеричных чисел, изменение системы счисления и многие другие) необходимо сбрасывать после того, как в них отпадает необходимость. Следующий оператор выключает выравнивание влево:

cout.unsetf(ios::left);

Для выбора экспоненциального формата достаточно установить соответствующий битовый флаг:

cout.setf (ios:: scientific);

Если установить флаг showpos, то можно печатать значения со знаком плюс (+) перед числом:

cout.setf (ios:: showpos);

Среди функций последней версии библиотеки ввода/вывода существует множество мелких деталей, которые поначалу могут вносить некоторую путаницу. Это объясняется тем, что некоторые операции, будучи однажды выполненными, изменяют состояние до момента выключения, а действие других операций распространяется только на следующий оператор вывода. Например: изменение ширины вывода cout.width(20) действует только на следующее печатаемое значение. Вот почему функция row() должна была постоянно менять ширину для печати форматированных номеров строк, занимающих две позиции — например, [ 1]. Другие операции форматирования, подобные изменению основания системы счисления, выбору заглавных букв, точности и формата (с плавающей точкой или экспоненциального), остаются активными до тех пор, пока их не выключат явно.

1.7.5. Файловый ввод и вывод в C++
Для осуществления операций с файлами библиотека ввода-вывода предусматривает три класса: ifstream, ofstream и fstream. Эти классы являются производными, соответственно, от классов istream, ostream и iostream. Поскольку эти последние классы, в свою очередь, являются производными от класса ios классы файловых потоков наследуют все функциональные возможности своих родителей (перегруженные операции << и >> для встроенных типов, функции и флаги форматирования, манипуляторы). Для реализации файлового ввода-вывода нужно включить в программу заголовочный файл <fstream>.
Существуют небольшие отличия между использованием предопределённых и файловых потоков. Файловый поток должен быть связан с файлом прежде, чем его можно будет использовать. С другой стороны, предопределенные потоки могут использоваться сразу после запуска программы, даже в конструкторах статических классов, которые выполняются даже раньше вызова функции main(). Вы можете позиционировать файловый поток в произвольную позицию в файле, в то время как для предопределённых потоков это обычно не имеет смысла.
Для создания файлового потока эти классы предусматривают следующие формы конструктора:
создать поток, не связывая его с файлом:

explicit ifstream();
explicit ofstream();
explicit fstream();

создать поток, открыть файл и связать поток с файлом:

explicit ifstream(const char *name,
				os::openmode mode = ios::in);
explicit ofstream(const char * name,
				ios::openmode mode = ios::out |
				ios::trunc);
explicit fstream(const char * name,
				ios::openmode mode = ios::in |
				ios::out);

Чтобы открыть файл для ввода или вывода, можно использовать вторую форму нужного конструктора

fstream fs("FileName.dat");

или вначале создать поток с помощью первой формы конструктора, а затем открыть файл и связать поток с открытым файлом, вызвав функцию-член open (). Эта функция определена в каждом из классов потокового ввода-вывода и имеет следующие прототипы:

void ifstream::open(const char *name,
					ios::openmode mode = ios::in);
void ofstream::open(const char * name,
					ios::openmode mode = ios::out |
					ios::trunc);
void fstream::open(const char * name,
					ios::openmode mode = ios::in |
					ios::out);

Здесь name - имя файла, mode - режим открытия файла.
Параметр mode является перечислением и может принимать значения, приведенные в таблице.

Режимы открытия и их назначение
Режим открытия	Назначение
ios::in	Открыть файл для чтения
ios::out	Открыть файл для записи
ios::ate	Начало вывода устанавливается в конец файла
ios::app	Окрьть файл для добавления в конец
ios:: trunc	Усечь файл, т.е. удалить его содержимое
ios::binary	Двоичный режим операций

Режимы открытия файла представляют собой битовые маски, поэтому вы можете задавать два или более режима, объединяя их операцией ИЛИ. В следующем фрагменте кода файл открывается для вывода с помощью функции open ():

ofstream ofs;
ofs.open("FileName.dat");

Обратите внимание, что по умолчанию режим открытия файла соответствует типу файлового потока. У потока ввода или вывода флаг режима всегда установлен неявно. Например, для потока вывода в режиме добавления файла можно вместо инструкции

ofstream ofs("FName.txt", ios:: out | ios::app);

написать следующую:

ofstream ofs("FName.txt", ios::app);

Между режимами открытия файла ios::app и ios::ate имеется небольшая разница.
Если файл открывается в режиме добавления весь вывод в файл будет осуществляться в позицию, начинающуюся с текущего конца файла, безотносительно к операциям позиционирования в файле. В режиме открытия ios:: ate (от англ. "at end" ) вы можете изменить позицию вывода в файл и осуществлять запись начиная с нее. Для потоков вывода режим открытия эквивалентен ios :: out | ios :: trunc, то есть вы можете опустить режим усечения файла. Однако для потоков ввода-вывода его нужно указывать явно. Файлы, которые открываются для вывода, создаются, если они еще не существуют.
Если открытие файла завершилось неудачей, объект, соответствующий потоку в булевом выражении, будет возвращать false:

if (!ofs){
	cout << "Файл не открыт\n";
}

Проверить успешность открытия файла можно также с помощью функции-члена is_open(), имеющей следующий прототип:

bool is_open() const;

Функция возвращает true, если поток удалось связать с открытым файлом. Например,

if (!osf.is_open()){
	cout << "Файл не открыт\n";
}

Если при открытии файла не указан режим ios::binary, файл открывается в текстовом режиме и после того, как файл успешно открыт, для выполнения операций ввода-вывода можно использовать операторы извлечения и вставки в поток. Можно даже использовать функции ввода-вывода, принятые в языке С, такие, как fprintf() и fscanf().Для проверки, достигнут ли конец файла, можно использовать функцию eof() класса ios, имеющую следующий прототип:

bool eof() const;

Завершив операцию ввода-вывода, необходимо закрыть файл, вызвав функцию-член close():

ofs.close();

Функция close() не имеет параметров и возвращаемого значения:

void.close();

Закрытие файла происходит автоматически при выходе объекта потока из области видимости, когда вызывается деструктор потока.
Рассмотрим пример, демонстрирующий файловый ввод-вывод с использованием потоков:

//04.01
#include <fstream>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, "Rus");
	int n = 50;
	//Открываем файл для вывода
	ofstream ofs("Test.txt");
	if (!ofs){
		cout << "Файл не открыт.\n";
		return 1;
	}
	ofs << "Hello!\n" << n;
	//Вывод другой информации в файл
	//…
	//Закрываем файл
	ofs.close();

	//открываем тот же файл для ввода
	ifstream file("Test.txt");
	if (!file){
		cout << "Файл не открыт.\n";
		return 2;
	}
	char str[80];
	file >> str >> n;
	cout << str << " " << n << endl;
	//Закрываем файл
	file.close();
	
	getchar(); 	getchar();
	return 0;
}

 

Следует иметь в виду, что стандартная библиотека ввода-вывода отличается от традиционной. Этот факт нужно учитывать при переносе старых программ в современные системы программирования. Во-первых, в традиционной библиотеке функция open() имела третий параметр, задававший режим защиты файла. Во-вторых, конструктор потока fstream и функция open() для него не предусматривали установки по умолчанию режимов открытия ios:: in | ios :: out. В-третьих, стандартная библиотека не поддерживает режимы открытия ios:: noncreate и ios:: noreplace, которые были в традиционной.
Во всех предыдущих примерах использовались предопределенные потоки cin и cout. Возможно, что программе потребуются собственные потоки для ввода/вывода. Если в приложении нужно создать файл для ввода и вывода, то в него необходимо включить заголовочный файл fstream.h (файл fstream.h включает в себя iostream.h). Классы ifstream и ofstream являются производными от istream и ostream и наследуют операции выделения и вставки, соответственно. В следующей программе на C++ показано, как объявить файл для считывания и для записи при помощи ifstream и ofstream, соответственно:

// 04.12FSTRM
// Программа на C++, иллюстрирует объявление ifstream и ofstream для
// файлового ввода и вывода
//
//#include "stdafx.h"
//#include <stdio.h>
//#include <strstream>
//#include <iostream>
//using namespace std;
#include <fstream.h>
void main(void)
{
	char c;
	ifstream ifsin("E:\\LECTURE\\text.in", ios::in);
	if(!ifsin)
		cerr << "\nUnable to open 'text.in' for input.";
	ofstream ofsout("E:\\LECTURE\\text.out",ios::out);
	if(!ofsout)
		cerr << "\nUnable to open 'text.out' for output."; // Нельзя открыть для вывода
	while(ofsout && ifsin.get(c))
		ofsout.put(c);
	ifsin.close();
	ofsout.close();
	cout << "\n\n";
}

Программа объявляет переменную ifsin класса ifstream и связывает ее с файлом TEXT.IN, расположенным на диске. В любой программе, работающей с файлами, желательно всегда проверять существование или результат создания указанного файла в заданном режиме. Используя описатель файла ifsin, при помощи простого оператора if можно проверить результат операции. Аналогичные действия выполняются с ofsout за исключением того, что файл является производным от класса ofstream. Цикл while начинает ввод и вывод отдельных символов, если файл ifsin существует и считанный символ не равен EOF. В конце программы оба файлa закрываются. Закрытие выходного файла может оказаться существенным для сбрасывания на диск всех буферизированных в памяти данных.
Могут возникнуть ситуации, когда файл описывается не сразу или когда несколько файловых потоков необходимо связать с одним дескриптором файла. Это демонстрируется в следующей программе:

ifstream ifsin;
…
ifsin.open("week1.in");
…
ifsin.close();
ifsin.open("week2.in");
…
ifsin.close();

Если в программе нужно изменить способ открытия или использования файла, то в конструкторах файловых потоков можно добавить второй аргумент. Например:

ofstream ofsout("week1.out", ios::app | ios::noreplace);

Этот оператор объявляет поток ofsout и связывает его с файлом по имени week1.out. Поскольку задана опция ios::noreplace (не замещать), то при наличии файла с таким именем он создаваться не будет. Параметр ios::app указывает на добавление всех операций записи к существующему файлу. В следующей таблице перечислены флаги второго аргумента для конструкторов файловых потоков, которые могут логически объединяться по условию ИЛИ:

Бит режима	Действие
ios:: in	Открыть для считывания
ios:: out	Открыть для записи
ios:: ate	Искать EOF после создания файла
ios:: app	Все записи добавляются к файлу
ios:: trunc	Если файл существует, то он очищается
ios:: nocreate	Открыть только существующий файл
ios:: noreplace	Открыть только несуществующий файл
ios:: binary	Открыть файл в двоичном режиме (по умолчанию — текстовый)

Для открытия файла для считывания и записи можно также использовать объект класса fstream. Например: следующее описание открывает файл UPDATE.DAT в режиме считывания и записи с добавлением:

fstream io("update.dat", ios::in | ios::app);

Файлы с произвольным доступом.
Произвольный доступ в системе ввода-вывода реализуется с помощью функций seekg() и seekp(), используемых для позиционирования, соответственно, входного и выходного потока. Каждая из них имеет по два прототипа:

istream& seekg(pos type pos);
istream_type& seekg (of f_type& offset,
						ios_base::seekdir dxr);
ostream& seekp(pos_type pos);
ostream_type& seekp (off_type offset,
						ios_base::seekdir dir);

Здесь параметр pos задает абсолютную позицию в файле относительно начала файла. Параметр offset задаст смещение в файле, а параметр dir — направление смещения которое может принимать значения:

ios:: beg — смещение от начала файла;
ios:: cur — смещение относительно текущей позиции;
ios:: end — смещение от конца файла

С каждым потоком связан указатель позиционирования, который изменяет свое значение в результате операции ввода или вывода. Для выполнения операций произвольного доступа файл должен открываться в двоичном режиме.
Получить текущее значение позиции в потоке ввода или вывода можно с помощью функций tellg() и tellp(), соответственно. Эти функции имеют следующие прототипы:

pos_type tellg();
pos_type tellp();

Следующий пример демонстрирует возможность позиционирования потока ввода информации:

//04.02
#include <cmath>
#include <iomanip>
#include <string.h>
#include <fstream>
#include <iostream>
using namespace std;
//using std::cout;
//using std::cin;

int main(int argc, char* argv[])
{
	setlocale(LC_ALL, "Rus");
	int size = 0;
	if (argc > 1){	
		const char *FileName = argv[1];
		ifstream file;
		file.open(FileName,ios::in | ios::binary);
		if (file){
			file.seekg(0, ios::end);
			size = file. tellg();
			if (size < 0){
				cerr << FileName
				<< " не найден.";
				return 1;
			}
			cout << FileName << " size = " << size;
		}
	}
	else
		cout << "Вы не задали имя файла.";

	getchar(); 	getchar();
	return 0;
}

 

Программа выводит на экран длину заданного файла.

Позиционирование для всех типов класса iostream можно осуществлять при помощи методов класса seekg() или seekp(), которые могут устанавливаться на абсолютный адрес в файле или смещаться на заданное число байт от конкретного положения. Оба метода, seekg() (установить или считать положение указателя считывания) и seekp() (установить или читать положение указателя записи), могут иметь один или два аргумента. Если используется один параметр, то iostream устанавливается в заданное положение указателя; если два — вычисляется относительное положение. В следующем листинге отмечены эти различия; предполагается приведенное выше объявление для io:

streampos current_position = io.tellp();
io << obj1 << obj2 << obj3;
io.seekp(current_position);
io.seekp(sizeof(MY_OBJ), ios:: cur);
io << objnewobj2;

Сначала от streampos порождается указатель current_position, начальное значение которого получается при помощи функции tellp() и равно текущему положению файлового указателя записи. После запоминания этой информации в поток io записываются три объекта. При помощи seekp() указатель записи позиционируется на начало файла. Во втором операторе seekp() с помощью операции sizeof() вычисляется количество байтов, необходимое для смещения в файле на длину одного объекта. В результате объект obj1 пропускается, и возможна запись нового объекта objnewobj2.
Если метод seekg() или seekp() используется с двумя аргументами, то второй параметр определяет тип перемещения: ios:: beg (от начала), ios:: cur (от текущего положения) и ios:: end (от конца файла). Например: следующий оператор выполняет перемещение указателя считывания на 5 байт от текущего положения:

io.seekg(5, ios::cur);

Следующий оператор перемешает указатель get_file на 7 байт назад относительно конца файла:

io.seekg(-7, ios::end);

1.8. Классы ios_base и ios.
В классах ios_base и ios определены методы, которые являются общими для входных и выходных потоков. Класс ios_base содержит методы, которые не зависят от параметров шаблона. Наоборот, класс ios содержит шаблонно-зависимые методы. Объект класса ios_base не может быть создан непосредственно, а только в наследуемых классах.
Объекты типа ios_base поддерживают следующую информацию о состоянии потока.
Информацию о форматировании ввода-вывода:
-	флаги форматирования,
-	длину полей ввода-вывода,
-	разрешимость дисплея.

Информацию о состоянии потока:
-	состояние ошибки,
-	маску исключений,

Другая информация:
-	стек вызовов callback функций при наступлении некоторых событий,
-	внутренний массив с элементами типа long,
-	внутренний массив с элементами типа void*.

Перечислим некоторые методы класса ios_base:
flags	чтение-установка флагов форматирования,
precision	чтение-установка точности double,
setf	установка некоторых флагов форматирования,
unsetf	сброс флагов форматирования.

Например, в следующей программе показано как установить в качестве базовой 16 с/с.

#include <iostream>
using namespace std;

int main ()
{
	// установить 16c/c в качестве базовой
	cout.setf ( ios_base::hex, ios_base::basefield );

	// показывать базу
	cout.setf ( ios_base::showbase );
	cout << 100 << endl;

	// не показывать базу
	cout.setf ( 0, ios_base::showbase );
	cout << 100 << endl;

	cin.get();
	return 1;
}

 

Класс ios поддерживает следующую информацию о потоке:
-	символ заполнитель,
-	указатель на поток вывода, связанный с объектом типа ios,
-	указатель на объект типа streambuf, связанный с объектом типа ios.

Перечислим некоторые методы класса ios:
operator	возвращает true, если установлен любой из флагов failbit или badbit, иначе возвращает false,
bad	возвращает true в случае неустранимой ошибки ввода-вывода,
clear	сбрасывает управляющие состояния,
eof	проверяет на конец файла,
exception	читает-устанавливает маску исключений,
fail	проверяет на ошибку, исключая конец файла,
fill	читает-устанавливает символ заполнитель,
good	возвращает true, если нет ошибок,
rdstate	читает управляющие состояния,
setstate	устанавливает управляющие состояния.

Кроме того, класс ios поддерживает режимы работы потока, которые задаются следующими флагами:
ios::app	данные всегда записываются в конец файла,
ios::ate	первый байт записывается в конец файла, остальные байты с текущей позиции,
ios::binary	бинарный файл,
ios::in	входной файл,
ios::nocreate	открыть существующий файл, если файла нет, то ошибка,
ios::noreplace	открыть новый файл, если файл уже есть, то ошибка,
ios::out	выходной файл,
ios::trunk	файл открывается и его содержимое стирается,

Например, в следующей программе показано, как проверить, успешно ли открыт файл.

#include <iostream>
#include <fstream>
using namespace std;
 
int main ()
{
	ifstream in;
	in.open ("test.txt");
	
	if (!in)
		cerr << "Error: open file 'test.txt' failed." << endl;
	cin.get();
	return 0;
}

 

1.9. Потоки вывода.
Потоки вывода создаются на базе класса ostream, который обеспечивает методы для записи данных в буфер потока. Перечислим основные методы класса ostream:
operator<<	форматированный вывод данных в поток,
flush	очищает буфер,
put	выводит символ,
seekp	устанавливает позицию для функции put,
tellp	читает позицию указателя для функции put,
write	пишет последовательность байтов,

От класса ostream наследуются класс ofstream, который содержит дополнительные методы:
open	открыть файл,
close	закрыть файл,
is_open	проверка открыт ли файл.

Сейчас приведем прототипы этих функций и примеры их использования.

1.9.1. Функции open, close и is_open
Функции open, close и is_open имеют следующие прототипы:

void open ( const char * filename, openmode mode = out | trunc );
void close ( );
bool is_open ( );

При открытии потока вывода нужно указать имя файла и режимы работы потока с этим файлом. При этом нужно запомнить, что режимы работы с потоками ввода и вывода совпадают.
Например, следующая программа добавляет предложение в конец текстового файла и показывает, как использовать вышеперечисленные функции.

//#include <iostream.h>
#include <iostream>
#include <fstream>
using namespace std;
 
int main ()
{
	ofstream out;
	out.open ("test.txt", ofstream::out | ofstream::app);
	if (out.is_open())
		out << "This sentence is appended to the file content.\n";
	else
	   cerr << "Open file failed." << endl;
	out.close();
	//cin.get();
	return 0;
}

1.9.2. Функция flush
Функция flush очищает буфер. Эта функция имеет следующий прототип:

ostream& flush ( );

Ниже приведен пример использования функции flush. Этот пример также показывает, как можно создавать текстовый файл

//#include <fstream.h>
#include <fstream>
#include <iostream>
using namespace std;

int main ()
{
	ofstream out("test.txt");
	for (int n=0; n<100; n++)
	{
		out << n << ' ';
		out.flush();
	}
	out << '\n'; // переход на новую строку

	for (int n=0; n<100; n++)
		out << (n+0.1) << ' ' << flush;
	out << endl; // переход на новую строку
	out.close();

	cin.get();
	return 0;
}

 

1.9.3. Функция put
Функция put выводит символ в файл. Эта функция имеет следующий прототип:

ostream& put ( char ch );

В следующем примере показано, как водить символы с консоли и выводить их в файл.

//#include <iostream.h>
//#include <fstream.h>
#include <iostream>
#include <fstream>
using namespace std;
 
int main ()
{
	char ch;
	ofstream out("test.txt");
	cout << "Input chars then input '.' to exit." << endl;
	
	do
	{
		ch = cin.get();
		out.put(ch);
	} while (ch!='.');

	return 0;
}

 

 

1.9.4. Функция seekp и tellp
Функция seekp устанавливает, а функция tellp читает позицию в файле для функции put. Эти функции имеют следующие прототипы:

streampos tellp ( );
ostream& seekp ( streampos pos );

где pos - новая позиция в потоке;

ostream& seekp ( streamoff off, ios_base::seekdir dir );

где параметры имеют следующее назначение:

off	смещение в потоке относительно позиции, указанной в параметре dir.
dir	направление поиска позиции, может принимать одно из следующих значений:
-	ios_base::beg – поиск от начала файла;
-	ios_base::cur  - поиск от текущей позиции;
-	ios_base::end – поиск от конца файла.

Ниже приведен пример использования этих функций.

//#include <fstream.h>
#include <fstream>
#include <iostream>
using namespace std;

int main ()
{
	long pos;
	ofstream out;
	out.open ("test.txt");
	
	out << "This is a string." << endl;
	
	pos=out.tellp();
	out.seekp (pos - 11);
	out << "an example.";
	out.close();

	cin.get();
	return 0;
}

 

1.9.5. Функция write
Функция write пишет последовательность символов (байтов) в файл. Эта функция имеет следующий прототип:

ostream& write ( const char* s , size n );

где s указывает на область памяти, из которой данные записываются в файл, а n – количество записываемых символов (байтов). Отметим, что эта функция используется для записи данных в бинарные файлы, то есть содержимое области памяти записывается в файл без изменения. Ниже приведен пример создания бинарного файла, используя функцию write.

//#include <iostream.h>
//#include <fstream.h>
#include <iostream>
#include <fstream>
using namespace std;

struct emp
{
	int code;
	char name[20];
	double salary;
};
 
int main()
{
	ofstream out; // выходной поток
	struct emp s; // для записей файла
	
	// открываем выходной поток в бинарном режиме
	out.open("demo.bin", ofstream::binary);

	if(!out)
	{
		cerr << "Open file failed." << endl;
		return 1;
	}
	
	cout << "Input code, name and salary." << endl;
	cout << "Press Ctrl+z to exit." << endl;
	cout << '>';

	// вводим первую запись с консоли
	cin >> s.code >> s.name >> s.salary;

	while (!cin.eof())
	{
		// пишем запись в файл
		out.write((const char*)&s, sizeof(struct emp));
		cout << '>';
		// вводим следующие записи с консоли
		cin >> s.code >> s.name >> s.salary;
	}

	// закрываем выходной поток
	out.close();

	return 0;
}

 

От класса ostream также наследуются класс ostringstream, который обеспечивает интерфейс для работы со строками.
Класс ostringstream содержит дополнительный метод:

str – чтение и запись строки в поток.

1.9.6. Функция str
Функция str выполняет запись и чтение строки в поток. Эта функция имеет следующий прототип:

string str ( ) const	чтение строки из потока
void str ( string & s );	запись строки s в поток

Например, в следующей программе показано, как ввести строку в поток типа ostringstream, а затем прочитать его содержимое в объект типа string.

#include <iostream>
#include <sstream>
#include <string>

using namespace std;

int main ()
{
	ostringstream oss;
	string s;
	oss.str("Sample string_1.");
	s = oss.str();
	cout << s << endl;
	oss << "Sample string_2.";

	s = oss.str();
	cout << s << endl;

	cin.get();
	return 0;
}

 


1.9.7. Классы потокового вывода.
Все классы ofstream, производные от fstreambase и ostream, позволяют выполнять форматированный и неформатированный вывод в поток streambuf. Ниже приводится программа, которую можно сравнить с примером из предыдущего материала.
 В программе используется конструктор ofstream, похожий на конструктор ifstream, описанный выше. Указывается имя файла, "myostrm.out", и режим открытия файла, ios::out.

// 05.17OSTRM.CPP
// применение класса ofstream
// допустимые методы класса ofstream
//	ofstream::open	ofstream::rdbuf
// допустимые методы класса ostream
//	ostream::flush	ostream::ostream
//	ostream::put	ostream::seekp
//	ostream::tellp	ostream::write
//
#include "stdafx.h"
#include <iostream>
#include <fstream>
#include <math.h>
using namespace std;

#define iSTRING_MAX	40

void main(void)
{
	int i=0;
	long ltellp;
	char pszString[iSTRING_MAX]="Simple test string\n";/* 6+1+4+1+6=18+(’\’)+(’n’)=20 */
	// по умолчанию файл открывается втекстовом режиме
	ofstream ofMyOutputStream("myostrm.out", ios::out);
	// посимвольный вывод строки
	// строка '\n' преобразуется в два символа
	while(pszString[i] != '\0')
	{
		ofMyOutputStream.put(pszString[i]);
		ltellp = ofMyOutputStream.tellp();
		cout << "\ntellp value: " << ltellp;
		i++;
	}
	// выод строки целиком при помощи метода класса
	ltellp = ofMyOutputStream.tellp();
	cout << "\ntellp's value before writing 2nd string: " << ltellp; // значение tellp перед выводом 2 строки
	ofMyOutputStream.write(pszString, strlen(pszString));
	ltellp=ofMyOutputStream.tellp();
	cout << "\ntellp's updated value: " << ltellp << '\n'; // обновленное значение tellp
	ofMyOutputStream.close();
}

В первом цикле while выполняется вывод строки pszString с использованием метода put(). После печати каждого символа переменной ltellp присваивается значение текущей позиции указателя, которое возвращает метод класса tellp(). В данный момент важно обратить внимание на распечатку результатов работы программы.
После инициализации строковая переменная pszString представляет собой 19 символов, заканчивающихся null-символом '\0'; таким образом, общее число символов — 20. Хотя программа выводит значения tellp от 1 до 20, однако двадцатый символ не является null-символом. Это объясняется тем, что в текстовом режиме символы \n из строки pszString преобразуются в два байта: один байт для символа возврата каретки (19-й символ) и второй — для перевода строки (20-й символ). null-символ не выводится.
В остальной части программы вычисляется позиция указателя вывода до и после вызова метода write() для печати строки pszString целиком. Заметим, что напечатанные значения tеllр говорят о том, что функция write() также преобразует один null-символ в два выводимых байта. Если бы этого преобразования не было, то последнее значение tе11р было бы равно 39 (с учетом того, что после выполнения put() счетчик остановился на числе 20, а не на 19-ти). Сокращенная распечатка результатов работы программы выглядит следующим образом:

 

К счастью, производные от iostream методы get() и read() автоматически преобразуют два байта, получающиеся при выводе, в один символ '\n'. Приведенная программа обращает внимание на особенности файлового ввода/вывода, требующие осторожности. Если файл, созданный данной программой, использовать в качестве входного файла, открываемого в двоичном режиме, то возникнет конфликт, поскольку в двоичных файлах подобного преобразования не выполняется, поэтому как позиционирование, так и содержимое файла будут неправильными.

1.10. Потоки ввода.
Потоки ввода являются объектами класса istream, который обеспечивает методы для чтения информации из буфера потока. Перечислим основные методы класса istream:

operator >>	форматированный ввод,
gcount	возвращает количество символов, прочитанных последней операцией ввода,
get	ввод символа,
getline	ввод строки,
ignore	удаление символов из буфера,
peek	читает символ, но не удаляет его из буфера,
putback	возвращает символ в буфер,
read	читает блок данных,
seekg	устанавливает указатель позиции файла для метода get,
sync	синхронизирует буфер потока с внешним устройством,
tellg	получает указатель позиции файла для метода get,
unget	возвращает символ в поток,

От класса istream наследуется класс ifstream, который обеспечивает интерфейс для работы с файлами. Класс ifstream содержит дополнительные методы:

open	открыть файл,
close	закрыть файл,
is_open	проверить, открыт ли файл.

1.10.1. Функция gcount
Функция gcount возвращает количество символов, прочитанных последней не форматирующей операцией ввода. Эта функция имеет следующий прототип:
	
streamsize gcount ( ) const;

К не форматирующим операциям ввода относятся следующие операции: get, getline, ignore, read и readsome. Пример использования функции gcount показан в следующей программе:

#include <iostream>
#include <string>
using namespace std;

int main()
{
	char line[80];
	int length;
	cout << "Input a string: " << endl;
	cin.getline(line, 80);

	length = cin.gcount();

	cout << "String length = " << length-1 << endl;

	cin.get();
	return 0;
}

 

1.10.2. Функция get
Функция get вводит символ из входного потока. Эта функция имеет следующий прототип:

int get();

возвращает символ, извлеченный из потока;

istream& get (char& c );

извлекает символ из потока и сохраняет его в переменной с;

istream& get (char* s, streamsize n, char delim = ‘\n’ );

вводит из потока символы и записывает их в массив s, ввод символов прекращается в следующих случаях:
•	если введен (n-1) символ;
•	если в потоке встретился символ разделитель delim, сам символ разделитель из потока не извлекается;
•	файл закончился раньше, чем прочитан (n-1) символ.

После записи прочитанных символов в массив s функция get записывает в этот массив пустой символ NULL, отмечающий конец строки. Ниже приведена программа, которая распечатывает содержимое текстового файла.

#include <iostream>
#include <fstream>
using namespace std;

int main()
{
	ifstream in;
	in.open ("test.txt", ifstream::in);

	while (in.good())
		cout << (char) in.get();
	cout << endl;

	in.close();
	cin.get();

	return 0;
}

 

А теперь приведена программа, которая читает символы из входного потока, используя функцию get.

//#include <iostream.h>
#include <iostream>
using namespace std;

int main()
{
	char c;
	char a[3];
	cout << "Input a char: ";

	c = cin.get();
	cout << c << endl;
	cin.get(); // удаляем символ конца строки

	cout << "Input a char: ";
	cin.get(c);
	cout << c << endl;
	cin.get(); // удаляем символ конца строки

	cout << "Input a string: ";
	cin.get(a, 3);

	cout << endl << "The first two symbols: ";
	cout << a << endl << endl;

	system("pause");
	return 0;
}

 

1.10.3. Функция getline
Функция getline вводит строки из файла. Эта функция имеет следующий прототип:

istream& getline (char* s, streamsize n, char delim = '\n');

вводит из потока символы и записывает их в массив s, ввод символов прекращается в следующих случаях:
•	если введен (n-1) символ;
•	если в потоке встретился символ разделитель delim, причем сам символ разделитель извлекается из потока, но не записывается в массив s;
•	файл закончился раньше, чем прочитан (n-1) символ.

После записи прочитанных символов в массив s функция getline записывает в этот массив пустой символ NULL, отмечающий конец строки. Ниже приведена программа, которая вводит строки из потока и распечатывает их на консоли.

//#include <iostream.h>
#include <iostream>
using namespace std;

int main ()
{
	char line[80];
	cout << "Input strings. " << endl;
	cout << "To exit press CTRL+Z." << endl;
	cout << '>';

	while (!cin.eof())
	{
		cin.getline(line, 80);
		cout << ' ' << line << endl;
		cout << '>';
	}

	system("pause");
	return 0;
}

 

1.10.4. Функция ignore
Функция ignore удаляет символы из буфера потока. Эта функция имеет следующий прототип:

istream& ignore ( streamsize n = 1, int delim = EOF );

где n – количество символов, которые необходимо удалить из потока, а delim – это символ ограничитель. Функция удаляет символы из потока до тех пор, пока не удалит n символов или не встретит символ разделитель. Например, в следующей программе выводятся только первые символы введенных слов.

#include <iostream>
using namespace std;

int main ()
{
	char c;
	cout << "Input a word: ";
	c = cin.get();

	cin.ignore(256,'\n');

	cout << "The first letter is: " << c << endl;
	cout << "Input another word: ";
	cin.ignore();

	c = cin.get();

	cin.ignore(256,'\n');
	cout << "The second letter is: " << c << endl;

	system("pause");
	return 0;
}

 

1.10.5. Функция peek
Функция peek читает символ, но не удаляет его из буфера. Эта функция имеет следующий прототип:

int peek ( );

возвращает прочитанный символ, а если файл закончился или в потоке произошла ошибка, то возвращает EOF.
Ниже приведена программа, в которой используется функция peek.

#include <iostream>
using namespace std;

int main ()
{
	char c;
	int n;
	char s[256];
	cout << "Enter a number or a word: ";
	c = cin.peek();

	if ((c >= '0') && (c <= '9'))
	{
		cin >> n;
		cout << "It is a number: " << n << endl;
	}
	else
	{
		cin >> s;
		cout << "It is a word: " << s << endl;
	}

	system("pause");
	return 0;
}

 

 

1.10.6. Функция putback
Функция putback возвращает символ в буфер. Эта функция имеет следующий прототип:

istream& putback (char ch);

если введенный символ совпадает с символом ch, то функция возвращает его в буфер ввода, иначе поведение функции непредсказуемо.
Использование функции putback показано в следующей программе.

#include <iostream>
using namespace std;

int main ()
{
	char c;
	int n;
	char s[256];
	cout << "Enter a number or a word: ";
	c = cin.get();
	cin.putback (c);

	if ((c >= '0') && (c <= '9'))
	{
		cin >> n;
		cout << "It is a number: " << n << endl;
	}
	else
	{
		cin >> s;
		cout << " It is a word: " << s << endl;
	}

	system("pause");
	return 0;
}

 

 

1.10.7. Функция read
Функция read читает блок данных из файла и имеет следующий прототип:

istream& read (char* s, streamsize n);

где s указывает на область памяти, в которую данные читаются из файла, а n – количество читаемых символов (байтов). Отметим, что эта функция используется для чтения данных из бинарных файлов, то есть содержимое файла без изменения читается в область памяти. Ниже приведен пример чтения записей бинарного файла, используя функцию read.

//чтение бинарного файла
//#include <iostream.h>
//#include <fstream.h>
#include <iostream>
#include <fstream>
using namespace std;

struct emp
{
    int code;
    char name[20];
    double salary;
};

int main()
{
	ifstream in; // выходной поток
	struct emp s; // для записей файла
	unsigned i; // номер записи

	// открываем входной поток в бинарном режиме
	in.open("demo.bin");
	if(!in)
	{
		cout << "Open file failed.\n";
		return 1;
	}

	cout << "Press Ctrl+z to exit.\n";
	// читаем индекс
	cout << "Input an index: ";
	cin >> i;

	while (!cin.eof())
	{
		// устанавливает указатель на нужную запись
		in.seekg(i*sizeof(struct emp));
		// читаем запись из файла
		in.read((char*)&s, sizeof(struct emp));
		if (!in.good())
		{
			cout << "The wrong index.\n";
			cout << "Input an index: ";
			cin >> i;
			in.clear(); // очищаем ошибку
			continue;
		}
		// выводим запись на консоль
		cout << "\tcode = " << s.code
		<< " name = " << s.name
		<< " sal = " << s.salary << endl,
		// читаем индекс
		cout << "Input an index: ";
		cin >> i;
	}

	// закрываем входной поток
	in.close();
	system("pause");

	return 0;
}

 

1.10.8. Функция seekg
Функция seekg устанавливает указатель позиции файла для метода get, а функция tellg получает указатель позиции файла для метода get. Эти функции имеют следующие прототипы:

istream& seekg (streampos pos);

устанавливает позицию файла на значение pos, тип streampos эквивалентен типу long.

istream&  seekg (streamoff off, ios_base::seekdir dir);

сдвигает позицию файла на значение off относительно значения параметра dir, который может принимать следующие значения:
ios_base::beg	смещение относительно начала файла;
ios_base::cur	смещение относительно текущей позиции;
ios_base::end	смещение относительно конца файла.

streampos tellg ( );

возвращает указатель позиции файла для функции get, тип streampos эквивалентен типу long.
Ниже приведена программа, которая демонстрирует использование вышеуказанных функций.

// чтение файла в память
//#include <iostream.h>
//#include <fstream.h>
#include <iostream>
#include <fstream>
using namespace std;

struct emp
{
    int code;
    char name[20];
    double salary;
};

int main()
{
	int length;
	emp* buffer;
	ifstream in;

	in.open("demo.bin", ios::binary);

	if (!in)
	{
		cout << "Open file failed" << endl;
		return 1;
	}

	// определеям длину файла
	in.seekg(0, ios::end);
	length = in.tellg();
	in.seekg(0, ios::beg);

	// распределяем память под файл
	buffer = (emp*) new char[length];

	// читаем файл
	in.read((char*)buffer,length);

	in.close();

	// выводим содержимое на консоль
	for (int i=0; i<length/(int)sizeof(emp); ++i)
		cout << buffer[i].code << ' '
		<< buffer[i].name << ' '
		<< buffer[i].salary << endl;

	system("pause");
	return 0;
}

 

1.10.9. Функция sync
Функция sync синхронизирует буфер потока с внешним устройством. Эта функция имеет следующий прототип:

int sync ( );

Как работает эта функция, и что такое синхронизация буфера потока с внешним устройством смотри в параграфе 1.6.

1.10.10. Функция unget
Функция unget возвращает в поток символ, предварительно извлеченный из потока. Эта функция имеет следующий прототип:

int unget();

возвращает символ, извлеченный из потока.
Ниже приведена программа, в которой показано использование функции unget.

#include <iostream>
using namespace std;

int main ()
{
	char c;
	int n;
	char s[256];

	cout << "Enter a number or a word: ";
	c = cin.get();
	cin.unget();

	if ((c >= '0') && (c <= '9'))
	{
		cin >> n;
		cout << "It is a number: " << n << endl;
	}
	else
	{
		cin >> s;
		cout << "It is a word: " << s << endl;
	}

	system("pause");
	return 0;
}

 

 

От класса istream наследуется класс istringstream, который обеспечивает интерфейс для работы со строками. Класс istringstream содержит дополнительный метод:

str

чтение или запись строки в поток.

1.10.11. Функция str
Функция str для записи и чтения строки в поток.
Прототипы этой функции были рассмотрены раньше в пункте 6. Сейчас же приведем только программу, в которой показано, как записать строку в поток типа istringstream, а затем вывести содержимое этого потока.

#include <iostream>
#include <sstream>
#include <string>
using namespace std;

int main ()
{
	int n;
	istringstream iss;
	string s = "0 1 2";

	iss.str(s);
	for (int i = 0; i < 3; ++i)
	{
		iss >> n;
		cout << n + 1 << endl;
	}

	system("pause");
	return 0;
}

 

1.10.12. Классы потокового ввода.
Используемый в следующем примере класс ifstream порожден от классов fstreambase и istream. Он выполняет операции ввода из потока filebuf. Данная программа осуществляет потоковый ввод текста.

// 05.17IFSTRM.CPP
// применение класса ifstream
// допустимые методы класса ifstream
//	ifstream::open	ifstream::rdbuf
//	istream::gcount	istream::get
//	istream::getline	istream::ignore
//	istream::istream	istream::peek
//	istream::putback	istream::read
//	istream::seekg	istream::tellg
//
#include "stdafx.h"
#include <iostream>
#include <fstream>
#include <math.h>
using namespace std;

#define iCOLUMNS	80

void main(void)
{
	char cOneLine[iCOLUMNS];
	ifstream ifMyInputStream("ifstrm.cpp", ios::in);
	while(ifMyInputStream)
	{
		ifMyInputStream.getline(cOneLine, iCOLUMNS);
		cout << '\n' << cOneLine;
	}
	ifMyInputStream.close();
}

В первом операторе программы для создания объекта ifstream и связывания его с дескриптором открытого файла ifMyInputStream используется конструктор класса ifstream. Этот оператор содержит имя файла, включая при необходимости путь к файлу ("ifstrm.cpp "), а также один или несколько режимов (например, ios::in | ios::nocreate | ios::binary). По умолчанию ввод — текстовый. При наличии опции ios::nocreate выполняется проверка существования файла. Целое значение дескриптора файла ifMyInputStream можно использовать при логических проверках, например в операторах if и while, это значение автоматически устанавливается в ноль при достижении конца файла — условие ЕОF.
Метод getline(), унаследованный от класса ifstream, позволяет читать полные строки текста, заканчивающиеся null-символом. Этот метод имеет три формальных параметра: указатель char *, количество вводимых символов — включая null-символ — и необязательный символ-разделитель (по умолчанию — '\n').
Поскольку имена массивов char на самом деле являются указателями на символы, переменная cOneLine удолетворяет требованиям первого параметра метода. Количество вводимых символов соответствуют размеру массива — iCOLUMNS. Опция разделителя отсутствует. Однако, если входные строки разделяются специальным символом — например, '*' -, то оператор getline() можно записать так:

ifMyInputStream.getline(cOneLine, iCOLUMNS, '*') ;

Затем в приведенной программе печатаются строки, и файл закрывается явно при помощи метода ifMyInputStream.close().

Как работать с этими функциями, было показано в предыдущем параграфе. Сейчас же подробно рассмотрим работу с функциями класса istream.

1.11. Потоки ввода-вывода.
Потоки ввода-вывода создаются на базе класса iostream, который является производным классом от классов istream и ostream и поэтому наследует все их методы. Для работы с файлами и со строками из класса iostream наследуются соответственно классы fstream и stringstream, которые позволяют, как писать данные в потоки, так и читать данные из потоков. Для наглядного представления отношения наследования между этими классами смотри диаграмму наследования в параграфе 1.1.
Здесь же заметим, что заголовочный файл <iostream> содержит потоки ввода-вывода: cin, cout, cerr и clog, примеры работы с которыми смотри в параграфе 1.8.

1.12. Классы буферизированных потоков.
Класс streambuf является основой для потокового ввода/вывода в С++. В этом базовом классе описаны все основные операции, выполняемые с символьными буферами. Класс streambuf также используется для порождения класса файловых буферов (класс filebuf) и классов istream и ostream, содержащих указатели на объекты streambuf.
Все производные классы, базирующиеся на классе ios, наследуют указатель на streambuf. Как показано на рисунке, класс filebuf происходит от streambuf и адаптирует этот родительский класс к работе с файлами.

 

В начале следующей программы описываются два описателя (handle) типа filebuf — fbMyInputBuf и fbMyOutputBuf после этого при помощи метода ореn() открываются текстовые файлы. Затем — при условии отсутствия ошибок открытия файлов — каждый описатель связывается с соответствующим объектом istream (для ввода) и ostream (для вывода). Когда оба файла открыты, в цикле while выполняется обычная эхо-печать от входного потока is.get() в выходной поток os.put(), и при этом подсчитывается число символов перевода строки '\n'. Необязательный в данном случае метод сlоsе() используется для явного закрытия файлов.

// 05.17FILBUF.CPP
// применение класса filebuf
// допустимые методы класса
//	filebuf::attach	filebuf::close
//	filebuf::fd	filebuf::~filebuf
//	filebuf::filebuf	filebuf::is_open
//	filebuf::open	filebuf::overflow
//	filebuf::seekoff	filebuf::setbuf
//	filebuf::sync	filebuf::underflow
//
#include  "stdafx.h"
#include <iostream>
#include <fstream>
#include <math.h>
using namespace std;

void main(void)
{
	char ch;
	int iLineCount = 0;
	filebuf fbMyInputBuf, fbMyOutputBuf;
	//fbMyInputBuf.open("filbuf.cpp",_O_RDONLY | _O_TEXT);
	fbMyInputBuf.open("filbuf.cpp", 1);
	if(fbMyInputBuf.is_open() == 0)
	{
		cerr << "Can't open input file" << '\n';
		exit(1);
	}
	istream is(&fbMyInputBuf);
	//fbMyOutputBuf.open("output.dat",_O_WRONLY | _O_TEXT);
	fbMyOutputBuf.open("output.dat", 2);
	if(fbMyOutputBuf.is_open() == 0)
	{
		cerr << "Can't open output file" << '\n';
		exit(2);
	}
	ostream os(&fbMyOutputBuf);
	while(is)
	{
		is.get(ch);
		os.put(ch);
		iLineCount += (ch == '\n');
	}
	fbMyInputBuf.close();
	fbMyOutputBuf.close();
	cout << "You have " << iLineCount << " lines in your file" << endl;
	// В Вашем файле ... строк
}

1.13. Класс строковых потоков.
Класс streambuf можно использовать для расширения возможностей класса iostream. На рисунке ранее показаны соотношения между классом ios и производными классами. Именно класс ios предоставляет порожденным классам интерфейс программирования и средства форматирования. Однако, все необходимые действия выполняют глобальные методы и виртуальные функции класса streambuf. Все производные от ios классы вызывают эти процедуры.
Все буферизированные объекты класса streambuf используют фиксированный буфер памяти, называемый областью резервирования. Эту область можно разделить на get-область для ввода и put-область для вывода. При необходимости области ввода и вывода могут накладываться друг на друга. При помощи защищенных методов класса программа получает к ним доступ и может манипулировать двумя отдельными указателями для ввода и для вывода, использующимися для символьного ввода/вывода. Учитывая реализацию производного класса в конкретной программе, каждое приложение определяет порядок использования буферов и указателей.
Для объектов streambuf имеются два конструктора, имеющие следующий синтаксис:

streambuf::streambuf();
streambuf::streambuf (char * рг, int nLength);

Первый конструктор используется косвенно всеми порожденными от streambuf классами. Он устанавливает в null все внутренние указатели объекта типа streambuf. Второй конструктор создает объект типа streambuf, связывающийся с существующим символьным массивом. В следующей программе показано, как объявить строковый объект strstreambuf, порожденный от базового класса streambuf. После создания объект stbMyStreamBuf программа выводит отдельный символ при помощи метода sputc() и затем считывает его обратно с помощью метода sgetc().

// 05.17STRBUF.CPP
// применение класса streambuf
//
#include "stdafx.h"
#include <iostream>
#include <fstream>
#include <math.h>
#include <strstream>
using namespace std;

#define iNYBUFFSIZE 1024

void main(void)
{
	char c;
	strstreambuf stbMyStreamBuf(iNYBUFFSIZE);
	stbMyStreamBuf.sputc('A'); // отдельный символ выдается в буфер
	c = stbMyStreamBuf.sgetc();
	cout << c << endl;
}

 

Необходимо помнить о том, что для объектов, созданных на основе класса streambuf, имеются два различных указателя — для ввода и для вывода. Каждый указатель работает независимо от другого. Метод sgetc() считывает символ 'А'. Это объясняется тем, что возвращается содержимое буфера по адресу, на который ссылается указатель ввода. Метод sputc() смещает указатель вывода, но не затрагивает указатель ввода и символ, находящийся в буфере.
В следующем списке перечислены имена и назначение всех глобальных методов класса streambuf и указано, какие методы работают с указателями ввода и вывода:

Глобальный
метод	Назначение
sgetc	Возвращает символ, на который ссылается указатель ввода, однако не перемещает указатель
sgetn	Читает последовательность символов из буфера streambuf
sputc	Помещает символ в область вывода и перемещает указатель вывода
sputn	Помещает цепочку символов в буфер streambuf и затем перемещает указатель вывода
snextc	Перемещает указатель ввода и возвращает следующий символ
sbumpc	Возвращает текущий символ и затем перемещает указатель ввода
stossc	Увеличивает указатель ввода на одну позицию, но не возвращает символ
sputbackc	Пытается сместить указатель ввода на одну позицию назад. Записываемый снова символ должен соответствовать предыдущему прочитанному символу
out_waiting	Возвращает число символов в области вывода
in_avail	Возвращает число символов в области ввода
dbp	Выводит статистику буфера streambuf и значения указателей

В следующем перечне приведены имена и назначение всех виртуальных функций класса streambuf:

Виртуальная
функция	Назначение
seekoff	Отрабатывает указанное смещение
seekpos	Переходит на указанную позицию
overflow	Очищает область вывода
underflow	Заполняет при необходимости область ввода
pbackfail	Расширяет метод sputbackc
setbuf	Пытается связать область резервирования с буфером streambuf
sync	Очищает области вывода и ввода

В следующем списке перечислены имена и назначение всех защищенных методов класса streambuf:

Защищенный
метод	Назначение
allocate	Выделяет буфер, вызывая функцию doallocate
doallocate	Выделяет область резервирования (виртуальная функция)
base	Возвращает указатель на начало области резервирования
ebuf	Возвращает указатель на конец области резервирования
blen	Возвращает размер области резервирования
pbase	Возвращает указатель на начало области вывода
pptr	Возвращает указатель вывода
gptr	Возвращает указатель ввода
eback	Возвращает нижнюю границу области ввода
epptr	Возвращает указатель на конец области вывода
egptr	Возвращает указатель на конец области ввода
setp	Устанавливает все указатели области вывода
setg	Устанавливает все указатели области ввода
pbump	Инкрементирует/декрементирует указатель вывода
gbump	Инкрементирует/декрементирует указатель ввода
setb	Устанавливает область резервирования
unbuffered	Устанавливает или проверяет переменную состояния буфера streambuf

Очевидно, что в классе streambuf имеются практически все функции, которые могут понадобиться в программе для работы с потоковым буфером. Поскольку класс streambuf используется для построения класса файловых буферов (класс filebuf) и классов istream и ostream, все эти классы наследуют характеристики базового класса streambuf.

1.14. Форматирование потока.
До сих пор мы использовали для вывода информации во всех примерах форматы, заданные в C++ по умолчанию. Для управления форматированием библиотека ввода-вывода предусматривает три вида средств:форматирующие функции, флаги и манипуляторы. Все эти средства являются членами класса basic_ios и потому доступны для всех потоков.
Рассмотрим вначале форматирующие функции-члены. Их всего три: width (). precision () и fill ().
По умолчанию при выводе любого значения оно занимает столько позиций, сколько символов выводится. Функция width() позволяет задать минимальную ширину поля для вывода значения. При вводе она задает максимальное число читаемых символов. Если выводимое значение имеет меньше символов, чем заданная ширина поля, то оно дополняется символами-заполнителями до заданной ширины (по умолчанию - пробелами). Однако если выводимое значение имеет больше символов, чем ширина отведенного ему поля, то поле будет расширено до нужного размера. Эта функция имеет следующие прототипы:

streamsize width(streamsize wide);
streamsize width() const;

Тип streamsize определен в заголовочном файле <iostream> как целочисленный. Функция с первым прототипом задает ширину поля wide, а возвращает предыдущее значение ширины поля. Функция со вторым прототипом возвращает текущее значение ширины поля. По умолчанию она равна нулю, то есть вывод не дополняется и не обрезается. В ряде компиляторов после выполнения каждой операции вывода значение ширины поля возвращается к значению, заданному по умолчанию.
Функция precision () позволяет узнать или задать точность (число выводимых цифр после запятой), с которой выводятся числа с плавающей точкой. По умолчанию числа с плавающей точкой выводятся с точностью, равной шести цифрам. Функция имеет precision () следующие прототипы:

streamsize precision(streamsize prec);
streamsize precision() const;

Функция с первым прототипом устанавливает точность равной рrес и возвращает предыдущую точность. Функция со вторым прототипом возвращает текущую точность.
Замечание. Если не установлен флаг scientific или fixed, задает precision() задает общее число цифр.
Функция fill() позволяет прочесть или установить символ-заполнитель. Она имеет следующие прототипы:

char_type fill(char_type ch);
char_type fill() const;

Функция с первым прототипом устанавливает ch в качестве текущего символа-заполнителя и возвращает предыдущий символ-заполнитель. Функция со вторым прототипом возвращает текущий символ-заполнитель. По умолчанию в качестве символа-заполнителя используется пробел. Тип данных char_type является параметром класса basic_ios и может обозначать набор "узких" или "широких" символов.
Рассмотрим пример программы, в котором используются форматирующие функции:
//05.01
#include <cmath>
#include <string.h>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, "Rus");
	double x;
	cout.precision(4);
	cout.fill('0');
	cout << " x sqrt(x) x^2\n\n";
	for (x= 1.0; x<= 6.0; x++){
		cout.width(7);
		cout << x << " ";
		cout.width(7);
		cout << sqrt(x) << " ";
		cout.width(7);
		cout << x*x << '\n';
	}

	getchar(); 	getchar();
	return 0;
}

 

Эта программа выводит на экран небольшую таблицу значений переменной x, ее квадратного корня и квадрата:

х 	sqrt(x) 	 х^2
0000001 00000001 0000001
0000002 0001.414 0000004
0000003 0001.732 0000009
0000004 0002.000 0000016
0000005 0002.236 0000025
0000006 0002.449 0000036

С каждым потоком связан набор флагов, которые управляют форматированием потока. Они представляют собой битовые маски, которые определены в классе ios как данные enum-типа fmt_flags. Сами флаги принадлежат типу fmtflags, который определен следующим образом:

typedef int	fmtflags;

Флаги форматирования и их назначение
Флаг	Назначение
boolalpha	Значения булева типа вставляются и извлекаются в виде слов true и false
Hex	Значения целого типа преобразуются к основанию 16 (как шестнадцатиричные')
Dec	Значения целого типа преобразуются к основанию 10
Oct	Значения целого типа преобразуются к основанию 8 (как восьмиричные)
Fixed	Числа с плавающей точкой выводятся в формате с фиксированной точкой (т. е., nnn.ddd)
Scientific	Числа с плавающей точкой выводятся в научной записи (т.е. n.хххЕуу)
showbase	Выводится основание системы счисления в виде префикса к целому числовому значению
showpoint	При выводе значений с плавающей точкой выводится десятичная точка и последующие нули
showpos	При выводе положительных числовых значений выводится знак плюс
uppercase	Заменяет определенные символы нижнего регистра на символы верхнего регистра (символ "е" при выводе чисел в научной нотации на "Е" и символ "х" при выводе 16-ричных чисел на "X")
Left	Данные при выводе выравниваются по левому краю поля
Right	Данные при выводе выравниваются по правому краю поля
internal	Добавляются символы-заполнители между всеми цифрами и знаками числа для заполнения поля вывода
skipws	Ведущие символы-заполнители (знаки пробела, табуляции и перевода на новую строку) отбрасываются
unitbuf	Выходной буфер очищается после каждой операции вставки в поток
adjustfield	= left | right | internal
basefield	= dec | oct | hex
floatfield	= scientific | fixed

Флаги left и right взаимно исключают друг друга. Флаги dec, oct и hex также взаимно исключают друг друга.
Прочесть текущие установки флагов позволяет функция-член flags () класса ios. Для этого используется следующий прототип этой функции:

fmtflags flags() const;

Функция flags() имеет и вторую форму, которая может использоваться для установки значений флагов. Для этого используется следующий прототип этой функции:

fmtflags flags(fmtflags fmtfl);

В этом случае битовый шаблон копируется fmtfl в переменную, предназначенную хотя хранения флагов форматирования. Функция возвращает предыдущие значения флагов. Поскольку эта форма функции меняет весь набор флагов, она применяется редко. Вместо нее используется функция-член setf () класса ios, которая позволяет установить значение одного или нескольких флагов. Она имеет следующие прототипы:

fmtflags setf (fmtflags mask);
fmtflags setf (fmtflags fmtfl, fmtflags mask);

Первая функция-член неявно вызывает функцию flags (mask | flags ()) для установки битов, указанных параметром mask, и возвращает предыдущее значения флагов. Второй вариант функции присваивает битам, указанным параметром mask, значения битов параметра fmtfl, а затем возвращает предыдущие значения флагов. Например, следующий вызов функции setf () устанавливает для потока cout флаги hex и uppercase:

cout.setf (ios::hex | ios:: uppercase);

Сбросить установленные флаги можно с помощью функции-члена unsetf () класса ios, имеющей следующий прототип:

void unsetf(fmtflags mask);

Она сбрасывает флаги, заданные параметром mask.
Следующий пример демонстрирует некоторые флаги:

//05.02
#include <cmath>
#include <string.h>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, "Rus");
	double d = 1.321e9;
	int n = 1024;
	//Вывести Значения
	cout << "d = " << d << '\n';
	cout << "n = " << n << '\n' << '\n';
	//Изменить флаги и
	//вывести значения снова
	cout.setf(ios::hex | ios::uppercase);
	cout.setf(ios::showpos);
	cout << "d = " << d << '\n';
	cout << "n = " << n << '\n';

	getchar(); 	getchar();
	return 0;
}

 

При выполнении программа выводит на экран:

d = 1.321е+009
n = 1024

d = +1.321E+009
n = +1024

Система ввода-вывода C++ предусматривает еще один способ форматирования потока. Этот способ основан на использовании манипуляторов ввода-вывода. Список манипуляторов и их назначение приведены в таблице. Манипуляторы ввода-вывода представляют собой просто вид функций-членов класса ios, которые, в отличие от обычных функций-членов, могут располагаться внутри инструкций ввода-вывода. В связи с этим ими пользоваться обычно удобнее.

Манипуляторы ввода-вывода и их назначение
Манипулятор	Использование	Назначение
boolalpha	ввод-вывод	Устанавливает флаг boolalpha
dec	ввод-вывод	Устанавливает флаг dec
endl	вывод	Вставляет символ новой строки и очищает буфер
ends	вывод	Вставляет символ конца строки
fixed	вывод	Устанавливает флаг fixed
flush	вывод	Очищает буфер потока
hex	ввод-вывод	Устанавливает флаг hex
internal	вывод	Устанавливает флаг internal
left	вывод	Устанавливает флаг left
noboolalpha	ввод-вывод	Сбрасывает флаг boolalpha
noshowbase	вывод	Сбрасывает флаг noshowbase
noshowpoint	вывод	Сбрасывает флаг noshowpoint
noshowpos	вывод	Сбрасывает флаг noshowpos
noskipws	ввод	Сбрасывает флаг noskipws
nounitbuf	вывод	Сбрасывает флаг nounitbuf
nouppercase	ввод-вывод	Сбрасывает флаг
oct	ввод-вывод	Устанавливает флаг oct
Resetiosflags (ios base:: fmtflags mask.)	ввод-вывод	Сбрасывает ios-флаги, в соответствии с mask
right	вывод	Устанавливает флаг right
scientific	ввод-вывод	Устанавливает флаг
scientific
setbase (int base)	ввод-вывод	Задает основание системы счисления для целых
setfill (charT c)	ввод-вывод	Устанавливает символ-заполнитель
setiosflags (ios base:: _fmtflags_mask)	ввод-вывод	Устанавливает ios-флаги, в соответствии с mask
setprecision (int n)	ввод-вывод	Устанавливает точность чисел с плавающей точкой
setw(int n)	ввод-вывод	Устанавливает минимальную ширину поля
showbase	вывод	Устанавливает флаг showbase
showpoint	вывод	Устанавливает флаг showpoint
showpos	вывод	Устанавливает флаг showpos
skipws	ввод	Устанавливает флаг skipws
unitbuf	вывод	Устанавливает флаг unitbuf
uppercase	вывод	Устанавливает флаг uppercase
ws	ввод	Устанавливает пропуск символов-заполнителей

За исключением setw (). все изменения в потоке, внесенные манипулятором, сохраняются до следующей установки.
При внимательном изучении таблицы можно заметить, что манипуляторы охватывают  функциональные возможности, предоставляемые обычными функциями-членами и флагами форматирования. В частности, манипулятор setiosflags () реализует те же функциональные возможности, что и функция-член setf (), а манипулятор resetiosflags () - те же, что и функция-член unsetf ().
Для доступа к манипуляторам с параметрами необходимо включить в программу стандартный заголовочный файл <iomanip>. При использовании манипулятора без параметров скобки за ним не ставятся, так как на самом деле он представляет собой указатель на функцию-член, который передается перегруженному оператору <<.
Рассмотрим пример, демонстрирующий использование манипуляторов.

//05.03
#include <cmath>
#include <iomanip>
#include <string.h>
#include <iostream>
using namespace std;

int main ()
{
	setlocale(LC_ALL, "Rus");
	double x;
	cout << setprecision(4);
	cout << setfill('0');
	cout << "x \tsqrt(x) x^2\n\n";
	for (x=1.0; x<=6.0; x++ ){
		cout << setw(7) << x << " ";
		cout << setw(7) << sqrt(x) << " ";
		cout << setw(7) << x*x << "\n";
	}

	getchar(); 	getchar();
	return 0;
}

 

Этот пример функционально полностью эквивалентен приведенному ранее, но для управления форматом вывода использует манипуляторы, а не функции форматирования.
Следующий пример продолжает обсуждение форматированного вывода С++, начатое ранее. Первая программа показывает, как распечатать таблицу факториалов, используя переменные типа long double и принятое по умолчанию выравнивание вывода вправо:

// 05.17FACT1.CPP
// форматированный ввод/вывод
// факториал чисел от 1 до 25
//
#include "stdafx.h"
#include <iostream>
#include <math.h>
using namespace std;
void main(void)
{
	long double number, factorial;
	number = 1.0;
	factorial = 1.0;
	cout.precision(0); // нет знаков после запятой
	cout.setf(ios::fixed); // фиксированный формат
	for(int i=0; i< 25; i++)
	{
		factorial *= number;
		number = number + 1.0;
		cout.width(30); // ширина 30 символов
		cout << factorial << endl;
	}
}

В цикле повторяются методы класса precision(), width () и setf (). Программа выводит следующие значения:

 

В следующем примере показано, как изменить ширину выходного столбца и установленное по умолчанию выравнивание вправо:

// 05.17FACT2.CPP
// форматированный ввод/вывод
//
#include "stdafx.h"
#include <iostream>
#include <math.h>
using namespace std;

void main(void)
{
	long double number, factorial;
	number = 1.0;
	factorial = 1.0;
	cout.precision(0); // нет знаков после запятой
	cout.setf(ios::left); // выравнивание влево
	cout.setf(ios::fixed); // фиксированный формат
	for(int i=0; i< 25; i++)
	{
		factorial *= number;
		number = number + 1.0;
		cout.width(30); // ширина 30 символов
		cout << factorial << endl;
	}
}

Числа, выровненные влево, выглядят следующим образом:

 

В третьем примере форматирования распечатывается таблица чисел, значения их квадратов и квадратных корней. Эта программа показывает, как легко в С++ выравнивать столбцы, дополнять их пробелами, заполнять пробелы нулями и устанавливать точность.

// 05.17SQRT.CPP
// форматированный ввод/вывод
// вычисление квадрата и квадратного корня для чисе от 1 до 15
//
#include "stdafx.h"
#include <iostream>
#include <math.h>
using namespace std;

void main(void)
{
	double number,square,sqroot;
	cout << "num\t" << "square\t\t" << "square root\n";
	cout << "--------------------------------------\n";

	number = 1.0;
	cout.setf(ios::fixed); // фиксированный формат
	for(int i=1; i< 16; i++)
	{
		square=number*number;
		sqroot=sqrt(number);
		cout.fill('0'); // пробелы заполнить нулями
		cout.width(2); // ширина столбца 2
		cout.precision(0); // нет знаков после десятичной точки
		cout << number << "\t";
			cout.width(6);
			cout.precision(1); // один знак после запятой
			cout << square << "\t\t";
		cout.width(8);
		cout.precision(6);
		cout << sqroot << endl;
		number = number + 1.0;
	}
}

Форматированная таблица выглядит так:

 


1.15. Резидентные в памяти потоки
Язык C++ поддерживает два вида ввода-вывода: файловый ввод-вывод и резидентные в памяти потоки. Файловый ввод-вывод предполагает передачу данных из внешнего устройства или в него. Напротив, резидентные потоки не предполагают работу с внешними устройствами. В этом случае не требуется преобразования кодов и выполнения операций с внешним устройством: осуществляется только форматирование информации. Результат такого форматирования сохраняется в памяти и может быть восстановлен в виде символьной строки. Класс istrstream предназначен для чтения символов из массива в памяти. Он использует private-объект strstreambuf для управления связанным с ним массивом. Поскольку он является производным от basic_istream, он может использовать функции для форматированного и неформатированного ввода. Класс ostrstream предназначен для записи массива в память. Он также использует private-объект strstreambuf для управления связанным с ним массивом. Поскольку он является производным от basic_ostream, он также может использовать функции для форматированного и неформатированного вывода. Класс strstream позволяет читать и записывать в массив символов в памяти и является производным от класса basic_iostrean. Все эти классы определены в заголовочном файле <strstream>. В контексте операций ввода-вывода массивы символов в памяти часто называют резидентными в памяти потоками (строк).
Для работы с резидентным в памяти потоком нужно сначала связать этот поток с некоторой областью памяти (массивом символов). Затем весь ввод-вывод в этот массив можно выполнять с помощью операторов излечения и помещения в поток. Чтобы открыть массив для ввода из него нужно создать объект класса istrstream и, тем самым, связать нужный поток с заданным массивом. Этот класс описывает объект, который управляет извлечением элементов из stream_buffer класса strstreambuf и объявлен следующим образом:

class istrstream: public istream
{
public:
	explicit istrstream(const char *s);
	explicit istrstream(char *s);
	istrstream (const char *s, streamsize n);
	istrstream(char *s, streamsize n);
	strstreambuf *rdbuf() const;
	char *str();
};

Таким образом, для создания объекта класса istrstream можно использовать один из четырех объявленных конструкторов. Конструкторы

istrstream <поток_ввода>(char *s, streamsize n);

и

istrstream <поток_ввода> (const char *s, streamsize n);

используется, когда ввод осуществляется из буфера (которым служит массив), заданного своим указателем s, в том случае, если буфер не заканчивается нулевым символом. В этом случае параметр n задает размер буфера. Если буфер заканчивается нулевым символом можно воспользоваться более простыми формами конструктора:

istrstream <поток_ввода>(const char *s);

и

istrstream <поток_ввода>(char *s);

Для вывода информации в символьный массив нужно создать объект класса ostrstream, который объявлен следующим образом:

class ostrstream: public ostream
{
public:
	ostrstream();
	ostrstream (char *s, streamsize n,
	ios_base :: opermode mode =ios_base:: out);
	strstreambuf *rdbuf() const;
	void freeze(bool frz = true);
	char *str();
	streamsize pcount() const;
};

Этот класс описывает объект, который управляет вставкой элементов в streambuffer класса trstreambuf.
Обычно для вывода информации в символьный массив используется конструктор вида:

ostrstream <поток_вывода>(char *s, streamsize n,
					ios base:: openmode mode =ios base::out);

Здесь <поток_вывода> — это поток, который связывается с буфером s, заданным своим указателем (которым является символьный массив), n — размер буфера, mode — задает режим открытия потока вывода. По умолчанию поток открывается для вывода, поэтому этот параметр можно опускать. Функция-член str () возвращает указатель на буфер и "замораживает" массив. При использовании динамических объектов вызов str() делает термический буфер вашей собственностью. Это означает, что в дальнейшем вы должны будете удалить этот буфер или вернуть его в собственность потока ostrstream, вызвав

<поток_вывода>->rdbuf () ->freeze (0);

Отметим, что перед использованием функции str() нужно явным образом вывести в поток нулевой символ, иначе она возвратит указатель на строку, не ограниченную нулем. Другая функция-член — pcount() — возвращает число записанных в буфер байтов информации.
Чтобы открыть массив для ввода и вывода, создайте объект класса strstream:

strstream <поток_вв>(char *s, streamsize n,
				ios_base::openmode mode =
				ios_base::in | ios_base::out);

Здесь <поток_вв> — это поток ввода-вывода, который для выполнения этих операций связывается с массивом s (который служит буфером) длиной n. После того, как вы создали нужный объект, вы можете пользоваться всеми ранее описанными функциями ввода-вывода, включая функции ввода-вывода для двоичных файлов и для файлов с произвольным доступом. Рассмотрим пример использования резидентного в памяти потока:

//04.05
#include <strstream>
#include <fstream>
#include <iostream>
using namespace std;
//using std::cout;
//using std::cin;

int main()
{
	setlocale(LC_ALL, "Rus");
	char buf[] = "test 9 50.32 *";
	char str[80];
	int n;
	float f;
	char c;
	//Открываем резидентный в памяти поток
	//для ввода
	istrstream istr(buf);
	istr >> str >> n >> f >> c;
	cout << str << ' ' << n << ' '
			<< f << ' ' << c << endl;

	getchar(); 	getchar();
	return 0;
}

 

В этом примере содержимое буфера извлекается в переменные, а затем значения переменных выводятся на экран.
Заметим, что, наряду с перечисленными тремя потоками, для работы с резидентными в памяти потоками могут использоваться три аналогичных им потока istringstream, ostringstream и stringstream. Эти потоки во всем аналогичны рассмотренным, за исключением того, что они используют буфер типа basic_stringbuf (то есть работают со строками типа string) и требуют для их использования подключения стандартного файла <sstream>.

1.16. Буферы и синхронизация.
Потоки выполняют обмен данными между прикладной программой и файлом через буферы, которые являются объектами классов filebuf и stringbuf соответственно. Эти классы являются производными от абстрактного класса streambuf. Каждый буфер содержит в зависимости от режима доступа один или два символьных массива: один для ввода, а второй для вывода данных. Каждый поток поддерживает внутренний указатель на буфер. Ввод-вывод данных из буфера в файл или в строку называется синхронизацией буфера с внешним устройством ввода-вывода. Синхронизация буфера с внешним устройством может выполняться неявно или явно. Неявно синхронизация выполняется в случае закрытия файла или заполнения буфера. Для явной синхронизации используют манипуляторы flush и endl или функцию sync.
Например, в следующей программе показана синхронизация буфера с входным потоком.

#include <iostream>
using namespace std;

int main ()
{
	char a, b;
	cout << "Enter a word: ";
	a = cin.get();
	cin.sync();

	cout << "Enter another word: ";
	b = cin.get();

	cout << "The first word began by: " << a << endl;
	cout << "The second word began by: " << b << endl;

	system("pause");
	return 0;
}

 


1.17. Условные признаки файлов в C++
С каждым потоком связано слово состояния ошибок. При возникновении некоторой ошибки в слове состояния устанавливаются разряды, соответствующие ее типу. В соответствие с принятым соглашением при выводе объектов в поток ostream, имеющий установленные разряды ошибок, операции записи игнорируются и не изменяют состояние потока. Объекты библиотеки ostream имеют набор предопределенных условных признаков, отображающих текущее состояние потока. В следующей таблице перечислены семь методов классов, имеющихся в распоряжении:

Методы функций	Действие
eof()	Возвращает ненулевое значение при достижении конца файла
fail()	Возвращает ненулевое значение, если операция завершена с ошибкой
bad()	Возвращает ненулевое значение, если возникла ошибка
good()	Возвращает ненулевое значение, если отсутствуют установленные разряды
rdstate()	Возвращает текущее состояние потока
сleаг()	Устанавливает состояние потока (int=0)

Эти методы классов можно использовать при реализации различных алгоритмов для определения конкретных состояний ввода/вывода и для большей читаемости программы:

ifstream pfsinfile("sample.dat", os::in);
if(pfsinfile.eof())
	pfsinfile.clear(); // устанавливает состояние pfsinfile в 0
if(pfsinfile.fail())
	cerr << ">>>>sample.dat creation error <<<<"; //ошибка создания sample.dat
if (pfsinfile.good())
	cin >> my_object;
if(!pfsinfile) // усеченный файл
	cout << ">>>> sample.dat creation error <<<<"; //ошибка создания sample.dat

Этот материал служит введением в концепцию ввода/вывода в C++. Для дальнейшего понимания различных возможностей форматирования необходимо познакомиться с классами C++ и разными способами перегрузки.

1.18. Опрос и установка состояния потока
Класс ios поддерживает информацию о состоянии потока после каждой операции ввода-вывода. Текущее состояние потока хранится в объекте типа iostate, который объявлен следующим образом:

typedef int iostate;

Состояния потока являются элементами перечислимого типа io_state, который может иметь значения, представленные в таблице.

Состояния потока и их значения
Состояние	Значение
Goodbit	Ошибок нет
Eofbit	Достигнут конец файла
Failbit	Имеет место ошибка форматирования или преобразования
Badbit	Имеет место серьёзная ошибка

Для опроса и установки состояния потока можно использовать функции-члены класса ios. Имеется два способа получения информации о состоянии операции ввода-вывода. Во-первых, можно вызвать функцию rdstate(), имеющую следующий прототип:

iostate rdstate() const;

Функция возвращает состояние операции ввода-вывода. Во-вторых, можно воспользоваться одной из следующих функций-членов:

bool good() const;
bool eof() const;
bool fail() const;
bool bad() const;

Каждая из этих функций возвращает true, если установлен соответствующий бит состояния (точнее, функция fail() возвращает true, если установлен бит failbit или badbit).
Если прочитано состояние, которое сигнализирует об ошибке, его можно сбросить с помощью функции clear ():

void clear(iostate state = ios::goodbit);

Установить нужное состояние можно с помощью функции setstate():

void setstate(iostate state);

Кроме перечисленных функций, класс ios содержит функцию приведения типа

operator void*() const;

(она возвращает NULL, если установлен бит badbit) и перегруженный оператор логического отрицания

bool operator!() const;

(он возвращает true, если установлен бит badbit). Это позволяет сравнивать выражения, в которые входит поток или его отрицание с нулем, то есть писать выражения вида:

while(!strmOb.eof())
{
	//…
}

Следующий пример иллюстрирует получение информации о состоянии ввода-вывода.

//04.03
#include <fstream>
#include <iostream>
using namespace std;
//using std::cout;
//using std::cin;

int main(int argc, char* argv[])
{
	char c;
	if (argc > 1){
		ifstream ifs(argv[1] );
		if (!ifs){
			cout << "Файл не открыт\n";
			return 1;
		}
		while (!ifs.eof()){
			ifs.get(c);
			//Контроль состояния потока
			if (ifs.fail()){
				cout << "Ошибка!";
				break;
			}
			cout << c;
		}
		ifs.close();
	}
return 0;
}

В этом примере осуществляется ввод символов из файла, заданного в командной строке при запуске программы. Если при извлечении символов встречается ошибка, чтение прекращается и выводится сообщение об этом.

1.19. Ошибки потоков
По умолчанию поток ввода-вывода не выбрасывает никаких исключений. Вы должны сами активизировать исключение. Для этой цели поток содержит маску исключений. Каждый из флагов этой маски соответствует одному из флагов ошибки (состояния потока). Ключевую роль в выбрасывании исключений играют две функции-члена класса ios:

iostate exceptions() const;

Эта функция возвращает маску, которая определяет, какие флаги состояния, установленные в маске флагов состояния, будут вызывать выбрасывание исключения. Она неявно использует вызов функции rdstate (). Другая функция

void exceptions(iostate except);

устанавливает маску исключений потока в значение, определяемое переменной except, а затем вызывает clear (rdstate ()) для сброса, возможно, установленных битов маски состояния потока. Например, если флаг badbit установлен в маске исключений, исключение будет выброшено, если этот флаг будет установлен в маске состояния потока. Следующий пример демонстрирует, как можно активизировать исключение в потоке ввода:

try
{
	ifs.exceptions (ios::badbit | ios::failbit);
	in >> x;
	//…
}

catch(ios::failure& e)
{
	cerr << e.what() << endl;
	throw;
}

При вызове функции exceptions() вы указываете, какие флаги состояния потока будут вызывать выбрасывание исключения. Объекты, выброшенные потоковыми операциями ввода-вывода, являются производными от исключения типа ios :: failure. Заметим, что любое изменение состояния потока будет приводить к выбрасыванию исключения. Это происходит потому, что функции setstate () и exception () приводят к выбрасыванию исключения, если в маске исключений установлен соответствующий бит. Следовательно, оператор catch, приведенньй выше, будет ловить все исключения, связанные с потоками. Рекомендуется активизировать исключение по флагу badbit и подавить исключения по флагам eofbit и faiibit, поскольку они, вообще говоря, не представляют исключительные состояния.

1.20. Часто применяемые функции
Помимо уже описанных функций, библиотека ввода-вывода C++ содержит широкий набор различных функций. Здесь мы приведем лишь некоторые, наиболее часто употребляемые из них. Большинство этих функций используется для неформатируемого ввода-вывода.
Для извлечения символа из потока можно использовать функцию-член get() потока istream. Она имеет много прототипов, однако чаще других используются следующие два:

int_type get();
istream_type& get(char_type& с);

Тип int_type определен как целочисленный. Приведем пример использования функции get ():

//05.05
#include <cmath>
#include <iomanip>
#include <string.h>
#include <fstream>
#include <iostream>
using namespace std;
//using std::cout;
//using std::cin;

int main()
{
	setlocale(LC_ALL, "Rus");
	char ch;
	cout << "Введите число. "
	<< "Для завершения ввода нажмите <ENTER>: ";
	while (cin.get(ch)){
		// Проверка на код клавиши <ЕNTER>
		if (ch == '\n')
		break;
	}

	getchar(); 	getchar();
	return 0;
}

 

Для вставки символа в поток вывода используется функция put(), которая имеет следующий прототип:

ostream& put(char ch);

Функция get() может также использоваться для чтения строки символов. В этом случае используются ее варианты, определяемые следующими прототипами:

istream_type& get(char_type* str, streamsxze len, char_type delim);
istream_type &get(char_type* str, streamsize len);

Эта функция извлекает из входного потока символы в буфер str, пока не встретится символ-разграничитель delim (по умолчанию - перевод строки) или не будет прочитано (lеn-1) символов, или не будет прочитан конец файла. Символ-разграничитель не извлекается из входного потока.
Ввиду того, что функция get() не извлекает из входного потока символ-разграничитель, она используется редко. Гораздо чаще используется функция getline (), которая не извлекает из входного потока символ-разграничитель, но не помещает его в буфер. Она имеет следующие прототипы:

istream_type& getline (char_type* str,streamsize len, char_type delim);
istream_type& getline (char_type* str,streamsize len);

Здесь параметры имеют то же назначение, что и в функции get().
Функция gcount () возвращает число символов, извлеченных из потока последней операцией неформатируемого ввода (т.е. функцией get(), getline() или read()). Она имеет следующий прототип:

streamsize gcount() const;

Рассмотрим пример, в котором используются две последние функции:

//05.06
#include <cmath>
#include <iomanip>
#include <string.h>
#include <fstream>
#include <iostream>
using namespace std;
//using std::cout;
//using std::cin;

int main()
{
	setlocale(LC_ALL, "Rus");
	char *name;
	int len = 100;
	int count = 0;
	name = new char[len];
	cout << "Введите свое имя: ";
	cin.getline(name, len);
	count = cin.gcount();
	//Уменьшаем значение счетчика на 1, т.к.
	//getline() не помещает
	//разграничитель в буфер
	cout << "\nЧисло прочитанных символов: "
	<< count - 1;

	getchar(); 	getchar();
	return 0;
}

 

Для того, чтобы пропустить при вводе несколько символов, используется функция ignore():

istream_type& ignore(streamsize n=1,
					int_type delim=traits::eof());

Эта функция игнорирует вплоть до n символов во входном потоке. Пропуск символов прекращается, если она встречает символ-разграничитель, которым по умолчанию является символ конца файла. Символ-разграничитель извлекается из входного потока.

Функция peek (), имеющая следующий прототип:

int_type peek();

позволяет "заглянуть" во входной поток и узнать следующий вводимый символ. При этом сам символ из потока не извлекается. С помощью функции putback (), имеющей прототип:

istream_type& putback(char_type ch);

можно вернуть символ ch в поток ввода.
При выполнении вывода данные не сразу записываются в файл, а временно хранятся в связанном с потоком буфере, пока он не заполнится. Функция flush() позволяет вызвать принудительную запись в файл до заполнения буфера. Эта функция имеет следующий прототип:

ostream_type& flush();

Она неявно используется манипулятором endl. Этот манипулятор вставляет в поток символ перевода строки и очищает буфер. Таким образом, инструкция

cout << endl;

эквивалентна следующим:

cout << '\n'; cout.flush ();

Функция rdbuf() позволяет получить указатель на связанный с потоком буфер. Эта функция имеет следующий прототип:

streambuf_type* rdbuf() const;

Наконец, функция setbuf () позволяет связать с потоком другой буфер. Она имеет такой прототип:

void setbuf (char* buf, streamsize n);

Здесь buf указатель на другой буфер длины n.

1.21. Двоичные файлы.
Когда вы открываете файл в текстовом режиме, происходит следующее:
	при вводе каждая пара символов '\r'+'\n' (возврат каретки + перевод строки) преобразуется в символ перевода строки ('\n');
	при выводе каждый символ перевода строки ('\n') преобразуется в пару ' \r' + ' \n' (возврат каретки + перевод строки).

Это не всегда удобно. Если вы собираетесь использовать выводимый файл для последующего ввода в (возможно, другую) программу, лишние байты информации ни к чему. С этой целью система ввода-вывода предоставляет вам возможность осуществления неформатируемого ввода-вывода, то есть записи и чтения двоичной информации (иногда говорят - сырых данных). Для осуществления ввода-вывода в двоичном режиме, включите флаг ios :: binary в параметр open_mode, передаваемый конструктору потока или функции open(). Чтение двоичной информации из файла осуществляется функцией read(), которая имеет следующий прототип:

istream_typr&
read (char_type* s, streamsize n);

Здесь параметр s задаст буфер для считывания данных, а параметр n—число читаемых символов.
Запись двоичных данных осуществляет функция-член write ():

ostream_type&
write(const char_type* s, streamsize n);

Эта функция получает n символов из буфера, адрес которого задан параметром s, и вставляет их в поток вывода. Рассмотрим пример:

//05.04
#include <cmath>
#include <iomanip>
#include <string.h>
#include <fstream>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, "Rus");
	int x = 255;
	char str[80] ="binary input-output testing";
	//"Тестирование двоичного ввода-вывода."
	//Открываем файл для вывода в
	//двоичном режиме
	ofstream ofs("Test.dat");
	if (!ofs){
		cout << "Файл не открыт.";
		return 1;
	}
	ofs.write ((char*) &x, sizeof(int));
	ofs.write ((char*) &str, sizeof(str));
	//Открываем файл для вывода в
	//двоичном режиме
	ifstream ifs("Test.dat");
	if (!ifs){
		cout << "Файл не открыт.";
		return 1;
	}
	ifs.read((char*)&x, sizeof(int));
	ifs.read((char*)&str, sizeof(str));
	cout << x << '\n' << str << '\n';

	getchar(); 	getchar();
	return 0;
}

 

В большинстве рассмотренных до сих пор программ использовались стандартные текстовые файлы, или потоки — как их более правильно называть. Это не удивительно, поскольку потоки первоначально разрабатывались для текстов и текстовый режим применяется по умолчанию при вводе/выводе.
Стандартные текстовые файлы или потоки состоят из последовательности символов, включающей символы возврата каретки и перевода строки. В текстовом режиме не требуется, чтобы отдельные символы оставались неизменными — такими, какими они записывались или читались из файла. В некоторых приложениях из-за этого могут возникнуть проблемы. Например, ASCII-КОД символа перевода строки равен десятичному числу 10. Однако, он может быть также записан как 8-разрядное шестнадцатеричное число 0А. В программах С/С++ это значение рассматривается как отдельная символьная константа '\n'.
Оказывается, что в системе MSDOS новая строка физически представляется двумя символами: возврат каретки (десятичное 13) и перевод строки (десятичное 10). Обычно это не представляет проблемы, поскольку при вводе программа автоматически преобразует эту пару символов в один символ новой строки и выполняет обратное преобразование при выводе. Проблема в том, что символ новой строки занимает один байт, а пара символов CR/LF занимает два байта памяти.
Двоичные файлы или потоки содержат последовательность байтов, полностью соответствующих их представлению на внешнем устройстве (диске, ленте или терминале). В двоичном файле никаких преобразований символов не выполняется, и поэтому число прочитанных или записанных байтов совпадает с числом байтов, располагающихся в файле на внешнем устройстве.
Если в программе необходимо считывать исполняемый файл, то это нужно делать в двоичном режиме. Двоичные файлы также используются при считывании и записи чисто информационных файлов, например баз данных. Это гарантирует, что не выполняется никаких преобразований данных, за исключением тех, которые осуществляются непосредственно в приложении.
Следующая программа идентична программе 17OSTRM.СРР, описанной ранее; отличие заключается в том, что выходной файл открывается не в текстовом режиме, а в режиме ios::binary:

// 05.17BINARY.CPP
// применение класса ofstream
// вывод двойчного файла
// допустимые методы класса ofstream
//	ofstream::open	ofstream::rdbuf
// допустимые методы класса ostream
//	ostream::flush	ostream::ostream
//	ostream::put	ostream::seekp
//	ostream::tellp	ostream::write
//
#include "stdafx.h"
#include <iostream>
#include <fstream>
#include <math.h>
#include <strstream>
using namespace std;

#define iSTRING_MAX	40

void main(void)
{
	int i = 0;
	long ltellp;
	char pszString[iSTRING_MAX] = "Simple test string\n"; /* 6+1+4+1+6=18+1(‘\n’)=19 */
	//файл открывается в двоичном режиме
	ofstream ofMyOutputStream("myostrm.out", ios::out|ios::binary);
	//посимвольный вывод строки
	//строка '\n' НЕ преобразуется в два символа
	while(pszString[i] != '\0')
	{
		ofMyOutputStream.put(pszString[i]);
		ltellp = ofMyOutputStream.tellp();
		cout << "\ntellp value: " << ltellp;
		i++;
	}
	//выод строки целиком при помощи метода класса
	ltellp = ofMyOutputStream.tellp();
	cout << "\ntellp's value before writing 2nd string: " << ltellp;
	ofMyOutputStream.write(pszString, strlen(pszString));
	ltellp = ofMyOutputStream.tellp();
	cout << "\ntellp's updated value: " << ltellp << '\n';
	ofMyOutputStream.close();
}

Сокращенная распечатка результатов показывает однозначное соответствие между файлом и внутренним представлением данных:

tellp value: 1
tellp value: 2
tellp value: 3
tellp value: 4

tellp value: 17
tellp value: 18
tellp value: 19
tellp's value before writing 2nd string: 19
tellp's updated value: 38

 

Строка pszString, занимающая 19 символов плюс null-символ '\0' в конце строки, выводится в точном соответствии с тем, как она хранится, без добавления символа конца строки '\0'. Именно поэтому функция tellp() выводит число, кратное 19, по окончанию вывода каждой строки.

1.22. Объединение программ на С и С++. Использование спецификатора extern "С".
Ранее уже рассказывалось о том, как ключевое слово extern указывает на внешнюю связь переменной или функции. Это означает, что данная переменная или функция описаны в некотором другом исходном файле или в том же файле, но ниже.
Однако, в С/С++ можно использовать extern вместе со строкой. Эта строка указывает на то, что для описываемых идентификаторов используются соглашения о компоновке другого языка. По умолчанию для программ С++ задается строка "С++".
По умолчанию в С++ функции можно перегружать. При этом компилятор С++ каждой функции присваивает новое имя. Эту операцию можно отменить, если указать перед описанием функции extern "С". Это необходимо для того, чтобы из программы, написанной на С++, были доступны функции и данные С. Конечно же, это нужно делать только для функций с одинаковыми именами. Если не отменить эту опцию, то компоновщик обнаружит несколько глобальных функций с одним и тем же именем. В настоящее время компилятор Visual С/С++ поддерживает единственный спецификатор другого языка — "С". Синтаксис записи extern "С" выглядит следующим образом:

extern "С" тип_ функции имя_ функции(тип_параметра (тип_параметров) параметр (параметры));

Следующий оператор показывает, как запись extern "С" используется вместе с прототипом отдельной функции:

extern "С" int fprintf(FILE *stream, char *format, ...);

Для модификации группы прототипов функций нужны фигурные скобки {}:

extern "С" {

		….
}

В следующем фрагменте кода модифицируются прототипы функций getc() и рutc():

extern "С" {
int getc(FILE *stream);
int putc(int с, FILE *stream);
}

Ниже приведена программа, показывающая, как использовать запись extern "С":

// 05.17CLINK.CPP
// связь С++ с библиотеками С
//
#include "stdafx.h"
#include <iostream>
#include <fstream>
#include <math.h>
#include <strstream>
using namespace std;

#define iMAX 9
extern "C" int imycompare(const void *pi1, const void *pi2);

void main(void)
{
	int iarray[iMAX]={1, 9, 2, 8, 3, 7, 4, 6, 5};
	for(int i=0; i < iMAX; i++)
		cout << iarray[i] << " ";
	cout << endl;
	qsort(iarray,iMAX, sizeof(int), imycompare);
	for(i = 0; i < iMAX; i++)
		cout << iarray[i] << " ";
	cout << endl;
}

extern "C" int imycompare(const void *pi1, const void *pi2)
{
	return(*(int *)pi1 - *(int *)pi2);
}

Результат работы программы

1 9 2 8 3 7 4 6 5
1 2 3 4 5 6 7 8 9
Press any key to continue

 

Во всех include-файлах Visual С используется спецификация extern "С". Благодаря этому, в программах, написанных на С++, можно вызывать библиотечные функции времени исполнения языка С. Вместо того, чтобы для каждого определения повторять спецификатор extern "С", во всех заголовочных файлах С используется пара следующих условных операторов, внутри которых располагаются описания:

// Операторы, расположенные в начале заголовочного файла
#ifdef __cplusplus
extern "С" {
#endif

// Операторы, расположенные в конце заголовочного файла
#ifdef __cplusplus
}
#endif

При компиляции программы на С++ транслятор автоматически определяет имя __cplusplus, которое, в свою очередь, управляет видимостью спецификатора extern "С" и фигурных скобок, обрамляющих описания.

1.23. Манипуляторы.
Манипулятором называется глобальная функция, которая изменяет поток. Манипуляторы предназначены для включения в последовательность операторов ввода или вывода и могут изменять состояние потока, управляя его флагами. Манипуляторы подразделяются на две группы: простые манипуляторы и параметризованные манипуляторы.
Простые манипуляторы не требуют аргументов. Ниже перечислены простые манипуляторы:

endl	помещает в выходной поток символ ‘\n’ и вызывает манипулятор flush,
ends	помещает в поток символ ‘\0’,
flush	освобождает поток,
dec	устанавливает 10 c/c,
hex	устанавливает 16 c/c,
oct	устанавливает 8 c/c,
ws	игнорирует при вводе ведущие пробелы.

Манипуляторы с аргументами называются параметризованными. Ниже перечислены параметризованные манипуляторы, которые объявлены в заголовочном файле <iomanip>:

resetiosflags	сбрасывает флаги форматирование,
setiosflags	устанавливает флаги форматирования,
setbase	устанавливает систему счисления,
setfill	устанавливает символ заполнитель,
setprecision	устанавливает точность для плавающих чисел,
setw	устанавливает ширину поля для символа заполнителя.

Можно написать свой манипулятор. Например, следующая функция является манипулятором, который выполняет переход на новый абзац.

//#include <iostream.h>
#include <iostream>
using namespace std;

ostream& tabl(ostream& out)
{
    out << '\n' << '\t';
    return out;
}

int main()
{
	cout << "This is a test for the manipulator tabl"
	<< tabl
	 
	<< "The end of the test" << endl;

	system("pause");
	return 0;
}

 

Ранее описывалась концепция манипуляторов потоков. Манипуляторы используются вместе с операциями вставки << и выделения >> аналогично выходным данным или входным переменным. Однако, в соответствии со своим названием манипуляторы могут выполнять различные действия над входным и выходным потоками.
В некоторых примерах программ использовались встроенные манипуляторы dec, hex, oct, setw и setprecision. Теперь вы познакомитесь с тем, как создавать пользовательские манипуляторы. По мере знакомства с синтаксическими конструкциями, необходимыми для создания специальных манипуляторов, примеры усложняются; сначала рассматриваются простейшие манипуляторы без параметров, а затем — с параметрами.

1.23.1. Манипуляторы без параметров.
Пользовательский манипулятор можно создать в любой момент, когда необходимо несколько раз выводить одну и ту же последовательность символов в выходной поток. Например: в приложении необходимо отмечать для пользователя важные данные. Возможно даже выдавать звуковой сигнал для привлечения внимания оператора к экрану. Без специальных манипуляторов операторы вывода будут выглядеть так:

cout << '\а' << "\n\n\t\tImportant data: " << fcritical_mass << endl; // Важные данные

Каждый раз для привлечения внимания пользователя нужно повторять символ звукового сигнала '\а' и строку "... Important data: ". Более простой вариант — определить манипулятор, названный beep, который будет автоматически подставлять нужную последовательность символов. Этот манипулятор упростит чтение оператора вывода:

cout << beep << fcritical_mass << endl;

В следующей программе показано, как описать и использовать функцию beep():

// 05.17BEEP.CPP
// манипультор без параметров
//
#include "stdafx.h"
#include <iostream>
#include <fstream>
#include <math.h>
#include <strstream>
using namespace std;

ostream& beep(ostream& os)
{
return os << '\a' << "\n\n\t\t\tImportant data: ";
}

void main(void)
{
	double fcritical_mass = 12459876.12;
	cout << beep << fcritical_mass << endl;
}

В глобально описанной функции beep() используется формальный параметр ostream&; он же является возвращаемым значением. При работе эта функция автоматически связывается с потоковой операцией <<. Для того, чтобы принимать подобную функцию, операция вставки в поток перегружается; для этого используется следующий формат встраиваемой функции:

inline ostream& ostream::operator << (ostream& (*f)(ostream&)) {
	(*f)(*this);
	return *this;
}

Встраиваемая функция связывает операцию << с пользовательским манипулятором; для этого она принимает указатель на переданный функции тип ostream& и затем возвращает его. Это полностью совпадает с прототипом функции beep(). После этого, когда совместно используются операция << и функция beep(), компилятор выполняет разыменование перегруженной операции, находит функцию beep(), а затем выполняет ее. Перегруженная операция возвращает ссылку на исходный поток ostream. Благодаря этому, можно комбинировать манипуляторы, строки и другие данные и операции <<.
Результат работы программы:

Important data: 1.24599e+007
Press any key to continue

 

1.23.2. Манипуляторы с одним параметром.
В библиотеке классов Microsoft iostream, имеющей прототипы в файле iomanip.h, описан набор специальных макросов, предназначенных для создания параметризованных макроопределений. Простейший параметризованный макрос может принимать один аргумент типа int или long.
В следующем листинге описан прототип для такого манипулятора (fс). Этот пример показывает, как создать пользовательский манипулятор с одним параметром:

// 05.17MANIP.CPP VC6.0
// манипультор с одним параметром
#include <iostream.h>
#include <iomanip.h>
#include <string.h>
#define iSCREEN_WIDTH 80

ostream& fc(ostream& os, int istring_width)
{
	os << '\n';
	for(int i = 0; i < ((iSCREEN_WIDTH - istring_width)/2); i++)
		os << ' ';
	return (os);
}

OMANIP(int) center(int istring_width)
{
	return OMANIP(int) (fc, istring_width);
}

void main(void)
{
	char *psz="This is auto-centered text!"; // автоцентрирующийся текст
	cout << center(strlen(psz)) << psz << endl;
}

Пользовательский параметризованный манипулятор center принимает одно значение, strlen(psz), представляющее собой длину строки. В файле iomanip.h описывается макрос OMANIP(int), расширяемый в класс __OMANIP_int. Описание этого класса включает конструктор и перегруженную операцию вставки в поток ostream. Когда функция center() включается в поток, она вызывает конструктор, который создает и возвращает объект __OMANIP_int. Затем конструктор объектов вызывает функцию fc().
Результат выполнения программы:

This is auto-centered text!
Press any key to continue

 

1.23.3. Манипуляторы с несколькими параметрами.
Следующий пример может показаться вам знакомым. Действительно, эта программа (17SQRT.СРР) описана выше и служит для демонстрации форматированного вывода цифр. Однако, программа переписана, и теперь в ней используется пользовательский манипулятор с двумя параметрами.
Во-первых, в программе описана простая структура, хранящая фактические параметры манипулятора форматирования:

struct stwidth_precision
{
	int iwidth;
	int iprecision;
};

При создании манипуляторов, получающих аргументы, отличные от int и long, необходимо использовать макрос IOMANIPdeclare. Это макроопределение объявляет классы для нового пользовательского типа данных. Описание манипулятора format начинается с макроса OMANIP:

OMANIP(stwidth_precision) format(int iwidth, int iprecision)
{
	stwidth_precision stWidth_Precision;
	stWidth_Precision.iwidth = iwidth;
	stWidth_Precision.iprecision = iprecision;
	return OMANIP(stwidth_precision) (ff, stWidth_Precision);
}

В этом примере пользовательскому манипулятору передаются два целочисленных аргумента, iwidth и iprecision. Первый из них определяет количество пробелов, используемых манипулятором format, а второй — задает число позиций после десятичной точки. После инициализации структуры stWidth_Precision манипулятор format вызывает конструктор, создающий и возвращающий объект __OMANIP. Затем конструктор объектов вызывает функцию ff(), которая устанавливает заданные параметры:

static ostream& ff(ostream& os, stwidth_precision stWidth_Precision)
{
	os.width(stWidth_Precision.iwidth);
	os.precision(stWidth_Precision.iprecision);
	os.setf(ios::fixed);
	return os;
}

Законченная программа приводится ниже. Для сравнения в листинге оставлен весь код, замененный манипулятором format. Обратите внимание на то, как использование этого манипулятора упрощает каждый оператор вывода.

// 05.17MANIP2.CPP VC6.0
// манипультор с двумя параметрами

#include <iostream.h>
#include <iomanip.h>
#include <math.h>
struct stwidth_precision
{
	int iwidth;
	int iprecision;
};

IOMANIPdeclare(stwidth_precision);
static ostream& ff(ostream& os, stwidth_precision stWidth_Precision)
{
	os.width(stWidth_Precision.iwidth);
	os.precision(stWidth_Precision.iprecision);
	os.setf(ios::fixed);
	return os;
}

OMANIP(stwidth_precision) format(int iwidth, int iprecision)
{
	stwidth_precision stWidth_Precision;
	stWidth_Precision.iwidth = iwidth;
	stWidth_Precision.iprecision = iprecision;
	return OMANIP(stwidth_precision) (ff, stWidth_Precision);
}

void main(void)
{
	double number,square,sqroot;
	cout << "num\t" << "square\t\t" << "square root\n";
	cout << "--------------------------------------\n";
	number = 1.0;
	//cout.setf(ios::ffixed);
	for(int i = 1;i < 16; i++)
	{
		square = number * number;
		sqroot = sqrt(number);
		cout.fill('0');
		//cout.width(2);
		//cout.precision(0);
		cout << format(2, 0) << number << "\t";
		//cout.width(6);
		//cout.precision(1);
		cout << format(6, 1) << square << "\t\t";
		//cout.width(8);
		//cout.precision(6);
		cout << format(8, 6) << sqroot << endl;
		number += 1.0;
	}
}

Результат работы программы:
num	square	square root
--------------------------------------
01	0001.0	1.000000
02	0004.0	1.414214
03	0009.0	1.732051
04	0016.0	2.000000
05	0025.0	2.236068
06	0036.0	2.449490
07	0049.0	2.645751
08	0064.0	2.828427
09	0081.0	3.000000
10	0100.0	3.162278
11	0121.0	3.316625
12	0144.0	3.464102
13	0169.0	3.605551
14	0196.0	3.741657
15	0225.0	3.872983
Press any key to continue

 
1. Файлы в C.
1.1. Файлы и потоки.
1.2. Связь с файлами.
1.3. Закрытие потоков.
1.4. Обработка ошибок в C и C++
1.4.1. Переменная errno и коды ошибок
1.5. Переключение и работа с файлами.
1.5.1. Переключение вывода.
1.5.2. Переключение ввода.
1.5.3. Комбинированное переключение.
1.5.4. Конвейерная пересылка
1.6. Текстовые и бинарные (двоичные) файлы
1.7. Потоковый ввод-вывод.
1.8. Соединение и отсоединение потока от файла.
1.8.1. Функция fopen
1.8.2. Функция fclose
1.8.3. Функция freopen
1.9. Работа с индикаторами ошибки, позиции и конца файла (ferror, clearerr, feof, rewind, fseek, fsetpos, ftell, fgetpos).
1.10. Блочный ввод-вывод (fwrite, fread).
1.11. Символьный ввод-вывод.
1.11.1. Функции fputc, putc, fgetc, getc, ungetc
1.11.2. Функции fputs и fgets
1.11.3. Функции fprintf, fscanf
1.12. Работа с буферами (setvbuf, setbuf, fflush).
1.13. Стандартные потоки (putchar, getchar, puts, gets, perror).
1.14. Служебные функции для работы с файлами (remove, rename, tmpfile, tmpnam).
1.15. Низкоуровневый ввод и вывод в С.
1.16. Форматированный вывод.
1.16.1. Использование функций printf() и fprintf().
1.17. Примеры
1.17.1. Содержимое файла
1.17.2. Чтение/запись из/в файл
1.17.3. Назначение буфера потоку stderr
1.17.4. Демо для функции setvbuf()
1.17.5. Структура и файл
1.17.6. Сжатие файла
1.17.7. Функции fgets и fputs
1.17.8. Функции fread и fwrite, fseek, ftell, rewind
1.17.9. Использование fseek

1. Файлы в C.

http://www.itmathrepetitor.ru/s-lekciya-6-fajjly-i-potoki-struktury-i-pe/

1.1. Файлы и потоки.

Интуитивное определение файла звучит примерно так. Файл -- именованная область на жестком диске. На самом деле с точки зрения ОС UNIX это совсем не так. В ОС UNIX файл -- очень удобная абстракция. С точки зрения UNIX файлом называется "что-нибудь", из чего можно считывать информацию или во что можно записывать информацию. Файлы это:
•	Файлы в обычном смысле: файлы, которые хранятся на жестком диске (можно считывать из них и запиcывать в них информацию);
•	Экран монитора: файл, в который можно выводить информацию (отобразится на экране монитора);
•	Клавиатура: файл, из которого можно считывать информацию;
•	Принтер: файл, в который можно выводить информацию (печать текста);
•	Модем: файл, из которого можно считывать информацию и в который можно записывать информацию (обмен информации по сети);

Файл -- это всё, что предназначено для ввода или вывода информации.
С этой точки зрения файлы бывают разными: принтер может только выводить информацию, а клавиатура -- только вводить. У такого рода файлов есть много особенностей. У файла на жестком диске есть понятие конца файла. Мы можем его считывать до тех пор, пока он не кончится. Тогда как у клавиатуры нет конца.
Неправильно думать, что между сущностями "файл" и "название файла" есть взаимно однозначное соответствие.
Можно привести аналогию из жизни: если представить, что файл -- это банка с некоторым содержимым, то название файла -- это этикетка на этой банке. Логично предположить, что у банки может быть несколько этикеток.
С точки зрения UNIX:

 

Правильно говорить, что у названия есть файл. И наоборот: неправильно говорить, что у файла есть название. Никакого эффективного способа узнать имя файла не существует (но можно перебрать все файлы файловой системы).

Чтение и запись: printf и scanf
Всем хорошо известная функция printf:

printf("Hello!");//печать текста на экран;
printf("N = %d", N);//форматированный вывод на экран: вывести число N в десятичной записи;
printf("N = %x", N);//форматированный вывод на экран: вывести число N в шестнадцатеричной записи;

Аналогично парная функция scanf:

scanf("%d", &N);//считывание с клавиатуры значения переменной N в десятичной записи;
char *ptr = new char[10];
scanf("%s", ptr);//считывание с клавиатуры строки в массив *ptr

Тут могут возникать различные проблемы.

1. Проблема безопасности:

char *ptr = new char[10];
scanf("%s", ptr);

Тут налицо потенциальная проблема переполнения буфера (в данном примере в буфере всего 10 байт).
Никогда не следует пользоваться scanf-ом для чтения строк.

scanf + "%s" -- запрещенная комбинация!

2. Форматная строка не компилируется: она будет разбираться в момент исполнения программы. Это обозначает проблему быстродействия. scanf -- не предназначен для чтения большого количества информации. Аналогично printf -- тоже сравнительно медленный (однако существенно быстрее, чем scanf).
3. Проблема безопасной работы со стеком:

printf("%d %d", N);

Проблема состоит в том, что форматная строка "%d %d" будет проанализирована в момент исполнения. В данном случае произойдет ошибка при работе со стеком: во время исполнения будет взят лишний int.
Перечисленные недостатки означают, что использование функций printf и scanf небезопасно и малоэффективно. Существенным плюсом этих функций является возможность простого форматированного ввода и вывода.

Для нас файл является частью памяти, обычно на диске, со своим именем. Мы считаем, например, stdio.h именем файла, содержащего некоторую полезную информацию. Для операционной системы файл более сложен, но это системные проблемы, а не наши. Однако мы должны знать, что означает файл для программы на языке Си. В предлагаемых для обсуждения функциях, работающих с файлами, язык Си «рассматривает» файл как структуру. Действительно, файл stdio.h содержит определение структуры файла.
В stdio.h (на моем компьютере) фрагмент описания файла выглядит следующим образом:

#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr; /* текущий указатель буфера */
        int   _cnt; /* текущий счетчик байтов */
        char *_base; /* базовый адрес буфера ввода-вывода*/
        int   _flag; /* управляющий признак */
        int   _file; /* номер файла */
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif

А вот типичный пример, взятый из IBM-версии компилятора Lattice С:

struct _iobuf
{
	char *_ptr; /* текущий указатель буфера */
	int _cnt; /* текущий счетчик байтов */
	char *_ base; /* базовый адрес буфера ввода-вывода*/
	char _ flag; /* управляющий признак */
	char _ file; /* номер файла */
};

#define FILE struct _iobuf /* краткая запись */

Здесь мы не собираемся разбираться детально в этом определении. Главное состоит в том, что файл является структурой, и что краткое наименование шаблона файла — FILE. (Многие системы используют директиву typedef для установления этого соответствия.) Таким образом, программа, имеющая дело с файлами, будет использовать тип структуры FILE, чтобы делать так.
Имея это в виду, мы сможем лучше понять операции над файлами.
Файлом называют последовательность байтов, хранящихся на внешнем носителе информации. Под доступом к файлу понимают запись и чтение данных из файла. Потоком называется логический интерфейс (программа), который обеспечивает доступ к файлу. Прежде чем использовать поток для доступа к файлу, его необходимо соединить с этим файлом, то есть обеспечить поток информацией о файле. Эта информация хранится в структуре типа FILE. Потому считается, что поток имеет тип FILE*, то есть является указателем на файл. Когда поток соединяют с файлом, то говорят, что файл открывают. Когда поток отсоединяют от файла, то говорят, что файл закрывают.
Каждый поток может работать в двух режимах: текстовом и бинарном. Режим работы потока задается при его соединении с файлом.
В текстовом режиме поток записывает и читает из файла текстовые строки, которые заканчиваются символом ‘\n’ и могут содержать символ ‘\t’. По стандарту поток должен обеспечивать обработку строк длиной не менее 254 символа, включая символ ‘\n’. Стандартом допускается, что при чтении и записи данных текстовым потоком может происходить их преобразование.
В бинарном режим поток записывает и читает данные из файла в том виде, в котором они хранятся в оперативной памяти.
Далее будут описаны стандартные функции для работы с файлами, используемые в языке С. Прототипы этих функций находятся в заголовочном файле stdio.h.
Термин поток происходит из представления процесса ввода-вывода в файл в виде последовательности или потока байтов. Над потоком можно выполнять следующие операции:
•	Считывание блока данных из потока в оперативную память;
•	Запись блока данных из оперативной памяти в поток;
•	Обновление блока данных в потоке;
•	Считывание записи из потока;
•	Занесение записи в поток.

Все потоковые функции ввода-вывода обеспечивают буферизированный, форматированный или не форматированный ввод и вывод.
Когда начинается выполнение программы, автоматически открываются следующие потоки:
•	stdin - стандартное устройство ввода;
•	stdout - стандартное устройство вывода;
•	stderr - стандартное устройство сообщений об ошибках;
•	stdprn - стандартное устройство печати;
•	stdaux - стандартное вспомогательное устройство.

Все они называются стандартными (или предопределенными) потоками ввода-вывода. По умолчанию стандартным устройством ввода, вывода и сообщений об ошибках является пользовательский терминал. Поток стандартного устройства печати относится к принтеру, а поток стандартного вспомогательного устройства - к вспомогательному порту компьютера. По умолчанию при открытии все стандартные потоки, за исключением потоков stderr и stdaux, буферизуются.

1.2. Связь с файлами.
Часто нам бывает нужна программа получения информации от файла или размещения результатов в файле. Один способ организации связи программы с файлом заключается в использовании операций переключения < и >. Этот метод прост, но ограничен. Например, предположим, вы хотите написать диалоговую программу, которая спрашивает у вас названия книг (звучит фамильярно?), и вы намерены сохранить весь список в файле. Если вы используете переключение как, например, в

books > bklist

то ваши диалоговые приглашения также будут переключены на bklist. И тогда не только нежелательная чепуха запишется в bklist, но и пользователь будет избавлен от вопросов, на которые он, как предполагалось, должен отвечать.
К счастью, язык Си предоставляет и более мощные методы связи с файлами. Один подход заключается в использовании функции fopen(), которая открывает файл, затем применяются специальные функции ввода-вывода для чтения файла или записи в этот файл и далее используется функция fclose() для закрытия файла. Однако прежде чем исследовать эти функции, нам нужно хотя бы кратко познакомиться с сущностью файла.

Чтение и запись файлов: FILE*, fopen, fprintf, fscanf
Есть несколько способов работы с файлами c использованием языков C и C++.
Самый распространенный связан со структурой FILE (это не класс, потому что сущность языка C). Эта структура определена в заголовочном файле стандартной библиотеки <stdio.h>. Размер этой структуры и ее поля зависят от ОС и от версии компилятора. Поэтому никто не пользуется структурой FILE. Обычно пользуются указателем на эту структуру: FILE*. Например:

FILE *f = fopen("file1.txt", "r");

fopen -- функция из стандартной библиотеки. Первый параметр -- имя файла (в текущем каталоге). Второй параметр задает режим открытия файла; в данном случае "r" означает, что файл будет открыт только для чтения. Эта функция возвращает ненулевой указатель, если открытие прошло успешно; и возвращает NULL, если произошла ошибка. Ошибка может возникать в следующих ситуациях:
•	не существует файла;
•	у программы недостаточно прав доступа для работы с файлом;

Для дальнейшей корректной работы следует писать примерно такой код:

if (f == NULL) {
  // файл не удалось открыть
}
else {
  // Работа с файлом
}

Допустим, что нам удалось открыть файл, т.е. f != NULL. Тогда для того, чтобы считывать файл, можно использовать функцию:

fscanf(f, "%s", ptr);

Эта функция работает аналогично функции scanf. Поэтому использовать эту функцию небезопасно! Все проблемы, перечисленные для scanf-а, имеют место и при работе с fscanf-ом.
Если мы хотим записать в файл что-то, то мы должны сначала открыть его на запись:

FILE *f = fopen("file2.html", "w");

Тут "w" означает, что мы открываем файл на запись (от write). Если файл не существовал, то он создастся и откроется на запись, а если он существовал, то он сначала будет уничтожен, а затем создан заново, и потом файл будет открыт на запись.
Еще один способ открыть файл -- это открыть его на дозапись. Это можно сделать с помощью параметра "a" (от append). Если файл не существовал, то он создастся и откроется на запись, а если он существовал, то он откроется на запись, и запись будет производится в конец файла.
Затем можно использовать функцию fprintf(f, ...)

Замечание
Подробности и примеры использования fopen в вопросе «1.8. Соединение и отсоединение потока от файла»

1.3. Закрытие потоков.
По завершении работы с потоком он должен быть закрыт. Это осуществляется с помощью функции fclose(), которая имеет следующий прототип:

int fclose(FILE *stream);

Все буферы, связанные с потоком, освобождаются перед закрытием потока. В случае успеха fclose() возвращает 0; в случае ошибки - EOF. Если ваша программа не закрывает поток с помощью явного вызова fclose (), то он закрывается автоматически по ее завершению.
Две функции fclose() и fcloseall() используются для закрытия потока или всех потоков, соответственно. Функция fclose() закрывает отдельный файл, а функция fcloseall() закрывает все открытые потоки, за исключением stdin, stdout, stderr, stdprn и stdaux. Однако, если ваша программа не закрывает поток явно, то он закрывается автоматически по ее завершению. Поскольку количество потоков, открытых одновременно, ограничено, то желательно закрывать поток по окончанию работы с ним.
Наш пример показывает, как закрывать файл:

fclose(in);

Просто используйте функцию fclose(). Заметим, что аргументом ее является in, указатель на файл, а не test, имя файла.
Для программы, более серьезной, чем эта, следовало бы посмотреть, успешно ли закрыт файл. Функция fclose() возвращает значение 0, если файл закрыт успешно, и — 1 в противном случае.

Зачем нужно закрывать файлы
•	Зададимся вопросом: "Что надо сделать после того, как мы поработали с файлом?"
Формальный ответ: "Закрыть файл." Это можно сделать с помощью функции:

fclose(f);

Но зачем это делать?

Ввиду механического устройства жесткого диска, данные в файл попадают не сразу. Сначала данные записываются в так называемый буфер (область оперативной памяти), и когда он переполнится, то данные из буфера будут записаны в файл. Такая схема придумана для ускорения работы с файлами. На самом деле, буфер -- это поле структуры FILE: указатель на массив char-ов.
Если мы напишем fprintf(...), то запись произведется в буфер. И только тогда, когда буфер будет заполнен до конца, он будет сразу весь записан на жесткий диск. По этой причине, если мы не закроем файл функцией fclose(f), то последние данные из буфера не запишутся в файл. Отсутствие этой команды может привести к потере данных в файле, который был открыт для записи (дозаписи).

•	А зачем закрывать файлы, открытые только на чтение?
Если не закрывать файлы (которые открыты даже для чтения), то это может привести к ограничению доступа к файлу для других программ. Какие именно ограничения наложатся - это зависит от ОС. Но в ОС Windows если файл открыт на чтение и не закрывается, то из другой программы его нельзя удалить.

•	В любой ОС есть ограничение на количество одновременно открытых файлов. И это еще одна причина для закрытия файлов.

Замечание
Подробности и примеры использования fclose в вопросе «1.8. Соединение и отсоединение потока от файла»

1.4. Обработка ошибок в C и C++
Ошибки, увы, неизбежны, поэтому их обработка занимает очень важное место в программировании. И если алгоритмические ошибки можно выявить и исправить во время написания и тестирования программы, то ошибок во время выполнения избежать нельзя в принципе. Рассмотрим функции стандартной библиотеки (C Standard Library) и POSIX, используемые в обработке ошибок.

1.4.1. Переменная errno и коды ошибок

<errno.h> (С) и <cerrno> (C++)

errno – переменная, хранящая целочисленный код последней ошибки. В каждом потоке существует своя локальная версия errno, чем и обусловливается её безопасность в многопоточной среде. Обычно errno реализуется в виде макроса, разворачивающегося в вызов функции, возвращающей указатель на целочисленный буфер. При запуске программы значение errno равно нулю.
Все коды ошибок имеют положительные значения, и могут использоваться в директивах препроцессора #if. В целях удобства и переносимости заголовочный файл <errno.h> определяет макросы, соответствующие кодам ошибок.
Стандарт ISO C определяет следующие коды:

EDOM – (Error domain) ошибка области определения.
EILSEQ – (Error invalid sequence) ошибочная последовательность байтов.
ERANGE – (Error range) результат слишком велик.

Прочие коды ошибок (несколько десятков) и их описания определены в стандарте POSIX. Кроме того, в спецификациях стандартных функций обычно указываются используемые ими коды ошибок и их описания.
Если вызов функции завершился ошибкой, то она устанавливает переменную errno в ненулевое значение. Если же вызов прошёл успешно, функция обычно не проверяет и не меняет переменную errno. Поэтому перед вызовом функции её нужно установить в 0.
Макрос errno возвращает последний номер ошибки. Этот макрос заменяется на модифицируемое значение типа int, поэтому errno может изменять ход работы программы.
В C++, ошибка всегда объявляется как макрос.

#include <iostream> // для оператора cout
#include <cerrno> // для макроса errno
#include <math.h> // для функции sqrt
using namespace std;

int main()
{
    setlocale(LC_ALL, "Rus");
    double x = -1, answer;
    answer = sqrt(x);
    cout << "EDOM = " << EDOM << endl
              << "nerrno = " << errno << endl;
    if (errno == EDOM) // если значения макросов errno и EDOM равны
        cout << "Ошибка области допустимых значений\n";
    system("pause");
    return 0;
}

 

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <iostream> // для оператора cout

void main(void)
{
   setlocale(LC_ALL, "Rus");
   FILE *fp;
   errno = 0;
   fp = fopen("Nofile", "r");
   if ( errno != 0 )
   {
     perror("Error occurred while opening file.\n");
     system("pause");
     exit(1);
   }
}

 

Здесь представлена наиболее полная информация для работы с файлами
https://msdn.microsoft.com/en-us/library/z5hh6ee9.aspx

// crt_fopen_s.c
// This program opens two files. It uses
// fclose to close the first file and
// _fcloseall to close all remaining files.

#include <stdio.h>
#include <iostream>

FILE *stream, *stream2;

int main( void )
{
   errno_t err;

   // Open for read (will fail if file "crt_fopen_s.c" does not exist)
   err  = fopen_s( &stream, "crt_fopen_s.c", "r" );
   if( err == 0 )
   {
      printf( "The file 'crt_fopen_s.c' was opened\n" );
   }
   else
   {
      printf( "The file 'crt_fopen_s.c' was not opened\n" );
   }

   // Open for write
   err = fopen_s( &stream2, "data2", "w+" );
   if( err == 0 )
   {
      printf( "The file 'data2' was opened\n" );
   }
   else
   {
      printf( "The file 'data2' was not opened\n" );
   }

   // Close stream if it is not NULL
   if( stream )
   {
      err = fclose( stream );
      if ( err == 0 )
      {
         printf( "The file 'crt_fopen_s.c' was closed\n" );
      }
      else
      {
         printf( "The file 'crt_fopen_s.c' was not closed\n" );
      }
   }

   // All other files are closed:
   int numclosed = _fcloseall( );
   printf( "Number of files closed by _fcloseall: %u\n", numclosed );
   system("pause");
}

 

1.5. Переключение и работа с файлами.
Понятие ввода-вывода включает в себя функции, данные и устройства. Рассмотрим, например, нашу программу ввод-вывод4. В ней используется функция getchar(), осуществляющая ввод, причем устройство ввода — клавиатура (в соответствии с нашим предположением), а входные данные — отдельные символы. Нам бы хотелось сохранить функции ввода и тип данных, но изменить источник их поступления в программу. Зададимся вопросом: откуда программа узнает, где искать входные данные?
По умолчанию Си-программа рассматривает «стандартный ввод» как источник поступления данных. «Стандартным вводом» называется устройство, принятое в качестве обычного средства ввода данных в машину. Это может быть устройство чтения данных с магнитной ленты или перфокарт, телетайп или (как мы продолжаем считать) терминал. Современная машина — это послушный инструмент, и мы можем воздействовать на нее так, чтобы она вводила данные из любого источника. В частности, мы можем сообщить программе, что источник входных данных — файл, а не клавиатура.
Существуют два способа написания программ, работающих с файлами. Первый способ заключается в явном использовании специальных функций, которые открывают и закрывают файлы, организуют чтение и запись данных и т. п.; мы не хотим пока касаться этого вопроса. Второй способ состоит в том, чтобы использовать программу, спроектированную первоначально в предположении, что данные в нее вводятся с клавиатуры и выводятся на экран, но переключить ввод и вывод на другие информационные каналы, например, из файла в файл. Этот способ в некоторых отношениях обладает меньшими возможностями, чем первый, но зато гораздо проще в использовании. Мы изучим понятие переключения в данном разделе.
Операция переключения — это средство ОС UNIX, а не самого языка Си. Но она оказалась настолько полезной, что при переносе компилятора с языка Си на другие вычислительные системы часто вместе с ним переносится в какой-то форме и эта операция. Более того, многие из вновь созданных операционных систем, таких, как MS-DOS 2, включают в себя данное средство. Поэтому, даже если вы не работаете в среде ОС UNIX существует большая вероятность того, что вы в той или иной форме сможете воспользоваться операцией переключения. Мы обсудим сначала возможности этой операции в ОС UNIX, а затем и в других системах.

1.5.1. Переключение вывода.
Предположим, вы осуществили компиляцию программы ввод-вывод4 и поместили выполняемый объектный код в файл с именем getput4. Затем, чтобы запустить данную программу, вы вводите с терминала только имя файла

getput4

и программа выполняется так, как было описано выше, т. е. получает в качестве входных данных символы, вводимые с клавиатуры. Теперь предположим, что вы хотите посмотреть, как наша программа работает с «текстовым файлом» с именем words. (Текстовой файл — это файл, содержащий некоторый текст, т. е. данные в виде символов. Это может быть, например, очерк или программа на языке Си. Файл, содержащий команды на машинном языке, например файл, полученный в результате компиляции данной программы, не является текстовым. Поскольку наша программа занимается обработкой символов, она должна использоваться вместе с текстовыми файлами.) Все, что для этого требуется — ввести вместо команды, указанной выше, следующую:

getput4 < words

Символ < служит обозначением операции переключения, используемой в ОС UNIX. Выполнение указанной операции приводит к тому, что содержимое файла words будет направлено в файл с именем getput4. Сама программа ввод-вывод4 не знает (и не должна знать), что входные данные поступают из некоторого файла, а не с терминала; на ее вход просто поступает поток символов, она читает их и последовательно, по одному выводит на печать до тех пор, пока не встретит признак EOF. В операционной системе UNIX файлы и устройства ввода-вывода в логическом смысле представляют собой одно и то же, поэтому теперь файл для данной программы является устройством ввода-вывода. Если вы попробуете ввести команду

getput4 < words

то в результате на экране могут появиться, например, следующие строки:
В одном мгновеньи видеть вечность,
Огромный мир - в зерне песка,
В единой горсти - бесконечность,
И небо - в чашечке цветка

Но мы, конечно, не можем гарантировать, что в файле, который выберете вы, тоже окажется четверостишие Вильяма Блейка.

1.5.2. Переключение ввода.
Теперь предположим (если вы еще не устали и в состоянии что-нибудь предположить), вам хочется, чтобы слова, вводимые с клавиатуры, попадали в файл с именем mywords. Для этого вы должны ввести команду

getput4 > mywords

и начать ввод символов. Символ > служит обозначением еще одной операции переключения, используемой в ОС UNIX. Ее выполнение приводит к тому, что создается новый файл с именем mywords, а затем результат работы программы ввод-вывод4, представляющий собой копию вводимых символов, направляется в данный файл. Если файл с именем mywords уже существует, он обычно уничтожается, и вместо него создается новый. (В некоторых реализациях ОС UNIX, однако, вам предоставляется возможность защитить существующие файлы.) На экране в данном случае появятся лишь вводимые вами символы, их же копии будут направлены в указанный файл. Чтобы закончить работу программы, введите признак EOF (в системе UNIX это обычно символ [CTRL/D]). Попробуйте воспользоваться описанной здесь операцией. Если вам ничего другого не придет в голову, просто воспроизведите на своей машине пример, приведенный ниже. Знак приглашения, выводимый на экран интерпретатором команд SHELL, обозначается здесь символом %. Не забывайте оканчивать каждую введенную строку символом [возврат], чтобы содержимое буфера пересылалось в программу.

% getput4 > mywords

У вас не должно быть трудностей с запоминанием того, какая операция переключения для чего предназначена. Необходимо помнить только, что знак каждой операции указывает на направление информационного потока. Вы можете по ассоциации представлять себе этот знак в виде воронки. [CTRL/D]

%

После того как введен символ [CTRL/D], программа заканчивает свою работу и возвращает управление операционной системе UNIX, на что указывает повторное появление знака приглашения. Как убедиться в том, что наша программа вообще работала? В ОС UNIX существует команда Is, которая выводит на экран имена файлов; обращение к ней должно продемонстрировать вам, что файл с именем mywords теперь существует. Чтобы проверить его содержимое, вы можете воспользоваться командой cat или запустить заново программу ввод-вывод4, направляя в нее на этот раз содержимое входного файла.

% getput4 < mywords

У вас не должно быть трудностей с запоминанием того, какая операция переключения для чего предназначена. Необходимо помнить только, что знак каждой операции указывает на направление информационного потока. Вы можете по ассоциации представлять себе этот знак в виде воронки.

1.5.3. Комбинированное переключение.
Предположим теперь, что вы хотите создать копию файла mywords и назвать ее savewords. Введите для этого команду

getput4 < mywords >savewords

и требуемое задание будет выполнено. Команда

getput4 >savewords < mywords

приведет к такому же результату, поскольку порядок указания операций переключения не имеет значения.
Нельзя использовать в одной команде один и тот же файл и для ввода и для вывода одновременно.

getput4 <mywords >mywords  /*НЕПРАВИЛЬНО*/

Причина этого заключается в том, что указание операции >mywords приводит к стиранию исходного файла перед его использованием в качестве входного.
Теперь, мы думаем, настало время суммировать правила, касающиеся использования двух операций переключения < и >.
1. Операция переключения связывает выполняемую программу (в том числе и стандартные команды ОС UNIX) с некоторым файлом. Она не может использоваться для связи одного файла с другим или одной программы с другой.
2. Имя выполняемой программы должно стоять слева от знака операции, а имя файла — справа от него.
3. При использовании этих операций ввод не может осуществляться более чем из одного файла, а вывод — более чем в один файл.
4. Обычно между именем и операцией пробелы не обязательны кроме тех редких случаев, когда используются некоторые символы специального назначения в интерпретаторе команд UNIX. Мы могли бы писать, например, так: getput4< words, или, что более предпочтительно, getput4 < words.

Мы уже привели выше несколько примеров правильного использования операций переключения. Ниже дается несколько ошибочных примеров (addup и count — выполняемые программы, a fish и stars — текстовые файлы).
fish > stars                //Нарушение правила 1
addup < count           //Нарушение правила 1
stars > count             //Нарушение правила 2
addup < fish < stars  //Нарушение правила 3
count > stars > fish       //Нарушение правила 3

В ОС UNIX применяются также операция >>, позволяющая добавлять данные в конец существующего файла, и операция «канал» (]), связывающая файл вывода одной программы с вводом другой. Для получения более детальной информации обо всех этих операциях вам необходимо обратиться к руководству по ОС UNIX (по аналогии с этим нам приходит в голову название «ОС UNIX: руководство для начинающих»).
Рассмотрим еще один пример: напишем очень простую программу, шифрующую сообщения. C этой целью мы немного изменим программу ввод-вывод4 и получим:

// простой шифр
// заменяет каждый символ текста
// следующим по порядку из кода ASCII
// X24.C
#include <stdio.h>
void main(void)
{
	char ch;
	printf("Для окончания работы введите <CTRL/Z>\n");
	while ((ch=getchar()) != EOF)
		putchar(ch+1);
}

 

Функция putchar() переводит целое «ch + 1» в соответствующий символ.
Выполните теперь компиляцию программы и поместите выполняемый объектный код в файл с именем simplecode. Затем занесите приведенные ниже строки (Перевод: знание орфографии — залог четкости письма) в файл с именем original. (Для этого можно воспользоваться системным текстовым редактором или, как было показано ранее, программой ввод-вывод4.)

Good spelling is an aid
to clear writing.

Теперь введите команду
simplecode < original

Результат должен выглядеть приблизительно так:
!!!!!Hppe!tqfmmjoh!jtbo!bje^Kup!dmfbs!xsjujohl^k

Буква G заменится на Н, о на р и т. д. Вас может удивить следующее: во-первых, что пробелы превратились в восклицательные знаки. Это служит напоминанием, что пробел — такой же символ, как и все остальные. Во-вторых, две строки слились в одну. Почему? Потому что в тексте, содержащемся в файле original, в конце первой строки находится символ «новая строка», служащий указанием компьютеру начать вывод следующего слова с новой строки. Но этот символ также был изменен. В нашей системе он был заменен символом ^К, являющимся аналогом специального символа [CTRL/K], и поэтому последующий вывод на печать был продолжен на прежней строке. Если мы хотим иметь программу шифровки сообщений, сохраняющую первоначальную структуру текста (по строкам), нам необходимо средство, позволяющее изменять все символы, кроме символа «новая строка». В дальнейшем мы узнаем, как это сделать.

1.5.4. Конвейерная пересылка
Можно также осуществить соединение выходного потока одной программы с входным потоком другой. Это называется конвейерной пересылкой. Если имеются две выполнимые программы example1 и example2, то конвейерная пересылка между ними организуется с помощью символа вертикальной черты ‘|’. Следующая строка организует конвейерную пересылку между example1 и example2:

example1 | example2

Организацию конвейерной пересылки обеспечит операционная система.

1.6. Текстовые и бинарные (двоичные) файлы
Язык С++ унаследовал от языка C библиотеку стандартных функций ввода-вывода. Функции ввода-вывода объявлены в заголовочном файле <stdio.h>. Операции ввода-вывода осуществляются с файлами. Файл может быть текстовым или бинарным (двоичным). Различие между ними заключается в том, что в текстовом файле последовательности символов разбиты на строки. Признаком конца строки является пара символов CR (возврат каретки) и LF (перевод строки) или, что то же самое - '\г' + '\n'. При вводе информации из текстового файла эта пара символов заменяется символом CR, при выводе, наоборот, - символ CR заменяется парой символов CR и LF. Бинарный (или двоичный) файл - это просто последовательность символов. Обычно двоичные файлы используются в том случае, если они являются источником информации, не предполагающей ее непосредственного представления человеку. При вводе и выводе информации в бинарные файлы никакого преобразования символов не производится.

Текстовые и бинарные файлы; что меняет опция t/b
Рассмотрим строку:

fopen(f, "file1.txt", "w");

Почему второй параметр "w" является строкой, а не символом?
На самом деле бывает много способов прочитать/записать файл. Например:

fopen("file1.txt", "wt") -- откроет файл как текстовый файл;
fopen("file1.txt", "wb") -- откроет файл как бинарный файл.

Но в чем отличие? Разница заключается лишь в том, что символы переноса строк запишутся по разному. Рассмотрим пример в UNIX и Windows.

Исходная строка кода выглядит так:

fprintf("Hello\n");

 

1. Откроем в Windows файл на запись с параметром "wb" (как бинарный файл). Это означает, что в него запишется в точности то, что мы передали в функции fprintf. Тогда в файл запишутся ровно 6 байт: 

Hello\10

2. А теперь мы откроем в Windows файл на запись с параметром "wt" (как текстовый файл). Тогда в файл запишутся ровно 7 байт:

Hello\10\13

Тут \10\13 означает символы перевода строки в ОС Windows.

3. Откроем в UNIX файл на запись с параметром "wt" или "wb". Тогда в файл запишутся ровно 6 байт:

Hello\10

Тут \10 означает символы перевода строки в ОС UNIX.

В ОС UNIX разницы все-таки нет.

Различие между "wt" и "wb" объясняется тем, что в разных операционных системах символы перевода строки разные. При чтении файла, т.е. при открытии файла с параметрами "rt" или "rb", проблема следующая. Если мы поставим параметр "rb", то при чтении файла символ \10 будет восприниматься как перевод строки. А если поставим параметр "rt", то при чтении файла пара символов \10\13 будет восприниматься как символ перевода строки.

http://rsdn.org/forum/cpp/2277645.hot
Двоичные файлы
Двоичные и текстовые файлы — это, как говорят в Одессе, «две большие разницы». Обмен данными между программой и двоичным потоком выполняется без всякого преобразования, поэтому работает быстрее. Двоичный ввод выполняется функцией fread(), имеющей следующий прототип:

size_t fread(void *buffer, size_t size, size_t n, FILE *stream);

Тип size_t обычно определен как unsigned int. Первый параметр часто определяет массив (или указатель на динамический массив), в который будет прочитана информация; третий параметр задает размер одного элемента данных в байтах, а второй — количество читаемых элементов. Четвертый параметр определяет двоичный файл, из которого информация вводится. Общее количество считанных байтов равно size*n. Однако возвращает функция количество корректно прочитанных элементов, а не байтов.
Вывод в двоичный файл выполняется функцией fwrite(), которая имеет совершенно аналогичный прототип:

size_t fwrite(const void *buffer, size_t size, size_t n, FILE *stream);

Функция записывает n элементов размера size в двоичный файл stream из буфера, указатель на который задается в качестве первого аргумента. Общее количество выводимых байтов равно size*n. Однако возвращает функция количество корректно записанных элементов, а не байтов.
В качестве элементов могут использоваться любые переменные любых типов, в том числе и динамические. Даже массив может быть одним-единственным элементом! Рассмотрим несколько простых примеров, аналогичных примерам для текстовых файлов. Создадим на диске C: каталог BinFiles и все двоичные файлы будем размещать в нем. Переделаем пример создания файла

//Создание и чтение двоичных файлов
#include <cstdio>
#include <cstdlib>
#include <ctime>
int main()
{    int m[10]={0};
    srand((unsigned)time(NULL)); // инициализация датчика случайных чисел
    FILE *stream;
/* открываем двоичный файл для записи */
    //if((stream = fopen("c:/binfiles/number1.bin", "wb" )) == NULL)
    if((stream = fopen("number1.bin", "wb" )) == NULL)
        return 1; // ошибка при открытии
/* заполняем массив m числами */
    for(int i = 0; i < 10; i++)
      m[i] = rand()%10; // случайные числа от 0 до 9
// заполняем файл number1.bin элементами-числами
    for(int i = 0; i < 10; i++)
      fwrite(&m[i], 1, sizeof(int), stream);
    fclose(stream); // закрываем файл
/* открываем другой файл для записи */
    //if((stream = fopen("c:/binfiles/number2.bin", "wb" )) == NULL)
    if((stream = fopen("number2.bin", "wb" )) == NULL)
        return 1; // ошибка при открытии
// заполняем файл number2.bin элементом-массивом
    fwrite(m, 1, sizeof(m), stream); // массив - один элемент
    fclose(stream); // закрываем файл
// вывод второго двоичного файла на экран
// открываем файл для чтения
    //if((stream = fopen("c:/binfiles/number2.bin", "rb" )) == NULL)
    if((stream = fopen("number2.bin", "rb" )) == NULL)
        return 1; // ошибка при открытии
    int a = 0; // сюда вводим
// читаем второй файл поэлементно
// правильный цикл
    printf("number2.bin\n");
    fread(&a, 1, sizeof(int), stream); // предварительное чтение
    while(!feof(stream)) // пока не конец файла
    { printf("%d\n", a);
      fread(&a, 1, sizeof(int), stream);
    }
    fclose(stream);
// открываем первый файл в режиме чтения
    printf("number1.bin\n");
    //if((stream = fopen("c:/binfiles/number1.bin", "rb" )) == NULL)
    if((stream = fopen("number1.bin", "rb" )) == NULL)
        return 1;
    int t[10] = {0}; // массив для чтения
// читаем первый файл как массив
    fread(t, 1, sizeof(t), stream);
    for(int i = 0; i < 10; i++) // выводим поэлементно
        printf("%d\n",t[i]);
    fclose(stream);
char ch = getchar();
return 0;
}

 

1.7. Потоковый ввод-вывод.
Многие широко используемые языки высокого уровня имеют механизмы ввода/вывода, позволяющие создавать нетривиальные алгоритмы для получения и отображения сложных структур данных. Это не относится к языку С, в котором имеется весьма развитая библиотека функций ввода/вывода, хотя, исторически, ввод/вывод никогда не являлся частью самого языка С. Если вы пользуетесь только простыми операторами ввода/вывода, подобными операторам Паскаля readln и writeln, то такая ситуация может вас удивить. Здесь описываются более 20 различных способов организации ввода/вывода в С.
Библиотека стандартных функций ввода/вывода С позволяет считывать данные и записывать их в файлы и устройства. Однако в самом языке С отсутствуют какие-либо предопределенные файловые структуры. В С все данные обрабатываются как последовательность байт. Имеется три основных типа функций ввода/вывода:
•	потоковые,
•	работающие с консолью и портами,
•	низкоуровневые.

В потоковых функциях ввода/вывода файлы или объекты данных рассматриваются как поток отдельных символов. Выбирая соответствующую потоковую функцию, вы можете обрабатывать данные любого необходимого размера или формата, начиная от отдельных символов и заканчивая большими, сложными структурами данных.
На техническом уровне, когда программа открывает файл для ввода/вывода при помощи потоковых функций, открытый файл связывается с некоторой структурой типа FILE (предопределенной в stdio.h), содержащей базовую информацию об этом файле. После открытия потока возвращается указатель на файловую структуру. Указатель файла, иногда называемый указателем потока или потоком, используется для ссылки к файлу при всех последующих операциях ввода/вывода.
Все потоковые функции ввода/вывода обеспечивают буферизированный, форматированный или неформатированный ввод и вывод. Буферизированный поток обеспечивает место для промежуточного хранения всей информации, вводимой из потока или записываемой в поток.
Поскольку дисковый ввод/вывод занимает довольно много времени, буферизация потока разгружает приложение. Вместо того чтобы вводить данные из потока по одному символу или по одному элементу данных, потоковые функции ввода/вывода получают данные поблочно. Когда приложению необходимо обработать введенную информацию, оно просто обращается к буферу, что гораздо быстрее. Когда буфер становится пустым, выполняется считывание с диска другого блока.
Во многих языках высокого уровня существует одна проблема с буферизированным вводом/выводом, которую нужно принимать во внимание. Например: если ваша программа выполнила несколько операторов вывода, которые не заполнили буфер вывода, и запись на диск не произошла, то по завершении программы эта информация будет потеряна. Для решения этой проблемы обычно выполняется вызов соответствующей функции для очистки буфера. В отличие от других языков высокого уровня, в языке С данная проблема с буферизированным вводом/выводом решается путем автоматической очистки содержимого буфера по завершении программы. Конечно, хорошо написанное приложение не должно рассчитывать на эти автоматические действия; все действия программы должны описываться в явном виде. Дополнительное замечание: если вы используете потоковый ввод/вывод и приложение заканчивается с аварийным остановом, то буферы вывода могут оказаться неочищенными, что приведет к потере данных.
Аналогичным образом выглядят процедуры, работающие с консолью и портами; их можно рассматривать как расширенные потоковые функции. Они позволяют читать и писать на терминал (консоль) или в порт ввода/вывода (например, в порт принтера). Функции портов ввода/вывода выполняют простое побайтное считывание и запись. Функции ввода/вывода на консоль обеспечивают несколько дополнительных возможностей. Например, можно определить: введен ли с консоли символ или имеют ли вводимые символы эхо-отображение на экране. Последним типом ввода и вывода является низкоуровневый. Функции низкоуровнего ввода/вывода не выполняют никакой буферизации и форматирования; они непосредственно обращаются к средствам ввода и вывода операционной системы. Эти функции позволяют обращаться к файлам и периферийным устройствам на более низком уровне, чем это делают потоковые функции. При открытии файла на этом уровне возвращается описатель файла (file handle), представляющий собой целое число, использующееся затем для обращения к этому файлу при последующих операциях. В общем случае не рекомендуется смешивать функции потокового ввода/вывода с низкоуровневыми. Поскольку потоковые функции являются буферизированными, а низкоуровневые — нет, при обращении к файлу или устройству при помощи двух разных способов возможны рассогласование или даже потеря данных в буферах. Поэтому для каждого конкретного файла необходимо использовать либо потоковые, либо низкоуровневые функции. В табл. 17.1 перечислены наиболее часто используемые в С функции потокового ввода/вывода.

Таблица 17.1. Функции С потокового ввода и вывода

Функция	Описание
clearer()	Сбрасывает индикатор ошибок потока и устанавливает в ноль индикатор конца файла (end-of-file)
fclose()	Закрывает поток
fcloseall()	Закрывает все потоки
fdopen()	Открывает поток, используя его описатель (handle), полученный при помощи creat, dup, dup2 или open
feof()	Проверяет поток на признак конца файла
ferror()	Проверяет поток на признак конца файла
fflush()	Проверяет поток на признак конца файла
fgetc()	Считывает символ из потока
fgetchar()	Считывает символ из потока stdin
fgetpos()	Возвращает текущий указатель файла
fgets()	Возвращает строку из потока
filelength()	Возвращает размер потока в байтах
fileno()	Возвращает описатель файла, связанного с потоком
flushall()	Очищает буферы всех потоков
fopen()	Открывает поток
fprintf()	Выполняет форматированную запись в поток
fputc()	Записывает символ в поток
fputchar()	Записывает символ в stdout
fputs()	Записывает строку в поток
fread()	Считывает неформатированные данные из потока
freopen()	Переназначает указатель потока
fscanf()	Считывает форматированные данные из потока
fseek()	Позиционирует указатель файла в указанную позицию
fsetpos()	Позиционирует указатель файла потока
fstat()	Возвращает информацию об открытом файле
ftell()	Возвращает положение текущего указателя файла
fwrite()	Записывает неформатированные данные в поток
getc()	Этот макрос считывает символ из потока
getchar()	Этот макрос считывает символ из stdin
gets()	Возвращает строку из stdin
getw()	Считывает целое число из потока
perror()	Выдает системную ошибку на stderr
printf()	Записывает форматированные данные в stdout
putc()	Этот макрос записывает символ в поток
putchar()	Этот макрос записывает символ в stdout 
puts()	Записывает строку в stdout
putw()	Записывает целое число в поток
remove()	Удаляет файл
rename()	Переименует файл
rewind()	Позиционирует указатель файла на начало потока
scanf()	Сканирует и вводит форматированные данные из stdln
setbuf()	Отменяет автоматическую буферизацию, позволяя приложению определить собственный буфер для потока
setvbuf()	То же самое, что и setbuf(); позволяет также определить размер буфера
sprintf()	Записывает форматированные данные в строку
sscanf()	Сканирует и вводит форматированные данные из строки
tmpnam()	Создает в заданном подкаталоге файл с уникальным именем
ungetch()	Засылает символ в буфер клавиатуры
vfprintf()	Записывает форматированные данные в поток, используя указатель на форматирующую строку
vfscanf()	Сканирует и форматирует ввод из потока, используя указатель на форматирующую строку
vprintf()	Записывает форматированные данные в stdout, используя указатель на форматирующую строку
vscanf()	Сканирует и форматирует ввод из stdin, используя указатель на форматирующую строку
vsprintf()	Записывает форматированные данные в строку, используя указатель на форматирующую строку
vsscanf()	Сканирует и форматирует ввод строки, используя указатель на форматирующую строку

1.8. Соединение и отсоединение потока от файла.
1.8.1. Функция fopen
Для соединения потока с файлом используется функция:

FILE*  fopen(const  char*  filename, const  char*  mode);

которая открывает файл, имя которого задано параметром filename, в режиме, заданнном параметром mode. В случае успешного завершения функция fopen возвращает указатель на поток, а в случае неудачи – NULL.
Параметр mode может принимать следующие значения:
“r” – чтение в текстовом режиме,
“w” – запись в текстовом режиме,
“a” – присоединение в текстовом режиме,
“rb” – чтение в бинарном режиме,
“wb” – запись в бинарном режиме,
“ab” – присоединение в бинарном режиме,
“r+” или “w+” или “a+” – чтение и запись в текстовом режиме,
“r+b” или “w+b” или “a+b” – чтение и запись в бинарном режиме,
“rb+” или “wb+” или “ab+” – чтение и запись в бинарном режиме.

При открытии файла в режимах “r”, “rb”, “r+”, “r+b” его индикатор позиции устанавливается на начало файла. В случае, если открывается несуществующий файл, то функция fopen заканчивается неудачей.
При открытии файла в режимах “w”, “wb”, “w+”, “w+b” создается новый файл. Если файл с заданным именем существует, то его содержимое стирается, а индикатор позиции устанавливается на начало файла.
При открытии файла в режимах “a”, “ab”, “a+”, “a+b” создается новый файл. Если файл с заданным именем существует, то он открывается, и индикатор позиции устанавливается на конец файла.
Следует учитывать, что если текстовый файл открывается в режиме чтения и записи, то базовая операционная система может открыть его в бинарном режиме. Максимальное количество файлов, которые можно открыть одновременно задается переменной FOPEN_MAX (равно 20 в Visual C++). Максимальная длина имени файла задается переменной FILENAME_MAX (равно 260 в ОС Windows).

1.8.2. Функция fclose
Для отсоединения потока от файла используется функция:

int  fclose(FILE*  stream);

которая закрывает файл, при этом освобождая все буферы потока. При успешном завершении функция возвращает 0, а в случае неудачи – EOF.

1.8.3. Функция freopen
Для перенаправления потока используется функция:

FILE*  freopen(const  char*  filename, const  char*  mode, FILE*  stream);

которая закрывает файл, соединенный с потоком stream, и соединяет с этим потоком файл filename в режиме mode. В случае успеха функция возвращает указатель на поток, а в случае неудачи – NULL. Параметр mode принимает те же значения, что и в функции fopen.
Поясним подробнее разницу между текстовым и бинарным режимами работы потока. Как в текстовом так и в бинарном режиме можно использовать все функции для доступа к файлу. При работе в бинарном режиме поток записывает на диск и считывает с диска точные копии данных, переданные функциями записи данных на диск и требуемые функциями чтения данных с диска соответственно. Работа потока в текстовом режиме отличается тремя моментами от работы потока в бинарном режиме. Во-первых, в этом случае символ CTRL+Z интерпретируется как конец файла. Во-вторых, при записи в текстовый поток из комбинации символов “\r” (carriage return, возврат каретки) и “\n” (new line, новая строка) в файл записывается только символ “\n”, а при чтении из текстового потока символ “\n” преобразуется в комбинацию символов “\r”+”\n”. В-третьих, так как при записи в текстовый поток может происходить преобразование количества и представления символов, то для получения требуемой позиции в файле нужно использовать только функции fgetpos и ftell.

1.9. Работа с индикаторами ошибки, позиции и конца файла (ferror, clearerr, feof, rewind, fseek, fsetpos, ftell, fgetpos).
1. Работа с индикатором ошибки. С каждым потоком связан индикатор ошибки, который находится в установленном положении, если в потоке, связанном с файлом произошла ошибка. В противном случае индикатор ошибки находится в сброшенном состоянии. Для работы с индикатором ошибки используются функции ferror и clearerr.
Функция

int  ferror(FILE*  stream);

возвращает ненулевое значение, если индикатор ошибки установлен, в противном случае – возвращает 0.
Функция

void  clearerr(FILE*  strem);

сбрасывает индикаторы ошибки и конца файла для потока stream.

2. Работа с индикатором конца файла. Структура FILE содержит индикатор конца файла, который устанавливается в ненулевое значение функцией чтения из файла при достижении этой функцией конца файла. Состояние конца файла читается функцией

int  feof(FILE*  stream);

которая возвращает ненулевое значение, если индикатор конца файла установлен, в противном случае функция возвращает 0.

3. Работа с индикатором позиции. Для каждого файла, после его открытия, определяется индикатор позиции, который указывает на смещение от начала файла в байтах. Тип индикатора позиции определяется как

typedef  long  fpos_t;

Для работы с индикатором позиции предназначены следующие функции.
Функция

void  rewind(FILE*  stream);

устанавливает индикатор позиции на начало файла, связанного с потоком stream. При этом сбрасывется индикатор ошибки и конца файла.
Функция

int  fseek(FILE*  stream,  long  offset, int  mode);

сдвигает индикатор позиции файла на offset байт. В случае успешного завершения функция возвращает 0, в противном случае – ненулевое значение. Параметр mode указывает на режим сдвига и может принимать следующие значения:
SEEK_SET – смещение от начала файла,
SEEK_CUR – смещение от текущей позиции,
SEEK_END – смещение от конца файла.

При работе с текстовым потоком должны использоваться только следующие комбинации значений параметров:
mode = SEEK_SET	 offset = 0 или
offset = значению, возвращаемому функцией ftell
mode = SEEK_CUR	offset = 0
mode = SEEK_END	offset = 0

Функция

int  fsetpos(FILE*  stream, const  fops_t  *pos);

устанавливает индикатор позиции файла stream в позицию, на которую указывает параметр pos. Индикатор конца файла сбрасывается. В случае успеха функция возвращает 0, а в случае неудачи возвращает ненулевое значение и устанавливает переменную errno.

Функция

long  ftell(FILE*  stream);

в случае успешного завершения возвращает текущую позицию файла stream, а в случае неудачи – возвращает значение 1L и устанавливает значение переменной errno. Для бинарного потока позиция равна смещению в байтах от начала файла, а в случае текстового потока – значению, которое может использоваться функцией fseek.

Функция

int  fgetpos(FILE*  stream, fops_t*  pos);

записывает текущую позицию файла stream по адресу pos. В случае успеха функция возвращает 0, а в случае неудачи – ненулевое значение и устанавливает значение переменной errno.

1.10. Блочный ввод-вывод (fwrite, fread).
Блоком называется область оперативной памяти, содержимое которой записывается в файл. Ввод-вывод блоками используется бинарными потоками.
Для записи блока в файл используется функция

size_t  fwrite(const  void*  ptr, size_t  size, size_t  nitems, FILE*  stream);

которая записывает содержимое блока памяти, на который указывает ptr, в файл stream. Длина записываемого блока определяется как произведение size*nitems. Функция возвращает число записанных единиц памяти. В случае удачи это число должно быть равно nitems.
Для чтения блока из файла используется функция

size_t  fread(const  void*  ptr, size_t  size, size_t  nitems, FILE*  stream);

параметры которой имеют тот же смысл, что и в функции fwrite.
По стандарту состояние индикатора позиции после работы функций fwrite и fread не определено.
В следующей программе создается бинарный файл.

// создание бинарного файла
#include <stdio.h>

struct emp
{
	int code;
	char name[20];
	double salary;
};

int main()
{
	FILE* out; // выходной поток
	struct emp s; // для записей файла
// открываем выходной поток в бинарном режиме
	//if(!(out = fopen("C:\\employee.bin", "wb")))
	if(!(out = fopen("employee.bin", "wb")))
	{
		printf("Open file failed.\n");
		return 0;
	}
	printf("Input code, name and salary.\n");
	printf("Press Ctrl+z to exit.\n");
	printf(">");
// вводим первую запись с консоли
	scanf("%d%s%lf", &s.code, &s.name, &s.salary);
	while (!feof(stdin))
	{
		// пишем запись в файл
		fwrite(&s, sizeof(struct emp), 1, out);
		printf(">");
		// вводим следующие записи с консоли
		scanf("%d%s%lf", &s.code, &s.name, &s.salary);
	}
	// закрываем выходной поток
	fclose(out);
	return 1;
}

 

В следующей программе выполняется чтение записей из бинарного файла.

// чтение бинарного файла
#include <stdio.h>

struct emp
{
	int code;
	char name[20];
	double salary;
};

int main()
{
	FILE* in; // выходной поток
	struct emp s; // для записей файла
	unsigned i; // номер записи
// открываем входной поток в бинарном режиме
	//if(!(in = fopen("C:\\employee.bin", "rb")))
	if(!(in = fopen("employee.bin", "rb")))
	{
		printf("Open file failed.\n");
		return 0;
	}
	printf("Press Ctrl+z to exit.\n");
	// читаем индекс
	printf("Input an index: ");
	scanf("%u", &i);
	while (!feof(stdin))
	{
		// устанавливает указатель на нужную запись
		fseek(in, i*sizeof(struct emp), SEEK_SET);
		// читаем запись из файла
		if(!fread(&s, sizeof(struct emp), 1, in))
		{
			printf("The wrong index.\n");
			continue;
		}
// выводим запись на консоль
		printf("\tcode = %d name = %s sal = %f\n",
			s.code, s.name, s.salary);
		// читаем индекс
		printf("Input an index: ");
		scanf("%u", &i);
	}
	// закрываем входной поток
	fclose(in);
	return 1;
}

 

1.11. Символьный ввод-вывод.
Символьный ввод-вывод используется с текстовыми потоками.

1.11.1. Функции fputc, putc, fgetc, getc, ungetc
Ввод-вывод символов. Для записи и чтения символов из текстового файла используются функции fputc, putc, fgetc, getc.
Функция

int  fputc(int  c, FILE*  stream);

записывает символ с в поток stream и продвигает индикатор позиции на следующий символ. В случае успеха функция возвращает символ с, а в случае неудачи EOF и устанавливает индикатор ошибки.
Функция

int  putc(int  c, FILE*  stream);

работает так же как и функция fputc, но может быть реализована как макрокоманда.
Функция

int  fgetc(FILE*  stream);

читает символ из потока stream и продвигает индикатор позиции на следующий символ. В случае успешного завершения функция возвращает прочитанный символ. В случае достижения конца файла функция возвращает EOF и устанавливает индикатор конца файла. В случае ошибки функция возвращает EOF и устанавливает индикатор ошибки.
Функция

int  getc(FILE*  stream);

работает так же кака и функция fgetc, но может быть реализована как макрокоманда.
Функция

int  ungetc(int  c, FILE*  stream);

записывает символ с в поток stream. Функции fseek, fsetpos и rewind игнорируют такие символы. Доступ к записанным символам выполняется по правилу FIFO. В случае успеха функция возвращает записанный символ, а в случае неудачи – EOF.

1.11.2. Функции fputs и fgets
Ввод-вывод строк. Для записи и чтения строк из символьного потока используются символы fpus и fgets.
Функция

int  fputs(const  char*  str, FILE*  stream);

записывает строку str в файл stream, не включая завершающий нулевой байт. В случае успешного завершения функция возвращает ненулевое число, а в случае неудачи – EOF.
Функция

int  fgets(char*  str, int  n, FILE*  stream);

читает строку из потока stream в строку str. Останавливается функция в случае, если прочитан (n-1) символ, или встретился символ ‘\n’, или достигнут конец файла.. В любом из этих случаев в конец строки помещается символ ‘\n’. В случае успеха функция возвращает указатель str, а в случае неудачи – NULL. Строка str не изменяется, если не прочитан ни один символ и встретился конец файла.

1.11.3. Функции fprintf, fscanf
Форматированный ввод-вывод. Для форматированного ввода-вывода в текстовые файлы используются функции fscanf и fprintf.
Функция

int  fprintf(FILE*  stream, const  char*  format, …);

выполняет вывод в файл stream в соответствии с форматной строкой format. Работает эта функция так же, как и функция форматирования строк sprintf, которая была рассмотрена в лабораторной работе №5.
Функция

int  fscanf(FILE*  stream, const  char*  format, …);

выполняет ввод из файла stream текста в соответствии с форматной строкой format. Работает эта функция так же, как и функция форматирования строк sscanf, которая была рассмотрена в лабораторной работе №5.
В следующей программе создается текстовый файл.

// создание текстового файла
#include <stdio.h>

int main()
{
	int code;
	char name[80];
	double salary;
	FILE* out; // выходной поток
	// открываем выходной поток в текстовом режиме
	//if(!(out = fopen("C:\\employee.txt", "w")))
	if(!(out = fopen("employee.txt", "w")))
	{
		printf("Open file failed.\n");
		return 0;
	}
	printf("Input code, name and salary.\n");
	printf("Press Ctrl+z to exit.\n");
	printf(">");
	// вводим первую запись с консоли
	scanf("%d%s%lf", &code, &name, &salary);
	while (!feof(stdin))
	{
		// пишем запись в файл
		fprintf(out, "%d %s %f ", code, name, salary);
		printf(">");
		// вводим следующие записи с консоли
		scanf("%d%s%lf", &code, &name, &salary);
	}
	// закрываем выходной поток
	fclose(out);
	return 1;
}

 

В следующей программе читается текстовый файл.

// чтение текстового файла
#include <stdio.h>

int main()
{
	int code;
	char name[80];
	double salary;
	FILE* in; // входной поток
	// открываем входной поток в текстовом режиме
	//if(!(in = fopen("C:\\employee.txt", "r")))
	if(!(in = fopen("employee.txt", "r")))
	{
		printf("Open file failed.\n");
		return 0;
	}
	// читаем первую запись
	fscanf(in, "%d%s%lf", &code, name, &salary);
	while (!feof(in))
	{
		// выводим запись на консоль
		printf("code = %d name = %s sal = %f\n", code, name, salary);
		// читаем следующие записи
		fscanf(in, "%d%s%lf", &code, name, &salary);
	}
	// закрываем входной поток
	fclose(in);
	scanf("%u", &code);
	return 1;
}

 

1.12. Работа с буферами (setvbuf, setbuf, fflush).
Буфером называется область оперативной памяти, используемая потоком для временного хранения данных из файла. Для работы с буферами используются функции setvbuf, setbuf, fflush.
Функция

int  setvbuf(FILE*  stream, char*  buffer, int  mode, size_t  size);

определяет буфер ввода-вывода и режим работы с ним для потока stream. Вызывается эта функция после открытия файла, но перед доступом к нему. При успешном завершении функция возвращает значение 0, а вслучае неудачи – ненулевое значение.
Параметр buffer указывает на блок памяти для буфера. Если этот параметр равен NULL, то функция setvbuf использует функцию malloc для захвата памяти под буфер.
Параметр mode определяет режим работы с буфером и может принимать следующие значения:
_IOFBF	вывод данных из буфера во внешнюю память выполняется только при полной загрузке буфера или при закрытии файла;
_IOLBF	 вывод данных из буфера во внешнюю память выполняется при записи в буфер символа ‘\n’;
_IONBF	нет буферизации, в этом случае параметры size и buffer игнорируются.

Параметр size определяет длину буфера в байтах.
Функция

int  setbuf(FILE*  stream, char*  buffer);

вызывает функцию setvbuf. Причем, если значение параметра buffer не равно NULL, то функция setvbuf вызывается следующим образом:

setvbuf(stream, 0, _IOFBF, BUFSIZE);

где константа BUFSIZE задает длину буфера по умолчанию. Эта константа описана в заголовочном файле stdio.h. В противном случае функция setvbuf вызывается следующим образом:

setvbuf(stream, 0, _IOFBF, BUFSIZE);

То есть в этом случае буферизация не используется.
Функция

int  fflush(FILE*  stream);

записывает данные из буфера потока stream, в соединенный с этим потоком файл. В случае успешного завершения функция возвращает значение 0, а в случае неудачи – EOF. Если значение параметра stream равно NULL, то освобождаются буферы всех потоков, которые работают в режиме вывода.
В следующей программе создается текстовый файл с буфером.

// создание файла с буфером
#include <stdio.h>

int main()
{
	int code;
	char name[80];
	double salary;
	FILE* out;
	const unsigned size = 1024; // размер буфера
	char buffer[size]; // буфер потока
	// открываем выходной поток в текстовом режиме
	//if(!(out = fopen("C:\\employee.txt", "w")))
	if(!(out = fopen("employee.txt", "w")))
	{
		printf("Open file failed.\n");
		return 0;
	}
	// устанавливаем буфер для потока
	if(setvbuf(out, buffer, _IOFBF, size))
	{
		printf("Set buffer failed.\n");
		return 0;
	}
	printf("Input code, name and salary.\n");
	printf("Press Ctrl+z to exit.\n");
	printf(">");
	// вводим первую запись с консоли
	scanf("%d%s%lf", &code, &name, &salary);
	while (!feof(stdin))
	{
		// пишем запись в файл
		fprintf(out, "%d %s %f ", code, name, salary);
		printf(">");
		// вводим следующие записи с консоли
		scanf("%d%s%lf", &code, &name, &salary);
	}
	// закрываем выходной поток
	fclose(out);
	return 1;
}

 

В следующей программе создается текстовый файл без буфера.

// создание файла без буфера

#include <stdio.h>

int main()
{
	int code;
	char name[80];
	double salary;
	FILE* out;
	// открываем выходной поток в текстовом режиме
	//if(!(out = fopen("C:\\employee.txt", "w")))
	if(!(out = fopen("employee.txt", "w")))
	{
		printf("Open file failed.\n");
		return 0;
	}
	// нет буферизации
	setbuf(out, NULL);
	printf("Input code, name and salary.\n");
	printf("Press Ctrl+z to exit.\n");
	printf(">");
	// вводим первую запись с консоли
	scanf("%d%s%lf", &code, &name, &salary);
	while (!feof(stdin))
	{
		// пишем запись в файл
		fprintf(out, "%d %s %f ", code, name, salary);
		printf(">");
		// вводим следующие записи с консоли
		scanf("%d%s%lf", &code, &name, &salary);
	}
	// закрываем выходной поток
	fclose(out);
	return 1;
}

 

1.13. Стандартные потоки (putchar, getchar, puts, gets, perror).
Каждой программе предоставляются три стандартных потока, которые по умолчанию соединены с консолью. Указатели на эти потоки возвращают макрокоманды stdin, stdout, stderr. Для работы со стандартными потоками предназначены рассмотренные ранее функции scanf, printf, а также следующие функции:

int  putchar(int  c); // вывод символа в stdout
int  getchar(void); // ввод символа из stdin
int  puts(const  char*  str); // вывод строки в stdout
char*  gets(char*  str); // ввод строки из stdin
void  perror(const  char*  str); // вывод сообщения об ошибке в stderr

Работают эти функции так же, как и аналогичные функции для работы с файлами.

1.14. Служебные функции для работы с файлами (remove, rename, tmpfile, tmpnam).
Здесь перечислим служебные функции для работы с файлами, которые не входят ни в одну из вышеперечисленных категорий. К ним относятся функции remove, rename, tmpfile, tmpname.
Функция

int  remove(const  char*  filename);

удаляет файл с именем filename. Если файл открыт, то работа функции зависит от реализации. В случае успешного завершения функция возвращает 0, а в случае неудачи – ненулевое значение.
В следующей программе показывается, как удалить файл.

// удаление файла
#include <stdio.h>

int main()
{
	//if(remove("C:\\employee.bin"))
	if(remove("employee.bin"))
	{
		printf("There is no such a file.\n");
		return 0;
	}
	printf("The file was deleted.\n");
	return 1;
}

Функция

int  rename(const  char*  old_filename, const  char*  new_filename);

переименовывает файл с именем old_filename в файл с именем new_filename. Если файл с именем new_filename уже существует, то работа функции зависит от реализации. В случае успешного завершения функция возвращает 0, а в случае неудачи – ненулевое значение.
В следующей программе показывается, как переименовать файл.

// переименование файла
#include <stdio.h>

int main()
{
	//if(rename("C:\\employee.txt", "C:\\emp.txt"))
	if(rename("employee.txt", "emp.txt"))
	{
		printf("There is no such a file.\n");
		return 0;
	}
	printf("The file was renamed.\n");
	return 1;
}

Функция

FILE*  tmpfile(void);

создает временный файл в режиме “w+b”. После закрытия потока файл удаляется. В случае успешного завершения функция возвращает указатель на файл, а в случае неудачи – NULL.
Функция

char*  tmpnam(char*  str);

возвращает имя для временного файла. Максимальное количество имен равно TMP_MAX, а максимальная длина имени равна L_tmpnam. Если значение параметра str равно NULL, то функция возвращает указатель на свою строку, в противном случае возвращается указатель str.
Следующая программа показывает пример использования временного файла.

// использование временного файла
#include <stdio.h>

int main()
{
	int code;
	char name[80];
	double salary;
	FILE* temp; // временный файл
	// открываем временный файл
	if(!(temp = tmpfile()))
	{
		printf("Create temp file failed.\n");
		return 0;
	}
	printf("Input code, name and salary.\n");
	printf("Press Ctrl+z to exit.\n");
	printf(">");
	// вводим первую запись с консоли
	scanf("%d%s%lf", &code, &name, &salary);
	while (!feof(stdin))
	{
		// пишем запись в файл во временный файл
		fprintf(temp, "%d %s %f ", code, name, salary);
		printf(">");
		// вводим следующие записи с консоли
		scanf("%d%s%lf", &code, &name, &salary);
	}
	// устанавливаем индикатор позиции на начало файла
	rewind(temp);
	printf("\nRead records from the temporary file.\n");
	// читаем первую запись из временного файла
	fscanf(temp, "%d%s%lf", &code, name, &salary);
	while (!feof(temp))
	{
		// выводим запись на консоль
		printf("code = %d name = %s sal = %f\n", code, name, salary);
		// читаем следующие записи из временного файла
		fscanf(temp, "%d%s%lf", &code, name, &salary);
	}
	// закрываем временный файл
	fclose(temp);
	scanf("%d", &code);
	return 1;
}

 

1.15. Низкоуровневый ввод и вывод в С.
В следующем списке перечислены наиболее часто используемые в программах функции низкоуровневого ввода и вывода:

Функция 	Описание
close()	Закрывает дисковый файл
lseek()	Поиск указанного байта в файле
open()	Открывает дисковый файл
read()	Читает данные в буфер
unlink()	Удаляет файл из подкаталога
write()	Записывает буфер данных

Функции низкоуровневого ввода и вывода не буферизируют и не форматируют данные. Доступ к файлам, открываемых функциями нижнего уровня, осуществляется при помощи описателя файла (handle — целое число, используемое операционной системой для обращения к файлу). Для открытия файлов используется функция ореn(). Для открытия файла с атрибутами совместного использования (sharing) можно использовать макрос sopen().
Низкоуровневые функции отличаются от своих аналогов — потоковых функций — тем, что они не требуют включения заголовочного файла stdio.h. Однако, могут быть полезны некоторые часто используемые константы, предопределенные в stdio.h: например, EOF и NULL. Объявления низкоуровневых функций дается в заголовочном файле io.h.
Первоначально данная система дискового ввода/вывода была создана для операционной системы UNIX. Поскольку комитет по стандарту ANSI С решил не стандартизовывать эту UNIX-подобную систему небуферизированного, низкоуровневого ввода/вывода, то ее нельзя рекомендовать для дальнейшего использования. Для всех новых разработок рекомендуется использовать стандартизованную систему буферизированного ввода/вывода.

File descriptors - open, close, read, write
В языке C есть много способов работы с файлами. Помимо структуры FILE можно использовать так называемые дескрипторы файла (file descriptors). Дескриптор файла -- целое неотрицательное число. Оно обозначает номер открытого файла в таблице открытых файлов операционной системы. Использование дескрипторов файла -- более низкий уровень, чем нежели ипользование струкруты FILE. Структура FILE -- сущность языка C и его стандартной библиотеки, тогда как дескриптор файла -- сущность операционной системы. Например, при работе со структурой FILE автоматически создается буфер, и программист работает с более высокоуровневой абстракцией. А при работе с дескрипторами файла программист должен позаботится о буферизации вручную.
Пример работы с дескрипторами файла довольно прост и почти в точности повторяет процесс работы со структурой FILE:

int fd = open("...");

Сходство работы с дескрипторами файла с работой со структурой FILE заключается в том, что в названии функций отсутствует буква "f". Иногда параметры функций незначительно отличаются.
Структуру FILE полезно использовать при работе с настоящими "файлами" (которые находятся на жестком диске). Ипользовать дескрипторы файла полезно в случаях работы со специальными "файлами". В этом подходе есть своя специфика работы, но сейчас просто полезно знать, что такой подход существует.
Аналогами stdin, stdout и stderr в дескрипторах файла являются числа 0, 1 и 2 соответственно. Стандарт POSIX.1 обозначил числа 0, 1, 2 символическими константами STDIN_FILENO, STDOUT_FILENO и STDERR_FILENO соответственно.

Memory mapping. Функция mmap
Следующий способ работы с файлами удобен в тех случаях, когда приходится читать файл нелинейно: надо "ходить" вперед и назад. В предыдущих подходах такие ситуации оказывались неудобными с точки зрения программирования: получился бы громоздкий код.
В языке C был придуман удобный способ работы в таких ситуациях, который называется memory mapping. Соответствующая функция:

char *ptr = mmap("...");

Работает эта функция примерно так. Мы указываем этой функции файл на диске, и она "отображает" этот файл в такую-то область в памяти. В результате работы функции мы получаем указатель на начало файла. И потом мы можем работать с этим файлом как с обычным указателем на какую-то область памяти: можем "ходить" вперед и назад по этому файлу.
Можно "отобразить" не весь файл целиком, а, например, отдельную часть файла: с 3-его килобайта по 4-ый килобайт.

Win32 API: FileCreate, FileRead, etc.
При работе с файлами в ОС Windows можно использовать все те функции, которые были описаны выше. В ОС Windows есть своя большая стандартная библиотека Win32 API. В этой библиотеке также есть функции для работы с файлами: например, функции FileCreate(...) или FileOpen(...). Они по своей работе похожи на функции из стандартной библиотеки C, но отличия также присутствуют. Они заключаются в параметрах этих функций и небольших "хитростях", которые мы здесь опустим.
Если вы программируете под ОС Windows и пишите программу для работы в ОС Windows, то стоит пользоваться библиотекой Win32 API для работы с файлами.

1.16. Форматированный вывод.
Богатый ассортимент средств управления форматом вывода в С позволяет легко создавать печатные графики, отчеты или таблицы. Двумя основными функциями, выполняющими этот форматированный вывод, являются printf() и эквивалентная функция для файлов — fprintf(). Эти функции могут использовать любые символы преобразования, показанные в табл. 11.2. Спецификация формата имеет следующий вид:

%[флаги] [ширина] [.точность] [{h | 1 | L}]тип

Таблица 11.2. Символы преобразования для функций printf() и fprintf()

ПОЛЕ “ТИП”
Сим-
вол	Тип	Формат вывода
c	int или wint_t	printf—означает однобайтный символ
wprintf—означает широкий символ
C	int или wint_t	printf—означает широкий символ
wprintf—означает однобайтный символ
d	int	Десятичное целое зо знаком
e	double	Число со знаком в виде [-]d.ddd e [знак]ddd,где d-отдельная десятичная цифра, ddd-одна или несколько десятичных цифр, ddd-ровно четыре десятичные цифры и знак “+” или ”-”
E	double	То же что и “е”, за исключением того, что перед экспонентой стоит “E”
f	double	Число со знаком в виде [-]ddd.ddd, где d-одна или несколько десятичных цифр. Число цифр после десятичной точки зависит от точности 
g	double	Число со знаком в формате ”f” или ”e”. Используется наиболее компактная форма. Отсутствуют нули в младших разрядах. Нет десятичной точки, если за ней отсутствуют цифры 
G	double	То же что и “g”, за исключением того, что перед экспонентой стоит “G”
i	int	Десятичное целое со знаком
n	Указатель на целое	Количество символов, записанных в поток или буфер. Адрес буфера, определяемого целочисленным аргументом
o	Int	Восьмеричное число без знака
p	Указатель на void	Печатается адрес(определяемый аргументом)
s	строка	printf – определяет строку однобайтных символов
wprintf - определяет строку широких символов(печать в NULL или с максимальной точностью)
S	строка	printf – определяет строку широких символов
wprintf - определяет строку однобайтных символов (печать в NULL или с максимальной точностью)
u	строка	Десятичное целое без знака
x	int	Шестнадцатеричное целое без знака (используются символы нижнего регистра)
X	int	Шестнадцатеричное целое без знака (используются символы верхнего регистра)

Таблица 11.2 Символы преобразования для функций printf() и fprintf() (продолжение)

Флаг	Значение
#	Перед ненулевыми значениями ставиться 0, 0x, или 0X (по умолчанию пробелы отсутствуют)
.	Для форматов “e”, “E”, или “f” символ “#” указывает на наличие в выходном значении десятичной точки во всех случаях (по умолчанию точка появляется тогда, когда за ним следуют цифры)
-	Если число введенных символов оказывается меньше указанного, результаты выравниваются по левому краю поля вывода(по умолчанию принято правостороннее выравнивание
+	При вводе знаковых чисел знак отображается всегда(по умолчанию знак устанавливается только перед отрицательными числами)
0	Если значению поля ширина предшествует символ ‘0’, выводимое число дополняется ведущими нулями до минимальной ширины поля вывода(по умолчанию в качестве заполнителей применяются пробелы); при левостороннем выравнивании игнорируется
пробел	Если выводится положительное знаковое число, перед ним ставится пробел(по умолчанию пробел в таких случаях не ставится); игнорируется при наличии флага +

Поле спецификации является символом или числом, которое задает опцию форматирования. Простейший случай — знак процента и тип: например, %f. Поле "тип" используется для того, чтобы определить, что аргумент должен интерпретироваться как символ, строка или число. Поле "флаги" используется для управления печатью знаков, пробелов, десятичных точек, основания системы счисления выходных значений и так далее. Поле "ширина" указывает минимальное число печатаемых символов. Поле "точность" указывает максимальное число символов, печатаемых при выводе. Символы h | l | L являются необязательными префиксами, определяющими размер аргумента.
Все функции (в том числе scanf(), fscanf() и sscanf()) можно использовать для ввода чрезвычайно сложных данных. Взгляните, например, на следующий оператор:

scanf("%2d%5s%4f", &ivalue, psz, &fvalue);

Этот оператор вводит целое число из двух цифр, строку из пяти символов и вещественное число, занимающее максимально четыре позиции (2.97, 12.5 и так далее). Сможете ли вы определить, что выполняет следующий оператор:

scanf ("%*[\t\n]\"%[^A-Za-z]%[^\"]\"", ps1, ps2);

Вначале оператор считывает, но не запоминает любой пустой символ (пробел). Это выполняется при помощи следующей спецификации форма-та: "%*[\t\n]". Символ (*) указывает функции, что она должна получить указанные данные, но не запоминать их ни в одной переменной. Если во входной строке содержатся только символы пробела, табуляции или перевода строки, то функция scanf() продолжает считывание до тех пор, пока не встретит двойную кавычку ("). Для этого используется спецификатор формата \", который указывает на то, что введенное значение должно совпадать с заданным символом. Символ двойной кавычки, однако, не вводится. огда функция scanf() обнаружила двойную кавычку, она получает указание вводить все символы, являющиеся цифрами, в переменную ps1. Для этого в спецификации формата %[^A-Za-z] используется модификатор — знак вставки (^), который указывает на то, что можно вводить любые символы, за исключением заглавных букв от "А" до "Z" и строчных букв от "а" до "z". Если бы знака вставки не было, то строка должна была бы содержать только буквенные символы. Знак тире между двумя символами "А" и "Z" и "а" и "z" говорит о том, что нужно рассматривать весь диапазон значений.
Мы уже использовали ранее функцию scanf() и формат %s для считывания строки. Основное различие между scanf() и gets() заключается в том, как они определяют, что достигли конца строки; scanf () предназначена скорее для получения слова, а не строки. Функция gets (), как мы уже видели, принимает все символы до тех пор, пока не встретит первый символ «новая строка». Функция scanf () имеет два варианта. Для любого из них строка начинается с первого встретившегося непустого символа. Если вы используете формат %s, строка продолжается до (но не включая) следующего пустого символа (пробел, табуляция или новая строка). Если вы определяете размер поля как %10s, то функция scanf() считает не более 10 символов или же считает до любого пришедшего первым пустого символа.
Функция scanf () возвращает целое значение, равное числу считанных символов, если ввод прошел успешно, или символ EOF, если он встретился.

1.16.1. Использование функций printf() и fprintf().
Мы уже обсуждали функцию printf() довольно основательно. Подобно puts(), она использует указатель строки в качестве аргумента. Функция printf() менее удобна, чем puts(), но более гибка. Разница заключается в том, что printf() не выводит автоматически каждую строку текста с новой строки. Вы должны указать, что хотите выводить с новых строк. Так,

printf(" %s\n", string);

дает то же самое, что и

puts(string);

Вы можете видеть, что первый оператор требует ввода большего числа символов и большего времени при выполнении на компьютере. С другой стороны, printf() позволяет легко объединять строки для печати их в одной строке. Например:

printf("Хорошо, %s, %s\n", name, MSG);

объединяет "Хорошо" с именем пользователя и с символьной строкой MSG в одну строку.

Функции ввода-вывода fprintf() и fscanf() работают почти как printf() и scanf(), но им нужен дополнительный аргумент для ссылки на сам файл. Он является первым в списке аргументов. Вот пример, иллюстрирующий обращение к этим функциям:

/* образец использования fprintf() и fscanf() */
#include <stdio.h>
void main()
{
FILE *fi;
int age;
fi = fopen("sam.txt" , "r"); /* считывание */
fscanf( fi, " %d", &age); /* fi указывает на sam */
fclose(fi);
fi = fopen("data.txt" , "a"); /* дополнение */
fprintf( fi, "sam is %d.\n", age); /* fi указывает на data */
fclose(fi);
}

Заметим, что можно было использовать fi для двух различных файлов, потому что мы закрыли первый файл, прежде чем открыть второй.
В отличие от getc() и putc() эти две функции получают указатель типа FILE в качестве первого аргумента. Две другие, описанные ниже, получают его в качестве последнего аргумента.
В следующем примере описываются переменные четырех типов: символьная, массив символов, целочисленная и вещественная; затем показано, как для каждой переменной использовать соответствующие средства управления форматированием. Исходный текст программы подробно прокомментирован, и для максимальной простоты использована нумерация строк вывода, связывающая выводимое значение и оператор, обеспечивающий это значение:

/*Программа на С, демонстрирующая развитые средства преобразования
и форматирования*/
#include "stdafx.h"
#include "E:\LECTURE\AlgorithmProgramming\Universal_HederFile.h"
void StopWait(void);

main()
{
	char c =	'A',
	psz1[] = "In making a living today many no ",
				/* Для того, чтобы жить, сегдня многие */
	psz2[] = "longer leave any room for life.";
				/* не ыыходят из комнат в течение всей жизни. */
	int iln = 0,
	ivalue = 1234;
	double dPi = 3.14159265;

	/* преобразования */
	printf("\n[%2d] %c",++iln,c); /*01*//* печать символа с */
	printf("\n[%2d] %d",++iln,c); /*02*//* печать ASCII-кода символа с */
	printf("\n[%2d] %c",++iln,90); /*03*//* печать символа с ASCII-кодом 90 */
	printf("\n[%2d] %o",++iln,ivalue); /*04*//* печать ivalue в восьмеричном виде */
	printf("\n[%2d] %x",++iln,ivalue); /*05*//* печать шестнадцатеричного числа буквами нижнего регистра */
	printf("\n[%2d] %X",++iln,ivalue); /*06*//* печать шестнадцатеричного числа буквами верхнего регистра */

	/* опции преобразования и форматирования */
	printf("\n[%2d] %c",++iln,c); /*07*//* минимальная ширина 1*/
	printf("\n[%2d] %5c",++iln,c); /*08*//* минимальная ширина 5, выравнивание вправо */
	printf("\n[%2d] %-5c",++iln,c); /*09*//* минимальная ширина 5, выравнивание влево */
	printf("\n[%2d] %s",++iln,psz1); /*10*//* 33 не-null символа с автоматическим определением ширины */
	printf("\n[%d] %s",++iln,psz2); /*11*//* 31 не-null символ с автоматическим определением ширины */
	printf("\n[%d] %5s",++iln,psz1); /*12*//* минимальная ширина 5 переопределена, автоматическая — 33 */
	printf("\n[%d] %38s",++iln,psz1);/*13*//* минимальная ширина 38, выравнивание вправо */
	printf("\n[%d] %-38s",++iln,psz2);/*14*//* минимальная ширина 38, выравнивание влево */
	printf("\n[%d] %d",++iln,ivalue);/*15*//* ширина ivalue по умолчанию 4 */
	printf("\n[%d] %+d",++iln,ivalue);/*16*//* печать ivalue со знаком "+" */
	printf("\n[%d] %3d",++iln,ivalue);/*17*//* минимальная ширина 3 переопределена, автоматическая — 4 */
	printf("\n[%d] %10d",++iln,ivalue);/*18*//* минимальная ширина 10, выравнивание вправо */
	printf ("\n[%d] %-10d",++iln,ivalue); /*19*//* минимальная ширина 10, выравнивание влево */
	printf ("\n[%d] %010d", ++iln, ivalue) ; /*20*//* выравнивание влево с дополнением пробелов */
	printf("\n[%d] %f",++iln,dPi); /*21*//* использование количества цифр по умолчанию */
	printf("\n[%d] %20f",++iln,dPi); /*22*//* минимальная ширина 20, выравнивание вправо */
	printf("\n[%d] %020f",++iln,dPi); /*23*//* выравнивание вправо с ведущими нулями */
	printf("\n[%d] %-20f",++iln,dPi); /*24*//* минимальная ширина 20, выравнивание влево */

	/* дополнительная точность при форматировании */
	printf("\n[%d] %19.19s",++iln,psz1); /*25*//* минимальная ширина 19, печать всех 19 */
	printf("\n[%d] %.2s",++iln,psz1); /*26*//* печать первых 2-х символов */
	printf("\n[%d] %19.2s",++iln,psz1); /*27*//* печать 2-х символов, выравнивание вправо */
	printf("\n[%d] %-19.2s",++iln,psz1); /*28*//* печать 2-х символов, выравнивание влево */
	printf("\n[%d] %*.*s",++iln,19,6,psz1); /*29*//* использование аргументов printf */
	printf("\n[%d] %10.8f",++iln,dPi); /*30*//* ширина 10; 8 справа от '.' */
	printf("\n[%d] %20.2f",++iln,dPi); /*31*//* ширина 20; 2 до правой границы выравнивания */
	printf("\n[%d] %-20.4f",++iln,dPi); /*32*//* 4 десятичных позиций, выравнивание влево */
	printf("\n[%d] %20.4f",++iln,dPi); /*33*//* 4 десятичных позиций, выравнивание вправо */
	printf("\n[%d] %20.2e",++iln,dPi); /*34*//* ширина 20, экспоненциальное представление */

	StopWait(); /* Wait a little */
	return (0);
}


Результат работы программы выглядит следующим образом:

 

Изучив приведенный пример, вы сможете легко форматировать выходные данные вашей программы и выбирать те комбинации, которые соответствуют типам данных вашего приложения.

1.17. Примеры

1.17.1. Содержимое файла

/* расскажите, что находится в файле "test" */
#include <stdio.h>
void main()
{
	FILE *in; /* описываю указатель на файл */
	int ch;
	if ( (in = fopen("test.txt" , "r")) != NULL){
		/* открываю test для чтения, проверяя, существует ли он */
		/* указатель FILE ссылается теперь на test */
		while ( (ch = getc(in) )!= EOF) /* получаю символ из in */
			putc(ch, stdout); /* посылаю на стандартный вывод */
		fclose(in); /* закрываю файл */
	}
	else
		printf("I couldn't open file  \"test\" \n");
}

 

1.17.2. Чтение/запись из/в файл

/*В данной программе на С показано, как объявлять и использовать
файлы для ввода и вывода. Программа считывает значение order_price
из файла customer.txt и вычисляет значение billing_price,
записываемое в файл billing.txt*/
#include <stdio.h>
#include<iomanip.h>
#define MIN_DISCOUNT .97
#define MAX_DISCOUNT .95
main ()
{
	float forder_price, fbilling_price;
	FILE *fin,*fout;
	fin=fopen ("customer.txt", "r") ;
	fout=fopen ("billing.txt", "w") ;

	while (fscanf(fin,"%f",&forder_price) != EOF) {
		fprintf(fout,"Your order of \t$%8.2f\n", forder_price);
		if (forder_price < 10000)
			fbilling_price = forder_price * MIN_DISCOUNT;
		else fbilling_price = forder_price * MAX_DISCOUNT;
		fprintf(fout,"is discounted to \t$%8.2f.\n\n", fbilling_price);
	}
	fclose(fin);
	fclose(fout);
	return(0);
}

1.17.3. Назначение буфера потоку stderr

/*Программа на С, демонстрирующая описание и назначение буфера
потоку stderr*/
#include "E:\LECTURE\AlgorithmProgramming\Universal_HederFile.h"

void StopWait(void);

char cmyoutputbuffer[BUFSIZ];
main(void)
{
	/* связь буфера с небуферизированным выходным потоком */
	setbuf(stderr, cmyoutputbuffer); /* строка, которую нужно */ /*ЗАКАМЕНТИРУЙ для 2 варианта*/
	/* заполнение буфера выходного потока */
	fputs("Sample output inserted into the\n",stderr); /*"Пример вывода в" */
	fputs("output stream buffer.\n",stderr); /* "буфер выходного потока." */
	/* вывод буфера выходного потока */
	fflush(stderr);

	StopWait(); /* Wait a little */
	return (0);
}

1.17.4. Демо для функции setvbuf()
/*Программа на С, демонстрирующая использование функции setvbuf()*/
#include "E:\LECTURE\AlgorithmProgramming\Universal_HederFile.h"
void StopWait(void);

#define MYBUFSIZ 512

main (void)
{
	char ichar, cmybuffer[MYBUFSIZ];
	FILE *pfinfile, *pfoutfile;
	pfinfile = fopen("E:\\LECTURE\\AlgorithmProgramming\\sample.in", "r");
	pfoutfile = fopen("E:\\LECTURE\\AlgorithmProgramming\\sample.out", "w");
	if (setvbuf(pfinfile, cmybuffer, _IOFBF, MYBUFSIZ) != 0)
		printf("pfinfile buffer allocation error\n"); /* ошибка назначения */
	else /* буфера */
		printf("pfinfile buffer created\n"); /* буфер создан */
	if (setvbuf(pfoutfile, NULL, _IOLBF, 132) != 0)
		printf("pfoutfile buffer allocation error\n"); /* ошибка назначения*/
	else
		/* буфера */
		printf("pfoutfile buffer created\n");
		/* буфер создан */
	while(fscanf(pfinfile,"%c",&ichar) != EOF)
		fprintf(pfoutfile,"%c",ichar);
	fclose(pfinfile);
	fclose(pfoutfile);

	StopWait(); /* Wait a little */
	return (0);
}

1.17.5. Структура и файл

#include <string.h>
#include <stdio.h>
using namespace std;

struct Client{
	int Num;
	char SurName[27];
	char Name[21];
	char SecName[21];
};

int main(void)
{
	setlocale(LC_ALL, "Rus");
	FILE *stream;
	Client AClient, RClient;
	//Открываем файл для вывода
	if ((stream = fopen("SAMPLE.DAT", "wb"))== NULL){
		printf("Cannot open output file.\n");
		getchar(); 	getchar();
		return 1;
	}
	AClient.Num = 1;
	strcpy(AClient.SurName,"Petrov");
	strcpy(AClient.Name, "Petr");
	strcpy(AClient.SecName, "Petrovich");
	//Запись структуры в файл
	fwrite(&AClient, sizeof(AClient), 1, stream);
	//Закрываем файл
	fclose(stream);
	//Открываем файл для чтения
	if ((stream = fopen("SAMPLE.DAT", "rb")) == NULL){
		printf("Cannot open input file.\n");
		getchar(); 	getchar();
		return 2;
	}
	fread(&RClient, sizeof(RClient), 1, stream);
	//Закрываем файл fclose(stream);
	printf("The structure contains:\n");
	printf("Num = %d SurName = %s "
		"Name = %s SecName = %s",
	RClient.Num, RClient.SurName,
	RClient.Name, RClient.SecName);

	getchar();
	return 0;
}

1.17.6. Сжатие файла
В нашем примере имя файла, который следовало открыть, было записано в программе. Мы не обязаны считаться с этим ограничением. Используя аргументы командной строки, можно сообщить нашей программе имя файла, который хотим считать. В нашем следующем примере так и происходит. С помощью, примитивного приема сжимается содержимое — остается только каждый третий символ. Наконец, сжатая версия размещается в новый файл, имя которого состоит из старого имени с добавкой .red (сокращение слова reduced). Обычно весьма важны первый и последний элементы (аргумент командной строки и добавка к имени файла). Само же сжатие имеет более ограниченное применение, но, как вы увидите, им можно пользоваться.

/* сожмите ваши файлы в 2—3 раза! */

#include <stdio.h>
#include<string.h>
void main(int argc, char *argv[])
{
FILE *in, *out; /* описывает два указателя типа FILE */
int ch;
static char name [20]; /* память для имени выходного файла */
int count = 0;
if ( argc < 2) /* проверяет, есть ли входной файл */
	printf("Sory, i need the title of the file.\n" );
else
{
	if ( (in = fopen(argv[1], "r")) != NULL)
	{
		strcpy(name, argv[1]); /* копирует имя файла в массив */
		strcat(name, " .red"); /* добавляет .red к имени */
		out = fopen(name, " w"); /* открывает файл для записи */
		while ( (ch = getc(in)) ! = EOF)
			if ( count++ %3 ==0)
				putc(ch, out); /* печатает каждый третий символ */
		fclose(in);
		fclose(out);
	}
	else
		printf(" Я не смогла открыть файл\" %s\" \n", argv[1]);
}
}

 

Мы поместили программу в файл, названный reduce и применили эту программу к файлу, названному eddy, который содержал одну единственную строку

Даже Эдди нас опередил с детским хором.

Была выполнена команда

reduce eddy

и на выходе получен файл, названный eddy .red, который содержит

Дед спел тихо

Какая удача! Наш случайно выбранный файл сделал осмысленное сокращение.
Вот некоторые замечания по программе.
Вспомните, что argc содержит определенное количество аргументов, в число которых входит имя программного файла. Вспомните также, что с согласия операционной системы argv[0] представляет имя программы, т. е. в нашем случае reduce. Вспомните еще, что argv[1] представляет первый аргумент, в нашем случае eddy. Так как сам argv[1] является указателем на строку, он не должен заключаться в двойные кавычки в операторе вызова функции.
Мы используем argc, чтобы посмотреть, есть ли аргумент. Любые избыточные аргументы игнорируются. Помещая в программу еще один цикл, вы могли бы использовать дополнительные аргументы — имена файлов и пропускать в цикле каждый из этих файлов по очереди.
С целью создания нового имени выходного файла мы используем функцию strcpy() для копирования имени eddy в массив name. Затем применяем функцию strcat() для объединения этого имени с .red.
Программа требует, чтобы два файла были открыты одновременно, поэтому мы описали два указателя типа ' FILE'. Заметим, что каждый файл должен открываться и закрываться независимо от другого. Существует ограничение на количество файлов, которые вы можете держать открытыми одновременно. Оно зависит от типа системы, но чаще всего находится в пределах от 10 до 20. Можно использовать один и тот же указатель для различных файлов при условии, что они не открываются в одно и то же время.

1.17.7. Функции fgets и fputs

/*Программа на С, демонстрирующая считывание записей при помощи
функции fgets и их вывод на stdout при помощи функции fputs*/
#include "stdafx.h"
#include "E:\LECTURE\AlgorithmProgramming\Universal_HederFile.h"
void StopWait(void);

#define INULL_CHAR 1
#define IMAX_REC_SIZE 40

main()
{
	FILE *pfinfile;
	char crecord[IMAX_REC_SIZE + INULL_CHAR];
	pfinfile=fopen("E:\\LECTURE\\AlgorithmProgramming\\boatsale.dat", "r");
	while(fgets(crecord,IMAX_REC_SIZE +INULL_CHAR,pfinfile) != NULL)
		fputs(crecord,stdout);
	fclose(pfinfile) ;

	StopWait(); /* Wait a little */
	return (0);
}

1.17.8. Функции fread и fwrite, fseek, ftell, rewind

#include <string.h>
#include <stdio.h>
using namespace std;

struct Client{
	int Num;
	char SurName[27];
	char Name[21];
	char SecName[21];
};

int main(void)
{
	setlocale(LC_ALL, "Rus");
	FILE *stream;
	Client AClient, RClient;
	long int pos;
	//Открываем файл для вывода
	if ((stream = fopen("SAMPLE.DAT", "wb")) == NULL){
		printf("Cannot open output file.\n");
		getchar(); 	getchar();
		return 1;
	}
	AClient.Num = 1;
	strcpy(AClient.SurName,"Petrov");
	strcpy(AClient.Name, "Petr");
	strcpy(AClient.SecName, "Petrovich");
	//Запись структуры в файл
	fwrite (&AClient, sizeof (AClient), 1, stream);
	pos = ftell(stream);
	//Выводим позицию файла и длину структуры
	printf("The file pos = %d "
	"structure length = %d\n", pos, sizeof(AClient));
	//Репозиционируем файл
	rewind(stream);
	//Открываем файл для чтения
	if ((stream = fopen("SAMPLE.DAT", "rb"))== NULL){
		printf("Cannot open input file.\n");
		getchar(); 	getchar();
		return 2;
	}
	fread (&RClient, sizeof (RClient), 1, stream);
	//Закрываем файл
	fclose(stream);
	printf("The structure contains:\n");
	printf("Num = %d SurName = %s Name = %s"
		"SecName = %s",
	RClient.Num, RClient.SurName,
	RClient.Name, RClient.SecName);

	getchar(); 	getchar();
	return 0;
}

 

Пример 2

/*Программа на С, иллюстрирующая использование функций fseek,
ftell и rewind*/
#include "E:\LECTURE\Universal_HederFile.h"
void StopWait(void);

main()
{
	FILE *pf;
	char c;
	long llocation;
	pf=fopen("E:\\LECTURE\\test.dat","r+");
	c=fgetc(pf);
	putchar(c);
		c=fgetc(pf);
		putchar(c);
	llocation=ftell(pf);
	c=fgetc(pf);
	putchar(c);
	fseek(pf,llocation,0);
		c=fgetc(pf);
		putchar(c);
	fseek(pf,llocation,0);
	fputc('E',pf);
	fseek(pf,llocation,0);
		c=fgetc(pf);
		putchar(c);
	rewind(pf);
	c=fgetc(pf);
	putchar(c);

	StopWait(); /* Wait a little */
	return (0);
}

1.17.9. Использование fseek

Для файлов, которые открыты на чтение есть полезные функции. Одна из них это:

int fseek(FILE *f, long offset, int flag);

•	FILE *f - файл, в котором передвигаемся;
•	long offset - количество байтов для отступа, отступ производится в соответствии с 3-м параметром;
•	int flag - позиция, от которой будет совершен отступ; в стандартной библиотеке C для этого параметра определены 3 константы:

SEEK_SET -- начало файла;
SEEK_CUR -- текущас позиция;
SEEK_END -- конец файла;

int fseek() -- сама функция возвращает ноль, если операция прошло успешно, иначе возвращается ненулевое значение.
Еще одна полезная функция может определить текущее положение в файле (который открыт для чтения):

long int ftell(FILE *f);

Вот простой пример, показывающий, как она работает. Как и в наших предыдущих примеpax, функция использует аргумент командной строки для получения имени файла, с которым она работает. Заметим, что fseek() имеет три аргумента и возвращает значение типа int.
Вот простой пример, показывающий, как она работает. Как и в наших предыдущих примеpax, функция использует аргумент командной строки для получения имени файла, с которым она работает. Заметим, что fseek() имеет три аргумента и возвращает значение типа int.

/* использование fseek() для печати содержимого файла */
#include <stdio.h>
void main(int number,char *names []) /* не следует использовать argc и argv */
{
FILE *fp;
long offset = 0L; /* обратите внимание, что это тип long */
if ( number < 2)
	puts ("I need a name of file as an argument");
else
{
if ((fp = fopen(names[1], "r")) == 0)
	printf(" I can't open file %s.\n" , names[1]);
else
{
	while( fseek(fp, offset++ , 0) == 0)
		putchar(getc(fp) );
	fclose(fp);
}
}
}

 

Первый из трех аргументов функции fseek() является указателем типа FILE на файл, в котором ведется поиск. Файл следует открыть, используя функцию fopen().
Второй аргумент назван "offset" (вот почему мы выбрали данное имя для переменной). Этот аргумент сообщает, как далеко следует передвинуться от начальной точки (см. ниже); он должен иметь* значение типа long, которое может быть положительным (движение вперед) или отрицательным (движение назад).
Третий аргумент является кодом, определяющим начальную точку:
Код	Положение в файле
0	начало файла
1	текущая позиция
2	конец файла

Функция fseek() возвращает 0, если все хорошо, и -1, если есть ошибка, например попытка перемещаться за границы файла.
Теперь мы можем разъяснить наш маленький цикл:

while ( fseek(fp, offset ++ , 0) == 0)
	putchar(getc(fp) );

Поскольку переменная offset инициализирована нулем, при первом прохождении через цикл мы имеем выражение

fseek(fp, 0L, 0);

означающее, что мы идем в файл, на который ссылается указатель fp, и находим байт, отстоящий на 0 байт от начала, т. е. первый байт. Затем функция putchar() печатает содержимое этого байта. При следующем прохождении через цикл переменная offset увеличивается до 1L, печатается следующий байт. По существу, переменная offset действует подобно индексу для элементов файла. Процесс продолжается до тех пор, пока offset не попытается попасть в fseek() после конца файла. В этом случае возвращает значение — 1 и цикл прекращается.
Этот последний пример чисто учебный. Нам не нужно использовать fseek(), потому что getc() так или иначе проходит через файл байт за байтом; fseek() приказала getc() «посмотреть» туда, куда она сама уже собиралась посмотреть.




1. Битовые операции
1.1. Двоичное представление числовых значений
1.2. Битовая маска
1.3. Битовые операторы (операции с битовыми масками)
1.3.1. Побитовое И (оператор &)
1.3.2. Побитовое ИЛИ (оператор |)
1.3.3. Побитовое отрицание (оператор ~)
1.3.4. Исключающее ИЛИ (оператор ^)
1.4. Дополнительный код
1.5. Операции побитового сдвига
1.6. Применение поразрядных операций
1.6.1. Степень числа 2
1.6.2. Получение значения отдельных бит
1.6.3. Установка единицы в отдельный бит
1.6.4. Установка нуля в отдельный бит
1.6.5. Битовый массив
1.6.6. Передача параметров в функции
1.7. Примеры
1.7.1. Примеры для языка C
1.7.2. Примеры для языка CPP
1.7.2.1. Сдвиги влево
1.7.2.2. Сдвиги вправо
1.7.2.3. Сдвиги и перемещения
1.7.2.4. Некоторые подробности

	Битовые операции

Язык Си иногда называют макроассемблером за его тягу к железу. Если не использовать оптимизацию, можно даже примерно оценить, в какие конструкции на ассемблере преобразуется код программы. Простота и минимализм языка (простоту языка не путать с простотой программирования на языке) привели к тому, что на многих платформах си остаётся единственным высокоуровневым языком программирования. Без обзора битовых операций, конечно, изучения языка было бы неполным.
Побитовые операции, как понятно из названия, позволяют оперировать непосредственно с битами. Большое количество примеров использования побитовых операций можно найти, например, в книге Генри Уоррена «Алгоритмические трюки для программистов». Здесь мы рассмотрим только сами операции и примитивные алгоритмы.
Битовые операции не особенность языка - это скорее особенность процессоров, принципов вычислений, ассемблера. Раз уж эти операции существуют, причем именно в том виде, в каком к ним привыкли то логично предположить, что многие программы и алгоритмы рассчитывают на их наличие в инструментарии разработчика. Представьте что вам пришлось бы портировать некий криптографический алгоритм использующий эти операторы на js в котором их не было бы. Допустим вы реализуете его умножая/деля на два, но затем обнаруживаете, что при умножении старший бит у вас исчезает, а должен становится самый младшим. Кроме того ваша реализация на js была бы много медленней чем встроенная в язык реализация.
Вместо того, чтобы проводить умножение (поначалу это было десятки тактов), подключаем регистр к регистрам процессора, и выполним всё за один такт. Существовала даже программа, генерирующая быстрый код умножения на константу, например, 6 — сдвинуть, сложить и ещё раз сдвинуть. И это в своё время было быстрее, чем mul — а ведь сейчас мы без зазрения совести пишем mul eax, 6. По правилам хорошего программистского тона умножение, даже на 2 или на 4, пишется как обычное * (>> пишут, если компилятор непроходимо туп и умножение медленнее). А вот сдвиги — именно их, а не умножение — пишут, когда работают с битовыми полями.
Есть также специальные сдвиги.
	Арифметический сдвиг вправо (левый совпадает с обычным) — для чисел со знаком.
	Сдвиг-вращение — в основном для криптографии.
	Сдвиг-вращение через регистр флагов — в основном для длинной арифметики.

Битовые операторы наиболее часто применяются при разработке драйверов устройств, например программ для модемов, дисков и принтеров, поскольку битовые операторы могут использоваться для выключения некоторых битов, например четности. (Бит четности используется для подтверждения того, что остальные биты в байте не изменялись. Он, как правило, является старшим битом в байте.)
Битовые операторы проводят операции непосредственно на битах числа, поэтому числа в примерах будут в двоичной системе счисления.
В теме рассмотрены операторы:
	|  (Побитовое ИЛИ (OR)),
	& (Побитовое И (AND)),
	^ (Исключающее ИЛИ (XOR)),
	~ (Побитовое отрицание (NOT)),
	<< (Побитовый сдвиг влево),
	>> (Побитовый сдвиг вправо).

Битовые операции изучаются в дискретной математике, а также лежат в основе цифровой техники, так как на них основана логика работы логических вентилей — базовых элементов цифровых схем. В дискретной математике, как и в цифровой технике, для описания их работы используются таблицы истинности.
О битовых операторах вам также необходимо знать:
	Некоторые побитовые операторы похожи на операторы, с которыми вы наверняка знакомы (&&, ||). Это потому, что они на самом деле в чем-то похожи. Тем не менее, путать их ни в коем случае нельзя.
	Большинство битовых операций являются операциями составного присваивания.

	Двоичное представление числовых значений
Как известно, целые числа представляются в виде последовательности цифр. Такое представление чисел называется позиционным. Весь набор цифр, которые могут использоваться в позиционном представлении числа, определяет систему счисления. В повседневной жизни используется десятичная система счисления, в которой числа представляются цифрами от 0 до 9. В программировании более популярны системы счисления с количеством цифр, равным степени двойки: восьмеричная и шестнадцатеричная.
Однако двоичная система счисления – вне конкуренции. В этой системе счисления числа записываются последовательностью из двух цифр: 0 и 1. Каждая позиция в двоичном представлении числа соответствует биту. Таким образом, с помощью бита можно задать два значения: 0 или 1. Если для представления числа используется n бит, то в этом случае существует  2n различных комбинаций, каждая из которых соответствует отдельному числу. Например, с помощью 8 бит (1 байт) можем записать 28= 256 чисел.
При представлении двоичным кодом положительных чисел можно было бы использовать стандартное математическое представление числа в двоичной системе. Однако на практике приходится иметь дело и с отрицательными числами, причем с технической точки зрения знаком минус здесь не обойтись – минус можно написать на бумаге, а реализовать его в памяти компьютера намного сложнее.
Для определения знака числа используют старший бит в позиционной записи. Нулевой старший бит соответствует положительному числу, а единичный старший бит соответствует отрицательному числу. При этом перевод для положительных чисел из двоичной системы счисления в десятичную осуществляется стандартными методами: если в двоичном представлении число позиционно задается как

□(→┬(b_n b_(n-1) …_ b_2 b_1 b_0 ) )

(причем цифры bi могут принимать значения 0 или 1, а старший бит для положительных чисел bn = 0), то в десятичной системе число вычисляется как

b_0 2^0 〖+b〗_1 2^1 〖+b〗_2 2^2+⋯〖+b〗_(n-1) 2^(n-1) 〖+b〗_n 2^n

С отрицательными числами дела обстоят несколько сложнее. Чтобы перевести отрицательное число с позиционным представлением в двоичной системе

□(→┬(b_n b_(n-1) …_ b_2 b_1 b_0 ) )

(старший бит для отрицательного числа 1 bn = 1), необходимо проделать несложную процедуру из двух этапов.
Во-первых, производится побитовое инвертирование кода, т.е. каждый бит в представлении числа меняется на противоположный: 0 на 1 и 1 на 0.
Во-вторых, результат переводится в десятичную систему и к нему добавляется 1. Это модуль отрицательного числа.
Чтобы получить само число, необходимо умножить на -1. Чтобы перевести отрицательное число из десятичной системы в двоичную, проделывают обратную процедуру: от модуля отрицательного числа отнимается 1, результат переводится в бинарный код, после чего производится побитовое инвертирование. Проиллюстрируем это на примере. Рассмотрим 8-битовое бинарное положительное число 01001011, что в десятичной системе счисления соответствует числу 75

7	6	5	4	3	2	1	0	
0	1	0	0	1	0	1	1	75

2^0+2^1+2^3+2^6=75

Определим бинарное машинное представление для отрицательного числа -75. Отнимаем от модуля числа единицу, получаем 74. Бинарное представление для этого числа 01001010

7	6	5	4	3	2	1	0	
0	1	0	0	1	0	1	0	74

2^1+2^3+2^6=74

После побитового инвертирования из числа 01001010 получаем 10110101. Это и есть представление числа -75.

7	6	5	4	3	2	1	0	
0	1	0	0	1	0	1	0	74
1	0	1	1	0	1	0	1	-75

В том, что это так, легко убедиться: сложим числа 01001011 и 10110101.

8	7	6	5	4	3	2	1	0	
	0	1	0	0	1	0	1	1	75
	1	0	1	1	0	1	0	1	-75
1	0	0	0	0	0	0	0	0	0

Формально получаем 100 000 000, однако поскольку числа 8-битовые, лишний единичный старший бит отбрасывается, и получаем представление 00 000 000, что соответствует нулю, как и должно быть.
Теперь рассмотрим основные побитовые операции и операторы, которые используются для этого в языке программирования C++. Список побитовых операторов приведен в таблице.

Таблица. Побитовые операторы C++

Оператор	Назначение
&	Побитовое И. Бинарный оператор. Результатом выражения  a&b является число, каждый бит которого в двоичном представлении равен результату сравнения соответствующих битов чисел  a и  b : значение бита равно 1, если оба сравниваемых бита равны 1. В противном случае значение бита равно 0
|	Побитовое ИЛИ. Бинарный оператор. Результатом выражения  a|b является число, каждый бит которого в двоичном представлении равен результату сравнения соответствующих битов чисел  a и  b : значение бита равно 1, если хотя бы один из сравниваемых битов равен 1. В противном случае значение бита равно 0
^	Побитовое исключающее ИЛИ. Бинарный оператор. Результатом выражения  a^b является число, каждый бит которого в двоичном представлении равен результату сравнения соответствующих битов чисел a и  b : значение бита равно 1, если один и только один из сравниваемых битов равен 1. В противном случае значение бита равно 0
~	Побитовое отрицание (дополнение до единицы). Унарный оператор. Результатом выражения  ~a является число, которое получается побитовым инвертированием числа  a
>>	Сдвиг вправо. Бинарный оператор. В двоичном представлении числа, указанном слева от оператора, выполняется сдвиг всех битов вправо на число позиций, указанных справа от оператора. При этом старший бит знака остается неизменным, а выходящие за диапазон младшие биты теряются
<<	Сдвиг влево. Бинарный оператор. В двоичном представлении числа, указанном слева от оператора, выполняется сдвиг всех битов влево на число позиций, указанных справа от оператора, с заполнением младших битов нулями и потерей старших битов

Приведем некоторые примеры использования побитовых операторов. Они представлены в таблице. Даже в самых простых случаях результат может оказаться несколько неожиданным.

Таблица. Примеры использования побитовых операторов

Выражение	Значение	Пояснение
5&3	1	В двоичном представлении число  5 имеет вид  101 , а число  3 представляется как  011 . Побитовое сравнение чисел  101 и  011 с помощью оператора побитового И  & дает  001 , что в десятичной системе соответствует числу  1
5|3	7	Применение оператора побитового ИЛИ  | для сравнения чисел  101 и  011 дает  111 , что в десятичной системе соответствует числу  7
5^3	6	Применение оператора побитового исключающего ИЛИ  ^ для сравнения чисел  101 и  011 дает  110 , что в десятичной системе соответствует числу  6
~5	-6	После применения операции побитового инвертирования ~ к числу  5 требует особых пояснений. На самом деле в 8-битовом представлении число  5 имеет вид  00000101 . В предыдущих случаях нулевые старшие разряды роли не играли, поэтому они явно не указывались. При инвертировании наличие старших нулевых битов важно. Инвертирование дает  11111010 . Это не что иное, как представление в двоичном машинном коде числа  -6 . Последнее читатель может проверить самостоятельно
5>>2	1	После сдвига вправо на две позиции для числа  5 (двоичный код  101 ) получаем  001 . В десятичной системе это число  1
5<<2	20	После сдвига влево на две позиции для числа  5 (двоичный код  101 ) получаем  10100 . В десятичной системе это число  20

Обращаем внимание на особенности применения операции побитового сдвига к отрицательным числам. Например, результатом выражения -6>>5 является число -1. Дело в том, что в бинарном коде 11111010 для числа -6 при сдвиге вправо на 5 позиций при условии сохранения значения старшего бита знака получаем код 11111111. Это код числа -1.
Особенности операций в двоичной системе таковы, что сдвиг в побитовом представлении числа на одну позицию влево означает умножение этого числа на 2. Следует только помнить, что с определенного момента при сдвиге вправо теряются старшие биты. Представим, что число задается 8 битами. Если воспользоваться командой 1<<6, получим в качестве результата значение 26 = 64. Действительно, десятичное число 1 в двоичной системе в 8-битовом представлении задается как 00000001. После сдвига влево на 6 позиций получаем 01000000, что в десятичной системе соответствует числу 64. Однако если воспользоваться командой 1<<7, получим в качестве результата -128. Объясняется это следующим обстоятельством. После сдвига влево на 7 позиций из числа 00000001 получаем число 1000000. Это отрицательное число, о чем свидетельствует старший единичный бит. Переводя это число в десятичную систему, сначала инвертируем бинарный код и получаем 01111111. Это код числа 127. Чтобы получить конечное значение, необходимо прибавить к этому результату 1 и добавить минус – в результате приходим к значению -128.

	Битовая маска
Битовая маска — определённые данные, которые используются для маскирования — выбора отдельных битов или полей из нескольких битов из двоичной строки или числа.
Как известно, числа в памяти компьютера представляются в двоичной системе счисления в виде последовательности битов. Один бит может иметь значение 0 или 1. Можно провести аналогию между битами и значениями типа bool: 0 обозначает false, а 1 – true. По такой аналогии число (последовательность битов) можно представить как массив значений bool. Например, тип int может обозначать массив из 32 значений bool, а long long – из 64.
Чаще всего массивы bool небольшого размера используются для обозначения некоторого подмножества объектов, выбранного из множества. Например, для обозначения элементов с индексами 1 и 4 (0-индексация), выбранных из множества из пяти элементов используется массив {false,true,false,false,true}, или {0,1,0,0,1}. Его можно представить в виде значения типа int: 100102 (индексация обычно начинается с младших битов числа, записываемых справа).
При интерпретации такого значения как обычного числа, оно будет равно 100102=1810. Но при интерпретации его как массива логических значений (битов), оно будет обозначать {0,1,0,0,1}. С точки зрения C++ эти два значения равносильны, и то, является ли значение типа int числом, или массивом bool, зависит только от контекста, в котором оно используется.
При использовании значений типа int или long long как массивов из bool, такие значения называются битовыми масками.

Получение значения бит
Битовую маску возможно использовать для получения значения бита. Для этого нужно отключить все остальные биты с помощью побитового логического «И» (конъюнкции).
Например, для получения значения пятого бита (считая слева) числа 10111011 нужно использовать маску 00001000. В результате получится:

10111011 & 00001000 = 00001000

Подобное число в языках, использующих вместо логического типа числовые типы, например в Си, будет означать истину или ложь, если этот бит принимает соответствующее значение. В языках, имеющих логические типы (например, C++), необходимо произвести приведение типа.

Основной плюс:
	Экономия памяти — требуется бит для хранения информации, а не байт.

Сфера использования в основном в интерфейсах, где приоритет отдаётся экономии памяти:
	Реализации криптографических алгоритмов
	выбор битов из слова состояния, идущие с пакетом по интерфейсу, например, контрольная сумма;
	выбор битов из IP-адреса для адресации подсети 255.255.224.0
	Реализации любых других алгоритмов требующих работу с битами
	Чтобы пользователи языка не изобретали велосипеды

	Битовые операторы (операции с битовыми масками)
В противоположность большинству языков, С поддерживает все существующие битовые операторы. Поскольку С создавался, чтобы заменить ассемблер, то была необходимость поддержки всех (или по крайней мере большинства) операции, которые может выполнить ассемблер. Битовые операции — это тестирование, установка или сдвиг битов в байте или слове, которые соответствуют стандартным типам языка С char и int. Битовые операторы не могут использоваться с float, double, long double, void и другими сложными типами. Таблица содержит имеющиеся операторы.

Оператор	Действие
&	И
|	ИЛИ
^	Исключающее ИЛИ
~	Дополнение
>>	Сдвиг вправо
<<	Сдвиг влево

Логические операции И, ИЛИ, исключающее ИЛИ и НЕ могут быть описаны с помощью таблиц истинности

Побитовое И (оператор &)
В побитовых (bit-wise) операциях значение бита, равное 1, рассматривается как логическая истина, а 0 как ложь. Побитовое И (оператор &) берёт два числа и логически умножает соответствующие биты.
Побитовое И — это что-то вроде операции, противоположной побитовому ИЛИ. Двоичный разряд результата равен 1 только тогда, когда оба соответствующих бита операндов равны 1. Другими словами, можно сказать, двоичные разряды получившегося числа — это результат умножения соответствующих битов операнда: 1х1 = 1, 1х0 = 0. Побитовому И соответствует следующая таблица истинности:

A	B	A & B
0	0	0
0	1	0
1	0	0
1	1	1

Пример работы побитового И на выражении 38 & 53:

A	0	0	1	0	0	1	1	0
B	0	0	1	1	0	1	0	1
A & B	0	0	1	0	0	1	0	0

Как результат, получаем 1001002 , или 3610 .
С помощью побитового оператора И можно проверить, является ли число четным или нечетным. Для целых чисел, если младший бит равен 1, то число нечетное (основываясь на преобразовании двоичных чисел в десятичные). Зачем это нужно, если можно просто использовать %2? На моем компьютере, например, &1 выполняется на 66% быстрее. Довольно неплохое повышение производительности.
Например, если логически умножить 3 на 8, то получим 0

#include <iostream>
using namespace std;
void main()
{
	setlocale(LC_CTYPE, "Russian");
	char a = 3;
	char b = 8;
	char c = a & b;
	printf("%d", c);
	cin >> a;
}



Так как в двоичном виде 3 в виде однобайтного целого представляет собой 00000011, а 8 - 00001000

Первый бит переменной c равен логическому произведению первого бита числа a и первого бита числа b. И так для каждого бита.

00000011
00001000
--------------
00000000

Соответственно, побитовое произведение чисел 31 и 17 даст 17, так как 31 это 00011111, а 17 это 00010001

00011111
00010001
--------------
00010001

Побитовое произведение чисел 35 и 15 равно 3.

00100011
00001111
--------------
00000011

Битовое И чаще всего используется для выключения битов. То есть любой бит, установленный в 0, вызывает установку соответствующего бита в другом операнде также в 0. Например, следующая функция читает символы из порта модема, используя функцию read_modem(), и сбрасывает бит четности в 0.

char get_char_from_modem(void)
{
	char ch;
	ch = read_modem (); /* получение символа из порта модема */
	return (ch & 127);
}

Побитовое ИЛИ (оператор |)
Аналогично работает операция побитового ИЛИ (оператор |), за исключением того, что она логически суммирует соответствующие биты чисел без переноса.
Побитовое ИЛИ действует эквивалентно логическому ИЛИ, но примененному к каждой паре битов двоичного числа. Двоичный разряд результата равен 0 только тогда, когда оба соответствующих бита в равны 0. Во всех других случаях двоичный результат равен 1. То есть, если у нас есть следующая таблица истинности:

A	B	A | B
0	0	0
0	1	1
1	0	1
1	1	1

38 | 53 будет таким:
A	0	0	1	0	0	1	1	0
B	0	0	1	1	0	1	0	1
A | B	0	0	1	1	0	1	1	1

В итоге мы получаем 1101112 , или 5510 .

Например:

#include <iostream>
using namespace std;
void main()
{
	setlocale(LC_CTYPE, "Russian");
	char a = 15;
	char b = 11;
	char c = a | b;
	printf("%d", c);
	cin >> a;
}


выведет 15, так как 15 это 00001111, а 11 это 00001011

00001111
00001011
--------------
00001111

Побитовое ИЛИ для чисел 33 и 11 вернёт 43, так как 33 это 00100001, а 11 это 00001011

00100001
00001011
--------------
00101011

Побитовое отрицание (оператор ~)
Побитовое отрицание (оператор ~) работает не для отдельного бита, а для всего числа целиком. Оператор инверсии меняет ложь на истину, а истину на ложь, для каждого бита.
Побитовое отрицание инвертирует все биты операнда. То есть, то что было 1 станет 0, и наоборот.

A	~A
0	1
1	0

Вот, например, операция ~52:

A	0	0	1	1	0	1	0	0
~A	1	1	0	0	1	0	1	1

Результатом будет 20310
При использовании побитового отрицания знак результата всегда будет противоположен знаку исходного числа (при работе со знаковыми числами). Почему так происходит, узнаете прямо сейчас.

Например

#include <iostream>
using namespace std;
void main()
{
	setlocale(LC_CTYPE, "Russian");
	char a = 65;
	char b = ~a;
	printf("%d", b);
	cin >> a;
}



Выведет -66, так как 65 это 01000001, а инверсия даст 10111110, что равно -66. Кстати, вот алгоритм для того, чтобы сделать число отрицательным: для нахождение дополнительного кода числа его надо инвертировать и прибавить к нему единицу.

#include <iostream>
using namespace std;
void main()
{
	setlocale(LC_CTYPE, "Russian");
	char a = 107;
	char b = ~a + 1;
	printf("a = %d, -a = %d", a, b);
	cin >> a;
}



Исключающее ИЛИ (оператор ^)
Исключающее ИЛИ (оператор ^) применяет побитовую операцию XOR.
Разница между исключающим ИЛИ и побитовым ИЛИ в том, что для получения 1 только один бит в паре может быть 1:

A	B	A ^ B
0	0	0
0	1	1
1	0	1
1	1	0

Например, выражение 138^43 будет равно

A	1	0	0	0	1	0	1	0
B	0	0	1	0	1	0	1	1
A ^ B	1	0	1	0	0	0	0	1

101000012 , или 16010

Например, для чисел

#include <iostream>
using namespace std;
void main()
{
	setlocale(LC_CTYPE, "Russian");
	char a = 12;
	char b = 85;
	char c = a ^ b;
	printf("%d", c);
	cin >> a;
}



будет выведено 89, так как a равно 00001100, а b равно 01010101. В итоге получим 01011001
Иногда логические операторы && и || путают с операторами & и |. Такие ошибки могут существовать в коде достаточно долго, потому что такой код в ряде случаев будет работать. Например, для чисел 1 и 0. Но так как в си истиной является любое ненулевое значение, то побитовое умножение чисел 3 и 4 вернёт 0, хотя логическое умножение должно вернуть истину.

#include <iostream>
using namespace std;
void main()
{
	setlocale(LC_CTYPE, "Russian");
	int a = 3;
	int b = 4;
	printf("a & b = %d\n", a & b);  //выведет 0
	printf("a && b = %d\n", a && b);//выведет не 0 (конкретнее, 1)
	cin >> a;
}



С помощью ^ можно поменять значения двух переменных (имеющих одинаковый тип данных) без использования временной переменной.
Также с помощью исключающего ИЛИ можно зашифровать текст. Для этого нужно лишь итерировать через все символы, и ^ их с символом-ключом. Для более сложного шифра можно использовать строку символов:

string msg = "This is a message";
char[] message = msg.toCharArray();
string key = ".*)";
string encryptedString = new string();
for(int i = 0; i< message.length; i++){
   encryptedString += message[i] ^ key.toCharArray()[i%key.length()];
}

Исключающее ИЛИ не самый надежный способ шифровки, но его можно сделать частью шифровального алгоритма.

	Дополнительный код
Здесь стоит рассказать немного о способе представления отрицательных целых чисел в ЭВМ, а именно о дополнительном коде (two’s complement). Не вдаваясь в подробности, он нужен для облегчения арифметики двоичных чисел.
Главное, что вам нужно знать о числах, записанных в дополнительном коде — это то, что старший разряд является знаковым. Если он равен 0, то число положительное и совпадает с представлением этого числа в прямом коде, а если 1 — то оно отрицательное. То есть, 10111101 — отрицательное число, а 01000011 — положительное.
Чтобы преобразовать отрицательное число в дополнительный код, нужно инвертировать все биты числа (то есть, по сути, использовать побитовое отрицание) и добавить к результату 1.
Например, если мы имеем 109:

A	0	1	1	0	1	1	0	1
~A	1	0	0	1	0	0	1	0
~A+1	1	0	0	1	0	0	1	1
Представленным выше методом мы получаем -109 в дополнительном коде.

	Операции побитового сдвига
Операций сдвига две – битовый сдвиг влево (оператор <<) и битовый сдвиг вправо (оператор >>). Битовый сдвиг вправо сдвигает биты числа вправо, дописывая слева нули. Битовый сдвиг влево делает противоположное: сдвигает биты влево, дописывая справа нули. Вышедшие за пределы числа биты отбрасываются.
Например, сдвиг числа 5 влево на 2 позиции

00000101 << 2 == 00010100

Сдвиг числа 19 вправо на 3 позиции

00010011 >> 3 == 00000010

Независимо от архитектуры (big-endian, или little-endian, или middle-endian) числа в двоичном виде представляются слева направо, от более значащего бита к менее значащему. Побитовый сдвиг принимает два операнда – число, над которым необходимо произвести сдвиг, и число бит, на которое необходимо произвести сдвиг.

#include <iostream>
using namespace std;
void main()
{
	setlocale(LC_CTYPE, "Russian");
	int a = 12;
	printf("%d << 1 == %d\n", a, a << 1);
	printf("%d << 2 == %d\n", a, a << 2);
	printf("%d >> 1 == %d\n", a, a >> 1);
	printf("%d >> 2 == %d\n", a, a >> 2);
	cin >> a;
}



Так как сдвиг вправо (>>) дописывает слева нули, то для целых чисел операция равносильна целочисленному делению пополам, а сдвиг влево умножению на 2. Произвести битовый сдвиг для числа с плавающей точкой без явного приведения типа нельзя. Это вызвано тем, что для си не определено представление числа с плавающей точкой. Однако можно переместить число типа float в int, затем сдвинуть и вернуть обратно

#include <iostream>
using namespace std;
void main()
{
	setlocale(LC_CTYPE, "Russian");
	float b = 10.0f;
	float c = (float) (*((unsigned int*)&b) >> 2);
	printf("%.3f >> 2 = %.3f", b, c);
	cin >> b;
}



Но мы, конечно же, получим не 5.0f, а совершенно другое число.
Особенностью операторов сдвига является то, что они могут по-разному вести себя с числами со знаком и без знака, в зависимости от компилятора. Действительно, отрицательное число обычно содержит один бит знака. Когда мы будем производить сдвиг влево, он может пропасть, число станет положительным. Однако, компилятор может сделать так, что сдвиг останется знакопостоянным и будет проходить по другим правилам. То же самое и для сдвига вправо.

#include <iostream>
using namespace std;
void main()
{
	setlocale(LC_CTYPE, "Russian");
	unsigned int ua = 12;
	signed int sa = -11;
	printf("ua = %d, ua >> 2 = %d\n", ua, ua >> 2);
	printf("sa = %d, sa >> 2 = %d\n", sa, sa >> 2);
	printf("(unsigned) sa = %u, sa >> 2 = %u\n", sa, sa >> 2);
	printf("sa = %d, ((unsigned) sa) >> 2 = %d", sa, ((unsigned) sa) >> 2);
	cin >> ua;
}



В данном случае при первом сдвиге всё работает, как и задумано, потому что число без знака. Во втором случае компилятор VSE2013 оставляет знак. Однако если посмотреть на представление этого числа, как беззнакового, сдвиг происходит по другим правилам, с сохранением самого левого бита. В последней строчке, если привести число со знаком к числу без знака, то произойдёт обычный сдвиг, и мы получим в результате положительное число.
Побитовые операторы и операторы сдвига не изменяют значения числа, возвращая новое. Они также как и арифметические операторы, могут входить в состав сложного присваивания

#include <iostream>
using namespace std;
void main()
{
	setlocale(LC_CTYPE, "Russian");
	int a = 10;
	int b = 1;
	cout << "a=" << a << " b=" << b << "\n";
	a >>= 3;
	cout << "a >>= 3; a=" << a << "\n";
	a ^= (b << 3);
	cout << "a ^= (b << 3); a=" << a << " b=" << b << "\n";
	cin >> a;
}



	Применение поразрядных операций
Степень числа 2
Одной из возможностей применения битовых операций является получение степени числа 2. Для этого используются операции побитового сдвига влево или в право. Дело в том что степени числа 2 в двоичном представлении выглядят так:

Десятичные	Двоичные
1	0001
2	0010
4	0100
8	1000

Как можно легко заметить, единица просто сдвигается влево от правого края, каждый шаг соответствует следующей степени числа 2.
Таким образом что бы получить к примеру 2 в 4 степени, нужно просто взять единицу и применить к ней операцию битового сдвига влево на 3 позиции.
И так операция 0001 << 3 даст нам в итоге 1000 что в десятичной форме равно числу 8.
Казалось бы для чего это требуется, когда например можно просто в цикле умножить число два сколько угодно раз.
Дело в том что операции в цикле займет много тактов процессора, в то время как описанная операция выше, будет выполнена в большинстве процессоров всего за 1 такт.
В итоге получается увеличение производительности и не потребуется писать целый цикл.

Получение значения отдельных бит
Зачастую требуется узнать значение отдельного бита в некоем числе, то есть 0 там или 1.
Ситуаций, в которых это может потребоваться достаточно много, особенно в низкоуровневом программировании.
Нам потребуется вот такая операция: new = target & ( 1 < offset) target - это число в котором мы желаем проверить некий разряд на наличие 0 или 1; offset - количество разрядов на которое требуется сдвинуть единицу от правого края влево, помните это значение будет всегда на 1 меньше реального номера интересующего вас разряда. Так что бы установить единицу в третий разряд справа вам требуется произвести сдвиг на 2 разряда а не на 3, так как единица уже стоит в 1 разряде а значит сдвиг на 1 разряд переместит ее во 2-й разряд.
В результате этой операции вам будет возвращено либо некое число либо ноль. Если данная операция вернет ноль, значит в данном разряде был ноль, если вернет любое другое отличное от нуля число, значит в данном разряде стояла единица.
Пример:
Предположим мы имеем двоичное число 1101 и желаем узнать значение 3 бита справа, операция бы выглядела так: 1101 & ( 0001 << 2) После выполнения операции в скобках у нас получится следующие: 1101 & 0100 которая в свою очередь вернет нам двоичное число 0100, так как операция И оставит единицы лишь там где единицы в обеих числах. Данное двоичное число соответствует десятичному числу 4, которое по сути не имеет никакого отношения к нашей задаче, узнать что находится в нужной битовой позиции. Но дело в том что нам не важно какое число получится, важно только факт будет это число нулем или нет. Следовательно если мы получаем число отличное от нуля, значит в той позиции была единица, если число равно нулю значит в той позиции был ноль. Так как выполни мы к примеру такую операцию: 1101 & 0010 на выходе мы бы получили 0000 так как не было бы ни одного разряда где в обоих числах были бы единицы.

Установка единицы в отдельный бит
Для установки единицы в отельный разряд числа нам потребуется следующая операция:

new = target | ( 1 << offset )

Назначения полей идентичных, описанным в абзаце о получении значения отдельных бит.
Данная операция вернет нам новое значение target в котором в нужный разряд будет установлена 1.

Пример:
Предположим мы имеем число 1001 и желаем в 3-й разряд справа установить в единицу, операция бы выглядела так: 1001 | ( 0001 << 2)
После выполнения операции в скобках у нас получится 1001 | 0100, далее операция ИЛИ вернет нам значение 1101 что нам и требовалось.

Установка нуля в отдельный бит
Для установки нуля в отдельный разряд числа нам потребуется такая операция:

new = target & ( ~ ( 1 << offset) )

либо:

new = target ^ ( 1 << offset )

Назначения полей идентичные, описанным в абзаце о получении значения отдельных бит. Данная операция вернет нам новое значение target в котором в нужный разряд будет установлена 0.

Пример:
Предположим мы имеем число 1101 и желаем в 3-м разряде установить ноль, операция бы выглядела так: 1101 & ( ~ ( 0001 << 2) )
После первого действия в скобках наша операция примет вид 1101 & ( ~0100), после чего операции инвертирования в скобках превратит наше число в 1011 и операция примет вид 1101 & 1011, затем операция И оставит единицы лишь в тех разрядах, где были единицы у обоих чисел, вернув нам число 1001.
Даже зная, как получать биты и устанавливать, для многих все равно остается вопросом для чего все это нужно. На самом деле, если бы например вы решили управлять простым текстовым LCD экраном без использования готовой библиотеки а формируя требуемые сигналы вы бы в долю секунды поняли зачем вам все эти операции. Но вот если вы работает на более высоком уровне, полезность данных операций не так очевидна. Ниже приведем пару общих примеров как такие операции можно применять и в более высокоуровневом программировании.

Битовый массив
Зачастую в программах требуется хранить некие флаги состояний, которые как правило принимают лишь два значения, например горит светодиод или не горит.
Вариантов как это реализовать и без битовых операций полно, но раз мы говорим о них посмотрим как они могут помочь. Идея крайне простая, давайте предположим, что у нас есть 4 диода, которые мы можем включать и выключать и для каких то целей нам требуется всегда знать какие из них горят а какие нет.
Таким образом мы просто берем одну числовую переменную которая будет выполнять роль битового массива, а каждый бит будет флагом состояния конкретного светодиода.
То есть к примеру если 0 то диод выключен если 1 то диод включен.
Как установить требуемые значения и получить эти значения вы уже знаете. У этого подхода есть один не совсем очевидный плюс, то есть узнать о том горит хотя бы один диод или все выключены можно просто сравнив такую переменную состояния с нулем, так как если все диоды выключены то все биты числа будут нулями и как следствие число будет ноль.
Таким образом данная переменная у вас всегда является неким числом, которое своего рода показывает вам "срез" состояния ваших диодов, что может быть удобно в неких логических операциях.

Передача параметров в функции
Пожалуй в высокоуровневом программировании это наиболее частое применение битовых операций.
Если вы касались работы с API различных операционных систем то могли обнаружить весьма странные на первый взгляд операции:

someFunction ( PARAM_1 | PARAM_2 | PARAM_3 );

На самом деле тут передается лишь один параметр в функцию, просто битовая операция ИЛИ создает некий срез параметров, как это было со светодиодами, то есть единицы в определенных битах говорят о том требуется эта опция или не требуется.
Представьте что мы хотим написать функцию которая бы могла разом включать любое количество диодов от 1 до 4 и желаем зажечь например 1-й и 3-й диоды, вызов функции мог бы выгладить например так.

switchOnLeds ( LED_1 | LED_3 );

Прежде чем передать значения в функцию операция ИЛИ сделала бы например вот так 0001 | 0100 что дало бы нам 0101, именно это значение бы поступило в функцию.
Дальше думаю уже все понятно, функция бы просмотрела все биты полученного числа и зажгла нужные диоды.
Не очевидных плюс данного метода стоит в том, что вы можете в функцию которая принимает в качестве одного аргумента простое целое число передать много разных параметров в этом аргументе.
И зажечь хоть один диод:

switchOnLeds ( LED_1 );

Хоть все 4:

switchOnLeds( LED_1 | LED_2 | LED_3 | LED_4 );

Или еще хитрее:

switchOnLeds ( ALL_LEDS );

Где ALL_LEDS будет равно двоичному числу 1111.
Описанные выше примеры являются лишь одним из множества вариантов достижения цели, таким образом они не идеальны и не универсальны, именно конкретная задача диктует приемлемость того или иного подхода, в одной ситуации битовые операции будут незаменимы, в другой не дав никакого выигрыша ухудшат читаемость кода или сделают программу еще более громоздкой.
Помните, не средства решают какую выбрать задачу а именно задача решает какие выбрать средства.

	Примеры
Примеры для языка C
1. Напишем функции, которые позволяют определять и изменять определённый бит числа
Для того, чтобы узнать, какой бит (1 или 0) стоит на позиции n, воспользуемся логическим умножением.
Пусть имеется число 9 (00001001). Нужно узнать, выставлен ли бит на позиции 3 (начиная с нуля). Для этого умножим его на число, у которого все биты равны нулю, кроме третьего:

00001001 & 00001000 = 00001000

Теперь узнаем значение бита в позиции 6

00001001 & 01000000 = 00000000

Таким образом, если мы получаем ответ, равный нулю, то на искомой позиции находится ноль, иначе единица. Чтобы получить число, состоящее из нулей с одним битом на нужной позиции, сдвинем 1 на нужное число бит влево.

#include <stdio.h>
#include <conio.h>
#include <limits.h>
 
int checkbit(const int value, const int position) {
    int result;
    if ((value & (1 << position)) == 0) {
        result = 0;
    } else {
        result = 1;
    }
    return result;
}
 
void main() {
    int a = 3;
    size_t len = sizeof(int) * CHAR_BIT;
    size_t i;
 
    for (i = 0; i < len; i++) {
        printf("%d", checkbit(a, i));
    }
 
    _getch();
}



Заметьте, что в функции условие записано так

    if ((value & (1 << position)) == 0)

Потому что без скобок сначала будет вычислено равенство нулю и только потом выполнено умножение.

((value & (1 << position)) == 0)

Функцию можно упростить

int checkbit(const int value, const int position) {
    return ((value & (1 << position)) != 0);
}

Функция, которая выставляет бит на n-й позиции в единицу.
Известно, что логическое сложение любого бита с 1 будет равно 1. Так что для установки n-го бита нужно логически сложить число с таким, у которого все биты, кроме нужного, равны нулю. Как получить такое число, уже рассмотрено.

int setbit(const int value, const int position) {
    return (value | (1 << position));
}

Функция, которая устанавливает бит на n-й позиции в ноль.
Для этого нужно, чтобы все биты числа, кроме n-го, не изменились. Умножим число на такое, у которого все биты равны единице, кроме бита под номером n. Например

0001011 & 1110111 = 0000011

Чтобы получить такую маску, сначала создадим число с нулями и одной единицей, а потом инвертируем его.

int unsetbit(const int value, const int position) {
    return (value & ~(1 << position));
}

Функция, изменющая значение n-го бита на противоположное.
Для этого воспользуемся функцией исключающего или: применим операцию XOR к числу, которое состоит из одних нулей и одной единицы на месте нужного бита.

int switchbit(const int value, const int position) {
    return (value ^ (1 << position));
}

Проверка

#include <stdio.h>
#include <conio.h>
#include <limits.h>
 
int checkbit(const int value, const int position) {
    return ((value & (1 << position)) != 0);
}
 
int setbit(const int value, const int position) {
    return (value | (1 << position));
}
 
int unsetbit(const int value, const int position) {
    return (value & ~(1 << position));
}
 
int switchbit(const int value, const int position) {
    return (value ^ (1 << position));
}
 
void printbits(int n) {
    //CHAR_BIT опеределён в библиотеке limits.h
    //и хранит число бит в байте для данной платформы
    size_t len = sizeof(int)* CHAR_BIT;
    size_t i;
    for (i = 0; i < len; i++) {
        printf("%d", checkbit(n, i));
    }
    printf("\n");
}
 
void main() {
    int a = 3;
    size_t len = sizeof(int) * CHAR_BIT;
    size_t i;
 
    printbits(a);
    a = setbit(a, 5);
    printbits(a);
    a = unsetbit(a, 5);
    printbits(a);
    a = switchbit(a, 11);
    printbits(a);
    a = switchbit(a, 11);
    printbits(a);
 
    _getch();
}



Примеры для языка CPP
Сдвиги влево

shift-expression << additive-expression

Оператор сдвига влево вызывает сдвиг битов shift-expression влево на количество позиций, определенных с помощью additive-expression. Позиции битов, освобожденные при операции сдвига, заполняются нулями. Сдвиг влево является логическим сдвигом (биты, сдвигаемые с конца отбрасываются, включая бит знака).
В следующем примере показаны операции сдвига влево с использованием чисел без знака. В этом примере показано, что происходит с битами при представлении значения как bitset.

#include <iostream>  
#include <bitset>  
using namespace std;

int main() {
	unsigned short short1 = 4;
	bitset<16> bitset1{ short1 };   // the bitset representation of 4  
	cout << bitset1 << endl;  // 0000000000000100  

	unsigned short short2 = short1 << 1;     // 4 left-shifted by 1 = 8  
	bitset<16> bitset2{ short2 };
	cout << bitset2 << endl;  // 0000000000001000  

	unsigned short short3 = short1 << 2;     // 4 left-shifted by 2 = 16  
	bitset<16> bitset3{ short3 };
	cout << bitset3 << endl;  // 0000000000010000  
	cin >> short1;
}



Если выполняется сдвиг влево числа со знаком и при этом затрагивается бит знака, результат не определен. В следующем примере показано, что происходит в Visual C++, если выполняется сдвиг влево 1 бита в позицию бита знака.

#include <iostream>  
#include <bitset>  
using namespace std;

int main() {
	short short1 = 16384;
	bitset<16> bitset1{ short2 };
	cout << bitset1 << endl;  // 0100000000000000   

	short short3 = short1 << 1;
	bitset<16> bitset3{ short3 };  // 16384 left-shifted by 1 = -32768  
	cout << bitset3 << endl;  // 100000000000000  

	short short4 = short1 << 14;
	bitset<16> bitset4{ short4 };  // 4 left-shifted by 14 = 0  
	cout << bitset4 << endl;  // 000000000000000    
	cin >> short1;
}

Сдвиги вправо

shift-expression >> additive-expression

Оператор сдвига вправо вызывает сдвиг группы битов shift-expression вправо на количество позиций, определенных с помощью additive-expression. Для чисел без знака позиции битов, освобожденные при операции сдвига, заполняются нулями. Для чисел со знаком бит знака используется для заполнения освобожденных позиций битов. Другими словами, если число является положительным, используется 0, если число является отрицательным, используется 1.

Замечание
Результат сдвига вправо отрицательного числа со знаком зависит от реализации. Хотя Visual C++ использует бит знака для заполнения освобожденных позиций битов, нет никакой гарантии, что другие реализации также выполняют это.

В следующем примере показаны операции сдвига вправо с использованием чисел без знака.

#include <iostream>  
#include <bitset>  
using namespace std;

int main() {
	unsigned short short11 = 1024;
	bitset<16> bitset11{ short11 };
	cout << bitset11 << endl;     // 0000010000000000  

	unsigned short short12 = short11 >> 1;  // 512  
	bitset<16> bitset12{ short12 };
	cout << bitset12 << endl;     // 0000001000000000  

	unsigned short short13 = short11 >> 10;  // 1  
	bitset<16> bitset13{ short13 };
	cout << bitset13 << endl;     // 0000000000000001  

	unsigned short short14 = short11 >> 11;  // 0  
	bitset<16> bitset14{ short14 };
	cout << bitset14 << endl;     // 0000000000000000}  
	cin >> short11;
}



В следующем примере показаны операции сдвига вправо с использованием положительных чисел со знаком.

#include <iostream>  
#include <bitset>  
using namespace std;

int main() {
	short short1 = 1024;
	bitset<16> bitset1{ short1 };
	cout << bitset1 << endl;     // 0000010000000000  

	short short2 = short1 >> 1;  // 512  
	bitset<16> bitset2{ short2 };
	cout << bitset2 << endl;     // 0000001000000000  

	short short3 = short1 >> 11;  // 0  
	bitset<16> bitset3{ short3 };
	cout << bitset3 << endl;     // 0000000000000000  
	cin >> short1;
}



В следующем примере показаны операции сдвига вправо с использованием отрицательных целых чисел со знаком.

#include <iostream>  
#include <bitset>  
using namespace std;

int main() {
	short neg1 = -16;
	bitset<16> bn1{ neg1 };
	cout << bn1 << endl;  // 1111111111110000  

	short neg2 = neg1 >> 1; // -8  
	bitset<16> bn2{ neg2 };
	cout << bn2 << endl;  // 1111111111111000  

	short neg3 = neg1 >> 2; // -4  
	bitset<16> bn3{ neg3 };
	cout << bn3 << endl;  // 1111111111111100  

	short neg4 = neg1 >> 4; // -1  
	bitset<16> bn4{ neg4 };
	cout << bn4 << endl;  // 1111111111111111  

	short neg5 = neg1 >> 5; // -1   
	bitset<16> bn5{ neg5 };
	cout << bn5 << endl;  // 1111111111111111  
	cin >> neg1;
}

Сдвиги и перемещения
Выражения с обеих сторон оператора сдвига должны быть целочисленными типами. Восходящие приведения целых типов выполняются в соответствии с правилами, описанным в разделе Восходящие приведения целых типов. Тип результата соответствует типу приводимого shift-expression.
В следующем примере у переменной типа char уровень повышается до int.

#include <iostream>  
#include <typeinfo>  

using namespace std;

int main() {
	char char1 = 'a';

	auto promoted1 = char1 << 1;  // 194  
	cout << typeid(promoted1).name() << endl;  // int  

	auto promoted2 = char1 << 10;  // 99328  
	cout << typeid(promoted2).name() << endl;   // int  
	cin >> char1;
}



Некоторые подробности
Результат операции сдвига не определен, если additive-expression имеет отрицательное значение или если additive-expression больше или равен количеству битов в повышаемом shift-expression. Операция сдвига не выполняется, если значение additive-expression равно 0

#include <iostream>  
#include <bitset>  
using namespace std;

int main() {
	unsigned int int1 = 4;
	bitset<32> b1{ int1 };
	cout << b1 << endl;    // 00000000000000000000000000000100  

	unsigned int int2 = int1 << -3;  // C4293: '<<' : shift count negative or too big, undefined behavior  
	unsigned int int3 = int1 >> -3;  // C4293: '>>' : shift count negative or too big, undefined behavior  

	unsigned int int4 = int1 << 32;  // C4293: '<<' : shift count negative or too big, undefined behavior  

	unsigned int int5 = int1 >> 32;  // C4293: '>>' : shift count negative or too big, undefined behavior  

	unsigned int int6 = int1 << 0;
	bitset<32> b6{ int6 };
	cout << b6 << endl;    // 00000000000000000000000000000100 (no change)}  
	cin >> int1;
}









